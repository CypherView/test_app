{"version":3,"sources":["node_modules/lz-string/libs/lz-string.js","src/environments/environment.ts","src/app/shared/utils/type-guards.ts","src/app/shared/utils/route.utils.ts","src/app/shared/utils/form-utils.ts","src/app/shared/utils/map.utils.ts","src/app/shared/utils/phone-number-utils.ts","src/app/core/services/api-url.service.ts","src/app/core/services/auth.service.ts","src/app/core/models/constants.ts","src/app/core/models/error-reasons.enum.ts","src/app/core/models/feature-flags.model.ts","src/app/core/services/auth-token-manager.service.ts","src/app/api/configuration.ts","src/app/api/encoder.ts","src/app/api/variables.ts","src/app/api/api/accounts.service.ts","src/app/api/api/deviceTypes.service.ts","src/app/api/api.module.ts","src/app/api/api/alerts.service.ts","src/app/api/api/analytics.service.ts","src/app/api/api/assetCategories.service.ts","src/app/api/api/assetGroups.service.ts","src/app/api/api/assetRatingProfiles.service.ts","src/app/api/api/assetStateProfiles.service.ts","src/app/api/api/assetTagTypes.service.ts","src/app/api/api/assetTags.service.ts","src/app/api/api/assetTypes.service.ts","src/app/api/api/assets.service.ts","src/app/api/api/auth.service.ts","src/app/api/api/clients.service.ts","src/app/api/api/companies.service.ts","src/app/api/api/companyGroups.service.ts","src/app/api/api/costCentres.service.ts","src/app/api/api/dashboardTemplates.service.ts","src/app/api/api/dashboards.service.ts","src/app/api/api/data.service.ts","src/app/api/api/deviceConfigProfiles.service.ts","src/app/api/api/deviceProviderTypes.service.ts","src/app/api/api/deviceProviders.service.ts","src/app/api/api/devices.service.ts","src/app/api/api/distributors.service.ts","src/app/api/api/emailProviders.service.ts","src/app/api/api/emailProvidersTypes.service.ts","src/app/api/api/entities.service.ts","src/app/api/api/exportTasks.service.ts","src/app/api/api/feeds.service.ts","src/app/api/api/fuelCards.service.ts","src/app/api/api/geoLockProfiles.service.ts","src/app/api/api/health.service.ts","src/app/api/api/history.service.ts","src/app/api/api/ioTypes.service.ts","src/app/api/api/labels.service.ts","src/app/api/api/lookups.service.ts","src/app/api/api/map.service.ts","src/app/api/api/mapSets.service.ts","src/app/api/api/media.service.ts","src/app/api/api/notifications.service.ts","src/app/api/api/overspeedProfiles.service.ts","src/app/api/api/queues.service.ts","src/app/api/api/redirect.service.ts","src/app/api/api/reminders.service.ts","src/app/api/api/reportDefinitions.service.ts","src/app/api/api/reportTemplates.service.ts","src/app/api/api/reports.service.ts","src/app/api/api/roadProfiles.service.ts","src/app/api/api/scheduledReports.service.ts","src/app/api/api/search.service.ts","src/app/api/api/simCards.service.ts","src/app/api/api/smsGatewayProviders.service.ts","src/app/api/api/smsGatewayProvidersTypes.service.ts","src/app/api/api/sslCertificates.service.ts","src/app/api/api/stats.service.ts","src/app/api/api/tasks.service.ts","src/app/api/api/themes.service.ts","src/app/api/api/translate.service.ts","src/app/api/api/userRoles.service.ts","src/app/api/api/users.service.ts","src/app/api/api/vendors.service.ts","src/app/api/api/zoneGroups.service.ts","src/app/api/api/zones.service.ts","src/app/api/model/alertAction.ts","src/app/api/model/alertCreateRequest.ts","src/app/api/model/alertListItem.ts","src/app/api/model/alertNotify.ts","src/app/api/model/alertResponse.ts","src/app/api/model/alertUpdateRequest.ts","src/app/api/model/analyticsBaseReportResponse.ts","src/app/api/model/analyticsDataSourceOptions.ts","src/app/api/model/analyticsDimension.ts","src/app/api/model/analyticsOutputFilter.ts","src/app/api/model/analyticsOutputRequest.ts","src/app/api/model/analyticsOutputSettings.ts","src/app/api/model/analyticsSettingsRequest.ts","src/app/api/model/analyticsSortOptions.ts","src/app/api/model/assetCreateRequest.ts","src/app/api/model/assetListItem.ts","src/app/api/model/assetRatingProfileCreateRequest.ts","src/app/api/model/assetRatingProfileListItem.ts","src/app/api/model/assetRatingProfileResponse.ts","src/app/api/model/assetRatingProfileUpdateRequest.ts","src/app/api/model/assetResponse.ts","src/app/api/model/assetStateProfileCreateRequest.ts","src/app/api/model/assetStateProfileListItem.ts","src/app/api/model/assetStateProfileResponse.ts","src/app/api/model/assetStateProfileUpdateRequest.ts","src/app/api/model/assetTagCreateRequest.ts","src/app/api/model/assetTagListItem.ts","src/app/api/model/assetTagResponse.ts","src/app/api/model/assetTagUpdateRequest.ts","src/app/api/model/assetUpdateRequest.ts","src/app/api/model/assetZoneTarget.ts","src/app/api/model/auditEventChange.ts","src/app/api/model/auditEventResponse.ts","src/app/api/model/authEndpoint.ts","src/app/api/model/authInfo.ts","src/app/api/model/calculatedMeasure.ts","src/app/api/model/cellProperties.ts","src/app/api/model/cellSet.ts","src/app/api/model/cellValue.ts","src/app/api/model/chartSeriesItem.ts","src/app/api/model/chartXAxisLabels.ts","src/app/api/model/clientCreateRequest.ts","src/app/api/model/clientListItem.ts","src/app/api/model/clientMeasurementUnits.ts","src/app/api/model/clientResponse.ts","src/app/api/model/clientUpdateRequest.ts","src/app/api/model/companyDataRetentionSettings.ts","src/app/api/model/companyResponse.ts","src/app/api/model/completedReportResponse.ts","src/app/api/model/contact.ts","src/app/api/model/dashboardCreateRequest.ts","src/app/api/model/dashboardListItem.ts","src/app/api/model/dashboardResponse.ts","src/app/api/model/dashboardTemplateListItem.ts","src/app/api/model/dashboardTemplateResponse.ts","src/app/api/model/dashboardTemplateUpdateRequest.ts","src/app/api/model/dashboardUpdateRequest.ts","src/app/api/model/dashboardWidget.ts","src/app/api/model/dashboardWidgetDataSource.ts","src/app/api/model/deviceBitmapConfiguration.ts","src/app/api/model/deviceConfigProfileCreateRequest.ts","src/app/api/model/deviceConfigProfileListItem.ts","src/app/api/model/deviceConfigProfileResponse.ts","src/app/api/model/deviceConfigProfileUpdateRequest.ts","src/app/api/model/deviceCreateRequest.ts","src/app/api/model/deviceListItem.ts","src/app/api/model/deviceProviderCreateRequest.ts","src/app/api/model/deviceProviderListItem.ts","src/app/api/model/deviceProviderResponse.ts","src/app/api/model/deviceProviderTypeListItem.ts","src/app/api/model/deviceProviderTypeResponse.ts","src/app/api/model/deviceProviderUpdateRequest.ts","src/app/api/model/deviceResponse.ts","src/app/api/model/deviceTypeCreateRequest.ts","src/app/api/model/deviceTypeListItem.ts","src/app/api/model/deviceTypeResponse.ts","src/app/api/model/deviceTypeUpdateRequest.ts","src/app/api/model/deviceUpdateRequest.ts","src/app/api/model/distributorCreateRequest.ts","src/app/api/model/distributorListItem.ts","src/app/api/model/distributorResponse.ts","src/app/api/model/distributorUpdateRequest.ts","src/app/api/model/emailProviderCreateRequest.ts","src/app/api/model/emailProviderListItem.ts","src/app/api/model/emailProviderResponse.ts","src/app/api/model/emailProviderTypeListItem.ts","src/app/api/model/emailProviderTypeResponse.ts","src/app/api/model/emailProviderUpdateRequest.ts","src/app/api/model/emailServerConfiguration.ts","src/app/api/model/eventActorFilter.ts","src/app/api/model/eventMedia.ts","src/app/api/model/eventTargetFilter.ts","src/app/api/model/exportTaskCreateRequest.ts","src/app/api/model/exportTaskListItem.ts","src/app/api/model/exportTaskResponse.ts","src/app/api/model/exportTaskUpdateRequest.ts","src/app/api/model/forwardGeocodeResult.ts","src/app/api/model/fuelCardCreateRequest.ts","src/app/api/model/fuelCardListItem.ts","src/app/api/model/fuelCardResponse.ts","src/app/api/model/fuelCardUpdateRequest.ts","src/app/api/model/geoLockProfileCreateRequest.ts","src/app/api/model/geoLockProfileListItem.ts","src/app/api/model/geoLockProfileResponse.ts","src/app/api/model/geoLockProfileUpdateRequest.ts","src/app/api/model/idNameState.ts","src/app/api/model/ioTypeCreateRequest.ts","src/app/api/model/ioTypeListItem.ts","src/app/api/model/ioTypeRateConfig.ts","src/app/api/model/ioTypeResponse.ts","src/app/api/model/ioTypeUpdateRequest.ts","src/app/api/model/labelCreateRequest.ts","src/app/api/model/labelListItem.ts","src/app/api/model/labelResponse.ts","src/app/api/model/labelUpdateRequest.ts","src/app/api/model/mapRoute.ts","src/app/api/model/mapSetLayer.ts","src/app/api/model/mapSetListItem.ts","src/app/api/model/mapSetResponse.ts","src/app/api/model/mapsetCreateRequest.ts","src/app/api/model/mapsetUpdateRequest.ts","src/app/api/model/measureDescription.ts","src/app/api/model/mediaInfoResponse.ts","src/app/api/model/notificationActions.ts","src/app/api/model/oTPSettings.ts","src/app/api/model/overspeedProfileCreateRequest.ts","src/app/api/model/overspeedProfileListItem.ts","src/app/api/model/overspeedProfileResponse.ts","src/app/api/model/overspeedProfileUpdateRequest.ts","src/app/api/model/pieChartOptions.ts","src/app/api/model/policyStatement.ts","src/app/api/model/queueReportRequest.ts","src/app/api/model/queuedReportResponse.ts","src/app/api/model/rebuildDashboardWidgetResponse.ts","src/app/api/model/reminderCreateRequest.ts","src/app/api/model/reminderListItem.ts","src/app/api/model/reminderReset.ts","src/app/api/model/reminderResponse.ts","src/app/api/model/reminderUpdateRequest.ts","src/app/api/model/reportDefinitionColumnOptions.ts","src/app/api/model/reportDefinitionResponse.ts","src/app/api/model/reportTemplateConfig.ts","src/app/api/model/reverseGeocodeResult.ts","src/app/api/model/roadProfileCreateRequest.ts","src/app/api/model/roadProfileListItem.ts","src/app/api/model/roadProfileResponse.ts","src/app/api/model/roadProfileUpdateRequest.ts","src/app/api/model/roadSpeedModifierEntry.ts","src/app/api/model/schedule.ts","src/app/api/model/scheduledReportCreateRequest.ts","src/app/api/model/scheduledReportListItem.ts","src/app/api/model/scheduledReportReport.ts","src/app/api/model/scheduledReportResponse.ts","src/app/api/model/scheduledReportUpdateRequest.ts","src/app/api/model/simCardCreateRequest.ts","src/app/api/model/simCardListItem.ts","src/app/api/model/simCardResponse.ts","src/app/api/model/simCardUpdateRequest.ts","src/app/api/model/smsGatewayProviderCreateRequest.ts","src/app/api/model/smsGatewayProviderListItem.ts","src/app/api/model/smsGatewayProviderResponse.ts","src/app/api/model/smsGatewayProviderTypeListItem.ts","src/app/api/model/smsGatewayProviderTypeResponse.ts","src/app/api/model/smsGatewayProviderUpdateRequest.ts","src/app/api/model/sslCertificateCreateRequest.ts","src/app/api/model/sslCertificateListItem.ts","src/app/api/model/sslCertificateResponse.ts","src/app/api/model/sslCertificateUpdateRequest.ts","src/app/api/model/statChartOptions.ts","src/app/api/model/statsEntityOutputOptions.ts","src/app/api/model/targetLine.ts","src/app/api/model/taskResponse.ts","src/app/api/model/testNotificationsRequest.ts","src/app/api/model/themeCreateRequest.ts","src/app/api/model/themeCustomHTMLTag.ts","src/app/api/model/themeResponse.ts","src/app/api/model/themeUpdateRequest.ts","src/app/api/model/tripResponse.ts","src/app/api/model/userCreateRequest.ts","src/app/api/model/userCreateResponse.ts","src/app/api/model/userListItem.ts","src/app/api/model/userProfileResponse.ts","src/app/api/model/userResetResponse.ts","src/app/api/model/userResponse.ts","src/app/api/model/userUpdateRequest.ts","src/app/api/model/vendorCreateRequest.ts","src/app/api/model/vendorListItem.ts","src/app/api/model/vendorResponse.ts","src/app/api/model/vendorUpdateRequest.ts","src/app/api/model/zoneCreateRequest.ts","src/app/api/model/zoneListItem.ts","src/app/api/model/zoneResponse.ts","src/app/api/model/zoneUpdateRequest.ts","src/app/shared/services/local-storage.service.ts","src/app/core/services/user-session.service.ts"],"sourcesContent":["// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.5\nvar LZString = (function() {\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nvar LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\n  return LZString;\n})();\n\nif (typeof define === 'function' && define.amd) {\n  define(function () { return LZString; });\n} else if( typeof module !== 'undefined' && module != null ) {\n  module.exports = LZString\n} else if( typeof angular !== 'undefined' && angular != null ) {\n  angular.module('LZString', [])\n  .factory('LZString', function () {\n    return LZString;\n  });\n}\n","export const environment = {\n  production: false,\n  showApiDropdown: true,\n  apiUrls: [\n    'https://v1-test-api.cypherview.net',\n    'https://api.us1.kt1.io/fleet/v2',\n    'https://api.staging.kt1.io/fleet/v2',\n    'https://api.us1.kt1.io/fleet/next/v2'\n  ],\n  defaultThemeId: '454d57b6-1678-4e61-8688-fb68b8b1f74c',\n  flutterUrl: '/assets/flutter/index.html',\n  googleMapsApiKey: 'AIzaSyC3PVw5GHsMfQiP5MjGxp1EW-Uea43WN48',\n};\n","import { SelectOption } from '../models/form-field.model';\n\n/**\n * Type guard to check if a value is null or undefined\n * @param value The value to check\n * @returns true if the value is null or undefined\n */\nexport function isNullOrUndefined<T>(\n  value: T | null | undefined,\n): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * Type guard to check if a value is defined (not null and not undefined)\n * @param value The value to check\n * @returns true if the value is defined\n */\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\n/**\n * Type guard to check if a value is a string\n * @param value The value to check\n * @returns true if the value is a string\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Type guard to check if a value is a number\n * @param value The value to check\n * @returns true if the value is a number\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number' && !Number.isNaN(value);\n}\n\n/**\n * Type guard to check if a value is a boolean\n * @param value The value to check\n * @returns true if the value is a boolean\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return typeof value === 'boolean';\n}\n\n/**\n * Type guard to check if a value is an array\n * @param value The value to check\n * @returns true if the value is an array\n */\nexport function isArray<T>(value: unknown): value is T[] {\n  return Array.isArray(value);\n}\n\n/**\n * Type guard to check if a value is an object (not null, not array)\n * @param value The value to check\n * @returns true if the value is an object\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n/**\n * Type guard to check if a value is a valid Date\n * @param value The value to check\n * @returns true if the value is a valid Date\n */\nexport function isValidDate(value: unknown): value is Date {\n  return value instanceof Date && !Number.isNaN(value.getTime());\n}\n\n/**\n * Type guard to check if a value is empty (null, undefined, empty string, empty array, empty object)\n * @param value The value to check\n * @returns true if the value is empty\n */\nexport function isEmpty(value: unknown): boolean {\n  if (isNullOrUndefined(value)) return true;\n  if (isString(value)) return value.trim().length === 0;\n  if (isArray(value)) return value.length === 0;\n  if (isObject(value)) return Object.keys(value).length === 0;\n  return false;\n}\n\n/**\n * Type guard to check if a value matches a specific enum\n * @param enumType The enum to check against\n * @param value The value to check\n * @returns true if the value exists in the enum\n */\nexport function isEnumValue<T extends Record<string, string | number>>(\n  enumType: T,\n  value: unknown,\n): value is T[keyof T] {\n  return Object.values(enumType).includes(value as T[keyof T]);\n}\n\n/**\n * Type guard to check if all properties of an object are defined\n * @param obj The object to check\n * @returns true if all properties are defined\n */\nexport function hasRequiredProperties<T extends object>(obj: T): boolean {\n  return Object.values(obj).every((value) => isDefined(value));\n}\n\n/**\n * Type guard to check if value has a specific property\n * @param value The value to check\n * @param prop The property to check for\n * @returns true if the value has the specified property\n */\nexport function hasProperty<K extends string>(\n  value: unknown,\n  prop: K,\n): value is Record<K, unknown> {\n  return isObject(value) && prop in value;\n}\n\n/**\n * Type guard to check if a value is a function with specific signature\n * @template T The return type of the function\n * @template Args The argument types of the function\n * @param value The value to check\n * @returns true if the value is a function matching the signature\n */\nexport function isFunction<T = unknown, Args extends unknown[] = unknown[]>(\n  value: unknown,\n): value is (...args: Args) => T {\n  return typeof value === 'function';\n}\n\n/**\n * Type guard to check if a value is a SelectOption\n * @param value The value to check\n * @returns true if the value is a SelectOption\n */\nexport function isSelectOption(value: unknown): value is SelectOption {\n  return (\n    isObject(value) &&\n    hasProperty(value, 'label') &&\n    hasProperty(value, 'value') &&\n    isString(value['label'])\n  );\n}\n\n/**\n * Deep comparison of two objects or values\n * Performs a recursive comparison of nested objects and arrays\n *\n * @param obj1 First value to compare\n * @param obj2 Second value to compare\n * @returns true if the objects are deeply equal\n */\nexport function isDeepEqual<T>(obj1: T, obj2: T): boolean {\n  // Handle primitives and referential equality\n  if (obj1 === obj2) return true;\n\n  // If either is null/undefined but not both (we already checked === above)\n  if (isNullOrUndefined(obj1) || isNullOrUndefined(obj2)) return false;\n\n  // Check if they're the same type\n  const type1 = typeof obj1;\n  const type2 = typeof obj2;\n  if (type1 !== type2) return false;\n\n  // Handle dates\n  if (isValidDate(obj1) && isValidDate(obj2)) {\n    return obj1.getTime() === obj2.getTime();\n  }\n\n  // Handle arrays\n  if (isArray(obj1) && isArray(obj2)) {\n    if (obj1.length !== obj2.length) return false;\n\n    return obj1.every((item, index) => isDeepEqual(item, obj2[index]));\n  }\n\n  // Handle objects\n  if (isObject(obj1) && isObject(obj2)) {\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n\n    if (keys1.length !== keys2.length) return false;\n\n    // Check that all keys in obj1 exist in obj2 and have equal values\n    return keys1.every((key) => {\n      return (\n        hasProperty(obj2, key) &&\n        isDeepEqual(obj1[key as keyof T], obj2[key as keyof T])\n      );\n    });\n  }\n\n  // For any other type, if they're not equal by === they're not equal\n  return false;\n}\n","import { ActivatedRouteSnapshot, CanActivateFn, Route } from '@angular/router';\nimport { isDefined } from './type-guards';\nimport { Type } from '@angular/core';\n\nexport function getAllRouteParams(\n  route: ActivatedRouteSnapshot,\n): Record<string, string> {\n  let currentRoute: ActivatedRouteSnapshot | null = route;\n  const params: Record<string, string> = {};\n  while (isDefined(currentRoute)) {\n    for (const key of currentRoute.paramMap.keys) {\n      params[key] = currentRoute.paramMap.get(key) as string;\n    }\n    currentRoute = currentRoute.parent;\n  }\n  return params;\n}\n\n/**\n * Creates a pair of routes for a guarded grid feature:\n * 1. Base path with guard and optional component\n * 2. Grid sub-route for the specified grid component\n *\n * @param basePath - The base URL path segment\n * @param guard - The route guard to apply to the base path\n * @param gridComponent - Component to render for the grid view\n * @param baseComponent - Optional component to render at the base path\n * @param gridPath - Optional path for the grid route (defaults to 'grid/:type')\n * @returns Array of routes for the feature\n */\nexport function createGuardedGridRoute(\n  basePath: string,\n  guard: CanActivateFn,\n  gridComponent: Type<unknown>,\n  baseComponent?: Type<unknown>,\n  gridPath = 'grid/:type',\n): Route[] {\n  return [\n    {\n      path: basePath,\n      canActivate: [guard],\n      component: baseComponent || undefined,\n      children: [], // Keep empty children array to allow for future sub components\n    },\n    {\n      path: `${basePath}/${gridPath}`,\n      component: gridComponent,\n    },\n    {\n      path: `${basePath}/${gridPath}/:entityType/:entityId`,\n      component: gridComponent,\n    },\n  ];\n}\n","import { isNullOrUndefined } from './type-guards';\n\n/**\n * Type for any object with string keys (safer than Record<string, any>)\n */\nexport interface JsonObject {\n  [key: string]: JsonValue;\n}\n\n/**\n * Type for any valid JSON value\n */\nexport type JsonValue =\n  | string\n  | number\n  | boolean\n  | null\n  | JsonObject\n  | JsonValue[];\n\n/**\n * Gets a nested property from an object using a dot-notation path\n *\n * @param source The source object to get the property from\n * @param path A dot-notation path to the property (e.g. \"user.address.street\")\n * @param defaultValue Value to return if the property doesn't exist\n * @returns The property value or the default value\n */\nexport function getNestedProperty<T>(\n  source: JsonObject | null | undefined,\n  path: string,\n  defaultValue?: T,\n): T | undefined {\n  if (isNullOrUndefined(source) || !path) {\n    return defaultValue;\n  }\n\n  const keys = path.split('.');\n  let current: unknown = source;\n\n  for (const key of keys) {\n    if (current === null || current === undefined) {\n      return defaultValue;\n    }\n    if (typeof current !== 'object') {\n      return defaultValue;\n    }\n    // Type assertion here is safer than before\n    current = (current as Record<string, unknown>)[key];\n  }\n\n  return current === undefined ? defaultValue : (current as T);\n}\n\n/**\n * Sets a nested property on an object using a dot-notation path\n *\n * @param target The target object to set the property on\n * @param path A dot-notation path to the property (e.g. \"user.address.street\")\n * @param value The value to set\n * @returns The modified target object\n */\nexport function setNestedProperty<T extends JsonObject, V extends JsonValue>(\n  target: T,\n  path: string,\n  value: V,\n): T | null {\n  if (isNullOrUndefined(target) || !path) {\n    return null;\n  }\n\n  const keys = path.split('.');\n  let current: Record<string, unknown> = target;\n\n  // Traverse the path except for the last key\n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n\n    // If the current location is not an object, create one\n    if (\n      current[key] === undefined ||\n      current[key] === null ||\n      typeof current[key] !== 'object'\n    ) {\n      current[key] = {} as JsonObject;\n    }\n\n    // Safe assertion since we ensure it's an object above\n    current = current[key] as Record<string, unknown>;\n  }\n\n  // Set the value at the final key\n  const lastKey = keys[keys.length - 1];\n  current[lastKey] = value;\n\n  return target;\n}\n\n/**\n * Checks if a nested property exists in an object using a dot-notation path\n *\n * @param source The source object to check\n * @param path A dot-notation path to the property (e.g. \"user.address.street\")\n * @returns True if the property exists, false otherwise\n */\nexport function hasNestedProperty(\n  source: JsonObject | null | undefined,\n  path: string,\n): boolean {\n  if (isNullOrUndefined(source) || !path) {\n    return false;\n  }\n\n  const keys = path.split('.');\n  let current: unknown = source;\n\n  for (const key of keys) {\n    if (\n      current === null ||\n      current === undefined ||\n      typeof current !== 'object'\n    ) {\n      return false;\n    }\n\n    // Using a safer check with Object.hasOwn\n    if (!Object.hasOwn(current, key)) {\n      return false;\n    }\n\n    current = (current as Record<string, unknown>)[key];\n  }\n\n  return true;\n}\n\n/**\n * Deletes a nested property from an object using a dot-notation path\n *\n * @param target The target object to delete the property from\n * @param path A dot-notation path to the property (e.g. \"user.address.street\")\n * @returns True if the property was deleted, false otherwise\n */\nexport function deleteNestedProperty<T extends JsonObject>(\n  target: T,\n  path: string,\n): boolean {\n  if (isNullOrUndefined(target) || !path) {\n    return false;\n  }\n\n  const keys = path.split('.');\n  let current: unknown = target;\n\n  // Navigate to the parent of the property to delete\n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n    if (\n      current === null ||\n      current === undefined ||\n      typeof current !== 'object' ||\n      !Object.hasOwn(current, key)\n    ) {\n      return false;\n    }\n    current = (current as Record<string, unknown>)[key];\n  }\n\n  // Delete the property\n  const lastKey = keys[keys.length - 1];\n  if (\n    current === null ||\n    current === undefined ||\n    typeof current !== 'object' ||\n    !Object.hasOwn(current, lastKey)\n  ) {\n    return false;\n  }\n\n  return delete (current as Record<string, unknown>)[lastKey];\n}\n\n/**\n * Merges a value into an object at a specified nested path\n *\n * @param target The target object to merge into\n * @param path A dot-notation path where the value should be merged (e.g. \"user.address\")\n * @param value The value to merge at the specified path\n * @returns The modified target object\n */\nexport function mergeAtPath<T extends JsonObject, V extends JsonObject>(\n  target: T,\n  path: string,\n  value: V,\n): T {\n  if (isNullOrUndefined(target) || !path) {\n    return target;\n  }\n\n  const existingValue = getNestedProperty<JsonObject>(target, path, {});\n  const merged = { ...existingValue, ...value };\n  return setNestedProperty(target, path, merged) ?? target;\n}\n\n/**\n * Converts an enum object to an array of select option values with properly formatted labels\n *\n * @param enumObj The enum object to convert\n * @param formatLabel Optional custom formatter for labels (defaults to auto-spacing)\n * @returns Array of {label, value} pairs suitable for dropdowns\n */\nexport function enumToSelectOptionValues<T>(\n  enumObj: Record<string, T>,\n  formatLabel?: (key: string) => string,\n): { label: string; value: T }[] {\n  return Object.entries(enumObj)\n    .filter(([key]) => isNaN(Number(key))) // Filter out numeric keys\n    .map(([key, value]) => ({\n      label: formatLabel ? formatLabel(key) : formatEnumKey(key),\n      value,\n    }));\n}\n\n/**\n * Formats an enum key by adding spaces between words and capitalizing first letters\n * Works with both PascalCase (DigitalInput) and snake_case (digital_input)\n *\n * @param key The enum key to format\n * @returns Formatted label with proper spacing and capitalization\n */\nfunction formatEnumKey(key: string): string {\n  // If key contains underscores, use them for splitting\n  if (key.includes('_')) {\n    return key\n      .split('_')\n      .map((word) => capitalizeFirstLetter(word))\n      .join(' ');\n  }\n\n  // Handle PascalCase or camelCase by inserting spaces before capital letters\n  // Transform: \"DigitalInput\" -> \"Digital Input\"\n  return (\n    key\n      // Add space before capital letters but not at the beginning\n      .replace(/([A-Z])/g, ' $1')\n      .trim() // Remove any leading space\n      .split(' ')\n      .map((word) => capitalizeFirstLetter(word))\n      .join(' ')\n  );\n}\n\n/**\n * Capitalizes just the first letter of a string\n */\nfunction capitalizeFirstLetter(str: string): string {\n  if (!str) return '';\n  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n}\n","interface Point {\n  x: number;\n  y: number;\n}\nexport class SpatialUtils {\n  static readonly earthRadius = 6367; // radius in km\n\n  static degToRad(x: number): number {\n    return (x * Math.PI) / 180.0;\n  }\n\n  static radToDeg(x: number): number {\n    return (x * 180.0) / Math.PI;\n  }\n\n  static calculateCoord(origin: Point, brng: number, arcLength: number): Point {\n    const lat1 = SpatialUtils.degToRad(origin.y);\n    const lon1 = SpatialUtils.degToRad(origin.x);\n    const centralAngle = arcLength / SpatialUtils.earthRadius;\n    const lat2 = Math.asin(\n      Math.sin(lat1) * Math.cos(centralAngle) +\n        Math.cos(lat1) *\n          Math.sin(centralAngle) *\n          Math.cos(SpatialUtils.degToRad(brng)),\n    );\n    const lon2 =\n      lon1 +\n      Math.atan2(\n        Math.sin(SpatialUtils.degToRad(brng)) *\n          Math.sin(centralAngle) *\n          Math.cos(lat1),\n        Math.cos(centralAngle) - Math.sin(lat1) * Math.sin(lat2),\n      );\n    return {\n      x: SpatialUtils.radToDeg(lon2),\n      y: SpatialUtils.radToDeg(lat2),\n    };\n  }\n\n  static getDistanceFromLatLonInKm(\n    lat1: number,\n    lon1: number,\n    lat2: number,\n    lon2: number,\n  ): number {\n    const dLat = SpatialUtils.degToRad(lat2 - lat1);\n    const dLon = SpatialUtils.degToRad(lon2 - lon1);\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(SpatialUtils.degToRad(lat1)) *\n        Math.cos(SpatialUtils.degToRad(lat2)) *\n        Math.sin(dLon / 2) *\n        Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const d = SpatialUtils.earthRadius * c; // Distance in km\n    return d;\n  }\n\n  static generateRegularPolygon(\n    centerPoint: Point,\n    radius: number,\n    numberOfPoints: number,\n  ): Point[] {\n    const points = [];\n    const centralAngle = 360.0 / numberOfPoints;\n    const offset = numberOfPoints === 4 ? 45.0 : 0.0;\n    for (let i = 0; i < numberOfPoints; i++) {\n      points.push(\n        SpatialUtils.calculateCoord(\n          centerPoint,\n          (i * centralAngle + offset) % 360,\n          radius,\n        ),\n      );\n    }\n    return points;\n  }\n\n  static pointInPolygon(point: Point, polygon: Point[]) {\n    // ray-casting algorithm based on\n    // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\n\n    const { x, y } = point;\n\n    let inside = false;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n      const xi = polygon[i].x,\n        yi = polygon[i].y;\n      const xj = polygon[j].x,\n        yj = polygon[j].y;\n\n      const intersect =\n        yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n\n    return inside;\n  }\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\nimport { isNullOrUndefined } from './type-guards';\n\n/**\n * Creates a phone number validator with configurable digit range\n * @param minDigits Minimum number of digits required\n * @param maxDigits Maximum number of digits allowed\n * @param errorKey Key to use in the validation error object\n * @param numberType Description of the number type for error messages\n */\nfunction createPhoneValidator(\n  minDigits: number,\n  maxDigits: number,\n  errorKey: string,\n  numberType: string,\n): ValidatorFn {\n  return (control: AbstractControl): ValidationErrors | null => {\n    if (isNullOrUndefined(control.value)) {\n      return null;\n    }\n\n    const value = control.value.toString().trim();\n    const digits = value.replaceAll(/\\D/g, '');\n\n    const validCharsRegex = /^[+]?[\\d\\s\\-().]+$/;\n    if (!validCharsRegex.test(value)) {\n      return {\n        [errorKey]: {\n          value: control.value,\n          message: `Invalid characters in ${numberType.toLowerCase()}`,\n        },\n      };\n    }\n\n    if (digits.length < minDigits || digits.length > maxDigits) {\n      return {\n        [errorKey]: {\n          value: control.value,\n          message: `${numberType} must contain ${minDigits}-${maxDigits} digits`,\n        },\n      };\n    }\n\n    return null;\n  };\n}\n\n/**\n * Validates international phone numbers\n * Accepts various formats including:\n * - +1 123 456 7890\n * - +44 20 7123 4567\n * - (123) 456-7890\n * - 123-456-7890\n * - +61 2 1234 5678\n * Requires 7-15 digits (international standard)\n */\nexport function phoneValidator(): ValidatorFn {\n  return createPhoneValidator(7, 15, 'phone', 'Phone number');\n}\n\n/**\n * Validates mobile phone numbers (typically 10-15 digits)\n * More lenient for international mobile formats\n */\nexport function mobileValidator(): ValidatorFn {\n  return createPhoneValidator(10, 15, 'mobile', 'Mobile number');\n}\n","import { Injectable } from '@angular/core';\nimport { environment } from '../../../environments/environment';\nimport { isString } from '../../shared/utils';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ApiUrlService {\n  private apiUrl: string = environment.apiUrls[0]; // Default fallback\n  private cachedUrlObj: URL | null = null;\n\n  constructor() {\n    const savedUrl = localStorage.getItem('apiUrl');\n    this.setApiUrl(isString(savedUrl) ? savedUrl : this.apiUrl);\n  }\n\n  setApiUrl(url: string) {\n    if (!url.trim()) throw new Error('Empty API URL');\n    try {\n      const urlObj = new URL(url);\n      this.cachedUrlObj = urlObj;\n      this.apiUrl = url;\n      localStorage.setItem('apiUrl', url);\n    } catch (error) {\n      this.cachedUrlObj = null;\n      throw error;\n    }\n  }\n\n  getCurrentApiUrl(): string {\n    return this.apiUrl;\n  }\n\n  getUrlObject(): URL {\n    if (!this.cachedUrlObj) {\n      throw new Error(\n        'No valid API URL configured. Please check your settings.',\n      );\n    }\n    return this.cachedUrlObj;\n  }\n}\n","import { HttpClient } from '@angular/common/http';\nimport { Injectable, inject } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { ApiUrlService } from './api-url.service';\nimport { isNullOrUndefined } from '../../shared/utils';\nimport { UserSessionResponse } from '../../api';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  private readonly http = inject(HttpClient);\n  private readonly apiUrlService = inject(ApiUrlService);\n\n  login(username: string, password: string): Observable<UserSessionResponse> {\n    const currentApiUrl = this.apiUrlService.getCurrentApiUrl();\n    return this.http.post<UserSessionResponse>(`${currentApiUrl}/auth/signin`, {\n      username,\n      password,\n    });\n  }\n\n  refreshToken(refreshToken: string): Observable<UserSessionResponse> {\n    const currentApiUrl = this.apiUrlService.getCurrentApiUrl();\n    return this.http.post<UserSessionResponse>(\n      `${currentApiUrl}/auth/refresh`,\n      {\n        refreshToken,\n      },\n    );\n  }\n\n  isAuthenticated(): boolean {\n    const expiry = localStorage.getItem('tokenExpiry');\n    if (isNullOrUndefined(expiry)) {\n      return false;\n    }\n    return Date.now() < parseInt(expiry, 10);\n  }\n}\n","import { InjectionToken } from '@angular/core';\nimport {\n  GridConfigurationEntry,\n  TreeTableConfigurationEntry,\n} from '../../shared/models';\n\nexport const LOCAL_STORAGE_KEY_SELECTED_CLIENT = 'app-client';\nexport const LOCAL_STORAGE_KEY_ACCESS_TOKEN = 'accessToken';\nexport const LOCAL_STORAGE_KEY_REFRESH_TOKEN = 'refreshToken';\nexport const LOCAL_STORAGE_KEY_TOKEN_EXPIRY = 'tokenExpiry';\nexport const LOCAL_STORAGE_KEY_USER_SESSION = 'userSession';\nexport const LOCAL_STORAGE_KEY_SELECTED_CLIENT_ID = 'selectedClientId';\nexport const LOCAL_STORAGE_SIDEBAR_STATE_KEY = 'sidebar-main-visible';\nexport const LOCAL_STORAGE_LAST_AUTHENTICATED_USER_ID =\n  'lastAuthenticatedUserId';\nexport const MOBILE_BREAKPOINT = 768;\nexport const DEFAULT_PAGE_SIZE = 100;\nexport const DEFAULT_PAGE_SIZE_OPTIONS = [10, 25, 50, 100];\nexport const DEFAULT_SYSTEM_ID = '00000000-0000-0000-0000-000000000000';\nexport const SUPER_ADMIN_ROLE_ID = '00000000-0000-0000-0000-000000000001';\nexport const DEFAULT_LIST_SIZE = 100;\nexport const DEFAULT_EMAIL_PROVIDER = {\n  id: '00000000-0000-0000-0000-000000000000',\n  name: 'Default',\n  state: 'active',\n};\nexport const GRID_CONFIGS = new InjectionToken<\n  Record<string, GridConfigurationEntry>\n>('GRID_CONFIGS');\nexport const TREE_TABLE_CONFIGS = new InjectionToken<\n  Record<string, TreeTableConfigurationEntry>\n>('TREE_TABLE_CONFIGS');\nexport const COLORS = [\n  'blue',\n  'lightblue',\n  'green',\n  'olive',\n  'orange',\n  'pink',\n  'purple',\n  'red',\n  'teal',\n  'yellow',\n  'white',\n  'gray',\n];\nexport const SEARCH_DEBOUNCE_TIME = 300;\nexport const CLIENT_SEARCH_LIMIT = 6;\n","export enum ErrorReasons {\n  AccessTokenExpired,\n  RefreshTokenExpired,\n  TooManyLogins,\n  RequestTimeout,\n  NoTokenAvailable,\n  Unknown,\n  Unauthorized,\n  NetworkError,\n  ServerError,\n  InvalidEndpoint,\n  BadRequest,\n  Forbidden,\n}\n","import { isDefined, isNullOrUndefined } from '../../shared/utils';\n\nexport const APP_FEATURE_FLAGS = 'fleet-ui-v2';\nexport const BACKEND_FEATURE_FLAGS = 'fleet-backend-v2';\n\nexport type FeatureType =\n  | 'checkbox'\n  | 'toggle'\n  | 'dropdown'\n  | 'number'\n  | 'text'\n  | 'checklist'\n  | 'memo'\n  | 'list';\n\nexport interface FormBuilderKeyValue {\n  key: string | boolean | null; // Allow null for 'Inherit'\n  value: string;\n  fields?: FormBuilderField[];\n}\n\nexport interface FormBuilderField {\n  id: string;\n  title: string;\n  type: string;\n  required?: boolean;\n  value?: string | number;\n  defaultValue?: string | number;\n  values?: FormBuilderKeyValue[];\n  valueLookup?: string;\n  min?: number;\n  max?: number;\n  hint?: string;\n  description?: string;\n}\n\nexport interface FeatureSection {\n  id: string;\n  title: string;\n  icon: string;\n  fields: FormBuilderField[];\n  addEnabledToggle: (id: string, defaultValue: boolean) => FeatureSection;\n  addCombo: (\n    id: string,\n    values: FormBuilderKeyValue[],\n    defaultValue: string | null, // Allow null for 'Inherit'\n  ) => FeatureSection;\n  addNumber: (\n    id: string,\n    min: number,\n    max: number,\n    defaultValue: number | null, // Allow null for 'Inherit'\n  ) => FeatureSection;\n  addCheckList: (\n    id: string,\n    lookupKey: string,\n    defaultValue: string[],\n  ) => FeatureSection;\n  addMemo: (id: string, defaultValue: string[]) => FeatureSection;\n  addText: (\n    id: string,\n    defaultValue: string,\n    required: boolean,\n  ) => FeatureSection;\n  addList: (id: string) => FeatureSection;\n}\n\nexport type FeatureSections = Record<string, FeatureSection>;\nexport type FeatureValue = boolean | string | number | null;\n\n// Icons for feature section pages\nexport const PAGE_ICONS: Record<string, string> = {\n  overview: 'compass',\n  dashboards: 'chart-line',\n  alerts: 'exclamation-triangle',\n  videos: 'photo-video',\n  replay: 'history',\n  mapsearch: 'search-location',\n  reporting: 'chart-bar',\n  admin: 'cog',\n  demo: 'palette',\n  system: 'heartbeat',\n  external: 'window-maximize',\n  geofence: 'draw-polygon',\n  assetperformance: 'medal',\n  devicehealth: 'heart-pulse',\n  settings: 'sliders',\n  maps: 'map-marked-alt',\n  notifications: 'bell',\n};\n\n// --- Start: Refined Types for AppFeatureDefaults ---\ninterface PageShowConfig {\n  activity?: boolean;\n  events?: boolean;\n  alerts?: boolean;\n  videos?: boolean;\n  sharing?: boolean;\n  tasks?: boolean;\n  editing?: boolean;\n  hours?: boolean;\n  analytics?: boolean;\n  fuelCards?: boolean;\n  savedVideos?: boolean;\n}\n\ninterface PageConfig {\n  enabled: boolean;\n  name?: string;\n  icon?: string;\n  layout?: 'advanced' | 'basic';\n  show?: PageShowConfig;\n  pageSize?: number;\n  customPanels?: string; // Represents a list, often newline-separated\n  group?: string;\n  order?: number;\n  maxDuration?: number;\n  feedLoadLimit?: number;\n  actions?: string; // Represents a list, often comma-separated\n  reports?: string; // Represents a list, often comma-separated\n  dateLimitOverride?: boolean;\n  tabs?: string; // Represents a list, often newline-separated name:url pairs\n  availableAssetTypes?: string; // Represents a list, often comma-separated\n  supportUrl?: string;\n}\n\ninterface MapConfig {\n  enabled: boolean;\n  liveTracking?: {\n    enabled: boolean;\n    refreshRate: number;\n  };\n  customMarkers?: {\n    enabled: boolean;\n  };\n  geofences?: {\n    enabled: boolean;\n    alerting: boolean;\n  };\n  traffic?: {\n    enabled: boolean;\n  };\n}\n\ninterface ReportingConfig {\n  enabled: boolean;\n  exportFormats?: {\n    pdf: boolean;\n    excel: boolean;\n    csv: boolean;\n  };\n  scheduling?: {\n    enabled: boolean;\n  };\n}\n\ninterface NotificationsConfig {\n  enabled: boolean;\n  channels?: {\n    email: boolean;\n    sms: boolean;\n    push: boolean;\n  };\n}\n\ninterface SettingsConfig {\n  userManagement?: {\n    enabled: boolean;\n    roles: {\n      admin: boolean;\n      manager: boolean;\n      user: boolean;\n    };\n  };\n  branding?: {\n    enabled: boolean;\n    logoCustomization: boolean;\n    colorSchemes: boolean;\n  };\n}\n\nexport interface AppFeatureDefaultsStructure {\n  page: Record<string, Partial<PageConfig>>;\n  maps: MapConfig;\n  reporting: ReportingConfig;\n  notifications: NotificationsConfig;\n  settings: SettingsConfig;\n}\n// --- End: Refined Types for AppFeatureDefaults ---\n\nexport const AppFeatureDefaults: AppFeatureDefaultsStructure = {\n  page: {\n    overview: {\n      enabled: true,\n      name: '',\n      icon: '',\n      layout: 'advanced',\n      show: {\n        activity: true,\n        events: true,\n        alerts: true,\n        videos: false,\n        sharing: false,\n        tasks: false,\n        editing: false,\n      },\n      pageSize: 300,\n      customPanels: '',\n      group: '',\n      order: 10,\n    },\n    /*  dashboards: {\n      enabled: false,\n      show: {\n        hours: false,\n      },\n      group: '',\n      order: 40,\n    }, */\n    videos: {\n      enabled: false,\n      maxDuration: 60,\n      group: '',\n      order: 30,\n    },\n    alerts: {\n      enabled: false,\n      feedLoadLimit: 30,\n      actions: '', // an array of allowed action types, separated by commas\n      group: '',\n      order: 20,\n    },\n    replay: {\n      enabled: false,\n      group: '',\n      order: 50,\n    },\n    /*   mapsearch: {\n      enabled: false,\n      group: '',\n      order: 60,\n    },\n    assetperformance: {\n      enabled: false,\n      name: '',\n      icon: '',\n      group: '',\n      order: 61,\n    },\n    reporting: {\n      enabled: false,\n      show: {\n        analytics: false,\n      },\n      reports: '', // an array of guid's separated by commas\n      dateLimitOverride: false, // enable to remove the standard report date limits and set all to 31 days (not recommended)\n      group: '',\n      order: 70,\n    }, */\n    external: {\n      enabled: false,\n      tabs: '', // a list of name:url pairs separated by newlines\n    },\n    admin: {\n      enabled: false,\n      customPanels: '',\n      show: {\n        fuelCards: false,\n      },\n      availableAssetTypes: '', // an array of guid's separated by commas\n      group: '',\n      order: 80,\n    },\n    devicehealth: {\n      enabled: false,\n      order: 81,\n      supportUrl: '',\n    },\n    geofence: {\n      enabled: false,\n      group: '',\n      order: 90,\n    },\n  },\n  maps: {\n    enabled: true,\n    liveTracking: {\n      enabled: true,\n      refreshRate: 30, // seconds\n    },\n    customMarkers: {\n      enabled: true,\n    },\n    geofences: {\n      enabled: true,\n      alerting: true,\n    },\n    traffic: {\n      enabled: true,\n    },\n  },\n  reporting: {\n    enabled: true,\n    exportFormats: {\n      pdf: true,\n      excel: true,\n      csv: true,\n    },\n    scheduling: {\n      enabled: true,\n    },\n  },\n  notifications: {\n    enabled: true,\n    channels: {\n      email: true,\n      sms: true,\n      push: true,\n    },\n  },\n  settings: {\n    userManagement: {\n      enabled: true,\n      roles: {\n        admin: true,\n        manager: true,\n        user: true,\n      },\n    },\n    branding: {\n      enabled: true,\n      logoCustomization: true,\n      colorSchemes: true,\n    },\n  },\n};\n\n// --- Start: Refined Type for BackendFeatureDefaults ---\ninterface BackendFeatureConfig {\n  enabled?: boolean;\n  [key: string]: unknown; // Allows other properties of unknown type\n}\n\ninterface BackendFeatureType {\n  _only?: string[];\n  [key: string]: BackendFeatureConfig | number | boolean | string[] | undefined;\n}\n// --- End: Refined Type for BackendFeatureDefaults ---\n\nexport const BackendFeatureDefaults: Record<string, BackendFeatureType> = {\n  geocoding: {\n    roadspeed: {\n      enabled: false,\n      radiusRoads: 100,\n    },\n  },\n  shifts: {\n    _only: ['system'],\n    shifts: {\n      enabled: false,\n    },\n  },\n  parsing: {\n    _only: ['system'],\n    native: {\n      enabled: false,\n    },\n    linking: {\n      enabled: false,\n    },\n    fnol: {\n      enabled: false,\n    },\n    v2tripcalculation: {\n      enabled: false,\n    },\n  },\n  tasks: {\n    _only: ['system'],\n    taskservice: {\n      enabled: false,\n    },\n  },\n  reports: {\n    _only: ['system'],\n    new_processor: {\n      enabled: false,\n    },\n    new_renderer: {\n      enabled: false,\n    },\n  },\n  privacy: {\n    _only: ['system'],\n    trip_privacy: {\n      enabled: false,\n    },\n  },\n  api: {\n    rateLimit: 100,\n    caching: {\n      enabled: true,\n      ttl: 300,\n    },\n  },\n  dataRetention: {\n    tripHistory: 90,\n    auditLogs: 30,\n  },\n  integrations: {\n    enabled: false,\n    thirdParty: {\n      _only: ['admin'],\n      webhook: {\n        enabled: false,\n      },\n      restApi: {\n        enabled: false,\n      },\n    },\n  },\n};\n\n// Feature sections for UI building\nexport const AppFeatures: Record<string, FeatureSection> = {};\n\n// Flattened defaults for storage\nexport const AppFeatureFlagDefaults: Record<string, FeatureValue> = {};\n\nexport class AppFeatureSection implements FeatureSection {\n  id: string;\n  icon = '';\n  title = '';\n  fields: FormBuilderField[] = [];\n  subfields: FormBuilderField[] = [];\n\n  constructor(\n    public page: string,\n    defaultState: boolean,\n  ) {\n    this.id = page;\n    this.title =\n      AppFeatureTranslations[page.toUpperCase()]?.['TITLE'] ??\n      page.toUpperCase();\n    this.icon = PAGE_ICONS[page.split('-')[1]] ?? 'cog';\n\n    this.fields.push({\n      id: this.page + '-enabled',\n      title: 'Page',\n      type: 'dropdown',\n      required: true,\n      values: [\n        { key: 'null', value: 'Inherit' }, // Use null for 'Inherit'\n        { key: true, value: 'Enabled', fields: this.subfields },\n        { key: false, value: 'Disabled' },\n      ],\n    });\n\n    this.addDefault('enabled', defaultState);\n    AppFeatures[this.page] = this;\n  }\n\n  private addDefault(\n    id: string,\n    defaultValue: boolean | string | number | string[] | null,\n  ): void {\n    // Convert array to string for storage if needed, handle null\n    let separator = ',';\n    if (id === 'tabs') {\n      separator = '\\n';\n    }\n    const valueToStore = Array.isArray(defaultValue)\n      ? defaultValue.join(separator)\n      : defaultValue;\n    AppFeatureFlagDefaults[`${this.page}-${id}`] = valueToStore;\n  }\n\n  addEnabledToggle(id: string, defaultValue: boolean): FeatureSection {\n    this.addDefault(id, defaultValue);\n    this.subfields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[id.toUpperCase()] ??\n        id.toUpperCase(),\n      type: 'dropdown',\n      required: true,\n      values: [\n        { key: 'null', value: 'Inherit' },\n        { key: true, value: 'Enabled' },\n        { key: false, value: 'Disabled' },\n      ],\n      hint:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addCombo(\n    id: string,\n    values: FormBuilderKeyValue[],\n    defaultValue: string | null,\n  ): FeatureSection {\n    this.addDefault(id, defaultValue);\n    this.subfields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[id.toUpperCase()] ??\n        id.toUpperCase(),\n      type: 'dropdown',\n      required: true,\n      values: [{ key: 'null', value: 'Inherit' }, ...values], // Add Inherit option\n      hint:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addNumber(\n    id: string,\n    min: number,\n    max: number,\n    defaultValue: number | null,\n  ): FeatureSection {\n    this.addDefault(id, defaultValue);\n    this.subfields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[id.toUpperCase()] ??\n        id.toUpperCase(),\n      type: 'number',\n      required: false, // Numbers are often optional overrides\n      min: min,\n      max: max,\n      hint:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addCheckList(\n    id: string,\n    lookupKey: string,\n    defaultValue: string[],\n  ): FeatureSection {\n    this.addDefault(id, defaultValue); // Store as comma-separated string\n    this.subfields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[id.toUpperCase()] ??\n        id.toUpperCase(),\n      type: 'checklist',\n      required: false,\n      values: [],\n      valueLookup: lookupKey,\n      hint:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addMemo(id: string, defaultValue: string[]): FeatureSection {\n    this.addDefault(id, defaultValue); // Store as newline-separated string\n    this.subfields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[id.toUpperCase()] ??\n        id.toUpperCase(),\n      type: 'memo',\n      required: false,\n      hint:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addText(id: string, defaultValue: string, required: boolean): FeatureSection {\n    this.addDefault(id, defaultValue);\n    this.subfields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[id.toUpperCase()] ??\n        id.toUpperCase(),\n      type: 'text',\n      required: required,\n      hint:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addList(id: string): FeatureSection {\n    this.addDefault(id, ''); // Default for list is usually an empty string representing empty list\n    this.subfields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[id.toUpperCase()] ??\n        id.toUpperCase(),\n      type: 'list',\n      required: false,\n      hint:\n        AppFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n}\n\nexport class BackendFeatureSection implements FeatureSection {\n  id: string;\n  icon = 'cog';\n  title = '';\n  fields: FormBuilderField[] = [];\n  defaults: Record<string, FeatureValue> = {};\n\n  constructor(public page: string) {\n    this.id = page;\n    this.title =\n      AppBackendFeatureTranslations[page.toUpperCase()]?.['TITLE'] ??\n      page.toUpperCase();\n  }\n\n  private addDefault(\n    id: string,\n    defaultValue: boolean | string | number | string[] | null,\n  ): void {\n    const valueToStore = Array.isArray(defaultValue)\n      ? defaultValue.join(',') // Assuming comma separation for backend lists\n      : defaultValue;\n    this.defaults[`${this.page}-${id}`] = valueToStore;\n  }\n\n  addEnabledToggle(id: string, defaultValue: boolean): FeatureSection {\n    this.addDefault(id, defaultValue);\n    this.fields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          id.toUpperCase()\n        ] ?? id.toUpperCase(),\n      type: 'dropdown',\n      required: true,\n      values: [\n        { key: 'null', value: 'Inherit' },\n        { key: true, value: 'Enabled' },\n        { key: false, value: 'Disabled' },\n      ],\n      hint:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addCombo(\n    id: string,\n    values: FormBuilderKeyValue[],\n    defaultValue: string | null,\n  ): FeatureSection {\n    this.addDefault(id, defaultValue);\n    this.fields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          id.toUpperCase()\n        ] ?? id.toUpperCase(),\n      type: 'dropdown',\n      required: true,\n      values: [{ key: 'null', value: 'Inherit' }, ...values],\n      hint:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addNumber(\n    id: string,\n    min: number,\n    max: number,\n    defaultValue: number | null,\n  ): FeatureSection {\n    this.addDefault(id, defaultValue);\n    this.fields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          id.toUpperCase()\n        ] ?? id.toUpperCase(),\n      type: 'number',\n      required: false,\n      min: min,\n      max: max,\n      hint:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addCheckList(\n    id: string,\n    lookupKey: string,\n    defaultValue: string[],\n  ): FeatureSection {\n    this.addDefault(id, defaultValue); // Store as comma-separated string\n    this.fields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          id.toUpperCase()\n        ] ?? id.toUpperCase(),\n      type: 'checklist',\n      required: false,\n      values: [],\n      valueLookup: lookupKey,\n      hint:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addMemo(id: string, defaultValue: string[]): FeatureSection {\n    this.addDefault(id, defaultValue); // Store as newline-separated string\n    this.fields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          id.toUpperCase()\n        ] ?? id.toUpperCase(),\n      type: 'memo',\n      required: false,\n      hint:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n\n  addText(id: string, defaultValue: string, required: boolean): FeatureSection {\n    this.addDefault(id, defaultValue);\n    this.fields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          id.toUpperCase()\n        ] ?? id.toUpperCase(),\n      type: 'text',\n      required: required,\n      hint:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? `${this.page.toUpperCase()}.${id.toUpperCase()}-DESC`,\n    });\n\n    return this;\n  }\n\n  addList(id: string): FeatureSection {\n    this.addDefault(id, ''); // Default for list is empty string\n    this.fields.push({\n      id: `${this.page}-${id}`,\n      title:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          id.toUpperCase()\n        ] ?? id.toUpperCase(),\n      type: 'list',\n      required: false,\n      hint:\n        AppBackendFeatureTranslations[this.page.toUpperCase()]?.[\n          `${id.toUpperCase()}-DESC`\n        ] ?? '',\n    });\n    return this;\n  }\n}\n\n/**\n * Creates a feature section for app UI features\n */\nexport function createFeature(\n  pageId: string,\n  defaultState: boolean,\n): AppFeatureSection {\n  return new AppFeatureSection('page-' + pageId, defaultState);\n}\n\n/**\n * Creates a feature section for backend features\n */\nexport function createBackendFeature(id: string): BackendFeatureSection {\n  return new BackendFeatureSection(id);\n}\n\n/**\n * Returns backend feature defaults with proper owner type filtering\n */\nexport function getBackendFeatureDefaults(ownerType: string): {\n  bucket: string;\n  sections: Record<string, BackendFeatureSection>;\n  defaults: Record<string, FeatureValue>;\n} {\n  const result: {\n    bucket: string;\n    sections: Record<string, BackendFeatureSection>;\n    defaults: Record<string, FeatureValue>;\n  } = {\n    bucket: BACKEND_FEATURE_FLAGS,\n    sections: {},\n    defaults: {},\n  };\n\n  Object.keys(BackendFeatureDefaults).forEach((name) => {\n    const sectionConfig = BackendFeatureDefaults[name];\n    if (\n      isNullOrUndefined(sectionConfig) || // Type guard\n      !('_only' in sectionConfig) ||\n      (Array.isArray(sectionConfig._only) &&\n        sectionConfig._only.includes(ownerType))\n    ) {\n      const section = new BackendFeatureSection(name);\n      Object.keys(sectionConfig).forEach((featureKey) => {\n        if (featureKey !== '_only') {\n          const featureValue = sectionConfig[featureKey];\n\n          // Handle top-level enabled toggles (e.g., geocoding.roadspeed.enabled)\n          if (\n            typeof featureValue === 'object' &&\n            featureValue !== null &&\n            'enabled' in featureValue &&\n            typeof featureValue.enabled === 'boolean'\n          ) {\n            section.addEnabledToggle(\n              `${featureKey}-enabled`,\n              featureValue.enabled,\n            );\n          }\n\n          // Handle nested properties (like numbers, strings, etc. within the feature object)\n          if (\n            isDefined(featureValue) &&\n            typeof featureValue === 'object' &&\n            !Array.isArray(featureValue) &&\n            featureValue !== null\n          ) {\n            Object.keys(featureValue).forEach((propKey) => {\n              const propValue = (featureValue as Record<string, unknown>)[\n                propKey\n              ];\n              if (propKey !== 'enabled') {\n                // Add specific handlers based on type if needed\n                if (typeof propValue === 'number') {\n                  section.addNumber(\n                    `${featureKey}-${propKey}`,\n                    0, // Default min, adjust if needed\n                    propValue * 10 || 1000, // Default max (10x default or 1000), adjust if needed\n                    propValue,\n                  );\n                } else if (typeof propValue === 'string') {\n                  // Example: Add text field if it's a string property\n                  // section.addText(`${featureKey}-${propKey}`, propValue, false);\n                }\n                // Add more handlers for other types (boolean, array) if necessary\n              }\n            });\n          } else if (typeof featureValue === 'number') {\n            // Handle top-level number properties (e.g., api.rateLimit)\n            section.addNumber(\n              featureKey,\n              0,\n              featureValue * 10 || 1000,\n              featureValue,\n            );\n          }\n          // Add handlers for top-level boolean, string, array properties if needed\n        }\n      });\n\n      if (section.fields.length > 0) {\n        result.sections[name] = section;\n        result.defaults = {\n          ...result.defaults,\n          ...section.defaults,\n        };\n      }\n    }\n  });\n\n  return result;\n}\n\n// Helper function to initialize show toggles\nfunction initializeShowToggles(\n  section: AppFeatureSection,\n  showConfig: PageShowConfig,\n): void {\n  Object.keys(showConfig).forEach((featureKey) => {\n    const feature = featureKey as keyof PageShowConfig;\n    const defaultValue = showConfig[feature];\n    if (typeof defaultValue === 'boolean') {\n      section.addEnabledToggle(`show-${feature}`, defaultValue);\n    }\n  });\n}\n\n// Helper function to initialize basic properties\nfunction initializeBasicProperties(\n  section: AppFeatureSection,\n  pageConfig: Partial<PageConfig>,\n): void {\n  if (pageConfig.group !== undefined) {\n    section.addText('group', pageConfig.group, false);\n  }\n  if (isDefined(pageConfig.order)) {\n    section.addNumber('order', 0, 1000, pageConfig.order);\n  }\n  if (isDefined(pageConfig.name)) {\n    section.addText('name', pageConfig.name, false);\n  }\n  if (isDefined(pageConfig.icon)) {\n    section.addText('icon', pageConfig.icon, false);\n  }\n}\n\n// Helper function to initialize advanced properties\nfunction initializeAdvancedProperties(\n  section: AppFeatureSection,\n  pageConfig: Partial<PageConfig>,\n): void {\n  if (isDefined(pageConfig.pageSize)) {\n    section.addNumber('pageSize', 5, 1000, pageConfig.pageSize);\n  }\n  if (isDefined(pageConfig.layout)) {\n    section.addCombo(\n      'layout',\n      [\n        { key: 'advanced', value: 'Advanced' },\n        { key: 'basic', value: 'Basic' },\n      ],\n      pageConfig.layout,\n    );\n  }\n  if (isDefined(pageConfig.maxDuration)) {\n    section.addNumber('maxDuration', 1, 600, pageConfig.maxDuration);\n  }\n  if (isDefined(pageConfig.feedLoadLimit)) {\n    section.addNumber('feedLoadLimit', 30, 500, pageConfig.feedLoadLimit);\n  }\n}\n\n// Helper function to initialize list properties\nfunction initializeListProperties(\n  section: AppFeatureSection,\n  pageConfig: Partial<PageConfig>,\n): void {\n  if (isDefined(pageConfig.actions)) {\n    section.addCheckList(\n      'actions',\n      'alert-actions',\n      pageConfig.actions.split(',').filter((a) => a),\n    );\n  }\n  if (isDefined(pageConfig.reports)) {\n    section.addCheckList(\n      'reports',\n      'reports',\n      pageConfig.reports.split(',').filter((r) => r),\n    );\n  }\n  if (isDefined(pageConfig.tabs)) {\n    section.addList('tabs');\n  }\n  if (isDefined(pageConfig.availableAssetTypes)) {\n    section.addCheckList(\n      'availableAssetTypes',\n      'assetTypes',\n      pageConfig.availableAssetTypes.split(',').filter((t) => t),\n    );\n  }\n  if (isDefined(pageConfig.customPanels)) {\n    section.addList('customPanels');\n  }\n}\n\n// This function is called during app initialization to set up feature defaults\nexport function initializeFeatureDefaults(): void {\n  Object.keys(AppFeatureDefaults.page).forEach((name) => {\n    const pageConfig = AppFeatureDefaults.page[name];\n    if (isNullOrUndefined(pageConfig)) return;\n\n    const section = createFeature(name, pageConfig.enabled ?? false);\n\n    if (pageConfig.show) {\n      initializeShowToggles(section, pageConfig.show);\n    }\n\n    initializeBasicProperties(section, pageConfig);\n    initializeAdvancedProperties(section, pageConfig);\n    initializeListProperties(section, pageConfig);\n\n    if (isDefined(pageConfig.dateLimitOverride)) {\n      section.addEnabledToggle(\n        'dateLimitOverride',\n        pageConfig.dateLimitOverride,\n      );\n    }\n    if (isDefined(pageConfig.supportUrl)) {\n      section.addText('supportUrl', pageConfig.supportUrl, false);\n    }\n  });\n}\n\nconst AppBackendFeatureTranslations: Record<string, Record<string, string>> = {\n  GEOCODING: {\n    TITLE: 'Geocoding',\n    DESC: 'Select the geocoding features to enable for this client.',\n    'ROADSPEED-ENABLED': 'Road Speed',\n    'ROADSPEED-ENABLED-DESC': 'Enable retrieval of road speed limits.',\n    RADIUSROADS: 'Road Radius',\n    'RADIUSROADS-DESC':\n      'The radius (in meters) around a coordinate that geocoding will search for roads (default 100m, max 1000m).',\n  },\n  PARSING: {\n    TITLE: 'Parsing',\n    DESC: 'Select the parsing features to enable for this client.',\n    'NATIVE-ENABLED': 'Native',\n    'NATIVE-ENABLED-DESC': 'Enable native device parsing.',\n    'LINKING-ENABLED': 'Asset Linking',\n    'LINKING-ENABLED-DESC': 'Enable automatic asset linking.',\n    'FNOL-ENABLED': 'FNOL Reports',\n    'FNOL-ENABLED-DESC': 'Enable First Notice of Loss report generation.',\n    'V2TRIPCALCULATION-ENABLED': 'V2 Trip Calculation',\n    'V2TRIPCALCULATION-ENABLED-DESC': 'Use the V2 trip calculation engine.',\n  },\n  SHIFTS: {\n    TITLE: 'Shifts',\n    DESC: 'Enable shifts for this client.',\n    'SHIFTS-ENABLED': 'Enable Shifts',\n    'SHIFTS-ENABLED-DESC': 'Allow users to define and use work shifts.',\n  },\n  TASKS: {\n    TITLE: 'Tasks',\n    DESC: 'Select the task features to enable for this client',\n    'TASKSERVICE-ENABLED': 'Enable TaskService',\n    'TASKSERVICE-ENABLED-DESC': 'Activate the task management service.',\n  },\n  REPORTS: {\n    TITLE: 'Reports',\n    DESC: 'Select the reporting backend features to enable for this client',\n    'NEW_PROCESSOR-ENABLED': 'New Processing',\n    'NEW_PROCESSOR-ENABLED-DESC': 'Use the new report processing engine.',\n    'NEW_RENDERER-ENABLED': 'New Renderer',\n    'NEW_RENDERER-ENABLED-DESC': 'Use the new report rendering engine.',\n  },\n  PRIVACY: {\n    TITLE: 'Privacy Features',\n    DESC: 'Select the privacy features to enable for this client. Note that enabling these has a performance impact for the client.',\n    'TRIP_PRIVACY-ENABLED': 'Trip Privacy',\n    'TRIP_PRIVACY-ENABLED-DESC': 'Enable trip privacy mode features.',\n  },\n  API: {\n    TITLE: 'API Settings',\n    DESC: 'Configure API behavior.',\n    RATELIMIT: 'Rate Limit (requests/minute)',\n    'RATELIMIT-DESC':\n      'Set the maximum number of API requests allowed per minute.',\n    'CACHING-ENABLED': 'Enable Caching',\n    'CACHING-ENABLED-DESC': 'Enable server-side caching for API responses.',\n    TTL: 'Cache TTL (seconds)',\n    'TTL-DESC': 'Set the time-to-live for cached API responses.',\n  },\n  DATARETENTION: {\n    TITLE: 'Data Retention',\n    DESC: 'Configure data retention periods.',\n    TRIPHISTORY: 'Trip History (days)',\n    'TRIPHISTORY-DESC': 'Number of days to retain trip history data.',\n    AUDITLOGS: 'Audit Logs (days)',\n    'AUDITLOGS-DESC': 'Number of days to retain audit log data.',\n  },\n  INTEGRATIONS: {\n    TITLE: 'Integrations',\n    DESC: 'Configure third-party integrations.',\n    'ENABLED-ENABLED': 'Enable Integrations', // Assuming top-level enable toggle\n    'ENABLED-ENABLED-DESC':\n      'Globally enable or disable third-party integrations.',\n    'WEBHOOK-ENABLED': 'Webhook Support',\n    'WEBHOOK-ENABLED-DESC': 'Enable outgoing webhooks for event notifications.',\n    'RESTAPI-ENABLED': 'REST API Access',\n    'RESTAPI-ENABLED-DESC': 'Enable access via the third-party REST API.',\n  },\n};\nconst AppFeatureTranslations: Record<string, Record<string, string>> = {\n  'PAGE-OVERVIEW': {\n    TITLE: 'Overview Page',\n    DESC: 'The overview page provides a central page to locate assets and view their recent activity.',\n    PAGE: 'Page',\n    'SHOW-ACTIVITY': 'Activity Feed',\n    'SHOW-ACTIVITY-DESC':\n      'Enable to display the last couple of trips that an asset has completed.',\n    'SHOW-EVENTS': 'Event Feed',\n    'SHOW-EVENTS-DESC':\n      'Enable to display the most recent events generated by the asset.',\n    'SHOW-ALERTS': 'Alert Feed',\n    'SHOW-ALERTS-DESC':\n      'Enable to display the most recent alerts triggered by the asset.',\n    'SHOW-VIDEOS': 'Video Feed',\n    'SHOW-VIDEOS-DESC':\n      'Enable to display the most recent videos generated by the asset.',\n    'SHOW-TASKS': 'Tasks Feed',\n    // Corrected typo from SHOW-TASK-DESC\n    'SHOW-TASKS-DESC':\n      'Enable to display the most recent tasks generated by the asset.',\n    'SHOW-SHARING': 'Location Sharing',\n    'SHOW-SHARING-DESC':\n      'Enable to allow sharing asset locations with third parties.',\n    'SHOW-EDITING': 'Asset Editing',\n    'SHOW-EDITING-DESC':\n      'Enable to allow editing assets from the overview screen.',\n    PAGESIZE: 'Page Size',\n    'PAGESIZE-DESC':\n      'The number of assets to load and display at one time. Larger values will negatively affect performance.',\n    NAME: 'Title',\n    'NAME-DESC':\n      'Optionally specify a new title for the overview page. Leave blank for default.',\n    ICON: 'Icon',\n    'ICON-DESC':\n      'Optionally specify a different icon, any FontAwesome icon name is accepted. Leave blank for default.',\n    LAYOUT: 'Layout',\n    'LAYOUT-DESC': 'Choose between Basic or Advanced layouts.',\n    CUSTOMPANELS: 'Custom Panels',\n    'CUSTOMPANELS-DESC':\n      'Add custom panels (title:url format, one per line) to the asset details view.',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n  },\n  'PAGE-DASHBOARDS': {\n    TITLE: 'Dashboard Page',\n    DESC: 'Pin dashboard graphs to generate a daily metric overview.',\n    PAGE: 'Page',\n    'SHOW-HOURS': 'Hours',\n    'SHOW-HOURS-DESC': 'Enable hourly reports',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n  },\n  'PAGE-VIDEOS': {\n    TITLE: 'Videos Page',\n    DESC: 'Create, monitor and respond to asset triggered videos.',\n    PAGE: 'Page',\n    MAXDURATION: 'Max duration (seconds)',\n    'MAXDURATION-DESC': 'Set the maximum duration for requested videos.',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n    'SHOW-SAVEDVIDEOS': 'Saved Videos',\n    'SHOW-SAVEDVIDEOS-DESC': 'Enable to allow saving videos.',\n  },\n  'PAGE-ALERTS': {\n    TITLE: 'Alerts Page',\n    DESC: 'Create, monitor and respond to asset triggered event alerts.',\n    PAGE: 'Page',\n    ACTIONS: 'Available Actions',\n    'ACTIONS-DESC': 'Select which actions users can perform on alerts.',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n    FEEDLOADLIMIT: 'Alert Feed Limit',\n    'FEEDLOADLIMIT-DESC': 'Define the amount of Alerts to display per feed.',\n  },\n  'PAGE-REPLAY': {\n    TITLE: 'Trip History Page',\n    DESC: 'Retrieve and replay historic trip information.',\n    PAGE: 'Page',\n    CUSTOMPANELS: 'Custom Panels',\n    'CUSTOMPANELS-DESC':\n      'Enter each custom panel on a line, in the format <title>:<url>',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n  },\n  'PAGE-MAPSEARCH': {\n    TITLE: 'Map Search Page',\n    DESC: 'Search for historic activity on a map.',\n    PAGE: 'Page',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n  },\n  'PAGE-ASSETPERFORMANCE': {\n    TITLE: 'Driver Performance Page',\n    DESC: 'View performance data for the assets within the system.',\n    PAGE: 'Page',\n    NAME: 'Title',\n    'NAME-DESC':\n      'Optionally specify a new title for the driver performance. Leave blank for default.',\n    ICON: 'Icon',\n    'ICON-DESC':\n      'Optionally specify a different icon, any FontAwesome icon name is accepted. Leave blank for default.',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n  },\n  'PAGE-DEVICEHEALTH': {\n    TITLE: 'Device Health Page',\n    DESC: 'Get an overview of device health in a handy dashboard.',\n    PAGE: 'Page',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n    SUPPORTURL: 'Support Url',\n    'SUPPORTURL-DESC':\n      'Enter a URL to redirect to when a user requests support for a device issue.',\n  },\n  'PAGE-REPORTING': {\n    TITLE: 'Reporting Page',\n    DESC: 'Generate PDF and live dashboard reports.',\n    PAGE: 'Page',\n    'SHOW-ANALYTICS': 'Dashboard Reports',\n    'SHOW-ANALYTICS-DESC': 'Enable to allow users to run dashboard reports.',\n    REPORTS: 'Reports',\n    'REPORTS-DESC':\n      'Only checked reports will be available for use by clients.',\n    DATELIMITOVERRIDE: 'Date Limit Override',\n    'DATELIMITOVERRIDE-DESC':\n      'WARNING: Removing the report date limits could cause report generation to fail if sufficiently large documents are requested.',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n  },\n  'PAGE-ADMIN': {\n    TITLE: 'Administration Page',\n    DESC: 'Add, modify and administer entities.',\n    PAGE: 'Page',\n    CUSTOMPANELS: 'Custom Panels',\n    'CUSTOMPANELS-DESC':\n      'Add custom panels (title:url format, one per line) to specific entity views.',\n    'SHOW-FUELCARDS': 'Show Fuel Cards',\n    'SHOW-FUELCARDS-DESC': 'Enable the fuel card management section.',\n    AVAILABLEASSETTYPES: 'Available Asset Types',\n    'AVAILABLEASSETTYPES-DESC':\n      'Select which asset types can be created and managed.',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n  },\n  'PAGE-EXTERNAL': {\n    TITLE: 'External Tabs',\n    DESC: 'Add external applications to the custom tabs section',\n    PAGE: 'Page',\n    TABS: 'Tabs',\n    'TABS-DESC':\n      'Add external tabs (title:url format, one per line) to the main navigation.',\n  },\n  'PAGE-GEOFENCE': {\n    TITLE: 'Geofence Shortcut',\n    DESC: 'Display a button to open Geofence actions',\n    PAGE: 'Page',\n    GROUP: 'Section',\n    'GROUP-DESC':\n      'Choose which section within the navigation panel this page will belong to.',\n    ORDER: 'Order',\n    'ORDER-DESC':\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n  },\n};\n\nexport const AppListsTranslations = {\n  MODALS: {\n    'EXTERNAL-TABS': {\n      TITLE: 'External Tab',\n      DESC: 'Complete the following fields to add an external tab to the main navigation bar.',\n    },\n    'OVERVIEW-TABS': {\n      TITLE: 'Overview Custom Panel',\n      DESC: 'Complete the following fields to add a custom tab to the asset details view.',\n    },\n    'ADMIN-ENTITY-TABS': {\n      TITLE: 'Admin Entity Panel',\n      DESC: 'Complete the following fields to add a custom panel to an entity view.',\n    },\n  },\n  FIELDS: {\n    TITLE: 'Title',\n    URL: 'URL',\n    ICON: 'Icon',\n    ENTITY: 'Entity',\n    SECTION: 'Section',\n    SECTION_DESC:\n      \"Leave blank to place the item in the default 'Applications' sub menu.\",\n    ORDER: 'Order',\n    ORDER_DESC:\n      'Specify the position of this page within the navigation panel with respect to the other items in its section.',\n  },\n};\n","import { Injectable, inject } from '@angular/core';\nimport { Observable, of, throwError } from 'rxjs';\nimport { catchError, switchMap } from 'rxjs/operators';\nimport { AuthService } from './auth.service';\nimport {\n  LOCAL_STORAGE_KEY_ACCESS_TOKEN,\n  LOCAL_STORAGE_KEY_REFRESH_TOKEN,\n  LOCAL_STORAGE_KEY_TOKEN_EXPIRY,\n  LOCAL_STORAGE_KEY_USER_SESSION,\n} from '../models';\nimport { isDefined, isString } from '../../shared/utils';\nimport { UserSessionResponse } from '../../api';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthTokenManagerService {\n  private readonly authService = inject(AuthService);\n\n  // private readonly TOKEN_EXPIRY_BUFFER = 60000*59+55000; // 1 minute before expiry\n  private readonly TOKEN_EXPIRY_BUFFER = 60000; // 1 minute before expiry\n  private readonly TOKEN_EXPIRY_TIME = 3600000; // 1 hour in milliseconds\n  private refreshTokenTimeout: number | undefined | null = null;\n\n  constructor() {\n    this.scheduleTokenRefresh();\n  }\n\n  // Store tokens in localStorage\n  storeTokens(response: UserSessionResponse): void {\n    localStorage.setItem(LOCAL_STORAGE_KEY_ACCESS_TOKEN, response.accessToken);\n    localStorage.setItem(\n      LOCAL_STORAGE_KEY_REFRESH_TOKEN,\n      response.refreshToken,\n    );\n    localStorage.setItem(\n      LOCAL_STORAGE_KEY_TOKEN_EXPIRY,\n      (Date.now() + this.TOKEN_EXPIRY_TIME).toString(),\n    );\n    localStorage.setItem(\n      LOCAL_STORAGE_KEY_USER_SESSION,\n      JSON.stringify(response.users),\n    );\n    this.scheduleTokenRefresh();\n  }\n\n  // Get access token from localStForage\n  getAccessToken(): string | null {\n    return localStorage.getItem(LOCAL_STORAGE_KEY_ACCESS_TOKEN);\n  }\n\n  // Get refresh token from localStorage\n  getRefreshToken(): string | null {\n    return localStorage.getItem(LOCAL_STORAGE_KEY_REFRESH_TOKEN);\n  }\n\n  getTokenExpiry(): string | null {\n    const expiry = localStorage.getItem(LOCAL_STORAGE_KEY_TOKEN_EXPIRY);\n    if (!isString(expiry)) return null;\n\n    const expiryTimestamp = parseInt(expiry, 10);\n    if (isNaN(expiryTimestamp)) return null;\n\n    return new Date(expiryTimestamp).toISOString();\n  }\n\n  // Check if the token is expired\n  isTokenExpired(): boolean {\n    const expiry = localStorage.getItem(LOCAL_STORAGE_KEY_TOKEN_EXPIRY);\n    if (!isString(expiry)) return true;\n\n    const expiryTimestamp = parseInt(expiry, 10);\n    return isNaN(expiryTimestamp) || Date.now() > expiryTimestamp;\n  }\n\n  // Clear tokens from localStorage\n  clearTokens(): void {\n    localStorage.removeItem(LOCAL_STORAGE_KEY_ACCESS_TOKEN);\n    localStorage.removeItem(LOCAL_STORAGE_KEY_REFRESH_TOKEN);\n    localStorage.removeItem(LOCAL_STORAGE_KEY_TOKEN_EXPIRY);\n    if (isDefined(this.refreshTokenTimeout)) {\n      clearTimeout(this.refreshTokenTimeout);\n      this.refreshTokenTimeout = null;\n    }\n  }\n\n  // Schedule token refresh before expiry\n  private scheduleTokenRefresh(): void {\n    if (this.isTokenExpired()) {\n      this.clearTokens();\n      return;\n    }\n\n    const expiry = localStorage.getItem(LOCAL_STORAGE_KEY_TOKEN_EXPIRY);\n    if (!isString(expiry)) {\n      this.clearTokens();\n      return;\n    }\n\n    const expiryTimestamp = parseInt(expiry, 10);\n    if (isNaN(expiryTimestamp)) {\n      this.clearTokens();\n      return;\n    }\n\n    const timeout = expiryTimestamp - Date.now() - this.TOKEN_EXPIRY_BUFFER;\n    if (isDefined(this.refreshTokenTimeout)) {\n      clearTimeout(this.refreshTokenTimeout);\n    }\n\n    setTimeout(() => {\n      this.refreshToken().subscribe();\n    }, timeout);\n  }\n\n  // Refresh the token\n  private refreshToken(): Observable<UserSessionResponse> {\n    const refreshToken = this.getRefreshToken();\n    if (!isString(refreshToken)) {\n      this.clearTokens();\n      return throwError(() => 'No refresh token available');\n    }\n\n    return this.authService.refreshToken(refreshToken).pipe(\n      switchMap(\n        (response: UserSessionResponse): Observable<UserSessionResponse> => {\n          this.storeTokens(response);\n          return of(response);\n        },\n      ),\n      catchError((error) => {\n        this.clearTokens();\n        return throwError(() => error);\n      }),\n    );\n  }\n}\n","import { HttpParameterCodec } from '@angular/common/http';\nimport { Param } from './param';\n\nexport interface ConfigurationParameters {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    /**\n     * Takes care of encoding query- and form-parameters.\n     */\n    encoder?: HttpParameterCodec;\n    /**\n     * Override the default method for encoding path parameters in various\n     * <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-values\">styles</a>.\n     * <p>\n     * See {@link README.md} for more details\n     * </p>\n     */\n    encodeParam?: (param: Param) => string;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials?: {[ key: string ]: string | (() => string | undefined)};\n}\n\nexport class Configuration {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    /**\n     * Takes care of encoding query- and form-parameters.\n     */\n    encoder?: HttpParameterCodec;\n    /**\n     * Encoding of various path parameter\n     * <a href=\"https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#style-values\">styles</a>.\n     * <p>\n     * See {@link README.md} for more details\n     * </p>\n     */\n    encodeParam: (param: Param) => string;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials: {[ key: string ]: string | (() => string | undefined)};\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n        this.encoder = configurationParameters.encoder;\n        if (configurationParameters.encodeParam) {\n            this.encodeParam = configurationParameters.encodeParam;\n        }\n        else {\n            this.encodeParam = param => this.defaultEncodeParam(param);\n        }\n        if (configurationParameters.credentials) {\n            this.credentials = configurationParameters.credentials;\n        }\n        else {\n            this.credentials = {};\n        }\n\n        // init default access_token credential\n        if (!this.credentials['access_token']) {\n            this.credentials['access_token'] = () => {\n                if (this.apiKeys === null || this.apiKeys === undefined) {\n                    return undefined;\n                } else {\n                    return this.apiKeys['access_token'] || this.apiKeys['x-access-token'];\n                }\n            };\n        }\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length === 0) {\n            return undefined;\n        }\n\n        const type = contentTypes.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length === 0) {\n            return undefined;\n        }\n\n        const type = accepts.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n\n    public lookupCredential(key: string): string | undefined {\n        const value = this.credentials[key];\n        return typeof value === 'function'\n            ? value()\n            : value;\n    }\n\n    private defaultEncodeParam(param: Param): string {\n        // This implementation exists as fallback for missing configuration\n        // and for backwards compatibility to older typescript-angular generator versions.\n        // It only works for the 'simple' parameter style.\n        // Date-handling only works for the 'date-time' format.\n        // All other styles and Date-formats are probably handled incorrectly.\n        //\n        // But: if that's all you need (i.e.: the most common use-case): no need for customization!\n\n        const value = param.dataFormat === 'date-time' && param.value instanceof Date\n            ? (param.value as Date).toISOString()\n            : param.value;\n\n        return encodeURIComponent(String(value));\n    }\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n\n/**\n * Custom HttpParameterCodec\n * Workaround for https://github.com/angular/angular/issues/18261\n */\nexport class CustomHttpParameterCodec implements HttpParameterCodec {\n    encodeKey(k: string): string {\n        return encodeURIComponent(k);\n    }\n    encodeValue(v: string): string {\n        return encodeURIComponent(v);\n    }\n    decodeKey(k: string): string {\n        return decodeURIComponent(k);\n    }\n    decodeValue(v: string): string {\n        return decodeURIComponent(v);\n    }\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ClientCreateRequest } from '../model/clientCreateRequest';\n// @ts-ignore\nimport { ClientDetailsUpdateRequest } from '../model/clientDetailsUpdateRequest';\n// @ts-ignore\nimport { ClientListResponse } from '../model/clientListResponse';\n// @ts-ignore\nimport { ClientResponse } from '../model/clientResponse';\n// @ts-ignore\nimport { ClientUpdateRequest } from '../model/clientUpdateRequest';\n// @ts-ignore\nimport { CompanyGroupCreateRequest } from '../model/companyGroupCreateRequest';\n// @ts-ignore\nimport { CompanyGroupListResponse } from '../model/companyGroupListResponse';\n// @ts-ignore\nimport { CompanyGroupResponse } from '../model/companyGroupResponse';\n// @ts-ignore\nimport { CompanyGroupUpdateRequest } from '../model/companyGroupUpdateRequest';\n// @ts-ignore\nimport { CompanyResponse } from '../model/companyResponse';\n// @ts-ignore\nimport { DistributorCreateRequest } from '../model/distributorCreateRequest';\n// @ts-ignore\nimport { DistributorDetailsUpdateRequest } from '../model/distributorDetailsUpdateRequest';\n// @ts-ignore\nimport { DistributorListResponse } from '../model/distributorListResponse';\n// @ts-ignore\nimport { DistributorResponse } from '../model/distributorResponse';\n// @ts-ignore\nimport { DistributorUpdateRequest } from '../model/distributorUpdateRequest';\n// @ts-ignore\nimport { ForbiddenError } from '../model/forbiddenError';\n// @ts-ignore\nimport { IdName } from '../model/idName';\n// @ts-ignore\nimport { NotFoundError } from '../model/notFoundError';\n// @ts-ignore\nimport { SuccessResponse } from '../model/successResponse';\n// @ts-ignore\nimport { TooManyRequestsError } from '../model/tooManyRequestsError';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n// @ts-ignore\nimport { UserApiKeyCreateRequest } from '../model/userApiKeyCreateRequest';\n// @ts-ignore\nimport { UserApiKeyCreateResponse } from '../model/userApiKeyCreateResponse';\n// @ts-ignore\nimport { UserCreateRequest } from '../model/userCreateRequest';\n// @ts-ignore\nimport { UserCreateResponse } from '../model/userCreateResponse';\n// @ts-ignore\nimport { UserListResponse } from '../model/userListResponse';\n// @ts-ignore\nimport { UserPoliciesResponse } from '../model/userPoliciesResponse';\n// @ts-ignore\nimport { UserResetRequest } from '../model/userResetRequest';\n// @ts-ignore\nimport { UserResetResponse } from '../model/userResetResponse';\n// @ts-ignore\nimport { UserResponse } from '../model/userResponse';\n// @ts-ignore\nimport { UserRoleCreateRequest } from '../model/userRoleCreateRequest';\n// @ts-ignore\nimport { UserRoleListResponse } from '../model/userRoleListResponse';\n// @ts-ignore\nimport { UserRoleResponse } from '../model/userRoleResponse';\n// @ts-ignore\nimport { UserRoleUpdateRequest } from '../model/userRoleUpdateRequest';\n// @ts-ignore\nimport { UserUpdateRequest } from '../model/userUpdateRequest';\n// @ts-ignore\nimport { VendorCreateRequest } from '../model/vendorCreateRequest';\n// @ts-ignore\nimport { VendorDetailsUpdateRequest } from '../model/vendorDetailsUpdateRequest';\n// @ts-ignore\nimport { VendorListResponse } from '../model/vendorListResponse';\n// @ts-ignore\nimport { VendorResponse } from '../model/vendorResponse';\n// @ts-ignore\nimport { VendorUpdateRequest } from '../model/vendorUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AccountsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new API key\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApiKey(id: string, request: UserApiKeyCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserApiKeyCreateResponse>;\n    public createApiKey(id: string, request: UserApiKeyCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserApiKeyCreateResponse>>;\n    public createApiKey(id: string, request: UserApiKeyCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserApiKeyCreateResponse>>;\n    public createApiKey(id: string, request: UserApiKeyCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling createApiKey.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createApiKey.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/apikeys`;\n        return this.httpClient.request<UserApiKeyCreateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new client entity.\n     * @param request The &#x60;ClientCreateRequest&#x60; that contains the required properties for the new entity.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createClient(request: ClientCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientResponse>;\n    public createClient(request: ClientCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientResponse>>;\n    public createClient(request: ClientCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientResponse>>;\n    public createClient(request: ClientCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createClient.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients`;\n        return this.httpClient.request<ClientResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new company group\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createCompanyGroup(request: CompanyGroupCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupResponse>;\n    public createCompanyGroup(request: CompanyGroupCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupResponse>>;\n    public createCompanyGroup(request: CompanyGroupCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupResponse>>;\n    public createCompanyGroup(request: CompanyGroupCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createCompanyGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups`;\n        return this.httpClient.request<CompanyGroupResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new distributor account\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDistributor(request: DistributorCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorResponse>;\n    public createDistributor(request: DistributorCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorResponse>>;\n    public createDistributor(request: DistributorCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorResponse>>;\n    public createDistributor(request: DistributorCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDistributor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors`;\n        return this.httpClient.request<DistributorResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new user\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createUser(request: UserCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserCreateResponse>;\n    public createUser(request: UserCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserCreateResponse>>;\n    public createUser(request: UserCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserCreateResponse>>;\n    public createUser(request: UserCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createUser.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users`;\n        return this.httpClient.request<UserCreateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new user role entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createUserRole(request: UserRoleCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleResponse>;\n    public createUserRole(request: UserRoleCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleResponse>>;\n    public createUserRole(request: UserRoleCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleResponse>>;\n    public createUserRole(request: UserRoleCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createUserRole.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles`;\n        return this.httpClient.request<UserRoleResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new vendor account\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createVendor(request: VendorCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorResponse>;\n    public createVendor(request: VendorCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorResponse>>;\n    public createVendor(request: VendorCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorResponse>>;\n    public createVendor(request: VendorCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createVendor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors`;\n        return this.httpClient.request<VendorResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes an API key\n     * @param id \n     * @param keyid \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteApiKey(id: string, keyid: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SuccessResponse>;\n    public deleteApiKey(id: string, keyid: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SuccessResponse>>;\n    public deleteApiKey(id: string, keyid: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SuccessResponse>>;\n    public deleteApiKey(id: string, keyid: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteApiKey.');\n        }\n        if (keyid === null || keyid === undefined) {\n            throw new Error('Required parameter keyid was null or undefined when calling deleteApiKey.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/apikeys/${this.configuration.encodeParam({name: \"keyid\", value: keyid, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SuccessResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a custom client logo. The logo will revert to the client\\&#39;s parent logo.\n     * @param id The client UUID.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteClientLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteClientLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteClientLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteClientLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteClientLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling deleteClientLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a company group\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteCompanyGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupResponse>;\n    public deleteCompanyGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupResponse>>;\n    public deleteCompanyGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupResponse>>;\n    public deleteCompanyGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteCompanyGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompanyGroupResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a custom distributor logo. The logo will revert to the Key Telematics logo.\n     * @param id The distributor UUID.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteDistributorLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteDistributorLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteDistributorLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteDistributorLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteDistributorLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling deleteDistributorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes a previously configured OTP method for a user.\n     * @param id \n     * @param method \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteOTPMethod(id: string, method: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SuccessResponse>;\n    public deleteOTPMethod(id: string, method: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SuccessResponse>>;\n    public deleteOTPMethod(id: string, method: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SuccessResponse>>;\n    public deleteOTPMethod(id: string, method: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteOTPMethod.');\n        }\n        if (method === null || method === undefined) {\n            throw new Error('Required parameter method was null or undefined when calling deleteOTPMethod.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/otp/${this.configuration.encodeParam({name: \"method\", value: method, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SuccessResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a user avatar.\n     * @param id The user UUID.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteUserAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteUserAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteUserAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteUserAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteUserAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a user role\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteUserRole(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleResponse>;\n    public deleteUserRole(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleResponse>>;\n    public deleteUserRole(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleResponse>>;\n    public deleteUserRole(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteUserRole.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserRoleResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a custom vendor logo. The logo will revert to the vendor\\&#39;s parent logo.\n     * @param id The vendor UUID.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteVendorLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteVendorLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteVendorLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteVendorLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteVendorLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling deleteVendorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns client details for the specified UUID.\n     * @param id The UUID of the client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getClient(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientResponse>;\n    public getClient(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientResponse>>;\n    public getClient(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientResponse>>;\n    public getClient(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getClient.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ClientResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns the client ID and name for the specified PIN. PINs are generated by the system and can be retrieved via the &#x60;pin&#x60; property on the  &#x60;ClientResponse&#x60; object retrieved with &#x60;getClient&#x60;.\n     * @param pin The PIN code of the client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getClientByPin(pin: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IdName>;\n    public getClientByPin(pin: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IdName>>;\n    public getClientByPin(pin: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IdName>>;\n    public getClientByPin(pin: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (pin === null || pin === undefined) {\n            throw new Error('Required parameter pin was null or undefined when calling getClientByPin.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/pin/${this.configuration.encodeParam({name: \"pin\", value: pin, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<IdName>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the specified client\\&#39;s logo in binary format. Should the client not have a custom logo, the logo of the vendor will be supplied.\n     * @param id The client UUID you are requesting data for.\n     * @param size The size of the returned image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getClientLogo(id: string, size?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getClientLogo(id: string, size?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getClientLogo(id: string, size?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getClientLogo(id: string, size?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getClientLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns company details for the specified id\n     * @param id The UUID of the client\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompany(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyResponse>;\n    public getCompany(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyResponse>>;\n    public getCompany(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyResponse>>;\n    public getCompany(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompany.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companies/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompanyResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns company group details for the specified id\n     * @param id The UUID of the company group\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompanyGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupResponse>;\n    public getCompanyGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupResponse>>;\n    public getCompanyGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupResponse>>;\n    public getCompanyGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompanyGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompanyGroupResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the specified company\\&#39;s logo in binary format.\n     * @param id The client UUID you are requesting data for.\n     * @param size The size of the returned image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param recurse Set recurse to true if you\\&#39;d like the parent tree to be searched for a logo if none exists for this company.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompanyLogo(id: string, size: string, recurse?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getCompanyLogo(id: string, size: string, recurse?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getCompanyLogo(id: string, size: string, recurse?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getCompanyLogo(id: string, size: string, recurse?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompanyLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling getCompanyLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companies/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns distributor details for the specified id\n     * @param id The UUID of the distributor\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDistributor(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorResponse>;\n    public getDistributor(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorResponse>>;\n    public getDistributor(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorResponse>>;\n    public getDistributor(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDistributor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DistributorResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the specified distributors\\&#39;s logo in binary format. Should the distributor not have a custom logo, the default Key Telematics logo will be supplied.\n     * @param id The distributor UUID you are requesting data for.\n     * @param size The size of the returned image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDistributorLogo(id: string, size?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getDistributorLogo(id: string, size?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getDistributorLogo(id: string, size?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getDistributorLogo(id: string, size?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDistributorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns user details for the specified id\n     * @param id The UUID of the user\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUser(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserResponse>;\n    public getUser(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserResponse>>;\n    public getUser(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserResponse>>;\n    public getUser(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getUser.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the user avatar in binary format\n     * @param id The UUID of the user\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUserAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getUserAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getUserAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getUserAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getUserAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns active security policies for the current user\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUserPolicies(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserPoliciesResponse>;\n    public getUserPolicies(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserPoliciesResponse>>;\n    public getUserPolicies(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserPoliciesResponse>>;\n    public getUserPolicies(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getUserPolicies.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/policies`;\n        return this.httpClient.request<UserPoliciesResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns export task details for the specified id\n     * @param id The UUID of the user role\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUserRole(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleResponse>;\n    public getUserRole(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleResponse>>;\n    public getUserRole(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleResponse>>;\n    public getUserRole(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getUserRole.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserRoleResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns vendor details for the specified id\n     * @param id The UUID of the vendor\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getVendor(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorResponse>;\n    public getVendor(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorResponse>>;\n    public getVendor(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorResponse>>;\n    public getVendor(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getVendor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<VendorResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the specified vendor\\&#39;s logo in binary format. Should the vendor not have a custom logo, the logo of the distributor will be supplied.\n     * @param id The vendor UUID you are requesting data for.\n     * @param size The size of the returned image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getVendorLogo(id: string, size?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getVendorLogo(id: string, size?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getVendorLogo(id: string, size?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getVendorLogo(id: string, size?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getVendorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of clients for a specified vendor.\n     * @param owner The UUID of the vendor you are requesting data for.\n     * @param offset An offset into the result set, useful for pagination.\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param counts A list of entity types to return counts for that belong to this client, comma delimited, i.e. &#x60;counts&#x3D;asset,device,simcard&#x60;. Each additional entity affects the performance of the query and should be used sparingly.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listClients(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientListResponse>;\n    public listClients(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientListResponse>>;\n    public listClients(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientListResponse>>;\n    public listClients(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listClients.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n        if (counts !== undefined && counts !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>counts, 'counts');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients`;\n        return this.httpClient.request<ClientListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of company groups for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listCompanyGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupListResponse>;\n    public listCompanyGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupListResponse>>;\n    public listCompanyGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupListResponse>>;\n    public listCompanyGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listCompanyGroups.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups`;\n        return this.httpClient.request<CompanyGroupListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of distributors for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param counts A list of entity types to return counts for that belong to this distributor, comma delimited, i.e. &#x60;counts&#x3D;vendor,client,asset,device&#x60;. Each additional entity affects the performance of the query and should be used sparingly.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDistributors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorListResponse>;\n    public listDistributors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorListResponse>>;\n    public listDistributors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorListResponse>>;\n    public listDistributors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDistributors.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n        if (counts !== undefined && counts !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>counts, 'counts');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors`;\n        return this.httpClient.request<DistributorListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of user roles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listUserRoles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleListResponse>;\n    public listUserRoles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleListResponse>>;\n    public listUserRoles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleListResponse>>;\n    public listUserRoles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listUserRoles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles`;\n        return this.httpClient.request<UserRoleListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of users for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listUsers(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserListResponse>;\n    public listUsers(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserListResponse>>;\n    public listUsers(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserListResponse>>;\n    public listUsers(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listUsers.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users`;\n        return this.httpClient.request<UserListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of vendors for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param counts A list of entity types to return counts for that belong to this vendor, comma delimited, i.e. &#x60;counts&#x3D;client,asset,device&#x60;. Each additional entity affects the performance of the query and should be used sparingly.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listVendors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorListResponse>;\n    public listVendors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorListResponse>>;\n    public listVendors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorListResponse>>;\n    public listVendors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listVendors.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n        if (counts !== undefined && counts !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>counts, 'counts');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors`;\n        return this.httpClient.request<VendorListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Optionally suspends the user and sends them a password reset email.\n     * @param id The UUID of the user\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public resetUser(id: string, request: UserResetRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserResetResponse>;\n    public resetUser(id: string, request: UserResetRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserResetResponse>>;\n    public resetUser(id: string, request: UserResetRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserResetResponse>>;\n    public resetUser(id: string, request: UserResetRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling resetUser.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling resetUser.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/reset`;\n        return this.httpClient.request<UserResetResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing client entity by patching the existing object with the properties supplied in the &#x60;ClientUpdateRequest&#x60;.\n     * @param id The UUID of the client\n     * @param request The &#x60;ClientUpdateRequest&#x60; that contains only the properites that are to be changed on the entity.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateClient(id: string, request: ClientUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientResponse>;\n    public updateClient(id: string, request: ClientUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientResponse>>;\n    public updateClient(id: string, request: ClientUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientResponse>>;\n    public updateClient(id: string, request: ClientUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateClient.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateClient.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ClientResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing client account details. Unlike updateClient, this route is available to client users.\n     * @param id The UUID of the client\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateClientDetails(id: string, request: ClientDetailsUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientResponse>;\n    public updateClientDetails(id: string, request: ClientDetailsUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientResponse>>;\n    public updateClientDetails(id: string, request: ClientDetailsUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientResponse>>;\n    public updateClientDetails(id: string, request: ClientDetailsUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateClientDetails.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateClientDetails.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/details`;\n        return this.httpClient.request<ClientResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified client\\&#39;s logo.\n     * @param id The client UUID you are requesting data for.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateClientLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateClientLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateClientLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateClientLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateClientLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling updateClientLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing company group\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCompanyGroup(id: string, request: CompanyGroupUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupResponse>;\n    public updateCompanyGroup(id: string, request: CompanyGroupUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupResponse>>;\n    public updateCompanyGroup(id: string, request: CompanyGroupUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupResponse>>;\n    public updateCompanyGroup(id: string, request: CompanyGroupUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateCompanyGroup.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateCompanyGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompanyGroupResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing distributor account\n     * @param id The UUID of the distributor\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDistributor(id: string, request: DistributorUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorResponse>;\n    public updateDistributor(id: string, request: DistributorUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorResponse>>;\n    public updateDistributor(id: string, request: DistributorUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorResponse>>;\n    public updateDistributor(id: string, request: DistributorUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDistributor.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDistributor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DistributorResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing distributor account details. Unlike &#x60;updateDistributor&#x60;, this route is available to distributor users.\n     * @param id The UUID of the distributor\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDistributorDetails(id: string, request: DistributorDetailsUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorResponse>;\n    public updateDistributorDetails(id: string, request: DistributorDetailsUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorResponse>>;\n    public updateDistributorDetails(id: string, request: DistributorDetailsUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorResponse>>;\n    public updateDistributorDetails(id: string, request: DistributorDetailsUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDistributorDetails.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDistributorDetails.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/details`;\n        return this.httpClient.request<DistributorResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified distributor\\&#39;s logo.\n     * @param id The distributor UUID you are requesting data for.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDistributorLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateDistributorLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateDistributorLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateDistributorLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDistributorLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling updateDistributorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing user\n     * @param id The UUID of the user\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateUser(id: string, request: UserUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserResponse>;\n    public updateUser(id: string, request: UserUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserResponse>>;\n    public updateUser(id: string, request: UserUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserResponse>>;\n    public updateUser(id: string, request: UserUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateUser.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateUser.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified user\\&#39;s avatar.\n     * @param id The user UUID you are requesting data for.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateUserAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateUserAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateUserAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateUserAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateUserAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing user role entity\n     * @param id The UUID of the user role\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateUserRole(id: string, request: UserRoleUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleResponse>;\n    public updateUserRole(id: string, request: UserRoleUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleResponse>>;\n    public updateUserRole(id: string, request: UserRoleUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleResponse>>;\n    public updateUserRole(id: string, request: UserRoleUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateUserRole.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateUserRole.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserRoleResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing vendor account\n     * @param id The UUID of the vendor\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateVendor(id: string, request: VendorUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorResponse>;\n    public updateVendor(id: string, request: VendorUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorResponse>>;\n    public updateVendor(id: string, request: VendorUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorResponse>>;\n    public updateVendor(id: string, request: VendorUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateVendor.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateVendor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<VendorResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing vendor account details. Unlike updateVendor, this route is available to vendor users.\n     * @param id The UUID of the vendor\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateVendorDetails(id: string, request: VendorDetailsUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorResponse>;\n    public updateVendorDetails(id: string, request: VendorDetailsUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorResponse>>;\n    public updateVendorDetails(id: string, request: VendorDetailsUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorResponse>>;\n    public updateVendorDetails(id: string, request: VendorDetailsUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateVendorDetails.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateVendorDetails.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/details`;\n        return this.httpClient.request<VendorResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified vendor\\&#39;s logo.\n     * @param id The vendor UUID you are requesting data for.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateVendorLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateVendorLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateVendorLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateVendorLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateVendorLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling updateVendorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { DeviceTypeCreateRequest } from '../model/deviceTypeCreateRequest';\n// @ts-ignore\nimport { DeviceTypeListResponse } from '../model/deviceTypeListResponse';\n// @ts-ignore\nimport { DeviceTypeResponse } from '../model/deviceTypeResponse';\n// @ts-ignore\nimport { DeviceTypeUpdateRequest } from '../model/deviceTypeUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DeviceTypesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new device type entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDeviceType(request: DeviceTypeCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceTypeResponse>;\n    public createDeviceType(request: DeviceTypeCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceTypeResponse>>;\n    public createDeviceType(request: DeviceTypeCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceTypeResponse>>;\n    public createDeviceType(request: DeviceTypeCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDeviceType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devicetypes`;\n        return this.httpClient.request<DeviceTypeResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device type details for the specified id\n     * @param id The UUID of the device\n     * @param owner The optional UUID of a Client. The device type may be customized based on settings and features in the client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceType(id: string, owner?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceTypeResponse>;\n    public getDeviceType(id: string, owner?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceTypeResponse>>;\n    public getDeviceType(id: string, owner?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceTypeResponse>>;\n    public getDeviceType(id: string, owner?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDeviceType.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devicetypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of device types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent company tree as well (defaults to \\&quot;true\\&quot;)\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDeviceTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceTypeListResponse>;\n    public listDeviceTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceTypeListResponse>>;\n    public listDeviceTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceTypeListResponse>>;\n    public listDeviceTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDeviceTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devicetypes`;\n        return this.httpClient.request<DeviceTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing device type\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDeviceType(id: string, request: DeviceTypeUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceTypeResponse>;\n    public updateDeviceType(id: string, request: DeviceTypeUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceTypeResponse>>;\n    public updateDeviceType(id: string, request: DeviceTypeUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceTypeResponse>>;\n    public updateDeviceType(id: string, request: DeviceTypeUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDeviceType.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDeviceType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devicetypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceTypeResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\nimport { Configuration } from './configuration';\nimport { HttpClient } from '@angular/common/http';\n\n\n@NgModule({\n  imports:      [],\n  declarations: [],\n  exports:      [],\n  providers: []\n})\nexport class ApiModule {\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders<ApiModule> {\n        return {\n            ngModule: ApiModule,\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\n        };\n    }\n\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\n                 @Optional() http: HttpClient) {\n        if (parentModule) {\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n        }\n        if (!http) {\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\n            'See also https://github.com/angular/angular/issues/20575');\n        }\n    }\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AlertCreateRequest } from '../model/alertCreateRequest';\n// @ts-ignore\nimport { AlertListResponse } from '../model/alertListResponse';\n// @ts-ignore\nimport { AlertResponse } from '../model/alertResponse';\n// @ts-ignore\nimport { AlertUpdateRequest } from '../model/alertUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AlertsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Alert\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAlert(request: AlertCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AlertResponse>;\n    public createAlert(request: AlertCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AlertResponse>>;\n    public createAlert(request: AlertCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AlertResponse>>;\n    public createAlert(request: AlertCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/alerts`;\n        return this.httpClient.request<AlertResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns alert details for the specified id\n     * @param id The UUID of the alert\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAlert(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AlertResponse>;\n    public getAlert(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AlertResponse>>;\n    public getAlert(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AlertResponse>>;\n    public getAlert(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/alerts/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AlertResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of alerts for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAlerts(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AlertListResponse>;\n    public listAlerts(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AlertListResponse>>;\n    public listAlerts(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AlertListResponse>>;\n    public listAlerts(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAlerts.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/alerts`;\n        return this.httpClient.request<AlertListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Alert\n     * @param id The UUID of the Alert\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAlert(id: string, request: AlertUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AlertResponse>;\n    public updateAlert(id: string, request: AlertUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AlertResponse>>;\n    public updateAlert(id: string, request: AlertUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AlertResponse>>;\n    public updateAlert(id: string, request: AlertUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAlert.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/alerts/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AlertResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AnalyticsBaseReportResponse } from '../model/analyticsBaseReportResponse';\n// @ts-ignore\nimport { AnalyticsBaseReportsListResponse } from '../model/analyticsBaseReportsListResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AnalyticsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Retrieve an analytics base report by its ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAnalyticsBaseReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AnalyticsBaseReportResponse>;\n    public getAnalyticsBaseReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AnalyticsBaseReportResponse>>;\n    public getAnalyticsBaseReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AnalyticsBaseReportResponse>>;\n    public getAnalyticsBaseReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAnalyticsBaseReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/analytics/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AnalyticsBaseReportResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of base reports for a specified owner, client or user.\n     * @param owner \n     * @param client \n     * @param user \n     * @param offset \n     * @param limit \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAnalyticsBaseReports(owner?: string, client?: string, user?: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AnalyticsBaseReportsListResponse>;\n    public listAnalyticsBaseReports(owner?: string, client?: string, user?: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AnalyticsBaseReportsListResponse>>;\n    public listAnalyticsBaseReports(owner?: string, client?: string, user?: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AnalyticsBaseReportsListResponse>>;\n    public listAnalyticsBaseReports(owner?: string, client?: string, user?: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (client !== undefined && client !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>client, 'client');\n        }\n        if (user !== undefined && user !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>user, 'user');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/analytics`;\n        return this.httpClient.request<AnalyticsBaseReportsListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Rebuilds a base report\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public rebuildAnalyticsBaseReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public rebuildAnalyticsBaseReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public rebuildAnalyticsBaseReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public rebuildAnalyticsBaseReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling rebuildAnalyticsBaseReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/analytics/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/rebuild`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AssetCategoryCreateRequest } from '../model/assetCategoryCreateRequest';\n// @ts-ignore\nimport { AssetCategoryListResponse } from '../model/assetCategoryListResponse';\n// @ts-ignore\nimport { AssetCategoryResponse } from '../model/assetCategoryResponse';\n// @ts-ignore\nimport { AssetCategoryUpdateRequest } from '../model/assetCategoryUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AssetCategoriesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new asset category\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetCategory(request: AssetCategoryCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryResponse>;\n    public createAssetCategory(request: AssetCategoryCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryResponse>>;\n    public createAssetCategory(request: AssetCategoryCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryResponse>>;\n    public createAssetCategory(request: AssetCategoryCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetCategory.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories`;\n        return this.httpClient.request<AssetCategoryResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete an asset category\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAssetCategory(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryResponse>;\n    public deleteAssetCategory(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryResponse>>;\n    public deleteAssetCategory(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryResponse>>;\n    public deleteAssetCategory(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteAssetCategory.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetCategoryResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset category details for the specified id\n     * @param id The UUID of the asset category\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetCategory(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryResponse>;\n    public getAssetCategory(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryResponse>>;\n    public getAssetCategory(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryResponse>>;\n    public getAssetCategory(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetCategory.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetCategoryResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset categories for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetCategories(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryListResponse>;\n    public listAssetCategories(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryListResponse>>;\n    public listAssetCategories(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryListResponse>>;\n    public listAssetCategories(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetCategories.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories`;\n        return this.httpClient.request<AssetCategoryListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing asset category\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetCategory(id: string, request: AssetCategoryUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryResponse>;\n    public updateAssetCategory(id: string, request: AssetCategoryUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryResponse>>;\n    public updateAssetCategory(id: string, request: AssetCategoryUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryResponse>>;\n    public updateAssetCategory(id: string, request: AssetCategoryUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetCategory.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetCategory.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetCategoryResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AssetGroupCreateRequest } from '../model/assetGroupCreateRequest';\n// @ts-ignore\nimport { AssetGroupListResponse } from '../model/assetGroupListResponse';\n// @ts-ignore\nimport { AssetGroupResponse } from '../model/assetGroupResponse';\n// @ts-ignore\nimport { AssetGroupUpdateRequest } from '../model/assetGroupUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AssetGroupsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Asset Group\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetGroup(request: AssetGroupCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupResponse>;\n    public createAssetGroup(request: AssetGroupCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupResponse>>;\n    public createAssetGroup(request: AssetGroupCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupResponse>>;\n    public createAssetGroup(request: AssetGroupCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups`;\n        return this.httpClient.request<AssetGroupResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete an asset group\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAssetGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupResponse>;\n    public deleteAssetGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupResponse>>;\n    public deleteAssetGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupResponse>>;\n    public deleteAssetGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteAssetGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetGroupResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset group details for the specified id\n     * @param id The UUID of the asset group\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupResponse>;\n    public getAssetGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupResponse>>;\n    public getAssetGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupResponse>>;\n    public getAssetGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetGroupResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset groups for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupListResponse>;\n    public listAssetGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupListResponse>>;\n    public listAssetGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupListResponse>>;\n    public listAssetGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetGroups.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups`;\n        return this.httpClient.request<AssetGroupListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Asset Group\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetGroup(id: string, request: AssetGroupUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupResponse>;\n    public updateAssetGroup(id: string, request: AssetGroupUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupResponse>>;\n    public updateAssetGroup(id: string, request: AssetGroupUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupResponse>>;\n    public updateAssetGroup(id: string, request: AssetGroupUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetGroup.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetGroupResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AssetRatingProfileCreateRequest } from '../model/assetRatingProfileCreateRequest';\n// @ts-ignore\nimport { AssetRatingProfileListResponse } from '../model/assetRatingProfileListResponse';\n// @ts-ignore\nimport { AssetRatingProfileResponse } from '../model/assetRatingProfileResponse';\n// @ts-ignore\nimport { AssetRatingProfileUpdateRequest } from '../model/assetRatingProfileUpdateRequest';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AssetRatingProfilesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Asset Rating Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetRatingProfile(request: AssetRatingProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetRatingProfileResponse>;\n    public createAssetRatingProfile(request: AssetRatingProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetRatingProfileResponse>>;\n    public createAssetRatingProfile(request: AssetRatingProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetRatingProfileResponse>>;\n    public createAssetRatingProfile(request: AssetRatingProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetRatingProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetratingprofiles`;\n        return this.httpClient.request<AssetRatingProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset rating profile details for the specified id\n     * @param id The UUID of the asset rating profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetRatingProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetRatingProfileResponse>;\n    public getAssetRatingProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetRatingProfileResponse>>;\n    public getAssetRatingProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetRatingProfileResponse>>;\n    public getAssetRatingProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetRatingProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetratingprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetRatingProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset rating profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetRatingProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetRatingProfileListResponse>;\n    public listAssetRatingProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetRatingProfileListResponse>>;\n    public listAssetRatingProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetRatingProfileListResponse>>;\n    public listAssetRatingProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetRatingProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetratingprofiles`;\n        return this.httpClient.request<AssetRatingProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Asset Rating Profile entity\n     * @param id The UUID of the Asset State Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetRatingProfile(id: string, request: AssetRatingProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetRatingProfileResponse>;\n    public updateAssetRatingProfile(id: string, request: AssetRatingProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetRatingProfileResponse>>;\n    public updateAssetRatingProfile(id: string, request: AssetRatingProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetRatingProfileResponse>>;\n    public updateAssetRatingProfile(id: string, request: AssetRatingProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetRatingProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetRatingProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetratingprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetRatingProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AssetStateProfileCreateRequest } from '../model/assetStateProfileCreateRequest';\n// @ts-ignore\nimport { AssetStateProfileListResponse } from '../model/assetStateProfileListResponse';\n// @ts-ignore\nimport { AssetStateProfileResponse } from '../model/assetStateProfileResponse';\n// @ts-ignore\nimport { AssetStateProfileUpdateRequest } from '../model/assetStateProfileUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AssetStateProfilesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Asset State Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetStateProfile(request: AssetStateProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetStateProfileResponse>;\n    public createAssetStateProfile(request: AssetStateProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetStateProfileResponse>>;\n    public createAssetStateProfile(request: AssetStateProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetStateProfileResponse>>;\n    public createAssetStateProfile(request: AssetStateProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetStateProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetstateprofiles`;\n        return this.httpClient.request<AssetStateProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset state profile details for the specified id\n     * @param id The UUID of the asset state profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetStateProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetStateProfileResponse>;\n    public getAssetStateProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetStateProfileResponse>>;\n    public getAssetStateProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetStateProfileResponse>>;\n    public getAssetStateProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetStateProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetstateprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetStateProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset state profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetStateProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetStateProfileListResponse>;\n    public listAssetStateProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetStateProfileListResponse>>;\n    public listAssetStateProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetStateProfileListResponse>>;\n    public listAssetStateProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetStateProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetstateprofiles`;\n        return this.httpClient.request<AssetStateProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Asset State Profile entity\n     * @param id The UUID of the Asset State Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetStateProfile(id: string, request: AssetStateProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetStateProfileResponse>;\n    public updateAssetStateProfile(id: string, request: AssetStateProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetStateProfileResponse>>;\n    public updateAssetStateProfile(id: string, request: AssetStateProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetStateProfileResponse>>;\n    public updateAssetStateProfile(id: string, request: AssetStateProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetStateProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetStateProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetstateprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetStateProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AssetTagTypeListResponse } from '../model/assetTagTypeListResponse';\n// @ts-ignore\nimport { AssetTagTypeResponse } from '../model/assetTagTypeResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AssetTagTypesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Returns asset tag type details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetTagType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagTypeResponse>;\n    public getAssetTagType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagTypeResponse>>;\n    public getAssetTagType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagTypeResponse>>;\n    public getAssetTagType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetTagType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettagtypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetTagTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset tag types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetTagTypes(owner: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagTypeListResponse>;\n    public listAssetTagTypes(owner: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagTypeListResponse>>;\n    public listAssetTagTypes(owner: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagTypeListResponse>>;\n    public listAssetTagTypes(owner: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetTagTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettagtypes`;\n        return this.httpClient.request<AssetTagTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AssetTagCreateRequest } from '../model/assetTagCreateRequest';\n// @ts-ignore\nimport { AssetTagListResponse } from '../model/assetTagListResponse';\n// @ts-ignore\nimport { AssetTagResponse } from '../model/assetTagResponse';\n// @ts-ignore\nimport { AssetTagUpdateRequest } from '../model/assetTagUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AssetTagsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Asset Tag\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetTag(request: AssetTagCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagResponse>;\n    public createAssetTag(request: AssetTagCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagResponse>>;\n    public createAssetTag(request: AssetTagCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagResponse>>;\n    public createAssetTag(request: AssetTagCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetTag.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettags`;\n        return this.httpClient.request<AssetTagResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns Asset Tag details for the specified id\n     * @param id The UUID of the Asset Tag\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetTag(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagResponse>;\n    public getAssetTag(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagResponse>>;\n    public getAssetTag(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagResponse>>;\n    public getAssetTag(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetTag.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettags/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetTagResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of Asset Tags for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetTags(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagListResponse>;\n    public listAssetTags(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagListResponse>>;\n    public listAssetTags(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagListResponse>>;\n    public listAssetTags(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetTags.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettags`;\n        return this.httpClient.request<AssetTagListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Asset Tag\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetTag(id: string, request: AssetTagUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagResponse>;\n    public updateAssetTag(id: string, request: AssetTagUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagResponse>>;\n    public updateAssetTag(id: string, request: AssetTagUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagResponse>>;\n    public updateAssetTag(id: string, request: AssetTagUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetTag.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetTag.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettags/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetTagResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AssetTypeListResponse } from '../model/assetTypeListResponse';\n// @ts-ignore\nimport { AssetTypeResponse } from '../model/assetTypeResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AssetTypesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Returns asset type details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTypeResponse>;\n    public getAssetType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTypeResponse>>;\n    public getAssetType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTypeResponse>>;\n    public getAssetType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetTypes(owner: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTypeListResponse>;\n    public listAssetTypes(owner: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTypeListResponse>>;\n    public listAssetTypes(owner: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTypeListResponse>>;\n    public listAssetTypes(owner: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettypes`;\n        return this.httpClient.request<AssetTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AssetCreateRequest } from '../model/assetCreateRequest';\n// @ts-ignore\nimport { AssetLinkRequest } from '../model/assetLinkRequest';\n// @ts-ignore\nimport { AssetLinkResponse } from '../model/assetLinkResponse';\n// @ts-ignore\nimport { AssetListResponse } from '../model/assetListResponse';\n// @ts-ignore\nimport { AssetMoveRequest } from '../model/assetMoveRequest';\n// @ts-ignore\nimport { AssetResponse } from '../model/assetResponse';\n// @ts-ignore\nimport { AssetSharedLocationResponse } from '../model/assetSharedLocationResponse';\n// @ts-ignore\nimport { AssetSharedLocationTokenListResponse } from '../model/assetSharedLocationTokenListResponse';\n// @ts-ignore\nimport { AssetSharedLocationTokenRequest } from '../model/assetSharedLocationTokenRequest';\n// @ts-ignore\nimport { AssetSharedLocationTokenResponse } from '../model/assetSharedLocationTokenResponse';\n// @ts-ignore\nimport { AssetUpdateRequest } from '../model/assetUpdateRequest';\n// @ts-ignore\nimport { TelemetryStateResponse } from '../model/telemetryStateResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AssetsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new asset entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAsset(request: AssetCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetResponse>;\n    public createAsset(request: AssetCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetResponse>>;\n    public createAsset(request: AssetCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetResponse>>;\n    public createAsset(request: AssetCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAsset.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets`;\n        return this.httpClient.request<AssetResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new shared asset location token\n     * @param id The UUID of the asset\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSharedAssetLocationToken(id: string, request: AssetSharedLocationTokenRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationTokenResponse>;\n    public createSharedAssetLocationToken(id: string, request: AssetSharedLocationTokenRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationTokenResponse>>;\n    public createSharedAssetLocationToken(id: string, request: AssetSharedLocationTokenRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationTokenResponse>>;\n    public createSharedAssetLocationToken(id: string, request: AssetSharedLocationTokenRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling createSharedAssetLocationToken.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createSharedAssetLocationToken.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetSharedLocationTokenResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a asset avatar.\n     * @param id The asset UUID.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAssetAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteAssetAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteAssetAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteAssetAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteAssetAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes a shared asset location token\n     * @param token The shared asset token to delete\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteSharedAssetLocationToken(token: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationTokenResponse>;\n    public deleteSharedAssetLocationToken(token: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationTokenResponse>>;\n    public deleteSharedAssetLocationToken(token: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationTokenResponse>>;\n    public deleteSharedAssetLocationToken(token: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (token === null || token === undefined) {\n            throw new Error('Required parameter token was null or undefined when calling deleteSharedAssetLocationToken.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location/${this.configuration.encodeParam({name: \"token\", value: token, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetSharedLocationTokenResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset details for the specified id\n     * @param id The UUID of the asset\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAsset(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetResponse>;\n    public getAsset(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetResponse>>;\n    public getAsset(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetResponse>>;\n    public getAsset(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAsset.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the asset avatar in binary format\n     * @param id The UUID of the asset\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getAssetAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getAssetAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getAssetAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns the latest known telemetry record for an asset\n     * @param id The UUID of the asset\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetLocation(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TelemetryStateResponse>;\n    public getAssetLocation(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TelemetryStateResponse>>;\n    public getAssetLocation(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TelemetryStateResponse>>;\n    public getAssetLocation(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetLocation.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/location`;\n        return this.httpClient.request<TelemetryStateResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns the latest known telemetry record for an asset using a shared token\n     * @param token The shared token\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSharedAssetLocation(token: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationResponse>;\n    public getSharedAssetLocation(token: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationResponse>>;\n    public getSharedAssetLocation(token: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationResponse>>;\n    public getSharedAssetLocation(token: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (token === null || token === undefined) {\n            throw new Error('Required parameter token was null or undefined when calling getSharedAssetLocation.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location/${this.configuration.encodeParam({name: \"token\", value: token, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetSharedLocationResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Links an asset from one account to one in another account. All data from the source asset will be duplicated for the destination asset. Returns both the source and destination asset if successful.\n     * @param id The source asset UUID you would like to link.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public linkAssets(id: string, request: AssetLinkRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetLinkResponse>;\n    public linkAssets(id: string, request: AssetLinkRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetLinkResponse>>;\n    public linkAssets(id: string, request: AssetLinkRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetLinkResponse>>;\n    public linkAssets(id: string, request: AssetLinkRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling linkAssets.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling linkAssets.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/link`;\n        return this.httpClient.request<AssetLinkResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of assets for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetListResponse>;\n    public listAssets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetListResponse>>;\n    public listAssets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetListResponse>>;\n    public listAssets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssets.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets`;\n        return this.httpClient.request<AssetListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of shared asset tokens for an asset or client.\n     * @param owner The owner id you are requesting data for\n     * @param asset The asset id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSharedAssetLocationTokens(owner?: string, asset?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationTokenListResponse>;\n    public listSharedAssetLocationTokens(owner?: string, asset?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationTokenListResponse>>;\n    public listSharedAssetLocationTokens(owner?: string, asset?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationTokenListResponse>>;\n    public listSharedAssetLocationTokens(owner?: string, asset?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (asset !== undefined && asset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>asset, 'asset');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location`;\n        return this.httpClient.request<AssetSharedLocationTokenListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Moves an asset from one client to another by deleting the asset in the source client and recreating it in the destination client. Also moves any associated device and simcard if assigned.\n     * @param id The asset UUID you would like to move.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public moveAsset(id: string, request: AssetMoveRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetResponse>;\n    public moveAsset(id: string, request: AssetMoveRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetResponse>>;\n    public moveAsset(id: string, request: AssetMoveRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetResponse>>;\n    public moveAsset(id: string, request: AssetMoveRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling moveAsset.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling moveAsset.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/move`;\n        return this.httpClient.request<AssetResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Unlinks an asset linked to another.  Returns both the source and destination asset if successful.\n     * @param id The source asset UUID you would like to unlink from.\n     * @param asset The destination asset UUID you would like to unlink from.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public unlinkAssets(id: string, asset: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetLinkResponse>;\n    public unlinkAssets(id: string, asset: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetLinkResponse>>;\n    public unlinkAssets(id: string, asset: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetLinkResponse>>;\n    public unlinkAssets(id: string, asset: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling unlinkAssets.');\n        }\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling unlinkAssets.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/unlink/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetLinkResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing asset\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAsset(id: string, request: AssetUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetResponse>;\n    public updateAsset(id: string, request: AssetUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetResponse>>;\n    public updateAsset(id: string, request: AssetUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetResponse>>;\n    public updateAsset(id: string, request: AssetUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAsset.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAsset.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified asset\\&#39;s avatar.\n     * @param id The asset UUID you are requesting data for.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateAssetAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateAssetAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateAssetAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a shared asset location token\n     * @param token The shared asset token to update\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateSharedAssetLocationToken(token: string, request: AssetSharedLocationTokenRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationTokenResponse>;\n    public updateSharedAssetLocationToken(token: string, request: AssetSharedLocationTokenRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationTokenResponse>>;\n    public updateSharedAssetLocationToken(token: string, request: AssetSharedLocationTokenRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationTokenResponse>>;\n    public updateSharedAssetLocationToken(token: string, request: AssetSharedLocationTokenRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (token === null || token === undefined) {\n            throw new Error('Required parameter token was null or undefined when calling updateSharedAssetLocationToken.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateSharedAssetLocationToken.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location/${this.configuration.encodeParam({name: \"token\", value: token, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetSharedLocationTokenResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AuthOTPGenerateResponse } from '../model/authOTPGenerateResponse';\n// @ts-ignore\nimport { AuthOTPSendResponse } from '../model/authOTPSendResponse';\n// @ts-ignore\nimport { AuthOTPValidateRequest } from '../model/authOTPValidateRequest';\n// @ts-ignore\nimport { AuthOTPValidateResponse } from '../model/authOTPValidateResponse';\n// @ts-ignore\nimport { AuthRefreshTokenRequest } from '../model/authRefreshTokenRequest';\n// @ts-ignore\nimport { AuthRequest } from '../model/authRequest';\n// @ts-ignore\nimport { AuthResetPasswordRequest } from '../model/authResetPasswordRequest';\n// @ts-ignore\nimport { AuthSetPasswordRequest } from '../model/authSetPasswordRequest';\n// @ts-ignore\nimport { NotFoundError } from '../model/notFoundError';\n// @ts-ignore\nimport { SelectedUserTokenResponse } from '../model/selectedUserTokenResponse';\n// @ts-ignore\nimport { SignOutRequest } from '../model/signOutRequest';\n// @ts-ignore\nimport { SuccessResponse } from '../model/successResponse';\n// @ts-ignore\nimport { TokenResponse } from '../model/tokenResponse';\n// @ts-ignore\nimport { TooManyRequestsError } from '../model/tooManyRequestsError';\n// @ts-ignore\nimport { UnauthorizedError } from '../model/unauthorizedError';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n// @ts-ignore\nimport { UpdateUserPasswordRequest } from '../model/updateUserPasswordRequest';\n// @ts-ignore\nimport { UserProfileResponse } from '../model/userProfileResponse';\n// @ts-ignore\nimport { UserSessionResponse } from '../model/userSessionResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Changes the currently authenticated user\\&#39;s password.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public changePassword(request: UpdateUserPasswordRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SuccessResponse>;\n    public changePassword(request: UpdateUserPasswordRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SuccessResponse>>;\n    public changePassword(request: UpdateUserPasswordRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SuccessResponse>>;\n    public changePassword(request: UpdateUserPasswordRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling changePassword.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/user/password`;\n        return this.httpClient.request<SuccessResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Generate a new TOTP secret for the current user\n     * @param method \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public enrolOTP(method: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AuthOTPGenerateResponse>;\n    public enrolOTP(method: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AuthOTPGenerateResponse>>;\n    public enrolOTP(method: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AuthOTPGenerateResponse>>;\n    public enrolOTP(method: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (method === null || method === undefined) {\n            throw new Error('Required parameter method was null or undefined when calling enrolOTP.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/otp/${this.configuration.encodeParam({name: \"method\", value: method, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/enrol`;\n        return this.httpClient.request<AuthOTPGenerateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the current user\\&#39;s avatar in binary format\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCurrentUserAvatar(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getCurrentUserAvatar(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getCurrentUserAvatar(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getCurrentUserAvatar(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/user/avatar`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieves the currently authenticated user\\&#39;s profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUserProfile(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserProfileResponse>;\n    public getUserProfile(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserProfileResponse>>;\n    public getUserProfile(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserProfileResponse>>;\n    public getUserProfile(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/user/profile`;\n        return this.httpClient.request<UserProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Refreshes a user\\&#39;s tokens by providing a valid refresh token\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public refreshTokens(request: AuthRefreshTokenRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TokenResponse>;\n    public refreshTokens(request: AuthRefreshTokenRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TokenResponse>>;\n    public refreshTokens(request: AuthRefreshTokenRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TokenResponse>>;\n    public refreshTokens(request: AuthRefreshTokenRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling refreshTokens.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/refresh`;\n        return this.httpClient.request<TokenResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Sends a password reset email to the user.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public resetPassword(request: AuthResetPasswordRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SuccessResponse>;\n    public resetPassword(request: AuthResetPasswordRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SuccessResponse>>;\n    public resetPassword(request: AuthResetPasswordRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SuccessResponse>>;\n    public resetPassword(request: AuthResetPasswordRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling resetPassword.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/password/reset`;\n        return this.httpClient.request<SuccessResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Selects a user from a list that has already been authenticated.\n     * @param id The user id you are requesting an access token for (previously retrieved using the /auth/signin route).\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public selectUser(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SelectedUserTokenResponse>;\n    public selectUser(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SelectedUserTokenResponse>>;\n    public selectUser(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SelectedUserTokenResponse>>;\n    public selectUser(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling selectUser.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/select/user/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SelectedUserTokenResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Generate a new TOTP secret for the current user\n     * @param method \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sendOTP(method: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AuthOTPSendResponse>;\n    public sendOTP(method: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AuthOTPSendResponse>>;\n    public sendOTP(method: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AuthOTPSendResponse>>;\n    public sendOTP(method: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (method === null || method === undefined) {\n            throw new Error('Required parameter method was null or undefined when calling sendOTP.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/otp/${this.configuration.encodeParam({name: \"method\", value: method, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/send`;\n        return this.httpClient.request<AuthOTPSendResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Sends a password reset email to the user.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public setPassword(request: AuthSetPasswordRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SuccessResponse>;\n    public setPassword(request: AuthSetPasswordRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SuccessResponse>>;\n    public setPassword(request: AuthSetPasswordRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SuccessResponse>>;\n    public setPassword(request: AuthSetPasswordRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling setPassword.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/password/set`;\n        return this.httpClient.request<SuccessResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Authenticate using a username and password\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public signIn(request: AuthRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserSessionResponse>;\n    public signIn(request: AuthRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserSessionResponse>>;\n    public signIn(request: AuthRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserSessionResponse>>;\n    public signIn(request: AuthRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling signIn.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/signin`;\n        return this.httpClient.request<UserSessionResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Invalidate an active access token\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public signOut(request: SignOutRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<{ [key: string]: any; }>;\n    public signOut(request: SignOutRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<{ [key: string]: any; }>>;\n    public signOut(request: SignOutRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<{ [key: string]: any; }>>;\n    public signOut(request: SignOutRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling signOut.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/signout`;\n        return this.httpClient.request<{ [key: string]: any; }>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Validate a user TOTP token against the user secret\n     * @param method \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public validateOTP(method: string, request: AuthOTPValidateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AuthOTPValidateResponse>;\n    public validateOTP(method: string, request: AuthOTPValidateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AuthOTPValidateResponse>>;\n    public validateOTP(method: string, request: AuthOTPValidateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AuthOTPValidateResponse>>;\n    public validateOTP(method: string, request: AuthOTPValidateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (method === null || method === undefined) {\n            throw new Error('Required parameter method was null or undefined when calling validateOTP.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling validateOTP.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/otp/${this.configuration.encodeParam({name: \"method\", value: method, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/validate`;\n        return this.httpClient.request<AuthOTPValidateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Verify a new TOTP token against the freshly generated user secret. Once successful, this route cannot be called again until TOTP is reset for the user.\n     * @param method \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public verifyOTP(method: string, request: AuthOTPValidateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AuthOTPValidateResponse>;\n    public verifyOTP(method: string, request: AuthOTPValidateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AuthOTPValidateResponse>>;\n    public verifyOTP(method: string, request: AuthOTPValidateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AuthOTPValidateResponse>>;\n    public verifyOTP(method: string, request: AuthOTPValidateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (method === null || method === undefined) {\n            throw new Error('Required parameter method was null or undefined when calling verifyOTP.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling verifyOTP.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/auth/otp/${this.configuration.encodeParam({name: \"method\", value: method, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/verify`;\n        return this.httpClient.request<AuthOTPValidateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ClientCreateRequest } from '../model/clientCreateRequest';\n// @ts-ignore\nimport { ClientDetailsUpdateRequest } from '../model/clientDetailsUpdateRequest';\n// @ts-ignore\nimport { ClientListResponse } from '../model/clientListResponse';\n// @ts-ignore\nimport { ClientResponse } from '../model/clientResponse';\n// @ts-ignore\nimport { ClientUpdateRequest } from '../model/clientUpdateRequest';\n// @ts-ignore\nimport { IdName } from '../model/idName';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ClientsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new client entity.\n     * @param request The &#x60;ClientCreateRequest&#x60; that contains the required properties for the new entity.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createClient(request: ClientCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientResponse>;\n    public createClient(request: ClientCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientResponse>>;\n    public createClient(request: ClientCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientResponse>>;\n    public createClient(request: ClientCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createClient.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients`;\n        return this.httpClient.request<ClientResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a custom client logo. The logo will revert to the client\\&#39;s parent logo.\n     * @param id The client UUID.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteClientLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteClientLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteClientLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteClientLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteClientLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling deleteClientLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns client details for the specified UUID.\n     * @param id The UUID of the client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getClient(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientResponse>;\n    public getClient(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientResponse>>;\n    public getClient(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientResponse>>;\n    public getClient(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getClient.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ClientResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns the client ID and name for the specified PIN. PINs are generated by the system and can be retrieved via the &#x60;pin&#x60; property on the  &#x60;ClientResponse&#x60; object retrieved with &#x60;getClient&#x60;.\n     * @param pin The PIN code of the client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getClientByPin(pin: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IdName>;\n    public getClientByPin(pin: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IdName>>;\n    public getClientByPin(pin: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IdName>>;\n    public getClientByPin(pin: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (pin === null || pin === undefined) {\n            throw new Error('Required parameter pin was null or undefined when calling getClientByPin.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/pin/${this.configuration.encodeParam({name: \"pin\", value: pin, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<IdName>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the specified client\\&#39;s logo in binary format. Should the client not have a custom logo, the logo of the vendor will be supplied.\n     * @param id The client UUID you are requesting data for.\n     * @param size The size of the returned image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getClientLogo(id: string, size?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getClientLogo(id: string, size?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getClientLogo(id: string, size?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getClientLogo(id: string, size?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getClientLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json, text/plain, */*'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of clients for a specified vendor.\n     * @param owner The UUID of the vendor you are requesting data for.\n     * @param offset An offset into the result set, useful for pagination.\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param counts A list of entity types to return counts for that belong to this client, comma delimited, i.e. &#x60;counts&#x3D;asset,device,simcard&#x60;. Each additional entity affects the performance of the query and should be used sparingly.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listClients(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientListResponse>;\n    public listClients(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientListResponse>>;\n    public listClients(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientListResponse>>;\n    public listClients(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listClients.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n        if (counts !== undefined && counts !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>counts, 'counts');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients`;\n        return this.httpClient.request<ClientListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing client entity by patching the existing object with the properties supplied in the &#x60;ClientUpdateRequest&#x60;.\n     * @param id The UUID of the client\n     * @param request The &#x60;ClientUpdateRequest&#x60; that contains only the properites that are to be changed on the entity.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateClient(id: string, request: ClientUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientResponse>;\n    public updateClient(id: string, request: ClientUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientResponse>>;\n    public updateClient(id: string, request: ClientUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientResponse>>;\n    public updateClient(id: string, request: ClientUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateClient.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateClient.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ClientResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing client account details. Unlike updateClient, this route is available to client users.\n     * @param id The UUID of the client\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateClientDetails(id: string, request: ClientDetailsUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ClientResponse>;\n    public updateClientDetails(id: string, request: ClientDetailsUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ClientResponse>>;\n    public updateClientDetails(id: string, request: ClientDetailsUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ClientResponse>>;\n    public updateClientDetails(id: string, request: ClientDetailsUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateClientDetails.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateClientDetails.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/details`;\n        return this.httpClient.request<ClientResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified client\\&#39;s logo.\n     * @param id The client UUID you are requesting data for.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateClientLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateClientLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateClientLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateClientLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateClientLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling updateClientLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/clients/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { CompanyResponse } from '../model/companyResponse';\n// @ts-ignore\nimport { ForbiddenError } from '../model/forbiddenError';\n// @ts-ignore\nimport { NotFoundError } from '../model/notFoundError';\n// @ts-ignore\nimport { TooManyRequestsError } from '../model/tooManyRequestsError';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CompaniesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Returns company details for the specified id\n     * @param id The UUID of the client\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompany(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyResponse>;\n    public getCompany(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyResponse>>;\n    public getCompany(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyResponse>>;\n    public getCompany(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompany.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companies/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompanyResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the specified company\\&#39;s logo in binary format.\n     * @param id The client UUID you are requesting data for.\n     * @param size The size of the returned image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param recurse Set recurse to true if you\\&#39;d like the parent tree to be searched for a logo if none exists for this company.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompanyLogo(id: string, size: string, recurse?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getCompanyLogo(id: string, size: string, recurse?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getCompanyLogo(id: string, size: string, recurse?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getCompanyLogo(id: string, size: string, recurse?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompanyLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling getCompanyLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companies/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { CompanyGroupCreateRequest } from '../model/companyGroupCreateRequest';\n// @ts-ignore\nimport { CompanyGroupListResponse } from '../model/companyGroupListResponse';\n// @ts-ignore\nimport { CompanyGroupResponse } from '../model/companyGroupResponse';\n// @ts-ignore\nimport { CompanyGroupUpdateRequest } from '../model/companyGroupUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CompanyGroupsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new company group\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createCompanyGroup(request: CompanyGroupCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupResponse>;\n    public createCompanyGroup(request: CompanyGroupCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupResponse>>;\n    public createCompanyGroup(request: CompanyGroupCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupResponse>>;\n    public createCompanyGroup(request: CompanyGroupCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createCompanyGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups`;\n        return this.httpClient.request<CompanyGroupResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a company group\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteCompanyGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupResponse>;\n    public deleteCompanyGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupResponse>>;\n    public deleteCompanyGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupResponse>>;\n    public deleteCompanyGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteCompanyGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompanyGroupResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns company group details for the specified id\n     * @param id The UUID of the company group\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompanyGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupResponse>;\n    public getCompanyGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupResponse>>;\n    public getCompanyGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupResponse>>;\n    public getCompanyGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompanyGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompanyGroupResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of company groups for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listCompanyGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupListResponse>;\n    public listCompanyGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupListResponse>>;\n    public listCompanyGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupListResponse>>;\n    public listCompanyGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listCompanyGroups.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups`;\n        return this.httpClient.request<CompanyGroupListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing company group\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCompanyGroup(id: string, request: CompanyGroupUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompanyGroupResponse>;\n    public updateCompanyGroup(id: string, request: CompanyGroupUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompanyGroupResponse>>;\n    public updateCompanyGroup(id: string, request: CompanyGroupUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompanyGroupResponse>>;\n    public updateCompanyGroup(id: string, request: CompanyGroupUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateCompanyGroup.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateCompanyGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/companygroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompanyGroupResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { CostCentreCreateRequest } from '../model/costCentreCreateRequest';\n// @ts-ignore\nimport { CostCentreListResponse } from '../model/costCentreListResponse';\n// @ts-ignore\nimport { CostCentreResponse } from '../model/costCentreResponse';\n// @ts-ignore\nimport { CostCentreUpdateRequest } from '../model/costCentreUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CostCentresService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new cost centre\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createCostCentre(request: CostCentreCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreResponse>;\n    public createCostCentre(request: CostCentreCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreResponse>>;\n    public createCostCentre(request: CostCentreCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreResponse>>;\n    public createCostCentre(request: CostCentreCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createCostCentre.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres`;\n        return this.httpClient.request<CostCentreResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a cost centre\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteCostCentre(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreResponse>;\n    public deleteCostCentre(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreResponse>>;\n    public deleteCostCentre(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreResponse>>;\n    public deleteCostCentre(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteCostCentre.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CostCentreResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns cost centre details for the specified id\n     * @param id The UUID of the cost centre\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCostCentre(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreResponse>;\n    public getCostCentre(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreResponse>>;\n    public getCostCentre(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreResponse>>;\n    public getCostCentre(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCostCentre.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CostCentreResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of cost centres for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listCostCentres(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreListResponse>;\n    public listCostCentres(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreListResponse>>;\n    public listCostCentres(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreListResponse>>;\n    public listCostCentres(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listCostCentres.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres`;\n        return this.httpClient.request<CostCentreListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing cost centre\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCostCentre(id: string, request: CostCentreUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreResponse>;\n    public updateCostCentre(id: string, request: CostCentreUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreResponse>>;\n    public updateCostCentre(id: string, request: CostCentreUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreResponse>>;\n    public updateCostCentre(id: string, request: CostCentreUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateCostCentre.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateCostCentre.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CostCentreResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { DashboardTemplateCreateRequest } from '../model/dashboardTemplateCreateRequest';\n// @ts-ignore\nimport { DashboardTemplateListResponse } from '../model/dashboardTemplateListResponse';\n// @ts-ignore\nimport { DashboardTemplateResponse } from '../model/dashboardTemplateResponse';\n// @ts-ignore\nimport { DashboardTemplateUpdateRequest } from '../model/dashboardTemplateUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DashboardTemplatesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new dashboard template\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDashboardTemplate(request: DashboardTemplateCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardTemplateResponse>;\n    public createDashboardTemplate(request: DashboardTemplateCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardTemplateResponse>>;\n    public createDashboardTemplate(request: DashboardTemplateCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardTemplateResponse>>;\n    public createDashboardTemplate(request: DashboardTemplateCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDashboardTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboardtemplates`;\n        return this.httpClient.request<DashboardTemplateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns dashboard template entity details for the specified id\n     * @param id The UUID of the Dashboard\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDashboardTemplate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardTemplateResponse>;\n    public getDashboardTemplate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardTemplateResponse>>;\n    public getDashboardTemplate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardTemplateResponse>>;\n    public getDashboardTemplate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDashboardTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboardtemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardTemplateResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of Dashboard templates for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDashboardTemplates(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardTemplateListResponse>;\n    public listDashboardTemplates(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardTemplateListResponse>>;\n    public listDashboardTemplates(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardTemplateListResponse>>;\n    public listDashboardTemplates(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDashboardTemplates.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboardtemplates`;\n        return this.httpClient.request<DashboardTemplateListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing dashboard template entity\n     * @param id The UUID of the Dashboard\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDashboardTemplate(id: string, request: DashboardTemplateUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardTemplateResponse>;\n    public updateDashboardTemplate(id: string, request: DashboardTemplateUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardTemplateResponse>>;\n    public updateDashboardTemplate(id: string, request: DashboardTemplateUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardTemplateResponse>>;\n    public updateDashboardTemplate(id: string, request: DashboardTemplateUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDashboardTemplate.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDashboardTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboardtemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardTemplateResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { DashboardCreateRequest } from '../model/dashboardCreateRequest';\n// @ts-ignore\nimport { DashboardListResponse } from '../model/dashboardListResponse';\n// @ts-ignore\nimport { DashboardResponse } from '../model/dashboardResponse';\n// @ts-ignore\nimport { DashboardUpdateRequest } from '../model/dashboardUpdateRequest';\n// @ts-ignore\nimport { RebuildDashboardWidgetResponse } from '../model/rebuildDashboardWidgetResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DashboardsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new dashboard entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDashboard(request: DashboardCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardResponse>;\n    public createDashboard(request: DashboardCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardResponse>>;\n    public createDashboard(request: DashboardCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardResponse>>;\n    public createDashboard(request: DashboardCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDashboard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards`;\n        return this.httpClient.request<DashboardResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a dashboard\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteDashboard(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardResponse>;\n    public deleteDashboard(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardResponse>>;\n    public deleteDashboard(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardResponse>>;\n    public deleteDashboard(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteDashboard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns dashboard entity details for the specified id\n     * @param id The UUID of the Dashboard\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDashboard(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardResponse>;\n    public getDashboard(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardResponse>>;\n    public getDashboard(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardResponse>>;\n    public getDashboard(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDashboard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of Dashboards for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardListResponse>;\n    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardListResponse>>;\n    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardListResponse>>;\n    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDashboards.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards`;\n        return this.httpClient.request<DashboardListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Rebuilds a widget\n     * @param id The UUID of the dashboard to which the widget belongs\n     * @param widgetId The UUID of the widget to rebuild\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public rebuildDashboardWidget(id: string, widgetId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RebuildDashboardWidgetResponse>;\n    public rebuildDashboardWidget(id: string, widgetId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RebuildDashboardWidgetResponse>>;\n    public rebuildDashboardWidget(id: string, widgetId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RebuildDashboardWidgetResponse>>;\n    public rebuildDashboardWidget(id: string, widgetId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling rebuildDashboardWidget.');\n        }\n        if (widgetId === null || widgetId === undefined) {\n            throw new Error('Required parameter widgetId was null or undefined when calling rebuildDashboardWidget.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/widgets/${this.configuration.encodeParam({name: \"widgetId\", value: widgetId, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/rebuild`;\n        return this.httpClient.request<RebuildDashboardWidgetResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing dashboard entity\n     * @param id The UUID of the Dashboard\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDashboard(id: string, request: DashboardUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardResponse>;\n    public updateDashboard(id: string, request: DashboardUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardResponse>>;\n    public updateDashboard(id: string, request: DashboardUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardResponse>>;\n    public updateDashboard(id: string, request: DashboardUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDashboard.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDashboard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AuditEventFeedResponse } from '../model/auditEventFeedResponse';\n// @ts-ignore\nimport { BadRequestError } from '../model/badRequestError';\n// @ts-ignore\nimport { EventCommentRequest } from '../model/eventCommentRequest';\n// @ts-ignore\nimport { EventFeedResponse } from '../model/eventFeedResponse';\n// @ts-ignore\nimport { EventListResponse } from '../model/eventListResponse';\n// @ts-ignore\nimport { EventResponse } from '../model/eventResponse';\n// @ts-ignore\nimport { ForbiddenError } from '../model/forbiddenError';\n// @ts-ignore\nimport { LogResponse } from '../model/logResponse';\n// @ts-ignore\nimport { NotificationFeedResponse } from '../model/notificationFeedResponse';\n// @ts-ignore\nimport { TelemetryFeedResponse } from '../model/telemetryFeedResponse';\n// @ts-ignore\nimport { TelemetryListResponse } from '../model/telemetryListResponse';\n// @ts-ignore\nimport { TooManyRequestsError } from '../model/tooManyRequestsError';\n// @ts-ignore\nimport { TripFeedResponse } from '../model/tripFeedResponse';\n// @ts-ignore\nimport { TripLabelRequest } from '../model/tripLabelRequest';\n// @ts-ignore\nimport { TripListResponse } from '../model/tripListResponse';\n// @ts-ignore\nimport { TripResponse } from '../model/tripResponse';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Acknowlege an alert.\n     * @param client The client id you are requesting data for\n     * @param alert The alert id you wish to acknowledge.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public acknowledgeAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventResponse>;\n    public acknowledgeAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventResponse>>;\n    public acknowledgeAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventResponse>>;\n    public acknowledgeAlert(client: string, alert: string, request: EventCommentRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling acknowledgeAlert.');\n        }\n        if (alert === null || alert === undefined) {\n            throw new Error('Required parameter alert was null or undefined when calling acknowledgeAlert.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling acknowledgeAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/alerts/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/acknowledge/${this.configuration.encodeParam({name: \"alert\", value: alert, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Adds one or more labels to a trip.\n     * @param asset The asset id for the trip\n     * @param date The trip start date (in ISO format)\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public addTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TripResponse>;\n    public addTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TripResponse>>;\n    public addTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TripResponse>>;\n    public addTripLabels(asset: string, date: string, request: TripLabelRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling addTripLabels.');\n        }\n        if (date === null || date === undefined) {\n            throw new Error('Required parameter date was null or undefined when calling addTripLabels.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling addTripLabels.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/trips/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"date\", value: date, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/labels`;\n        return this.httpClient.request<TripResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add a comment to an alert.\n     * @param client The client id you are requesting data for\n     * @param alert The alert id you wish to comment on.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public commentAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventResponse>;\n    public commentAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventResponse>>;\n    public commentAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventResponse>>;\n    public commentAlert(client: string, alert: string, request: EventCommentRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling commentAlert.');\n        }\n        if (alert === null || alert === undefined) {\n            throw new Error('Required parameter alert was null or undefined when calling commentAlert.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling commentAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/alerts/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/comment/${this.configuration.encodeParam({name: \"alert\", value: alert, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve an alert feed for the specified asset.\n     * @param client The client id you are requesting data for\n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value. This function may return slightly more results than requested.\n     * @param asset Filter alerts for this asset only.\n     * @param alert Filter alerts for this alert only.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAlertFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, alert?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventFeedResponse>;\n    public getAlertFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, alert?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventFeedResponse>>;\n    public getAlertFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, alert?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventFeedResponse>>;\n    public getAlertFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, alert?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling getAlertFeed.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getAlertFeed.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getAlertFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (asset !== undefined && asset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>asset, 'asset');\n        }\n        if (alert !== undefined && alert !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>alert, 'alert');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/alerts/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve alert records between two dates.\n     * @param id The client, alert or asset id you are requesting data for\n     * @param start The start date (in ISO format)\n     * @param end The end date (in ISO format)\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAlertHistory(id: string, start: string, end: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventListResponse>;\n    public getAlertHistory(id: string, start: string, end: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventListResponse>>;\n    public getAlertHistory(id: string, start: string, end: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventListResponse>>;\n    public getAlertHistory(id: string, start: string, end: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAlertHistory.');\n        }\n        if (start === null || start === undefined) {\n            throw new Error('Required parameter start was null or undefined when calling getAlertHistory.');\n        }\n        if (end === null || end === undefined) {\n            throw new Error('Required parameter end was null or undefined when calling getAlertHistory.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/alerts/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve an audit log feed for the specified client and entity.\n     * @param company The client, vendor or distributor id you are requesting data for\n     * @param entity \n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAuditFeedForEntity(company: string, entity: string, sequence: number, direction: 'forward' | 'backward', limit: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AuditEventFeedResponse>;\n    public getAuditFeedForEntity(company: string, entity: string, sequence: number, direction: 'forward' | 'backward', limit: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AuditEventFeedResponse>>;\n    public getAuditFeedForEntity(company: string, entity: string, sequence: number, direction: 'forward' | 'backward', limit: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AuditEventFeedResponse>>;\n    public getAuditFeedForEntity(company: string, entity: string, sequence: number, direction: 'forward' | 'backward', limit: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (company === null || company === undefined) {\n            throw new Error('Required parameter company was null or undefined when calling getAuditFeedForEntity.');\n        }\n        if (entity === null || entity === undefined) {\n            throw new Error('Required parameter entity was null or undefined when calling getAuditFeedForEntity.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getAuditFeedForEntity.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getAuditFeedForEntity.');\n        }\n        if (limit === null || limit === undefined) {\n            throw new Error('Required parameter limit was null or undefined when calling getAuditFeedForEntity.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/audit/${this.configuration.encodeParam({name: \"company\", value: company, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/entity/${this.configuration.encodeParam({name: \"entity\", value: entity, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AuditEventFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve an event feed for the specified asset.\n     * @param client The client id you are requesting data for\n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value.\n     * @param asset Filter events for this asset only.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getEventFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventFeedResponse>;\n    public getEventFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventFeedResponse>>;\n    public getEventFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventFeedResponse>>;\n    public getEventFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling getEventFeed.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getEventFeed.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getEventFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (asset !== undefined && asset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>asset, 'asset');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/events/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve event records between two dates.\n     * @param id The asset id you are requesting data for\n     * @param start The start date (in ISO format)\n     * @param end The end date (in ISO format)\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getEventHistory(id: string, start: string, end: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventListResponse>;\n    public getEventHistory(id: string, start: string, end: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventListResponse>>;\n    public getEventHistory(id: string, start: string, end: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventListResponse>>;\n    public getEventHistory(id: string, start: string, end: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getEventHistory.');\n        }\n        if (start === null || start === undefined) {\n            throw new Error('Required parameter start was null or undefined when calling getEventHistory.');\n        }\n        if (end === null || end === undefined) {\n            throw new Error('Required parameter end was null or undefined when calling getEventHistory.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/events/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the current state for all assets for the specified client.\n     * @param client The client id you\\&#39;re requesting data for.\n     * @param sequence The sequence to continue from.\n     * @param offset \n     * @param limit Limit the number of results to this value.\n     * @param sort \n     * @param filter \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getLocationFeed(client: string, sequence: number, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TelemetryFeedResponse>;\n    public getLocationFeed(client: string, sequence: number, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TelemetryFeedResponse>>;\n    public getLocationFeed(client: string, sequence: number, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TelemetryFeedResponse>>;\n    public getLocationFeed(client: string, sequence: number, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling getLocationFeed.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getLocationFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/location/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TelemetryFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Restricted route, not available for general usage.\n     * @param entityType \n     * @param id \n     * @param start \n     * @param end \n     * @param limit \n     * @param levels \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getLogHistoryForEntity(entityType: string, id: string, start?: string, end?: string, limit?: number, levels?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LogResponse>;\n    public getLogHistoryForEntity(entityType: string, id: string, start?: string, end?: string, limit?: number, levels?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LogResponse>>;\n    public getLogHistoryForEntity(entityType: string, id: string, start?: string, end?: string, limit?: number, levels?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LogResponse>>;\n    public getLogHistoryForEntity(entityType: string, id: string, start?: string, end?: string, limit?: number, levels?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (entityType === null || entityType === undefined) {\n            throw new Error('Required parameter entityType was null or undefined when calling getLogHistoryForEntity.');\n        }\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getLogHistoryForEntity.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (levels !== undefined && levels !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>levels, 'levels');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/logs/${this.configuration.encodeParam({name: \"entityType\", value: entityType, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<LogResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the notification feed for the current user.\n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getNotificationFeed(sequence: number, direction: 'forward' | 'backward', limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<NotificationFeedResponse>;\n    public getNotificationFeed(sequence: number, direction: 'forward' | 'backward', limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<NotificationFeedResponse>>;\n    public getNotificationFeed(sequence: number, direction: 'forward' | 'backward', limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<NotificationFeedResponse>>;\n    public getNotificationFeed(sequence: number, direction: 'forward' | 'backward', limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getNotificationFeed.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getNotificationFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/notifications`;\n        return this.httpClient.request<NotificationFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve telemetry records between two dates.\n     * @param id The asset id you are requesting data for\n     * @param start The start date (in ISO format)\n     * @param end The end date (in ISO format)\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTelemetryHistory(id: string, start: string, end: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TelemetryListResponse>;\n    public getTelemetryHistory(id: string, start: string, end: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TelemetryListResponse>>;\n    public getTelemetryHistory(id: string, start: string, end: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TelemetryListResponse>>;\n    public getTelemetryHistory(id: string, start: string, end: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getTelemetryHistory.');\n        }\n        if (start === null || start === undefined) {\n            throw new Error('Required parameter start was null or undefined when calling getTelemetryHistory.');\n        }\n        if (end === null || end === undefined) {\n            throw new Error('Required parameter end was null or undefined when calling getTelemetryHistory.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/telemetry/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TelemetryListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a trip feed for the specified asset.\n     * @param client The client id you are requesting data for\n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value.\n     * @param asset \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTripFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TripFeedResponse>;\n    public getTripFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TripFeedResponse>>;\n    public getTripFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TripFeedResponse>>;\n    public getTripFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling getTripFeed.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getTripFeed.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getTripFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (asset !== undefined && asset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>asset, 'asset');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/trips/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TripFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve trip records between two dates.\n     * @param id The asset id you are requesting data for\n     * @param start The start date (in ISO format)\n     * @param end The end date (in ISO format)\n     * @param date Use the date parameter to find the specific trip that contains this date (start and end are ignored)\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTripHistory(id: string, start?: string, end?: string, date?: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TripListResponse>;\n    public getTripHistory(id: string, start?: string, end?: string, date?: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TripListResponse>>;\n    public getTripHistory(id: string, start?: string, end?: string, date?: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TripListResponse>>;\n    public getTripHistory(id: string, start?: string, end?: string, date?: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getTripHistory.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (date !== undefined && date !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>date, 'date');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/trips/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TripListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Adds one or more labels to a trip.\n     * @param asset The asset id for the trip\n     * @param date The trip start date (in ISO format)\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public removeTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TripResponse>;\n    public removeTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TripResponse>>;\n    public removeTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TripResponse>>;\n    public removeTripLabels(asset: string, date: string, request: TripLabelRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling removeTripLabels.');\n        }\n        if (date === null || date === undefined) {\n            throw new Error('Required parameter date was null or undefined when calling removeTripLabels.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling removeTripLabels.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/trips/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"date\", value: date, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/labels`;\n        return this.httpClient.request<TripResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { DeviceConfigProfileCreateRequest } from '../model/deviceConfigProfileCreateRequest';\n// @ts-ignore\nimport { DeviceConfigProfileListResponse } from '../model/deviceConfigProfileListResponse';\n// @ts-ignore\nimport { DeviceConfigProfileResponse } from '../model/deviceConfigProfileResponse';\n// @ts-ignore\nimport { DeviceConfigProfileUpdateRequest } from '../model/deviceConfigProfileUpdateRequest';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DeviceConfigProfilesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new DeviceConfig Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDeviceConfigProfile(request: DeviceConfigProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceConfigProfileResponse>;\n    public createDeviceConfigProfile(request: DeviceConfigProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceConfigProfileResponse>>;\n    public createDeviceConfigProfile(request: DeviceConfigProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceConfigProfileResponse>>;\n    public createDeviceConfigProfile(request: DeviceConfigProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDeviceConfigProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceconfigprofiles`;\n        return this.httpClient.request<DeviceConfigProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device config profile details for the specified id\n     * @param id The UUID of the device config profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceConfigProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceConfigProfileResponse>;\n    public getDeviceConfigProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceConfigProfileResponse>>;\n    public getDeviceConfigProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceConfigProfileResponse>>;\n    public getDeviceConfigProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDeviceConfigProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceconfigprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceConfigProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of device config profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDeviceConfigProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceConfigProfileListResponse>;\n    public listDeviceConfigProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceConfigProfileListResponse>>;\n    public listDeviceConfigProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceConfigProfileListResponse>>;\n    public listDeviceConfigProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDeviceConfigProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceconfigprofiles`;\n        return this.httpClient.request<DeviceConfigProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing DeviceConfig Profile entity\n     * @param id The UUID of the DeviceConfig Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDeviceConfigProfile(id: string, request: DeviceConfigProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceConfigProfileResponse>;\n    public updateDeviceConfigProfile(id: string, request: DeviceConfigProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceConfigProfileResponse>>;\n    public updateDeviceConfigProfile(id: string, request: DeviceConfigProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceConfigProfileResponse>>;\n    public updateDeviceConfigProfile(id: string, request: DeviceConfigProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDeviceConfigProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDeviceConfigProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceconfigprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceConfigProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { DeviceProviderTypeListResponse } from '../model/deviceProviderTypeListResponse';\n// @ts-ignore\nimport { DeviceProviderTypeResponse } from '../model/deviceProviderTypeResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DeviceProviderTypesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Returns device provider type details for the specified id\n     * @param id The UUID of the device\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceProviderType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderTypeResponse>;\n    public getDeviceProviderType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderTypeResponse>>;\n    public getDeviceProviderType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderTypeResponse>>;\n    public getDeviceProviderType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDeviceProviderType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceprovidertypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceProviderTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of device provider types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDeviceProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderTypeListResponse>;\n    public listDeviceProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderTypeListResponse>>;\n    public listDeviceProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderTypeListResponse>>;\n    public listDeviceProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDeviceProviderTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceprovidertypes`;\n        return this.httpClient.request<DeviceProviderTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { DeviceProviderCreateRequest } from '../model/deviceProviderCreateRequest';\n// @ts-ignore\nimport { DeviceProviderListResponse } from '../model/deviceProviderListResponse';\n// @ts-ignore\nimport { DeviceProviderResponse } from '../model/deviceProviderResponse';\n// @ts-ignore\nimport { DeviceProviderUpdateRequest } from '../model/deviceProviderUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DeviceProvidersService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new device provider entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDeviceProvider(request: DeviceProviderCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderResponse>;\n    public createDeviceProvider(request: DeviceProviderCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderResponse>>;\n    public createDeviceProvider(request: DeviceProviderCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderResponse>>;\n    public createDeviceProvider(request: DeviceProviderCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDeviceProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceproviders`;\n        return this.httpClient.request<DeviceProviderResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device provider details for the specified id\n     * @param id The UUID of the device\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceProvider(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderResponse>;\n    public getDeviceProvider(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderResponse>>;\n    public getDeviceProvider(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderResponse>>;\n    public getDeviceProvider(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDeviceProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceProviderResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of device providers for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDeviceProviders(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderListResponse>;\n    public listDeviceProviders(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderListResponse>>;\n    public listDeviceProviders(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderListResponse>>;\n    public listDeviceProviders(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDeviceProviders.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceproviders`;\n        return this.httpClient.request<DeviceProviderListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing device provider\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDeviceProvider(id: string, request: DeviceProviderUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderResponse>;\n    public updateDeviceProvider(id: string, request: DeviceProviderUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderResponse>>;\n    public updateDeviceProvider(id: string, request: DeviceProviderUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderResponse>>;\n    public updateDeviceProvider(id: string, request: DeviceProviderUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDeviceProvider.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDeviceProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceProviderResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { DeviceCreateRequest } from '../model/deviceCreateRequest';\n// @ts-ignore\nimport { DeviceListResponse } from '../model/deviceListResponse';\n// @ts-ignore\nimport { DeviceResponse } from '../model/deviceResponse';\n// @ts-ignore\nimport { DeviceUpdateRequest } from '../model/deviceUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DevicesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new device entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDevice(request: DeviceCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceResponse>;\n    public createDevice(request: DeviceCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceResponse>>;\n    public createDevice(request: DeviceCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceResponse>>;\n    public createDevice(request: DeviceCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDevice.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices`;\n        return this.httpClient.request<DeviceResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device details for the specified id\n     * @param id The UUID of the device\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDevice(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceResponse>;\n    public getDevice(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceResponse>>;\n    public getDevice(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceResponse>>;\n    public getDevice(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDevice.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device details for the specified device type and device IMEI or serial number\n     * @param deviceType The UUID of the device type\n     * @param deviceName The name of the device (usually an IMEI or serial number)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceByName(deviceType: string, deviceName: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceResponse>;\n    public getDeviceByName(deviceType: string, deviceName: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceResponse>>;\n    public getDeviceByName(deviceType: string, deviceName: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceResponse>>;\n    public getDeviceByName(deviceType: string, deviceName: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (deviceType === null || deviceType === undefined) {\n            throw new Error('Required parameter deviceType was null or undefined when calling getDeviceByName.');\n        }\n        if (deviceName === null || deviceName === undefined) {\n            throw new Error('Required parameter deviceName was null or undefined when calling getDeviceByName.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices/name/${this.configuration.encodeParam({name: \"deviceType\", value: deviceType, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"deviceName\", value: deviceName, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of devices for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDevices(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceListResponse>;\n    public listDevices(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceListResponse>>;\n    public listDevices(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceListResponse>>;\n    public listDevices(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDevices.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices`;\n        return this.httpClient.request<DeviceListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing device\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDevice(id: string, request: DeviceUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceResponse>;\n    public updateDevice(id: string, request: DeviceUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceResponse>>;\n    public updateDevice(id: string, request: DeviceUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceResponse>>;\n    public updateDevice(id: string, request: DeviceUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDevice.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDevice.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { DistributorCreateRequest } from '../model/distributorCreateRequest';\n// @ts-ignore\nimport { DistributorDetailsUpdateRequest } from '../model/distributorDetailsUpdateRequest';\n// @ts-ignore\nimport { DistributorListResponse } from '../model/distributorListResponse';\n// @ts-ignore\nimport { DistributorResponse } from '../model/distributorResponse';\n// @ts-ignore\nimport { DistributorUpdateRequest } from '../model/distributorUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DistributorsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new distributor account\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDistributor(request: DistributorCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorResponse>;\n    public createDistributor(request: DistributorCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorResponse>>;\n    public createDistributor(request: DistributorCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorResponse>>;\n    public createDistributor(request: DistributorCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDistributor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors`;\n        return this.httpClient.request<DistributorResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a custom distributor logo. The logo will revert to the Key Telematics logo.\n     * @param id The distributor UUID.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteDistributorLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteDistributorLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteDistributorLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteDistributorLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteDistributorLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling deleteDistributorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns distributor details for the specified id\n     * @param id The UUID of the distributor\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDistributor(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorResponse>;\n    public getDistributor(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorResponse>>;\n    public getDistributor(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorResponse>>;\n    public getDistributor(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDistributor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DistributorResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the specified distributors\\&#39;s logo in binary format. Should the distributor not have a custom logo, the default Key Telematics logo will be supplied.\n     * @param id The distributor UUID you are requesting data for.\n     * @param size The size of the returned image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDistributorLogo(id: string, size?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getDistributorLogo(id: string, size?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getDistributorLogo(id: string, size?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getDistributorLogo(id: string, size?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDistributorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of distributors for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param counts A list of entity types to return counts for that belong to this distributor, comma delimited, i.e. &#x60;counts&#x3D;vendor,client,asset,device&#x60;. Each additional entity affects the performance of the query and should be used sparingly.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDistributors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorListResponse>;\n    public listDistributors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorListResponse>>;\n    public listDistributors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorListResponse>>;\n    public listDistributors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDistributors.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n        if (counts !== undefined && counts !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>counts, 'counts');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors`;\n        return this.httpClient.request<DistributorListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing distributor account\n     * @param id The UUID of the distributor\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDistributor(id: string, request: DistributorUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorResponse>;\n    public updateDistributor(id: string, request: DistributorUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorResponse>>;\n    public updateDistributor(id: string, request: DistributorUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorResponse>>;\n    public updateDistributor(id: string, request: DistributorUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDistributor.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDistributor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DistributorResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing distributor account details. Unlike &#x60;updateDistributor&#x60;, this route is available to distributor users.\n     * @param id The UUID of the distributor\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDistributorDetails(id: string, request: DistributorDetailsUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DistributorResponse>;\n    public updateDistributorDetails(id: string, request: DistributorDetailsUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DistributorResponse>>;\n    public updateDistributorDetails(id: string, request: DistributorDetailsUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DistributorResponse>>;\n    public updateDistributorDetails(id: string, request: DistributorDetailsUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDistributorDetails.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDistributorDetails.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/details`;\n        return this.httpClient.request<DistributorResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified distributor\\&#39;s logo.\n     * @param id The distributor UUID you are requesting data for.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDistributorLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateDistributorLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateDistributorLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateDistributorLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDistributorLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling updateDistributorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/distributors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { EmailProviderCreateRequest } from '../model/emailProviderCreateRequest';\n// @ts-ignore\nimport { EmailProviderListResponse } from '../model/emailProviderListResponse';\n// @ts-ignore\nimport { EmailProviderResponse } from '../model/emailProviderResponse';\n// @ts-ignore\nimport { EmailProviderUpdateRequest } from '../model/emailProviderUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class EmailProvidersService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new email provider entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createEmailProvider(request: EmailProviderCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderResponse>;\n    public createEmailProvider(request: EmailProviderCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderResponse>>;\n    public createEmailProvider(request: EmailProviderCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderResponse>>;\n    public createEmailProvider(request: EmailProviderCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createEmailProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailproviders`;\n        return this.httpClient.request<EmailProviderResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns email provider details for the specified id\n     * @param id The UUID of the email provider\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getEmailProvider(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderResponse>;\n    public getEmailProvider(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderResponse>>;\n    public getEmailProvider(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderResponse>>;\n    public getEmailProvider(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getEmailProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EmailProviderResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of email providers.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listEmailProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderListResponse>;\n    public listEmailProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderListResponse>>;\n    public listEmailProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderListResponse>>;\n    public listEmailProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listEmailProviders.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailproviders`;\n        return this.httpClient.request<EmailProviderListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing email provider entity\n     * @param id The UUID of the email provider\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateEmailProvider(id: string, request: EmailProviderUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderResponse>;\n    public updateEmailProvider(id: string, request: EmailProviderUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderResponse>>;\n    public updateEmailProvider(id: string, request: EmailProviderUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderResponse>>;\n    public updateEmailProvider(id: string, request: EmailProviderUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateEmailProvider.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateEmailProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EmailProviderResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { EmailProviderTypeListResponse } from '../model/emailProviderTypeListResponse';\n// @ts-ignore\nimport { EmailProviderTypeResponse } from '../model/emailProviderTypeResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class EmailProvidersTypesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Returns email provider type details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getEmailProviderType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderTypeResponse>;\n    public getEmailProviderType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderTypeResponse>>;\n    public getEmailProviderType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderTypeResponse>>;\n    public getEmailProviderType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getEmailProviderType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailprovidertypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EmailProviderTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of email provider types.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listEmailProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderTypeListResponse>;\n    public listEmailProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderTypeListResponse>>;\n    public listEmailProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderTypeListResponse>>;\n    public listEmailProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listEmailProviderTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailprovidertypes`;\n        return this.httpClient.request<EmailProviderTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AlertCreateRequest } from '../model/alertCreateRequest';\n// @ts-ignore\nimport { AlertListResponse } from '../model/alertListResponse';\n// @ts-ignore\nimport { AlertResponse } from '../model/alertResponse';\n// @ts-ignore\nimport { AlertUpdateRequest } from '../model/alertUpdateRequest';\n// @ts-ignore\nimport { AssetCategoryCreateRequest } from '../model/assetCategoryCreateRequest';\n// @ts-ignore\nimport { AssetCategoryListResponse } from '../model/assetCategoryListResponse';\n// @ts-ignore\nimport { AssetCategoryResponse } from '../model/assetCategoryResponse';\n// @ts-ignore\nimport { AssetCategoryUpdateRequest } from '../model/assetCategoryUpdateRequest';\n// @ts-ignore\nimport { AssetCreateRequest } from '../model/assetCreateRequest';\n// @ts-ignore\nimport { AssetGroupCreateRequest } from '../model/assetGroupCreateRequest';\n// @ts-ignore\nimport { AssetGroupListResponse } from '../model/assetGroupListResponse';\n// @ts-ignore\nimport { AssetGroupResponse } from '../model/assetGroupResponse';\n// @ts-ignore\nimport { AssetGroupUpdateRequest } from '../model/assetGroupUpdateRequest';\n// @ts-ignore\nimport { AssetLinkRequest } from '../model/assetLinkRequest';\n// @ts-ignore\nimport { AssetLinkResponse } from '../model/assetLinkResponse';\n// @ts-ignore\nimport { AssetListResponse } from '../model/assetListResponse';\n// @ts-ignore\nimport { AssetMoveRequest } from '../model/assetMoveRequest';\n// @ts-ignore\nimport { AssetRatingProfileCreateRequest } from '../model/assetRatingProfileCreateRequest';\n// @ts-ignore\nimport { AssetRatingProfileListResponse } from '../model/assetRatingProfileListResponse';\n// @ts-ignore\nimport { AssetRatingProfileResponse } from '../model/assetRatingProfileResponse';\n// @ts-ignore\nimport { AssetRatingProfileUpdateRequest } from '../model/assetRatingProfileUpdateRequest';\n// @ts-ignore\nimport { AssetResponse } from '../model/assetResponse';\n// @ts-ignore\nimport { AssetSharedLocationResponse } from '../model/assetSharedLocationResponse';\n// @ts-ignore\nimport { AssetSharedLocationTokenListResponse } from '../model/assetSharedLocationTokenListResponse';\n// @ts-ignore\nimport { AssetSharedLocationTokenRequest } from '../model/assetSharedLocationTokenRequest';\n// @ts-ignore\nimport { AssetSharedLocationTokenResponse } from '../model/assetSharedLocationTokenResponse';\n// @ts-ignore\nimport { AssetStateProfileCreateRequest } from '../model/assetStateProfileCreateRequest';\n// @ts-ignore\nimport { AssetStateProfileListResponse } from '../model/assetStateProfileListResponse';\n// @ts-ignore\nimport { AssetStateProfileResponse } from '../model/assetStateProfileResponse';\n// @ts-ignore\nimport { AssetStateProfileUpdateRequest } from '../model/assetStateProfileUpdateRequest';\n// @ts-ignore\nimport { AssetTagCreateRequest } from '../model/assetTagCreateRequest';\n// @ts-ignore\nimport { AssetTagListResponse } from '../model/assetTagListResponse';\n// @ts-ignore\nimport { AssetTagResponse } from '../model/assetTagResponse';\n// @ts-ignore\nimport { AssetTagTypeListResponse } from '../model/assetTagTypeListResponse';\n// @ts-ignore\nimport { AssetTagTypeResponse } from '../model/assetTagTypeResponse';\n// @ts-ignore\nimport { AssetTagUpdateRequest } from '../model/assetTagUpdateRequest';\n// @ts-ignore\nimport { AssetTypeListResponse } from '../model/assetTypeListResponse';\n// @ts-ignore\nimport { AssetTypeResponse } from '../model/assetTypeResponse';\n// @ts-ignore\nimport { AssetUpdateRequest } from '../model/assetUpdateRequest';\n// @ts-ignore\nimport { CostCentreCreateRequest } from '../model/costCentreCreateRequest';\n// @ts-ignore\nimport { CostCentreListResponse } from '../model/costCentreListResponse';\n// @ts-ignore\nimport { CostCentreResponse } from '../model/costCentreResponse';\n// @ts-ignore\nimport { CostCentreUpdateRequest } from '../model/costCentreUpdateRequest';\n// @ts-ignore\nimport { DashboardCreateRequest } from '../model/dashboardCreateRequest';\n// @ts-ignore\nimport { DashboardListResponse } from '../model/dashboardListResponse';\n// @ts-ignore\nimport { DashboardResponse } from '../model/dashboardResponse';\n// @ts-ignore\nimport { DashboardTemplateCreateRequest } from '../model/dashboardTemplateCreateRequest';\n// @ts-ignore\nimport { DashboardTemplateListResponse } from '../model/dashboardTemplateListResponse';\n// @ts-ignore\nimport { DashboardTemplateResponse } from '../model/dashboardTemplateResponse';\n// @ts-ignore\nimport { DashboardTemplateUpdateRequest } from '../model/dashboardTemplateUpdateRequest';\n// @ts-ignore\nimport { DashboardUpdateRequest } from '../model/dashboardUpdateRequest';\n// @ts-ignore\nimport { DeviceConfigProfileCreateRequest } from '../model/deviceConfigProfileCreateRequest';\n// @ts-ignore\nimport { DeviceConfigProfileListResponse } from '../model/deviceConfigProfileListResponse';\n// @ts-ignore\nimport { DeviceConfigProfileResponse } from '../model/deviceConfigProfileResponse';\n// @ts-ignore\nimport { DeviceConfigProfileUpdateRequest } from '../model/deviceConfigProfileUpdateRequest';\n// @ts-ignore\nimport { DeviceCreateRequest } from '../model/deviceCreateRequest';\n// @ts-ignore\nimport { DeviceListResponse } from '../model/deviceListResponse';\n// @ts-ignore\nimport { DeviceProviderCreateRequest } from '../model/deviceProviderCreateRequest';\n// @ts-ignore\nimport { DeviceProviderListResponse } from '../model/deviceProviderListResponse';\n// @ts-ignore\nimport { DeviceProviderResponse } from '../model/deviceProviderResponse';\n// @ts-ignore\nimport { DeviceProviderTypeListResponse } from '../model/deviceProviderTypeListResponse';\n// @ts-ignore\nimport { DeviceProviderTypeResponse } from '../model/deviceProviderTypeResponse';\n// @ts-ignore\nimport { DeviceProviderUpdateRequest } from '../model/deviceProviderUpdateRequest';\n// @ts-ignore\nimport { DeviceResponse } from '../model/deviceResponse';\n// @ts-ignore\nimport { DeviceTypeCreateRequest } from '../model/deviceTypeCreateRequest';\n// @ts-ignore\nimport { DeviceTypeListResponse } from '../model/deviceTypeListResponse';\n// @ts-ignore\nimport { DeviceTypeResponse } from '../model/deviceTypeResponse';\n// @ts-ignore\nimport { DeviceTypeUpdateRequest } from '../model/deviceTypeUpdateRequest';\n// @ts-ignore\nimport { DeviceUpdateRequest } from '../model/deviceUpdateRequest';\n// @ts-ignore\nimport { DomainThemeResponse } from '../model/domainThemeResponse';\n// @ts-ignore\nimport { EmailProviderCreateRequest } from '../model/emailProviderCreateRequest';\n// @ts-ignore\nimport { EmailProviderListResponse } from '../model/emailProviderListResponse';\n// @ts-ignore\nimport { EmailProviderResponse } from '../model/emailProviderResponse';\n// @ts-ignore\nimport { EmailProviderTypeListResponse } from '../model/emailProviderTypeListResponse';\n// @ts-ignore\nimport { EmailProviderTypeResponse } from '../model/emailProviderTypeResponse';\n// @ts-ignore\nimport { EmailProviderUpdateRequest } from '../model/emailProviderUpdateRequest';\n// @ts-ignore\nimport { ExportTaskCreateRequest } from '../model/exportTaskCreateRequest';\n// @ts-ignore\nimport { ExportTaskListResponse } from '../model/exportTaskListResponse';\n// @ts-ignore\nimport { ExportTaskResponse } from '../model/exportTaskResponse';\n// @ts-ignore\nimport { ExportTaskUpdateRequest } from '../model/exportTaskUpdateRequest';\n// @ts-ignore\nimport { FuelCardCreateRequest } from '../model/fuelCardCreateRequest';\n// @ts-ignore\nimport { FuelCardListResponse } from '../model/fuelCardListResponse';\n// @ts-ignore\nimport { FuelCardResponse } from '../model/fuelCardResponse';\n// @ts-ignore\nimport { FuelCardUpdateRequest } from '../model/fuelCardUpdateRequest';\n// @ts-ignore\nimport { GeoLockProfileCreateRequest } from '../model/geoLockProfileCreateRequest';\n// @ts-ignore\nimport { GeoLockProfileListResponse } from '../model/geoLockProfileListResponse';\n// @ts-ignore\nimport { GeoLockProfileResponse } from '../model/geoLockProfileResponse';\n// @ts-ignore\nimport { GeoLockProfileUpdateRequest } from '../model/geoLockProfileUpdateRequest';\n// @ts-ignore\nimport { IoTypeCreateRequest } from '../model/ioTypeCreateRequest';\n// @ts-ignore\nimport { IoTypeListResponse } from '../model/ioTypeListResponse';\n// @ts-ignore\nimport { IoTypeResponse } from '../model/ioTypeResponse';\n// @ts-ignore\nimport { IoTypeUpdateRequest } from '../model/ioTypeUpdateRequest';\n// @ts-ignore\nimport { LabelCreateRequest } from '../model/labelCreateRequest';\n// @ts-ignore\nimport { LabelListResponse } from '../model/labelListResponse';\n// @ts-ignore\nimport { LabelResponse } from '../model/labelResponse';\n// @ts-ignore\nimport { LabelUpdateRequest } from '../model/labelUpdateRequest';\n// @ts-ignore\nimport { MapSetListResponse } from '../model/mapSetListResponse';\n// @ts-ignore\nimport { MapSetResponse } from '../model/mapSetResponse';\n// @ts-ignore\nimport { MapsetCreateRequest } from '../model/mapsetCreateRequest';\n// @ts-ignore\nimport { MapsetUpdateRequest } from '../model/mapsetUpdateRequest';\n// @ts-ignore\nimport { OverspeedProfileCreateRequest } from '../model/overspeedProfileCreateRequest';\n// @ts-ignore\nimport { OverspeedProfileListResponse } from '../model/overspeedProfileListResponse';\n// @ts-ignore\nimport { OverspeedProfileResponse } from '../model/overspeedProfileResponse';\n// @ts-ignore\nimport { OverspeedProfileUpdateRequest } from '../model/overspeedProfileUpdateRequest';\n// @ts-ignore\nimport { RebuildDashboardWidgetResponse } from '../model/rebuildDashboardWidgetResponse';\n// @ts-ignore\nimport { ReminderCreateRequest } from '../model/reminderCreateRequest';\n// @ts-ignore\nimport { ReminderListResponse } from '../model/reminderListResponse';\n// @ts-ignore\nimport { ReminderResponse } from '../model/reminderResponse';\n// @ts-ignore\nimport { ReminderUpdateRequest } from '../model/reminderUpdateRequest';\n// @ts-ignore\nimport { ReportDefinitionListResponse } from '../model/reportDefinitionListResponse';\n// @ts-ignore\nimport { ReportDefinitionResponse } from '../model/reportDefinitionResponse';\n// @ts-ignore\nimport { ReportTemplateCreateRequest } from '../model/reportTemplateCreateRequest';\n// @ts-ignore\nimport { ReportTemplateListResponse } from '../model/reportTemplateListResponse';\n// @ts-ignore\nimport { ReportTemplateResponse } from '../model/reportTemplateResponse';\n// @ts-ignore\nimport { ReportTemplateUpdateRequest } from '../model/reportTemplateUpdateRequest';\n// @ts-ignore\nimport { RoadProfileCreateRequest } from '../model/roadProfileCreateRequest';\n// @ts-ignore\nimport { RoadProfileListResponse } from '../model/roadProfileListResponse';\n// @ts-ignore\nimport { RoadProfileResponse } from '../model/roadProfileResponse';\n// @ts-ignore\nimport { RoadProfileUpdateRequest } from '../model/roadProfileUpdateRequest';\n// @ts-ignore\nimport { ScheduledReportCreateRequest } from '../model/scheduledReportCreateRequest';\n// @ts-ignore\nimport { ScheduledReportListResponse } from '../model/scheduledReportListResponse';\n// @ts-ignore\nimport { ScheduledReportResponse } from '../model/scheduledReportResponse';\n// @ts-ignore\nimport { ScheduledReportUpdateRequest } from '../model/scheduledReportUpdateRequest';\n// @ts-ignore\nimport { SimCardCreateRequest } from '../model/simCardCreateRequest';\n// @ts-ignore\nimport { SimCardListResponse } from '../model/simCardListResponse';\n// @ts-ignore\nimport { SimCardResponse } from '../model/simCardResponse';\n// @ts-ignore\nimport { SimCardUpdateRequest } from '../model/simCardUpdateRequest';\n// @ts-ignore\nimport { SmsGatewayProviderCreateRequest } from '../model/smsGatewayProviderCreateRequest';\n// @ts-ignore\nimport { SmsGatewayProviderListResponse } from '../model/smsGatewayProviderListResponse';\n// @ts-ignore\nimport { SmsGatewayProviderResponse } from '../model/smsGatewayProviderResponse';\n// @ts-ignore\nimport { SmsGatewayProviderTypeListResponse } from '../model/smsGatewayProviderTypeListResponse';\n// @ts-ignore\nimport { SmsGatewayProviderTypeResponse } from '../model/smsGatewayProviderTypeResponse';\n// @ts-ignore\nimport { SmsGatewayProviderUpdateRequest } from '../model/smsGatewayProviderUpdateRequest';\n// @ts-ignore\nimport { SslCertificateCreateRequest } from '../model/sslCertificateCreateRequest';\n// @ts-ignore\nimport { SslCertificateListResponse } from '../model/sslCertificateListResponse';\n// @ts-ignore\nimport { SslCertificateProvisionResponse } from '../model/sslCertificateProvisionResponse';\n// @ts-ignore\nimport { SslCertificateResponse } from '../model/sslCertificateResponse';\n// @ts-ignore\nimport { SslCertificateUpdateRequest } from '../model/sslCertificateUpdateRequest';\n// @ts-ignore\nimport { SslCertificateValidationResponse } from '../model/sslCertificateValidationResponse';\n// @ts-ignore\nimport { TelemetryStateResponse } from '../model/telemetryStateResponse';\n// @ts-ignore\nimport { ThemeCreateRequest } from '../model/themeCreateRequest';\n// @ts-ignore\nimport { ThemeListResponse } from '../model/themeListResponse';\n// @ts-ignore\nimport { ThemeResponse } from '../model/themeResponse';\n// @ts-ignore\nimport { ThemeUpdateRequest } from '../model/themeUpdateRequest';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n// @ts-ignore\nimport { ZoneCreateRequest } from '../model/zoneCreateRequest';\n// @ts-ignore\nimport { ZoneGroupCreateRequest } from '../model/zoneGroupCreateRequest';\n// @ts-ignore\nimport { ZoneGroupListResponse } from '../model/zoneGroupListResponse';\n// @ts-ignore\nimport { ZoneGroupResponse } from '../model/zoneGroupResponse';\n// @ts-ignore\nimport { ZoneGroupUpdateRequest } from '../model/zoneGroupUpdateRequest';\n// @ts-ignore\nimport { ZoneListResponse } from '../model/zoneListResponse';\n// @ts-ignore\nimport { ZoneResponse } from '../model/zoneResponse';\n// @ts-ignore\nimport { ZoneUpdateRequest } from '../model/zoneUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class EntitiesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Alert\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAlert(request: AlertCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AlertResponse>;\n    public createAlert(request: AlertCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AlertResponse>>;\n    public createAlert(request: AlertCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AlertResponse>>;\n    public createAlert(request: AlertCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/alerts`;\n        return this.httpClient.request<AlertResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new asset entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAsset(request: AssetCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetResponse>;\n    public createAsset(request: AssetCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetResponse>>;\n    public createAsset(request: AssetCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetResponse>>;\n    public createAsset(request: AssetCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAsset.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets`;\n        return this.httpClient.request<AssetResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new asset category\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetCategory(request: AssetCategoryCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryResponse>;\n    public createAssetCategory(request: AssetCategoryCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryResponse>>;\n    public createAssetCategory(request: AssetCategoryCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryResponse>>;\n    public createAssetCategory(request: AssetCategoryCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetCategory.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories`;\n        return this.httpClient.request<AssetCategoryResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new Asset Group\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetGroup(request: AssetGroupCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupResponse>;\n    public createAssetGroup(request: AssetGroupCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupResponse>>;\n    public createAssetGroup(request: AssetGroupCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupResponse>>;\n    public createAssetGroup(request: AssetGroupCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups`;\n        return this.httpClient.request<AssetGroupResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new Asset Rating Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetRatingProfile(request: AssetRatingProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetRatingProfileResponse>;\n    public createAssetRatingProfile(request: AssetRatingProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetRatingProfileResponse>>;\n    public createAssetRatingProfile(request: AssetRatingProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetRatingProfileResponse>>;\n    public createAssetRatingProfile(request: AssetRatingProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetRatingProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetratingprofiles`;\n        return this.httpClient.request<AssetRatingProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new Asset State Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetStateProfile(request: AssetStateProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetStateProfileResponse>;\n    public createAssetStateProfile(request: AssetStateProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetStateProfileResponse>>;\n    public createAssetStateProfile(request: AssetStateProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetStateProfileResponse>>;\n    public createAssetStateProfile(request: AssetStateProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetStateProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetstateprofiles`;\n        return this.httpClient.request<AssetStateProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new Asset Tag\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createAssetTag(request: AssetTagCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagResponse>;\n    public createAssetTag(request: AssetTagCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagResponse>>;\n    public createAssetTag(request: AssetTagCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagResponse>>;\n    public createAssetTag(request: AssetTagCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createAssetTag.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettags`;\n        return this.httpClient.request<AssetTagResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new cost centre\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createCostCentre(request: CostCentreCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreResponse>;\n    public createCostCentre(request: CostCentreCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreResponse>>;\n    public createCostCentre(request: CostCentreCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreResponse>>;\n    public createCostCentre(request: CostCentreCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createCostCentre.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres`;\n        return this.httpClient.request<CostCentreResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new dashboard entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDashboard(request: DashboardCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardResponse>;\n    public createDashboard(request: DashboardCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardResponse>>;\n    public createDashboard(request: DashboardCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardResponse>>;\n    public createDashboard(request: DashboardCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDashboard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards`;\n        return this.httpClient.request<DashboardResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new dashboard template\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDashboardTemplate(request: DashboardTemplateCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardTemplateResponse>;\n    public createDashboardTemplate(request: DashboardTemplateCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardTemplateResponse>>;\n    public createDashboardTemplate(request: DashboardTemplateCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardTemplateResponse>>;\n    public createDashboardTemplate(request: DashboardTemplateCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDashboardTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboardtemplates`;\n        return this.httpClient.request<DashboardTemplateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new device entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDevice(request: DeviceCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceResponse>;\n    public createDevice(request: DeviceCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceResponse>>;\n    public createDevice(request: DeviceCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceResponse>>;\n    public createDevice(request: DeviceCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDevice.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices`;\n        return this.httpClient.request<DeviceResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new DeviceConfig Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDeviceConfigProfile(request: DeviceConfigProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceConfigProfileResponse>;\n    public createDeviceConfigProfile(request: DeviceConfigProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceConfigProfileResponse>>;\n    public createDeviceConfigProfile(request: DeviceConfigProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceConfigProfileResponse>>;\n    public createDeviceConfigProfile(request: DeviceConfigProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDeviceConfigProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceconfigprofiles`;\n        return this.httpClient.request<DeviceConfigProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new device provider entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDeviceProvider(request: DeviceProviderCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderResponse>;\n    public createDeviceProvider(request: DeviceProviderCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderResponse>>;\n    public createDeviceProvider(request: DeviceProviderCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderResponse>>;\n    public createDeviceProvider(request: DeviceProviderCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDeviceProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceproviders`;\n        return this.httpClient.request<DeviceProviderResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new device type entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createDeviceType(request: DeviceTypeCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceTypeResponse>;\n    public createDeviceType(request: DeviceTypeCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceTypeResponse>>;\n    public createDeviceType(request: DeviceTypeCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceTypeResponse>>;\n    public createDeviceType(request: DeviceTypeCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createDeviceType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devicetypes`;\n        return this.httpClient.request<DeviceTypeResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new email provider entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createEmailProvider(request: EmailProviderCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderResponse>;\n    public createEmailProvider(request: EmailProviderCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderResponse>>;\n    public createEmailProvider(request: EmailProviderCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderResponse>>;\n    public createEmailProvider(request: EmailProviderCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createEmailProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailproviders`;\n        return this.httpClient.request<EmailProviderResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new export task entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createExportTask(request: ExportTaskCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ExportTaskResponse>;\n    public createExportTask(request: ExportTaskCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ExportTaskResponse>>;\n    public createExportTask(request: ExportTaskCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ExportTaskResponse>>;\n    public createExportTask(request: ExportTaskCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createExportTask.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/exporttasks`;\n        return this.httpClient.request<ExportTaskResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new fuel card\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createFuelCard(request: FuelCardCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FuelCardResponse>;\n    public createFuelCard(request: FuelCardCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FuelCardResponse>>;\n    public createFuelCard(request: FuelCardCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FuelCardResponse>>;\n    public createFuelCard(request: FuelCardCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createFuelCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/fuelcards`;\n        return this.httpClient.request<FuelCardResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new GeoLock Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createGeoLockProfile(request: GeoLockProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<GeoLockProfileResponse>;\n    public createGeoLockProfile(request: GeoLockProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<GeoLockProfileResponse>>;\n    public createGeoLockProfile(request: GeoLockProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<GeoLockProfileResponse>>;\n    public createGeoLockProfile(request: GeoLockProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createGeoLockProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/geolockprofiles`;\n        return this.httpClient.request<GeoLockProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new I/O type entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createIoType(request: IoTypeCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IoTypeResponse>;\n    public createIoType(request: IoTypeCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IoTypeResponse>>;\n    public createIoType(request: IoTypeCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IoTypeResponse>>;\n    public createIoType(request: IoTypeCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createIoType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/iotypes`;\n        return this.httpClient.request<IoTypeResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new I/O type entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createLabel(request: LabelCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LabelResponse>;\n    public createLabel(request: LabelCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LabelResponse>>;\n    public createLabel(request: LabelCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LabelResponse>>;\n    public createLabel(request: LabelCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createLabel.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/labels`;\n        return this.httpClient.request<LabelResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new map set entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createMapSet(request: MapsetCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MapSetResponse>;\n    public createMapSet(request: MapsetCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MapSetResponse>>;\n    public createMapSet(request: MapsetCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MapSetResponse>>;\n    public createMapSet(request: MapsetCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createMapSet.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/mapsets`;\n        return this.httpClient.request<MapSetResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new Overspeed Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createOverspeedProfile(request: OverspeedProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<OverspeedProfileResponse>;\n    public createOverspeedProfile(request: OverspeedProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OverspeedProfileResponse>>;\n    public createOverspeedProfile(request: OverspeedProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OverspeedProfileResponse>>;\n    public createOverspeedProfile(request: OverspeedProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createOverspeedProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/overspeedprofiles`;\n        return this.httpClient.request<OverspeedProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new reminder entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createReminder(request: ReminderCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderResponse>;\n    public createReminder(request: ReminderCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderResponse>>;\n    public createReminder(request: ReminderCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderResponse>>;\n    public createReminder(request: ReminderCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createReminder.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders`;\n        return this.httpClient.request<ReminderResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new report template\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createReportTemplate(request: ReportTemplateCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateResponse>;\n    public createReportTemplate(request: ReportTemplateCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateResponse>>;\n    public createReportTemplate(request: ReportTemplateCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateResponse>>;\n    public createReportTemplate(request: ReportTemplateCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createReportTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates`;\n        return this.httpClient.request<ReportTemplateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new Road Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createRoadProfile(request: RoadProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RoadProfileResponse>;\n    public createRoadProfile(request: RoadProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RoadProfileResponse>>;\n    public createRoadProfile(request: RoadProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RoadProfileResponse>>;\n    public createRoadProfile(request: RoadProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createRoadProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/roadprofiles`;\n        return this.httpClient.request<RoadProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new scheduled report entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createScheduledReport(request: ScheduledReportCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ScheduledReportResponse>;\n    public createScheduledReport(request: ScheduledReportCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScheduledReportResponse>>;\n    public createScheduledReport(request: ScheduledReportCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScheduledReportResponse>>;\n    public createScheduledReport(request: ScheduledReportCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createScheduledReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/scheduledreports`;\n        return this.httpClient.request<ScheduledReportResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new shared asset location token\n     * @param id The UUID of the asset\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSharedAssetLocationToken(id: string, request: AssetSharedLocationTokenRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationTokenResponse>;\n    public createSharedAssetLocationToken(id: string, request: AssetSharedLocationTokenRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationTokenResponse>>;\n    public createSharedAssetLocationToken(id: string, request: AssetSharedLocationTokenRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationTokenResponse>>;\n    public createSharedAssetLocationToken(id: string, request: AssetSharedLocationTokenRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling createSharedAssetLocationToken.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createSharedAssetLocationToken.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetSharedLocationTokenResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new SIM card\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSimCard(request: SimCardCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SimCardResponse>;\n    public createSimCard(request: SimCardCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SimCardResponse>>;\n    public createSimCard(request: SimCardCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SimCardResponse>>;\n    public createSimCard(request: SimCardCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createSimCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/simcards`;\n        return this.httpClient.request<SimCardResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new sms gateway provider entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSmsGatewayProvider(request: SmsGatewayProviderCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderResponse>;\n    public createSmsGatewayProvider(request: SmsGatewayProviderCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderResponse>>;\n    public createSmsGatewayProvider(request: SmsGatewayProviderCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderResponse>>;\n    public createSmsGatewayProvider(request: SmsGatewayProviderCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createSmsGatewayProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayproviders`;\n        return this.httpClient.request<SmsGatewayProviderResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new ssl certificate entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSslCertificate(request: SslCertificateCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateResponse>;\n    public createSslCertificate(request: SslCertificateCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateResponse>>;\n    public createSslCertificate(request: SslCertificateCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateResponse>>;\n    public createSslCertificate(request: SslCertificateCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates`;\n        return this.httpClient.request<SslCertificateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new Theme entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createTheme(request: ThemeCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThemeResponse>;\n    public createTheme(request: ThemeCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThemeResponse>>;\n    public createTheme(request: ThemeCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThemeResponse>>;\n    public createTheme(request: ThemeCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createTheme.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes`;\n        return this.httpClient.request<ThemeResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new zone\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createZone(request: ZoneCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneResponse>;\n    public createZone(request: ZoneCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneResponse>>;\n    public createZone(request: ZoneCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneResponse>>;\n    public createZone(request: ZoneCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createZone.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zones`;\n        return this.httpClient.request<ZoneResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new Zone Group\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createZoneGroup(request: ZoneGroupCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupResponse>;\n    public createZoneGroup(request: ZoneGroupCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupResponse>>;\n    public createZoneGroup(request: ZoneGroupCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupResponse>>;\n    public createZoneGroup(request: ZoneGroupCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createZoneGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups`;\n        return this.httpClient.request<ZoneGroupResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a asset avatar.\n     * @param id The asset UUID.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAssetAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteAssetAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteAssetAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteAssetAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteAssetAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete an asset category\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAssetCategory(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryResponse>;\n    public deleteAssetCategory(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryResponse>>;\n    public deleteAssetCategory(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryResponse>>;\n    public deleteAssetCategory(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteAssetCategory.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetCategoryResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete an asset group\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAssetGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupResponse>;\n    public deleteAssetGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupResponse>>;\n    public deleteAssetGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupResponse>>;\n    public deleteAssetGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteAssetGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetGroupResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a cost centre\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteCostCentre(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreResponse>;\n    public deleteCostCentre(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreResponse>>;\n    public deleteCostCentre(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreResponse>>;\n    public deleteCostCentre(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteCostCentre.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CostCentreResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a dashboard\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteDashboard(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardResponse>;\n    public deleteDashboard(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardResponse>>;\n    public deleteDashboard(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardResponse>>;\n    public deleteDashboard(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteDashboard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes an existing reminder entity\n     * @param id The reminder UUID.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteReminder(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderResponse>;\n    public deleteReminder(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderResponse>>;\n    public deleteReminder(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderResponse>>;\n    public deleteReminder(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteReminder.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReminderResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes a report template\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteReportTemplate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateResponse>;\n    public deleteReportTemplate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateResponse>>;\n    public deleteReportTemplate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateResponse>>;\n    public deleteReportTemplate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteReportTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReportTemplateResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes a shared asset location token\n     * @param token The shared asset token to delete\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteSharedAssetLocationToken(token: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationTokenResponse>;\n    public deleteSharedAssetLocationToken(token: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationTokenResponse>>;\n    public deleteSharedAssetLocationToken(token: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationTokenResponse>>;\n    public deleteSharedAssetLocationToken(token: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (token === null || token === undefined) {\n            throw new Error('Required parameter token was null or undefined when calling deleteSharedAssetLocationToken.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location/${this.configuration.encodeParam({name: \"token\", value: token, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetSharedLocationTokenResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a Zone Group\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteZoneGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupResponse>;\n    public deleteZoneGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupResponse>>;\n    public deleteZoneGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupResponse>>;\n    public deleteZoneGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteZoneGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneGroupResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns alert details for the specified id\n     * @param id The UUID of the alert\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAlert(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AlertResponse>;\n    public getAlert(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AlertResponse>>;\n    public getAlert(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AlertResponse>>;\n    public getAlert(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/alerts/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AlertResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset details for the specified id\n     * @param id The UUID of the asset\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAsset(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetResponse>;\n    public getAsset(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetResponse>>;\n    public getAsset(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetResponse>>;\n    public getAsset(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAsset.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the asset avatar in binary format\n     * @param id The UUID of the asset\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getAssetAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getAssetAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getAssetAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset category details for the specified id\n     * @param id The UUID of the asset category\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetCategory(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryResponse>;\n    public getAssetCategory(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryResponse>>;\n    public getAssetCategory(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryResponse>>;\n    public getAssetCategory(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetCategory.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetCategoryResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset group details for the specified id\n     * @param id The UUID of the asset group\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupResponse>;\n    public getAssetGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupResponse>>;\n    public getAssetGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupResponse>>;\n    public getAssetGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetGroupResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns the latest known telemetry record for an asset\n     * @param id The UUID of the asset\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetLocation(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TelemetryStateResponse>;\n    public getAssetLocation(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TelemetryStateResponse>>;\n    public getAssetLocation(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TelemetryStateResponse>>;\n    public getAssetLocation(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetLocation.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/location`;\n        return this.httpClient.request<TelemetryStateResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset rating profile details for the specified id\n     * @param id The UUID of the asset rating profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetRatingProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetRatingProfileResponse>;\n    public getAssetRatingProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetRatingProfileResponse>>;\n    public getAssetRatingProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetRatingProfileResponse>>;\n    public getAssetRatingProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetRatingProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetratingprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetRatingProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset state profile details for the specified id\n     * @param id The UUID of the asset state profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetStateProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetStateProfileResponse>;\n    public getAssetStateProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetStateProfileResponse>>;\n    public getAssetStateProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetStateProfileResponse>>;\n    public getAssetStateProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetStateProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetstateprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetStateProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns Asset Tag details for the specified id\n     * @param id The UUID of the Asset Tag\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetTag(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagResponse>;\n    public getAssetTag(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagResponse>>;\n    public getAssetTag(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagResponse>>;\n    public getAssetTag(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetTag.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettags/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetTagResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset tag type details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetTagType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagTypeResponse>;\n    public getAssetTagType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagTypeResponse>>;\n    public getAssetTagType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagTypeResponse>>;\n    public getAssetTagType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetTagType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettagtypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetTagTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns asset type details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAssetType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTypeResponse>;\n    public getAssetType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTypeResponse>>;\n    public getAssetType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTypeResponse>>;\n    public getAssetType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAssetType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns cost centre details for the specified id\n     * @param id The UUID of the cost centre\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCostCentre(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreResponse>;\n    public getCostCentre(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreResponse>>;\n    public getCostCentre(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreResponse>>;\n    public getCostCentre(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCostCentre.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CostCentreResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns dashboard entity details for the specified id\n     * @param id The UUID of the Dashboard\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDashboard(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardResponse>;\n    public getDashboard(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardResponse>>;\n    public getDashboard(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardResponse>>;\n    public getDashboard(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDashboard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns dashboard template entity details for the specified id\n     * @param id The UUID of the Dashboard\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDashboardTemplate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardTemplateResponse>;\n    public getDashboardTemplate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardTemplateResponse>>;\n    public getDashboardTemplate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardTemplateResponse>>;\n    public getDashboardTemplate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDashboardTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboardtemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardTemplateResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device details for the specified id\n     * @param id The UUID of the device\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDevice(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceResponse>;\n    public getDevice(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceResponse>>;\n    public getDevice(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceResponse>>;\n    public getDevice(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDevice.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device details for the specified device type and device IMEI or serial number\n     * @param deviceType The UUID of the device type\n     * @param deviceName The name of the device (usually an IMEI or serial number)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceByName(deviceType: string, deviceName: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceResponse>;\n    public getDeviceByName(deviceType: string, deviceName: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceResponse>>;\n    public getDeviceByName(deviceType: string, deviceName: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceResponse>>;\n    public getDeviceByName(deviceType: string, deviceName: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (deviceType === null || deviceType === undefined) {\n            throw new Error('Required parameter deviceType was null or undefined when calling getDeviceByName.');\n        }\n        if (deviceName === null || deviceName === undefined) {\n            throw new Error('Required parameter deviceName was null or undefined when calling getDeviceByName.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices/name/${this.configuration.encodeParam({name: \"deviceType\", value: deviceType, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"deviceName\", value: deviceName, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device config profile details for the specified id\n     * @param id The UUID of the device config profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceConfigProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceConfigProfileResponse>;\n    public getDeviceConfigProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceConfigProfileResponse>>;\n    public getDeviceConfigProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceConfigProfileResponse>>;\n    public getDeviceConfigProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDeviceConfigProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceconfigprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceConfigProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device provider details for the specified id\n     * @param id The UUID of the device\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceProvider(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderResponse>;\n    public getDeviceProvider(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderResponse>>;\n    public getDeviceProvider(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderResponse>>;\n    public getDeviceProvider(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDeviceProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceProviderResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device provider type details for the specified id\n     * @param id The UUID of the device\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceProviderType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderTypeResponse>;\n    public getDeviceProviderType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderTypeResponse>>;\n    public getDeviceProviderType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderTypeResponse>>;\n    public getDeviceProviderType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDeviceProviderType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceprovidertypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceProviderTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns device type details for the specified id\n     * @param id The UUID of the device\n     * @param owner The optional UUID of a Client. The device type may be customized based on settings and features in the client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDeviceType(id: string, owner?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceTypeResponse>;\n    public getDeviceType(id: string, owner?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceTypeResponse>>;\n    public getDeviceType(id: string, owner?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceTypeResponse>>;\n    public getDeviceType(id: string, owner?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getDeviceType.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devicetypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns email provider details for the specified id\n     * @param id The UUID of the email provider\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getEmailProvider(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderResponse>;\n    public getEmailProvider(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderResponse>>;\n    public getEmailProvider(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderResponse>>;\n    public getEmailProvider(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getEmailProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EmailProviderResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns email provider type details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getEmailProviderType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderTypeResponse>;\n    public getEmailProviderType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderTypeResponse>>;\n    public getEmailProviderType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderTypeResponse>>;\n    public getEmailProviderType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getEmailProviderType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailprovidertypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EmailProviderTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns export task details for the specified id\n     * @param id The UUID of the export task\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getExportTask(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ExportTaskResponse>;\n    public getExportTask(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ExportTaskResponse>>;\n    public getExportTask(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ExportTaskResponse>>;\n    public getExportTask(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getExportTask.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/exporttasks/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ExportTaskResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns fuel card details for the specified id\n     * @param id The UUID of the fuel card\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getFuelCard(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FuelCardResponse>;\n    public getFuelCard(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FuelCardResponse>>;\n    public getFuelCard(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FuelCardResponse>>;\n    public getFuelCard(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getFuelCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/fuelcards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<FuelCardResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns GeoLock profile details for the specified id\n     * @param id The UUID of the GeoLock profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getGeoLockProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<GeoLockProfileResponse>;\n    public getGeoLockProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<GeoLockProfileResponse>>;\n    public getGeoLockProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<GeoLockProfileResponse>>;\n    public getGeoLockProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getGeoLockProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/geolockprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<GeoLockProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns I/O type details for the specified id\n     * @param id The UUID of the I/O type\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIoType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IoTypeResponse>;\n    public getIoType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IoTypeResponse>>;\n    public getIoType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IoTypeResponse>>;\n    public getIoType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getIoType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/iotypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<IoTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns I/O type details for the specified id\n     * @param id The UUID of the I/O type\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getLabel(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LabelResponse>;\n    public getLabel(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LabelResponse>>;\n    public getLabel(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LabelResponse>>;\n    public getLabel(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getLabel.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/labels/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<LabelResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of lookups for a specified entity.\n     * @param entity \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getLookups(entity: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<{ [key: string]: { [key: string]: any; }; }>;\n    public getLookups(entity: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<{ [key: string]: { [key: string]: any; }; }>>;\n    public getLookups(entity: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<{ [key: string]: { [key: string]: any; }; }>>;\n    public getLookups(entity: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (entity === null || entity === undefined) {\n            throw new Error('Required parameter entity was null or undefined when calling getLookups.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/lookups/${this.configuration.encodeParam({name: \"entity\", value: entity, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<{ [key: string]: { [key: string]: any; }; }>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a map set by it\\&#39;s ID.\n     * @param id The Map Set UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getMapSet(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MapSetResponse>;\n    public getMapSet(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MapSetResponse>>;\n    public getMapSet(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MapSetResponse>>;\n    public getMapSet(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getMapSet.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/mapsets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<MapSetResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns overspeed profile details for the specified id\n     * @param id The UUID of the overspeed profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getOverspeedProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<OverspeedProfileResponse>;\n    public getOverspeedProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OverspeedProfileResponse>>;\n    public getOverspeedProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OverspeedProfileResponse>>;\n    public getOverspeedProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getOverspeedProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/overspeedprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<OverspeedProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a reminder by it\\&#39;s ID.\n     * @param id The reminder UUID.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getReminder(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderResponse>;\n    public getReminder(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderResponse>>;\n    public getReminder(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderResponse>>;\n    public getReminder(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getReminder.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReminderResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a report definition by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getReportDefinition(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportDefinitionResponse>;\n    public getReportDefinition(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportDefinitionResponse>>;\n    public getReportDefinition(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportDefinitionResponse>>;\n    public getReportDefinition(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getReportDefinition.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reportdefinitions/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReportDefinitionResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a report template by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getReportTemplate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateResponse>;\n    public getReportTemplate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateResponse>>;\n    public getReportTemplate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateResponse>>;\n    public getReportTemplate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getReportTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReportTemplateResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns road profile details for the specified id\n     * @param id The UUID of the road profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getRoadProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RoadProfileResponse>;\n    public getRoadProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RoadProfileResponse>>;\n    public getRoadProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RoadProfileResponse>>;\n    public getRoadProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getRoadProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/roadprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<RoadProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns scheduled report details for the specified id\n     * @param id The UUID of the scheduled report\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getScheduledReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ScheduledReportResponse>;\n    public getScheduledReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScheduledReportResponse>>;\n    public getScheduledReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScheduledReportResponse>>;\n    public getScheduledReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getScheduledReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/scheduledreports/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ScheduledReportResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns the latest known telemetry record for an asset using a shared token\n     * @param token The shared token\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSharedAssetLocation(token: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationResponse>;\n    public getSharedAssetLocation(token: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationResponse>>;\n    public getSharedAssetLocation(token: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationResponse>>;\n    public getSharedAssetLocation(token: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (token === null || token === undefined) {\n            throw new Error('Required parameter token was null or undefined when calling getSharedAssetLocation.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location/${this.configuration.encodeParam({name: \"token\", value: token, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetSharedLocationResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns SIM card details for the specified id\n     * @param id The UUID of the SIM card\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSimCard(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SimCardResponse>;\n    public getSimCard(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SimCardResponse>>;\n    public getSimCard(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SimCardResponse>>;\n    public getSimCard(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getSimCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/simcards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SimCardResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns sms gateway provider details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSmsGatewayProvider(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderResponse>;\n    public getSmsGatewayProvider(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderResponse>>;\n    public getSmsGatewayProvider(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderResponse>>;\n    public getSmsGatewayProvider(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getSmsGatewayProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SmsGatewayProviderResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns sms gateway provider type details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSmsGatewayProviderType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderTypeResponse>;\n    public getSmsGatewayProviderType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderTypeResponse>>;\n    public getSmsGatewayProviderType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderTypeResponse>>;\n    public getSmsGatewayProviderType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getSmsGatewayProviderType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayprovidertypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SmsGatewayProviderTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns ssl certificate details for the specified id\n     * @param id The UUID of the ssl certificate\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSslCertificate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateResponse>;\n    public getSslCertificate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateResponse>>;\n    public getSslCertificate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateResponse>>;\n    public getSslCertificate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SslCertificateResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns Theme details for the specified id\n     * @param id The UUID of the Theme\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTheme(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThemeResponse>;\n    public getTheme(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThemeResponse>>;\n    public getTheme(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThemeResponse>>;\n    public getTheme(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getTheme.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ThemeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns client details for the specified id\n     * @param domain The domain name to look up\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getThemeForDomain(domain: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DomainThemeResponse>;\n    public getThemeForDomain(domain: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DomainThemeResponse>>;\n    public getThemeForDomain(domain: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DomainThemeResponse>>;\n    public getThemeForDomain(domain: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (domain === null || domain === undefined) {\n            throw new Error('Required parameter domain was null or undefined when calling getThemeForDomain.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes/domain/${this.configuration.encodeParam({name: \"domain\", value: domain, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DomainThemeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a Map Set by it\\&#39;s ID.\n     * @param id The Map Set UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getZone(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneResponse>;\n    public getZone(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneResponse>>;\n    public getZone(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneResponse>>;\n    public getZone(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getZone.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zones/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns zone group details for the specified id\n     * @param id The UUID of the zone group\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getZoneGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupResponse>;\n    public getZoneGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupResponse>>;\n    public getZoneGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupResponse>>;\n    public getZoneGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getZoneGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneGroupResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Links an asset from one account to one in another account. All data from the source asset will be duplicated for the destination asset. Returns both the source and destination asset if successful.\n     * @param id The source asset UUID you would like to link.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public linkAssets(id: string, request: AssetLinkRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetLinkResponse>;\n    public linkAssets(id: string, request: AssetLinkRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetLinkResponse>>;\n    public linkAssets(id: string, request: AssetLinkRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetLinkResponse>>;\n    public linkAssets(id: string, request: AssetLinkRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling linkAssets.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling linkAssets.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/link`;\n        return this.httpClient.request<AssetLinkResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of alerts for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAlerts(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AlertListResponse>;\n    public listAlerts(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AlertListResponse>>;\n    public listAlerts(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AlertListResponse>>;\n    public listAlerts(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAlerts.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/alerts`;\n        return this.httpClient.request<AlertListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset categories for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetCategories(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryListResponse>;\n    public listAssetCategories(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryListResponse>>;\n    public listAssetCategories(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryListResponse>>;\n    public listAssetCategories(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetCategories.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories`;\n        return this.httpClient.request<AssetCategoryListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset groups for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupListResponse>;\n    public listAssetGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupListResponse>>;\n    public listAssetGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupListResponse>>;\n    public listAssetGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetGroups.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups`;\n        return this.httpClient.request<AssetGroupListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset rating profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetRatingProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetRatingProfileListResponse>;\n    public listAssetRatingProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetRatingProfileListResponse>>;\n    public listAssetRatingProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetRatingProfileListResponse>>;\n    public listAssetRatingProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetRatingProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetratingprofiles`;\n        return this.httpClient.request<AssetRatingProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset state profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetStateProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetStateProfileListResponse>;\n    public listAssetStateProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetStateProfileListResponse>>;\n    public listAssetStateProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetStateProfileListResponse>>;\n    public listAssetStateProfiles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetStateProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetstateprofiles`;\n        return this.httpClient.request<AssetStateProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset tag types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetTagTypes(owner: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagTypeListResponse>;\n    public listAssetTagTypes(owner: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagTypeListResponse>>;\n    public listAssetTagTypes(owner: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagTypeListResponse>>;\n    public listAssetTagTypes(owner: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetTagTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettagtypes`;\n        return this.httpClient.request<AssetTagTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of Asset Tags for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetTags(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagListResponse>;\n    public listAssetTags(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagListResponse>>;\n    public listAssetTags(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagListResponse>>;\n    public listAssetTags(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetTags.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettags`;\n        return this.httpClient.request<AssetTagListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of asset types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssetTypes(owner: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTypeListResponse>;\n    public listAssetTypes(owner: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTypeListResponse>>;\n    public listAssetTypes(owner: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTypeListResponse>>;\n    public listAssetTypes(owner: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssetTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettypes`;\n        return this.httpClient.request<AssetTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of assets for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAssets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetListResponse>;\n    public listAssets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetListResponse>>;\n    public listAssets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetListResponse>>;\n    public listAssets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listAssets.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets`;\n        return this.httpClient.request<AssetListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of cost centres for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listCostCentres(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreListResponse>;\n    public listCostCentres(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreListResponse>>;\n    public listCostCentres(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreListResponse>>;\n    public listCostCentres(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listCostCentres.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres`;\n        return this.httpClient.request<CostCentreListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of Dashboard templates for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDashboardTemplates(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardTemplateListResponse>;\n    public listDashboardTemplates(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardTemplateListResponse>>;\n    public listDashboardTemplates(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardTemplateListResponse>>;\n    public listDashboardTemplates(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDashboardTemplates.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboardtemplates`;\n        return this.httpClient.request<DashboardTemplateListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of Dashboards for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardListResponse>;\n    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardListResponse>>;\n    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardListResponse>>;\n    public listDashboards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDashboards.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards`;\n        return this.httpClient.request<DashboardListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of device config profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDeviceConfigProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceConfigProfileListResponse>;\n    public listDeviceConfigProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceConfigProfileListResponse>>;\n    public listDeviceConfigProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceConfigProfileListResponse>>;\n    public listDeviceConfigProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDeviceConfigProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceconfigprofiles`;\n        return this.httpClient.request<DeviceConfigProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of device provider types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDeviceProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderTypeListResponse>;\n    public listDeviceProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderTypeListResponse>>;\n    public listDeviceProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderTypeListResponse>>;\n    public listDeviceProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDeviceProviderTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceprovidertypes`;\n        return this.httpClient.request<DeviceProviderTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of device providers for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDeviceProviders(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderListResponse>;\n    public listDeviceProviders(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderListResponse>>;\n    public listDeviceProviders(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderListResponse>>;\n    public listDeviceProviders(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDeviceProviders.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceproviders`;\n        return this.httpClient.request<DeviceProviderListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of device types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent company tree as well (defaults to \\&quot;true\\&quot;)\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDeviceTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceTypeListResponse>;\n    public listDeviceTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceTypeListResponse>>;\n    public listDeviceTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceTypeListResponse>>;\n    public listDeviceTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDeviceTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devicetypes`;\n        return this.httpClient.request<DeviceTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of devices for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listDevices(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceListResponse>;\n    public listDevices(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceListResponse>>;\n    public listDevices(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceListResponse>>;\n    public listDevices(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listDevices.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices`;\n        return this.httpClient.request<DeviceListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of email provider types.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listEmailProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderTypeListResponse>;\n    public listEmailProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderTypeListResponse>>;\n    public listEmailProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderTypeListResponse>>;\n    public listEmailProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listEmailProviderTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailprovidertypes`;\n        return this.httpClient.request<EmailProviderTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of email providers.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listEmailProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderListResponse>;\n    public listEmailProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderListResponse>>;\n    public listEmailProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderListResponse>>;\n    public listEmailProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listEmailProviders.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailproviders`;\n        return this.httpClient.request<EmailProviderListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of export tasks for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listExportTasks(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ExportTaskListResponse>;\n    public listExportTasks(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ExportTaskListResponse>>;\n    public listExportTasks(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ExportTaskListResponse>>;\n    public listExportTasks(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listExportTasks.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/exporttasks`;\n        return this.httpClient.request<ExportTaskListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of fuel cards for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listFuelCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FuelCardListResponse>;\n    public listFuelCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FuelCardListResponse>>;\n    public listFuelCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FuelCardListResponse>>;\n    public listFuelCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listFuelCards.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/fuelcards`;\n        return this.httpClient.request<FuelCardListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of GeoLock profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listGeoLockProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<GeoLockProfileListResponse>;\n    public listGeoLockProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<GeoLockProfileListResponse>>;\n    public listGeoLockProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<GeoLockProfileListResponse>>;\n    public listGeoLockProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listGeoLockProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/geolockprofiles`;\n        return this.httpClient.request<GeoLockProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of I/O types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listIoTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IoTypeListResponse>;\n    public listIoTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IoTypeListResponse>>;\n    public listIoTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IoTypeListResponse>>;\n    public listIoTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listIoTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/iotypes`;\n        return this.httpClient.request<IoTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of I/O types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listLabels(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LabelListResponse>;\n    public listLabels(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LabelListResponse>>;\n    public listLabels(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LabelListResponse>>;\n    public listLabels(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listLabels.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/labels`;\n        return this.httpClient.request<LabelListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of map sets for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listMapSets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MapSetListResponse>;\n    public listMapSets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MapSetListResponse>>;\n    public listMapSets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MapSetListResponse>>;\n    public listMapSets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listMapSets.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/mapsets`;\n        return this.httpClient.request<MapSetListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of overspeed profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listOverspeedProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<OverspeedProfileListResponse>;\n    public listOverspeedProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OverspeedProfileListResponse>>;\n    public listOverspeedProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OverspeedProfileListResponse>>;\n    public listOverspeedProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listOverspeedProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/overspeedprofiles`;\n        return this.httpClient.request<OverspeedProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of reminders for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param target The target entity you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listReminders(owner: string, target?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderListResponse>;\n    public listReminders(owner: string, target?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderListResponse>>;\n    public listReminders(owner: string, target?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderListResponse>>;\n    public listReminders(owner: string, target?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listReminders.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (target !== undefined && target !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>target, 'target');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders`;\n        return this.httpClient.request<ReminderListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of report definitions for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listReportDefinitions(owner: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportDefinitionListResponse>;\n    public listReportDefinitions(owner: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportDefinitionListResponse>>;\n    public listReportDefinitions(owner: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportDefinitionListResponse>>;\n    public listReportDefinitions(owner: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listReportDefinitions.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reportdefinitions`;\n        return this.httpClient.request<ReportDefinitionListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of report templates for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listReportTemplates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateListResponse>;\n    public listReportTemplates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateListResponse>>;\n    public listReportTemplates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateListResponse>>;\n    public listReportTemplates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listReportTemplates.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates`;\n        return this.httpClient.request<ReportTemplateListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of road profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listRoadProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RoadProfileListResponse>;\n    public listRoadProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RoadProfileListResponse>>;\n    public listRoadProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RoadProfileListResponse>>;\n    public listRoadProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listRoadProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/roadprofiles`;\n        return this.httpClient.request<RoadProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of scheduled reports for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listScheduledReports(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ScheduledReportListResponse>;\n    public listScheduledReports(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScheduledReportListResponse>>;\n    public listScheduledReports(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScheduledReportListResponse>>;\n    public listScheduledReports(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listScheduledReports.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/scheduledreports`;\n        return this.httpClient.request<ScheduledReportListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of shared asset tokens for an asset or client.\n     * @param owner The owner id you are requesting data for\n     * @param asset The asset id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSharedAssetLocationTokens(owner?: string, asset?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationTokenListResponse>;\n    public listSharedAssetLocationTokens(owner?: string, asset?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationTokenListResponse>>;\n    public listSharedAssetLocationTokens(owner?: string, asset?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationTokenListResponse>>;\n    public listSharedAssetLocationTokens(owner?: string, asset?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (asset !== undefined && asset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>asset, 'asset');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location`;\n        return this.httpClient.request<AssetSharedLocationTokenListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of SIM cards for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSimCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SimCardListResponse>;\n    public listSimCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SimCardListResponse>>;\n    public listSimCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SimCardListResponse>>;\n    public listSimCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listSimCards.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/simcards`;\n        return this.httpClient.request<SimCardListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of sms gateway provider types.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSmsGatewayProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderTypeListResponse>;\n    public listSmsGatewayProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderTypeListResponse>>;\n    public listSmsGatewayProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderTypeListResponse>>;\n    public listSmsGatewayProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listSmsGatewayProviderTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayprovidertypes`;\n        return this.httpClient.request<SmsGatewayProviderTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of sms gateway providers.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSmsGatewayProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderListResponse>;\n    public listSmsGatewayProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderListResponse>>;\n    public listSmsGatewayProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderListResponse>>;\n    public listSmsGatewayProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listSmsGatewayProviders.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayproviders`;\n        return this.httpClient.request<SmsGatewayProviderListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of ssl certificates.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSslCertificates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateListResponse>;\n    public listSslCertificates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateListResponse>>;\n    public listSslCertificates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateListResponse>>;\n    public listSslCertificates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listSslCertificates.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates`;\n        return this.httpClient.request<SslCertificateListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of themes for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse \n     * @param offset \n     * @param limit \n     * @param sort \n     * @param filter \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listThemes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThemeListResponse>;\n    public listThemes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThemeListResponse>>;\n    public listThemes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThemeListResponse>>;\n    public listThemes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listThemes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes`;\n        return this.httpClient.request<ThemeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of zone groups for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listZoneGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupListResponse>;\n    public listZoneGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupListResponse>>;\n    public listZoneGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupListResponse>>;\n    public listZoneGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listZoneGroups.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups`;\n        return this.httpClient.request<ZoneGroupListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of zones for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param bounds A bounding rectangle to restrict the result set to in string format as &#x60;left,top,right,bottom&#x60;\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listZones(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, bounds?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneListResponse>;\n    public listZones(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, bounds?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneListResponse>>;\n    public listZones(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, bounds?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneListResponse>>;\n    public listZones(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, bounds?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listZones.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n        if (bounds !== undefined && bounds !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>bounds, 'bounds');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zones`;\n        return this.httpClient.request<ZoneListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Moves an asset from one client to another by deleting the asset in the source client and recreating it in the destination client. Also moves any associated device and simcard if assigned.\n     * @param id The asset UUID you would like to move.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public moveAsset(id: string, request: AssetMoveRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetResponse>;\n    public moveAsset(id: string, request: AssetMoveRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetResponse>>;\n    public moveAsset(id: string, request: AssetMoveRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetResponse>>;\n    public moveAsset(id: string, request: AssetMoveRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling moveAsset.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling moveAsset.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/move`;\n        return this.httpClient.request<AssetResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Attempts to provision the ssl certificate\n     * @param id The UUID of the ssl certificate\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public provisionSslCertificate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateProvisionResponse>;\n    public provisionSslCertificate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateProvisionResponse>>;\n    public provisionSslCertificate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateProvisionResponse>>;\n    public provisionSslCertificate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling provisionSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/provision`;\n        return this.httpClient.request<SslCertificateProvisionResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Rebuilds a widget\n     * @param id The UUID of the dashboard to which the widget belongs\n     * @param widgetId The UUID of the widget to rebuild\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public rebuildDashboardWidget(id: string, widgetId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RebuildDashboardWidgetResponse>;\n    public rebuildDashboardWidget(id: string, widgetId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RebuildDashboardWidgetResponse>>;\n    public rebuildDashboardWidget(id: string, widgetId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RebuildDashboardWidgetResponse>>;\n    public rebuildDashboardWidget(id: string, widgetId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling rebuildDashboardWidget.');\n        }\n        if (widgetId === null || widgetId === undefined) {\n            throw new Error('Required parameter widgetId was null or undefined when calling rebuildDashboardWidget.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/widgets/${this.configuration.encodeParam({name: \"widgetId\", value: widgetId, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/rebuild`;\n        return this.httpClient.request<RebuildDashboardWidgetResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Unlinks an asset linked to another.  Returns both the source and destination asset if successful.\n     * @param id The source asset UUID you would like to unlink from.\n     * @param asset The destination asset UUID you would like to unlink from.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public unlinkAssets(id: string, asset: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetLinkResponse>;\n    public unlinkAssets(id: string, asset: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetLinkResponse>>;\n    public unlinkAssets(id: string, asset: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetLinkResponse>>;\n    public unlinkAssets(id: string, asset: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling unlinkAssets.');\n        }\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling unlinkAssets.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/unlink/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetLinkResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Alert\n     * @param id The UUID of the Alert\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAlert(id: string, request: AlertUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AlertResponse>;\n    public updateAlert(id: string, request: AlertUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AlertResponse>>;\n    public updateAlert(id: string, request: AlertUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AlertResponse>>;\n    public updateAlert(id: string, request: AlertUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAlert.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/alerts/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AlertResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing asset\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAsset(id: string, request: AssetUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetResponse>;\n    public updateAsset(id: string, request: AssetUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetResponse>>;\n    public updateAsset(id: string, request: AssetUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetResponse>>;\n    public updateAsset(id: string, request: AssetUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAsset.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAsset.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified asset\\&#39;s avatar.\n     * @param id The asset UUID you are requesting data for.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateAssetAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateAssetAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateAssetAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing asset category\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetCategory(id: string, request: AssetCategoryUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetCategoryResponse>;\n    public updateAssetCategory(id: string, request: AssetCategoryUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetCategoryResponse>>;\n    public updateAssetCategory(id: string, request: AssetCategoryUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetCategoryResponse>>;\n    public updateAssetCategory(id: string, request: AssetCategoryUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetCategory.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetCategory.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetcategories/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetCategoryResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Asset Group\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetGroup(id: string, request: AssetGroupUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetGroupResponse>;\n    public updateAssetGroup(id: string, request: AssetGroupUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetGroupResponse>>;\n    public updateAssetGroup(id: string, request: AssetGroupUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetGroupResponse>>;\n    public updateAssetGroup(id: string, request: AssetGroupUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetGroup.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetgroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetGroupResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Asset Rating Profile entity\n     * @param id The UUID of the Asset State Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetRatingProfile(id: string, request: AssetRatingProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetRatingProfileResponse>;\n    public updateAssetRatingProfile(id: string, request: AssetRatingProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetRatingProfileResponse>>;\n    public updateAssetRatingProfile(id: string, request: AssetRatingProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetRatingProfileResponse>>;\n    public updateAssetRatingProfile(id: string, request: AssetRatingProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetRatingProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetRatingProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetratingprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetRatingProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Asset State Profile entity\n     * @param id The UUID of the Asset State Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetStateProfile(id: string, request: AssetStateProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetStateProfileResponse>;\n    public updateAssetStateProfile(id: string, request: AssetStateProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetStateProfileResponse>>;\n    public updateAssetStateProfile(id: string, request: AssetStateProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetStateProfileResponse>>;\n    public updateAssetStateProfile(id: string, request: AssetStateProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetStateProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetStateProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assetstateprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetStateProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Asset Tag\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateAssetTag(id: string, request: AssetTagUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetTagResponse>;\n    public updateAssetTag(id: string, request: AssetTagUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetTagResponse>>;\n    public updateAssetTag(id: string, request: AssetTagUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetTagResponse>>;\n    public updateAssetTag(id: string, request: AssetTagUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateAssetTag.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateAssetTag.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assettags/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetTagResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing cost centre\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCostCentre(id: string, request: CostCentreUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CostCentreResponse>;\n    public updateCostCentre(id: string, request: CostCentreUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CostCentreResponse>>;\n    public updateCostCentre(id: string, request: CostCentreUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CostCentreResponse>>;\n    public updateCostCentre(id: string, request: CostCentreUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateCostCentre.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateCostCentre.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/costcentres/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CostCentreResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing dashboard entity\n     * @param id The UUID of the Dashboard\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDashboard(id: string, request: DashboardUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardResponse>;\n    public updateDashboard(id: string, request: DashboardUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardResponse>>;\n    public updateDashboard(id: string, request: DashboardUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardResponse>>;\n    public updateDashboard(id: string, request: DashboardUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDashboard.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDashboard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing dashboard template entity\n     * @param id The UUID of the Dashboard\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDashboardTemplate(id: string, request: DashboardTemplateUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DashboardTemplateResponse>;\n    public updateDashboardTemplate(id: string, request: DashboardTemplateUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DashboardTemplateResponse>>;\n    public updateDashboardTemplate(id: string, request: DashboardTemplateUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DashboardTemplateResponse>>;\n    public updateDashboardTemplate(id: string, request: DashboardTemplateUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDashboardTemplate.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDashboardTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/dashboardtemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DashboardTemplateResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing device\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDevice(id: string, request: DeviceUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceResponse>;\n    public updateDevice(id: string, request: DeviceUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceResponse>>;\n    public updateDevice(id: string, request: DeviceUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceResponse>>;\n    public updateDevice(id: string, request: DeviceUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDevice.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDevice.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devices/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing DeviceConfig Profile entity\n     * @param id The UUID of the DeviceConfig Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDeviceConfigProfile(id: string, request: DeviceConfigProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceConfigProfileResponse>;\n    public updateDeviceConfigProfile(id: string, request: DeviceConfigProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceConfigProfileResponse>>;\n    public updateDeviceConfigProfile(id: string, request: DeviceConfigProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceConfigProfileResponse>>;\n    public updateDeviceConfigProfile(id: string, request: DeviceConfigProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDeviceConfigProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDeviceConfigProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceconfigprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceConfigProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing device provider\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDeviceProvider(id: string, request: DeviceProviderUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceProviderResponse>;\n    public updateDeviceProvider(id: string, request: DeviceProviderUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceProviderResponse>>;\n    public updateDeviceProvider(id: string, request: DeviceProviderUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceProviderResponse>>;\n    public updateDeviceProvider(id: string, request: DeviceProviderUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDeviceProvider.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDeviceProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/deviceproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceProviderResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing device type\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDeviceType(id: string, request: DeviceTypeUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DeviceTypeResponse>;\n    public updateDeviceType(id: string, request: DeviceTypeUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DeviceTypeResponse>>;\n    public updateDeviceType(id: string, request: DeviceTypeUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DeviceTypeResponse>>;\n    public updateDeviceType(id: string, request: DeviceTypeUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateDeviceType.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateDeviceType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/devicetypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DeviceTypeResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing email provider entity\n     * @param id The UUID of the email provider\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateEmailProvider(id: string, request: EmailProviderUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EmailProviderResponse>;\n    public updateEmailProvider(id: string, request: EmailProviderUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EmailProviderResponse>>;\n    public updateEmailProvider(id: string, request: EmailProviderUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EmailProviderResponse>>;\n    public updateEmailProvider(id: string, request: EmailProviderUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateEmailProvider.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateEmailProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/emailproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EmailProviderResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing export task entity\n     * @param id The UUID of the export task\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateExportTask(id: string, request: ExportTaskUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ExportTaskResponse>;\n    public updateExportTask(id: string, request: ExportTaskUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ExportTaskResponse>>;\n    public updateExportTask(id: string, request: ExportTaskUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ExportTaskResponse>>;\n    public updateExportTask(id: string, request: ExportTaskUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateExportTask.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateExportTask.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/exporttasks/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ExportTaskResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing fuel card\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateFuelCard(id: string, request: FuelCardUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FuelCardResponse>;\n    public updateFuelCard(id: string, request: FuelCardUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FuelCardResponse>>;\n    public updateFuelCard(id: string, request: FuelCardUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FuelCardResponse>>;\n    public updateFuelCard(id: string, request: FuelCardUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateFuelCard.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateFuelCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/fuelcards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<FuelCardResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing GeoLock Profile entity\n     * @param id The UUID of the GeoLock Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateGeoLockProfile(id: string, request: GeoLockProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<GeoLockProfileResponse>;\n    public updateGeoLockProfile(id: string, request: GeoLockProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<GeoLockProfileResponse>>;\n    public updateGeoLockProfile(id: string, request: GeoLockProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<GeoLockProfileResponse>>;\n    public updateGeoLockProfile(id: string, request: GeoLockProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateGeoLockProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateGeoLockProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/geolockprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<GeoLockProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing I/O type entity\n     * @param id The UUID of the I/O type\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateIoType(id: string, request: IoTypeUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IoTypeResponse>;\n    public updateIoType(id: string, request: IoTypeUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IoTypeResponse>>;\n    public updateIoType(id: string, request: IoTypeUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IoTypeResponse>>;\n    public updateIoType(id: string, request: IoTypeUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateIoType.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateIoType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/iotypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<IoTypeResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing I/O type entity\n     * @param id The UUID of the I/O type\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateLabel(id: string, request: LabelUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LabelResponse>;\n    public updateLabel(id: string, request: LabelUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LabelResponse>>;\n    public updateLabel(id: string, request: LabelUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LabelResponse>>;\n    public updateLabel(id: string, request: LabelUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateLabel.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateLabel.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/labels/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<LabelResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing map set entity\n     * @param id The UUID of the mapset\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateMapSet(id: string, request: MapsetUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MapSetResponse>;\n    public updateMapSet(id: string, request: MapsetUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MapSetResponse>>;\n    public updateMapSet(id: string, request: MapsetUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MapSetResponse>>;\n    public updateMapSet(id: string, request: MapsetUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateMapSet.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateMapSet.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/mapsets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<MapSetResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Overspeed Profile entity\n     * @param id The UUID of the Overspeed Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateOverspeedProfile(id: string, request: OverspeedProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<OverspeedProfileResponse>;\n    public updateOverspeedProfile(id: string, request: OverspeedProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OverspeedProfileResponse>>;\n    public updateOverspeedProfile(id: string, request: OverspeedProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OverspeedProfileResponse>>;\n    public updateOverspeedProfile(id: string, request: OverspeedProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateOverspeedProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateOverspeedProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/overspeedprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<OverspeedProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing reminder entity\n     * @param id The reminder UUID.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateReminder(id: string, request: ReminderUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderResponse>;\n    public updateReminder(id: string, request: ReminderUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderResponse>>;\n    public updateReminder(id: string, request: ReminderUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderResponse>>;\n    public updateReminder(id: string, request: ReminderUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateReminder.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateReminder.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReminderResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing report template\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateReportTemplate(id: string, request: ReportTemplateUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateResponse>;\n    public updateReportTemplate(id: string, request: ReportTemplateUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateResponse>>;\n    public updateReportTemplate(id: string, request: ReportTemplateUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateResponse>>;\n    public updateReportTemplate(id: string, request: ReportTemplateUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateReportTemplate.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateReportTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReportTemplateResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Road Profile entity\n     * @param id The UUID of the Road Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateRoadProfile(id: string, request: RoadProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RoadProfileResponse>;\n    public updateRoadProfile(id: string, request: RoadProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RoadProfileResponse>>;\n    public updateRoadProfile(id: string, request: RoadProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RoadProfileResponse>>;\n    public updateRoadProfile(id: string, request: RoadProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateRoadProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateRoadProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/roadprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<RoadProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing scheduled report entity\n     * @param id The UUID of the scheduled report\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateScheduledReport(id: string, request: ScheduledReportUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ScheduledReportResponse>;\n    public updateScheduledReport(id: string, request: ScheduledReportUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScheduledReportResponse>>;\n    public updateScheduledReport(id: string, request: ScheduledReportUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScheduledReportResponse>>;\n    public updateScheduledReport(id: string, request: ScheduledReportUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateScheduledReport.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateScheduledReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/scheduledreports/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ScheduledReportResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a shared asset location token\n     * @param token The shared asset token to update\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateSharedAssetLocationToken(token: string, request: AssetSharedLocationTokenRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AssetSharedLocationTokenResponse>;\n    public updateSharedAssetLocationToken(token: string, request: AssetSharedLocationTokenRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AssetSharedLocationTokenResponse>>;\n    public updateSharedAssetLocationToken(token: string, request: AssetSharedLocationTokenRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AssetSharedLocationTokenResponse>>;\n    public updateSharedAssetLocationToken(token: string, request: AssetSharedLocationTokenRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (token === null || token === undefined) {\n            throw new Error('Required parameter token was null or undefined when calling updateSharedAssetLocationToken.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateSharedAssetLocationToken.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/assets/shared/location/${this.configuration.encodeParam({name: \"token\", value: token, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AssetSharedLocationTokenResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing SIM card\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateSimCard(id: string, request: SimCardUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SimCardResponse>;\n    public updateSimCard(id: string, request: SimCardUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SimCardResponse>>;\n    public updateSimCard(id: string, request: SimCardUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SimCardResponse>>;\n    public updateSimCard(id: string, request: SimCardUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateSimCard.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateSimCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/simcards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SimCardResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing sms gateway provider entity\n     * @param id The UUID of the sms gateway provider\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateSmsGatewayProvider(id: string, request: SmsGatewayProviderUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderResponse>;\n    public updateSmsGatewayProvider(id: string, request: SmsGatewayProviderUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderResponse>>;\n    public updateSmsGatewayProvider(id: string, request: SmsGatewayProviderUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderResponse>>;\n    public updateSmsGatewayProvider(id: string, request: SmsGatewayProviderUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateSmsGatewayProvider.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateSmsGatewayProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SmsGatewayProviderResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing ssl certificate entity\n     * @param id The UUID of the ssl certificate\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateSslCertificate(id: string, request: SslCertificateUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateResponse>;\n    public updateSslCertificate(id: string, request: SslCertificateUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateResponse>>;\n    public updateSslCertificate(id: string, request: SslCertificateUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateResponse>>;\n    public updateSslCertificate(id: string, request: SslCertificateUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateSslCertificate.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SslCertificateResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Theme entity\n     * @param id The UUID of the Theme\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateTheme(id: string, request: ThemeUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThemeResponse>;\n    public updateTheme(id: string, request: ThemeUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThemeResponse>>;\n    public updateTheme(id: string, request: ThemeUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThemeResponse>>;\n    public updateTheme(id: string, request: ThemeUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateTheme.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateTheme.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ThemeResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing zone\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateZone(id: string, request: ZoneUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneResponse>;\n    public updateZone(id: string, request: ZoneUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneResponse>>;\n    public updateZone(id: string, request: ZoneUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneResponse>>;\n    public updateZone(id: string, request: ZoneUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateZone.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateZone.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zones/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Zone Group\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateZoneGroup(id: string, request: ZoneGroupUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupResponse>;\n    public updateZoneGroup(id: string, request: ZoneGroupUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupResponse>>;\n    public updateZoneGroup(id: string, request: ZoneGroupUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupResponse>>;\n    public updateZoneGroup(id: string, request: ZoneGroupUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateZoneGroup.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateZoneGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneGroupResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Validates the ssl certificate and all prerequisites\n     * @param id The UUID of the ssl certificate\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public validateSslCertificate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateValidationResponse>;\n    public validateSslCertificate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateValidationResponse>>;\n    public validateSslCertificate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateValidationResponse>>;\n    public validateSslCertificate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling validateSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/validate`;\n        return this.httpClient.request<SslCertificateValidationResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ExportTaskCreateRequest } from '../model/exportTaskCreateRequest';\n// @ts-ignore\nimport { ExportTaskListResponse } from '../model/exportTaskListResponse';\n// @ts-ignore\nimport { ExportTaskResponse } from '../model/exportTaskResponse';\n// @ts-ignore\nimport { ExportTaskUpdateRequest } from '../model/exportTaskUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ExportTasksService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new export task entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createExportTask(request: ExportTaskCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ExportTaskResponse>;\n    public createExportTask(request: ExportTaskCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ExportTaskResponse>>;\n    public createExportTask(request: ExportTaskCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ExportTaskResponse>>;\n    public createExportTask(request: ExportTaskCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createExportTask.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/exporttasks`;\n        return this.httpClient.request<ExportTaskResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns export task details for the specified id\n     * @param id The UUID of the export task\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getExportTask(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ExportTaskResponse>;\n    public getExportTask(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ExportTaskResponse>>;\n    public getExportTask(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ExportTaskResponse>>;\n    public getExportTask(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getExportTask.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/exporttasks/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ExportTaskResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of export tasks for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listExportTasks(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ExportTaskListResponse>;\n    public listExportTasks(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ExportTaskListResponse>>;\n    public listExportTasks(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ExportTaskListResponse>>;\n    public listExportTasks(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listExportTasks.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/exporttasks`;\n        return this.httpClient.request<ExportTaskListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing export task entity\n     * @param id The UUID of the export task\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateExportTask(id: string, request: ExportTaskUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ExportTaskResponse>;\n    public updateExportTask(id: string, request: ExportTaskUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ExportTaskResponse>>;\n    public updateExportTask(id: string, request: ExportTaskUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ExportTaskResponse>>;\n    public updateExportTask(id: string, request: ExportTaskUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateExportTask.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateExportTask.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/exporttasks/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ExportTaskResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AuditEventFeedResponse } from '../model/auditEventFeedResponse';\n// @ts-ignore\nimport { EventCommentRequest } from '../model/eventCommentRequest';\n// @ts-ignore\nimport { EventFeedResponse } from '../model/eventFeedResponse';\n// @ts-ignore\nimport { EventResponse } from '../model/eventResponse';\n// @ts-ignore\nimport { ForbiddenError } from '../model/forbiddenError';\n// @ts-ignore\nimport { NotificationFeedResponse } from '../model/notificationFeedResponse';\n// @ts-ignore\nimport { TelemetryFeedResponse } from '../model/telemetryFeedResponse';\n// @ts-ignore\nimport { TooManyRequestsError } from '../model/tooManyRequestsError';\n// @ts-ignore\nimport { TripFeedResponse } from '../model/tripFeedResponse';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FeedsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Acknowlege an alert.\n     * @param client The client id you are requesting data for\n     * @param alert The alert id you wish to acknowledge.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public acknowledgeAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventResponse>;\n    public acknowledgeAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventResponse>>;\n    public acknowledgeAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventResponse>>;\n    public acknowledgeAlert(client: string, alert: string, request: EventCommentRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling acknowledgeAlert.');\n        }\n        if (alert === null || alert === undefined) {\n            throw new Error('Required parameter alert was null or undefined when calling acknowledgeAlert.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling acknowledgeAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/alerts/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/acknowledge/${this.configuration.encodeParam({name: \"alert\", value: alert, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add a comment to an alert.\n     * @param client The client id you are requesting data for\n     * @param alert The alert id you wish to comment on.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public commentAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventResponse>;\n    public commentAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventResponse>>;\n    public commentAlert(client: string, alert: string, request: EventCommentRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventResponse>>;\n    public commentAlert(client: string, alert: string, request: EventCommentRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling commentAlert.');\n        }\n        if (alert === null || alert === undefined) {\n            throw new Error('Required parameter alert was null or undefined when calling commentAlert.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling commentAlert.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/alerts/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/comment/${this.configuration.encodeParam({name: \"alert\", value: alert, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve an alert feed for the specified asset.\n     * @param client The client id you are requesting data for\n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value. This function may return slightly more results than requested.\n     * @param asset Filter alerts for this asset only.\n     * @param alert Filter alerts for this alert only.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAlertFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, alert?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventFeedResponse>;\n    public getAlertFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, alert?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventFeedResponse>>;\n    public getAlertFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, alert?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventFeedResponse>>;\n    public getAlertFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, alert?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling getAlertFeed.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getAlertFeed.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getAlertFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (asset !== undefined && asset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>asset, 'asset');\n        }\n        if (alert !== undefined && alert !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>alert, 'alert');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/alerts/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve an audit log feed for the specified client and entity.\n     * @param company The client, vendor or distributor id you are requesting data for\n     * @param entity \n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAuditFeedForEntity(company: string, entity: string, sequence: number, direction: 'forward' | 'backward', limit: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AuditEventFeedResponse>;\n    public getAuditFeedForEntity(company: string, entity: string, sequence: number, direction: 'forward' | 'backward', limit: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AuditEventFeedResponse>>;\n    public getAuditFeedForEntity(company: string, entity: string, sequence: number, direction: 'forward' | 'backward', limit: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AuditEventFeedResponse>>;\n    public getAuditFeedForEntity(company: string, entity: string, sequence: number, direction: 'forward' | 'backward', limit: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (company === null || company === undefined) {\n            throw new Error('Required parameter company was null or undefined when calling getAuditFeedForEntity.');\n        }\n        if (entity === null || entity === undefined) {\n            throw new Error('Required parameter entity was null or undefined when calling getAuditFeedForEntity.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getAuditFeedForEntity.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getAuditFeedForEntity.');\n        }\n        if (limit === null || limit === undefined) {\n            throw new Error('Required parameter limit was null or undefined when calling getAuditFeedForEntity.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/audit/${this.configuration.encodeParam({name: \"company\", value: company, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/entity/${this.configuration.encodeParam({name: \"entity\", value: entity, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AuditEventFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve an event feed for the specified asset.\n     * @param client The client id you are requesting data for\n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value.\n     * @param asset Filter events for this asset only.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getEventFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventFeedResponse>;\n    public getEventFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventFeedResponse>>;\n    public getEventFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventFeedResponse>>;\n    public getEventFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling getEventFeed.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getEventFeed.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getEventFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (asset !== undefined && asset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>asset, 'asset');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/events/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the current state for all assets for the specified client.\n     * @param client The client id you\\&#39;re requesting data for.\n     * @param sequence The sequence to continue from.\n     * @param offset \n     * @param limit Limit the number of results to this value.\n     * @param sort \n     * @param filter \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getLocationFeed(client: string, sequence: number, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TelemetryFeedResponse>;\n    public getLocationFeed(client: string, sequence: number, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TelemetryFeedResponse>>;\n    public getLocationFeed(client: string, sequence: number, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TelemetryFeedResponse>>;\n    public getLocationFeed(client: string, sequence: number, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling getLocationFeed.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getLocationFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/location/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TelemetryFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the notification feed for the current user.\n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getNotificationFeed(sequence: number, direction: 'forward' | 'backward', limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<NotificationFeedResponse>;\n    public getNotificationFeed(sequence: number, direction: 'forward' | 'backward', limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<NotificationFeedResponse>>;\n    public getNotificationFeed(sequence: number, direction: 'forward' | 'backward', limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<NotificationFeedResponse>>;\n    public getNotificationFeed(sequence: number, direction: 'forward' | 'backward', limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getNotificationFeed.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getNotificationFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/notifications`;\n        return this.httpClient.request<NotificationFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a trip feed for the specified asset.\n     * @param client The client id you are requesting data for\n     * @param sequence The sequence to continue from.\n     * @param direction The direction to run the feed in.\n     * @param limit Limit the number of results to this value.\n     * @param asset \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTripFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TripFeedResponse>;\n    public getTripFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TripFeedResponse>>;\n    public getTripFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TripFeedResponse>>;\n    public getTripFeed(client: string, sequence: number, direction: 'forward' | 'backward', limit?: number, asset?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling getTripFeed.');\n        }\n        if (sequence === null || sequence === undefined) {\n            throw new Error('Required parameter sequence was null or undefined when calling getTripFeed.');\n        }\n        if (direction === null || direction === undefined) {\n            throw new Error('Required parameter direction was null or undefined when calling getTripFeed.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (sequence !== undefined && sequence !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sequence, 'sequence');\n        }\n        if (direction !== undefined && direction !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>direction, 'direction');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (asset !== undefined && asset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>asset, 'asset');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/feeds/trips/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TripFeedResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { FuelCardCreateRequest } from '../model/fuelCardCreateRequest';\n// @ts-ignore\nimport { FuelCardListResponse } from '../model/fuelCardListResponse';\n// @ts-ignore\nimport { FuelCardResponse } from '../model/fuelCardResponse';\n// @ts-ignore\nimport { FuelCardUpdateRequest } from '../model/fuelCardUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FuelCardsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new fuel card\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createFuelCard(request: FuelCardCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FuelCardResponse>;\n    public createFuelCard(request: FuelCardCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FuelCardResponse>>;\n    public createFuelCard(request: FuelCardCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FuelCardResponse>>;\n    public createFuelCard(request: FuelCardCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createFuelCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/fuelcards`;\n        return this.httpClient.request<FuelCardResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns fuel card details for the specified id\n     * @param id The UUID of the fuel card\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getFuelCard(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FuelCardResponse>;\n    public getFuelCard(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FuelCardResponse>>;\n    public getFuelCard(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FuelCardResponse>>;\n    public getFuelCard(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getFuelCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/fuelcards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<FuelCardResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of fuel cards for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listFuelCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FuelCardListResponse>;\n    public listFuelCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FuelCardListResponse>>;\n    public listFuelCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FuelCardListResponse>>;\n    public listFuelCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listFuelCards.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/fuelcards`;\n        return this.httpClient.request<FuelCardListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing fuel card\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateFuelCard(id: string, request: FuelCardUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<FuelCardResponse>;\n    public updateFuelCard(id: string, request: FuelCardUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<FuelCardResponse>>;\n    public updateFuelCard(id: string, request: FuelCardUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<FuelCardResponse>>;\n    public updateFuelCard(id: string, request: FuelCardUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateFuelCard.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateFuelCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/fuelcards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<FuelCardResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { GeoLockProfileCreateRequest } from '../model/geoLockProfileCreateRequest';\n// @ts-ignore\nimport { GeoLockProfileListResponse } from '../model/geoLockProfileListResponse';\n// @ts-ignore\nimport { GeoLockProfileResponse } from '../model/geoLockProfileResponse';\n// @ts-ignore\nimport { GeoLockProfileUpdateRequest } from '../model/geoLockProfileUpdateRequest';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class GeoLockProfilesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new GeoLock Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createGeoLockProfile(request: GeoLockProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<GeoLockProfileResponse>;\n    public createGeoLockProfile(request: GeoLockProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<GeoLockProfileResponse>>;\n    public createGeoLockProfile(request: GeoLockProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<GeoLockProfileResponse>>;\n    public createGeoLockProfile(request: GeoLockProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createGeoLockProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/geolockprofiles`;\n        return this.httpClient.request<GeoLockProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns GeoLock profile details for the specified id\n     * @param id The UUID of the GeoLock profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getGeoLockProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<GeoLockProfileResponse>;\n    public getGeoLockProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<GeoLockProfileResponse>>;\n    public getGeoLockProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<GeoLockProfileResponse>>;\n    public getGeoLockProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getGeoLockProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/geolockprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<GeoLockProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of GeoLock profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listGeoLockProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<GeoLockProfileListResponse>;\n    public listGeoLockProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<GeoLockProfileListResponse>>;\n    public listGeoLockProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<GeoLockProfileListResponse>>;\n    public listGeoLockProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listGeoLockProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/geolockprofiles`;\n        return this.httpClient.request<GeoLockProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing GeoLock Profile entity\n     * @param id The UUID of the GeoLock Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateGeoLockProfile(id: string, request: GeoLockProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<GeoLockProfileResponse>;\n    public updateGeoLockProfile(id: string, request: GeoLockProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<GeoLockProfileResponse>>;\n    public updateGeoLockProfile(id: string, request: GeoLockProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<GeoLockProfileResponse>>;\n    public updateGeoLockProfile(id: string, request: GeoLockProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateGeoLockProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateGeoLockProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/geolockprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<GeoLockProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ForbiddenError } from '../model/forbiddenError';\n// @ts-ignore\nimport { HealthIssueListResponse } from '../model/healthIssueListResponse';\n// @ts-ignore\nimport { HealthIssueResponse } from '../model/healthIssueResponse';\n// @ts-ignore\nimport { HealthIssueUpdateRequest } from '../model/healthIssueUpdateRequest';\n// @ts-ignore\nimport { NotFoundError } from '../model/notFoundError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class HealthService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Returns a health issue for the specified id\n     * @param id The UUID of the health issue\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIssue(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HealthIssueResponse>;\n    public getIssue(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<HealthIssueResponse>>;\n    public getIssue(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<HealthIssueResponse>>;\n    public getIssue(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getIssue.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/health/issues/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<HealthIssueResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of health issues.\n     * @param owner The owner id you are requesting data for\n     * @param targetId The id of the entity on which to filter issues for\n     * @param resolved Filter issues by their resolved status\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listIssues(owner?: string, targetId?: string, resolved?: boolean, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HealthIssueListResponse>;\n    public listIssues(owner?: string, targetId?: string, resolved?: boolean, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<HealthIssueListResponse>>;\n    public listIssues(owner?: string, targetId?: string, resolved?: boolean, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<HealthIssueListResponse>>;\n    public listIssues(owner?: string, targetId?: string, resolved?: boolean, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (targetId !== undefined && targetId !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>targetId, 'targetId');\n        }\n        if (resolved !== undefined && resolved !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>resolved, 'resolved');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/health/issues`;\n        return this.httpClient.request<HealthIssueListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a health issue for the specified id\n     * @param id The UUID of the health issue\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateIssue(id: string, request: HealthIssueUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HealthIssueResponse>;\n    public updateIssue(id: string, request: HealthIssueUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<HealthIssueResponse>>;\n    public updateIssue(id: string, request: HealthIssueUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<HealthIssueResponse>>;\n    public updateIssue(id: string, request: HealthIssueUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateIssue.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateIssue.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/health/issues/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<HealthIssueResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { BadRequestError } from '../model/badRequestError';\n// @ts-ignore\nimport { CompletedReportDataRequest } from '../model/completedReportDataRequest';\n// @ts-ignore\nimport { CompletedReportListResponse } from '../model/completedReportListResponse';\n// @ts-ignore\nimport { CompletedReportRequest } from '../model/completedReportRequest';\n// @ts-ignore\nimport { CompletedReportResponse } from '../model/completedReportResponse';\n// @ts-ignore\nimport { CompletedReportUpdateRequest } from '../model/completedReportUpdateRequest';\n// @ts-ignore\nimport { EventListResponse } from '../model/eventListResponse';\n// @ts-ignore\nimport { ForbiddenError } from '../model/forbiddenError';\n// @ts-ignore\nimport { LogResponse } from '../model/logResponse';\n// @ts-ignore\nimport { NotFoundError } from '../model/notFoundError';\n// @ts-ignore\nimport { TelemetryListResponse } from '../model/telemetryListResponse';\n// @ts-ignore\nimport { TooManyRequestsError } from '../model/tooManyRequestsError';\n// @ts-ignore\nimport { TripLabelRequest } from '../model/tripLabelRequest';\n// @ts-ignore\nimport { TripListResponse } from '../model/tripListResponse';\n// @ts-ignore\nimport { TripResponse } from '../model/tripResponse';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class HistoryService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Adds one or more labels to a trip.\n     * @param asset The asset id for the trip\n     * @param date The trip start date (in ISO format)\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public addTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TripResponse>;\n    public addTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TripResponse>>;\n    public addTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TripResponse>>;\n    public addTripLabels(asset: string, date: string, request: TripLabelRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling addTripLabels.');\n        }\n        if (date === null || date === undefined) {\n            throw new Error('Required parameter date was null or undefined when calling addTripLabels.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling addTripLabels.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/trips/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"date\", value: date, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/labels`;\n        return this.httpClient.request<TripResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve alert records between two dates.\n     * @param id The client, alert or asset id you are requesting data for\n     * @param start The start date (in ISO format)\n     * @param end The end date (in ISO format)\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAlertHistory(id: string, start: string, end: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventListResponse>;\n    public getAlertHistory(id: string, start: string, end: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventListResponse>>;\n    public getAlertHistory(id: string, start: string, end: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventListResponse>>;\n    public getAlertHistory(id: string, start: string, end: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAlertHistory.');\n        }\n        if (start === null || start === undefined) {\n            throw new Error('Required parameter start was null or undefined when calling getAlertHistory.');\n        }\n        if (end === null || end === undefined) {\n            throw new Error('Required parameter end was null or undefined when calling getAlertHistory.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/alerts/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompletedReportResponse>;\n    public getCompletedReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompletedReportResponse>>;\n    public getCompletedReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompletedReportResponse>>;\n    public getCompletedReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompletedReportResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the binary data for a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param filename The filename and type your want the to be returned as, can be \\&#39;.pdf\\&#39;, \\&#39;.csv\\&#39; or \\&#39;.json\\&#39;\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReportData(id: string, filename: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getCompletedReportData(id: string, filename: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getCompletedReportData(id: string, filename: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getCompletedReportData(id: string, filename: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReportData.');\n        }\n        if (filename === null || filename === undefined) {\n            throw new Error('Required parameter filename was null or undefined when calling getCompletedReportData.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"filename\", value: filename, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the binary data for a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param filename The filename and type your want the to be returned as, can be \\&#39;.pdf\\&#39;, \\&#39;.csv\\&#39; or \\&#39;.json\\&#39;\n     * @param outputFormat \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReportDataStream(id: string, filename: string, outputFormat?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public getCompletedReportDataStream(id: string, filename: string, outputFormat?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public getCompletedReportDataStream(id: string, filename: string, outputFormat?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public getCompletedReportDataStream(id: string, filename: string, outputFormat?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReportDataStream.');\n        }\n        if (filename === null || filename === undefined) {\n            throw new Error('Required parameter filename was null or undefined when calling getCompletedReportDataStream.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (outputFormat !== undefined && outputFormat !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>outputFormat, 'outputFormat');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/stream/${this.configuration.encodeParam({name: \"filename\", value: filename, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<any>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the binary data for a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param filename The filename and type your want the data to be returned as, can be \\&#39;.pdf\\&#39;, \\&#39;.csv\\&#39; or \\&#39;.json\\&#39;\n     * @param options \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReportDataWithOptions(id: string, filename: string, options: CompletedReportDataRequest, observe?: 'body', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<{ [key: string]: any; }>;\n    public getCompletedReportDataWithOptions(id: string, filename: string, options: CompletedReportDataRequest, observe?: 'response', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<{ [key: string]: any; }>>;\n    public getCompletedReportDataWithOptions(id: string, filename: string, options: CompletedReportDataRequest, observe?: 'events', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<{ [key: string]: any; }>>;\n    public getCompletedReportDataWithOptions(id: string, filename: string, options: CompletedReportDataRequest, observe: any = 'body', reportProgress: boolean = false, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReportDataWithOptions.');\n        }\n        if (filename === null || filename === undefined) {\n            throw new Error('Required parameter filename was null or undefined when calling getCompletedReportDataWithOptions.');\n        }\n        if (options === null || options === undefined) {\n            throw new Error('Required parameter options was null or undefined when calling getCompletedReportDataWithOptions.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = httpOptions && httpOptions.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = httpOptions && httpOptions.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = httpOptions && httpOptions.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"filename\", value: filename, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<{ [key: string]: any; }>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: options,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param options \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReportWithOptions(id: string, options: CompletedReportRequest, observe?: 'body', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompletedReportResponse>;\n    public getCompletedReportWithOptions(id: string, options: CompletedReportRequest, observe?: 'response', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompletedReportResponse>>;\n    public getCompletedReportWithOptions(id: string, options: CompletedReportRequest, observe?: 'events', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompletedReportResponse>>;\n    public getCompletedReportWithOptions(id: string, options: CompletedReportRequest, observe: any = 'body', reportProgress: boolean = false, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReportWithOptions.');\n        }\n        if (options === null || options === undefined) {\n            throw new Error('Required parameter options was null or undefined when calling getCompletedReportWithOptions.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = httpOptions && httpOptions.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = httpOptions && httpOptions.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = httpOptions && httpOptions.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompletedReportResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: options,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve event records between two dates.\n     * @param id The asset id you are requesting data for\n     * @param start The start date (in ISO format)\n     * @param end The end date (in ISO format)\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getEventHistory(id: string, start: string, end: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventListResponse>;\n    public getEventHistory(id: string, start: string, end: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventListResponse>>;\n    public getEventHistory(id: string, start: string, end: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventListResponse>>;\n    public getEventHistory(id: string, start: string, end: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getEventHistory.');\n        }\n        if (start === null || start === undefined) {\n            throw new Error('Required parameter start was null or undefined when calling getEventHistory.');\n        }\n        if (end === null || end === undefined) {\n            throw new Error('Required parameter end was null or undefined when calling getEventHistory.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/events/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Restricted route, not available for general usage.\n     * @param entityType \n     * @param id \n     * @param start \n     * @param end \n     * @param limit \n     * @param levels \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getLogHistoryForEntity(entityType: string, id: string, start?: string, end?: string, limit?: number, levels?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LogResponse>;\n    public getLogHistoryForEntity(entityType: string, id: string, start?: string, end?: string, limit?: number, levels?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LogResponse>>;\n    public getLogHistoryForEntity(entityType: string, id: string, start?: string, end?: string, limit?: number, levels?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LogResponse>>;\n    public getLogHistoryForEntity(entityType: string, id: string, start?: string, end?: string, limit?: number, levels?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (entityType === null || entityType === undefined) {\n            throw new Error('Required parameter entityType was null or undefined when calling getLogHistoryForEntity.');\n        }\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getLogHistoryForEntity.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (levels !== undefined && levels !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>levels, 'levels');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/logs/${this.configuration.encodeParam({name: \"entityType\", value: entityType, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<LogResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve telemetry records between two dates.\n     * @param id The asset id you are requesting data for\n     * @param start The start date (in ISO format)\n     * @param end The end date (in ISO format)\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTelemetryHistory(id: string, start: string, end: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TelemetryListResponse>;\n    public getTelemetryHistory(id: string, start: string, end: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TelemetryListResponse>>;\n    public getTelemetryHistory(id: string, start: string, end: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TelemetryListResponse>>;\n    public getTelemetryHistory(id: string, start: string, end: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getTelemetryHistory.');\n        }\n        if (start === null || start === undefined) {\n            throw new Error('Required parameter start was null or undefined when calling getTelemetryHistory.');\n        }\n        if (end === null || end === undefined) {\n            throw new Error('Required parameter end was null or undefined when calling getTelemetryHistory.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/telemetry/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TelemetryListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve trip records between two dates.\n     * @param id The asset id you are requesting data for\n     * @param start The start date (in ISO format)\n     * @param end The end date (in ISO format)\n     * @param date Use the date parameter to find the specific trip that contains this date (start and end are ignored)\n     * @param limit Limit the number of results to this value.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTripHistory(id: string, start?: string, end?: string, date?: string, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TripListResponse>;\n    public getTripHistory(id: string, start?: string, end?: string, date?: string, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TripListResponse>>;\n    public getTripHistory(id: string, start?: string, end?: string, date?: string, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TripListResponse>>;\n    public getTripHistory(id: string, start?: string, end?: string, date?: string, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getTripHistory.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (date !== undefined && date !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>date, 'date');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/trips/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TripListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of queued reports for a specified owner.\n     * @param start \n     * @param end \n     * @param client The client id you are requesting reports for\n     * @param user \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listCompletedReports(start: string, end: string, client?: string, user?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompletedReportListResponse>;\n    public listCompletedReports(start: string, end: string, client?: string, user?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompletedReportListResponse>>;\n    public listCompletedReports(start: string, end: string, client?: string, user?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompletedReportListResponse>>;\n    public listCompletedReports(start: string, end: string, client?: string, user?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (start === null || start === undefined) {\n            throw new Error('Required parameter start was null or undefined when calling listCompletedReports.');\n        }\n        if (end === null || end === undefined) {\n            throw new Error('Required parameter end was null or undefined when calling listCompletedReports.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (client !== undefined && client !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>client, 'client');\n        }\n        if (user !== undefined && user !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>user, 'user');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history`;\n        return this.httpClient.request<CompletedReportListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Adds one or more labels to a trip.\n     * @param asset The asset id for the trip\n     * @param date The trip start date (in ISO format)\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public removeTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TripResponse>;\n    public removeTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TripResponse>>;\n    public removeTripLabels(asset: string, date: string, request: TripLabelRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TripResponse>>;\n    public removeTripLabels(asset: string, date: string, request: TripLabelRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling removeTripLabels.');\n        }\n        if (date === null || date === undefined) {\n            throw new Error('Required parameter date was null or undefined when calling removeTripLabels.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling removeTripLabels.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/data/history/trips/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"date\", value: date, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/labels`;\n        return this.httpClient.request<TripResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a report by it\\&#39;s ID.\n     * @param id The UUID of the report to update\n     * @param report The data with which to update an existing report.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCompletedReport(id: string, report: CompletedReportUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompletedReportResponse>;\n    public updateCompletedReport(id: string, report: CompletedReportUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompletedReportResponse>>;\n    public updateCompletedReport(id: string, report: CompletedReportUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompletedReportResponse>>;\n    public updateCompletedReport(id: string, report: CompletedReportUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateCompletedReport.');\n        }\n        if (report === null || report === undefined) {\n            throw new Error('Required parameter report was null or undefined when calling updateCompletedReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompletedReportResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: report,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { IoTypeCreateRequest } from '../model/ioTypeCreateRequest';\n// @ts-ignore\nimport { IoTypeListResponse } from '../model/ioTypeListResponse';\n// @ts-ignore\nimport { IoTypeResponse } from '../model/ioTypeResponse';\n// @ts-ignore\nimport { IoTypeUpdateRequest } from '../model/ioTypeUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class IoTypesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new I/O type entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createIoType(request: IoTypeCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IoTypeResponse>;\n    public createIoType(request: IoTypeCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IoTypeResponse>>;\n    public createIoType(request: IoTypeCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IoTypeResponse>>;\n    public createIoType(request: IoTypeCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createIoType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/iotypes`;\n        return this.httpClient.request<IoTypeResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns I/O type details for the specified id\n     * @param id The UUID of the I/O type\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIoType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IoTypeResponse>;\n    public getIoType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IoTypeResponse>>;\n    public getIoType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IoTypeResponse>>;\n    public getIoType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getIoType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/iotypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<IoTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of I/O types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listIoTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IoTypeListResponse>;\n    public listIoTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IoTypeListResponse>>;\n    public listIoTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IoTypeListResponse>>;\n    public listIoTypes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listIoTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/iotypes`;\n        return this.httpClient.request<IoTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing I/O type entity\n     * @param id The UUID of the I/O type\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateIoType(id: string, request: IoTypeUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<IoTypeResponse>;\n    public updateIoType(id: string, request: IoTypeUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<IoTypeResponse>>;\n    public updateIoType(id: string, request: IoTypeUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<IoTypeResponse>>;\n    public updateIoType(id: string, request: IoTypeUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateIoType.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateIoType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/iotypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<IoTypeResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { LabelCreateRequest } from '../model/labelCreateRequest';\n// @ts-ignore\nimport { LabelListResponse } from '../model/labelListResponse';\n// @ts-ignore\nimport { LabelResponse } from '../model/labelResponse';\n// @ts-ignore\nimport { LabelUpdateRequest } from '../model/labelUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LabelsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new I/O type entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createLabel(request: LabelCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LabelResponse>;\n    public createLabel(request: LabelCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LabelResponse>>;\n    public createLabel(request: LabelCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LabelResponse>>;\n    public createLabel(request: LabelCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createLabel.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/labels`;\n        return this.httpClient.request<LabelResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns I/O type details for the specified id\n     * @param id The UUID of the I/O type\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getLabel(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LabelResponse>;\n    public getLabel(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LabelResponse>>;\n    public getLabel(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LabelResponse>>;\n    public getLabel(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getLabel.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/labels/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<LabelResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of I/O types for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listLabels(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LabelListResponse>;\n    public listLabels(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LabelListResponse>>;\n    public listLabels(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LabelListResponse>>;\n    public listLabels(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listLabels.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/labels`;\n        return this.httpClient.request<LabelListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing I/O type entity\n     * @param id The UUID of the I/O type\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateLabel(id: string, request: LabelUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<LabelResponse>;\n    public updateLabel(id: string, request: LabelUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<LabelResponse>>;\n    public updateLabel(id: string, request: LabelUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<LabelResponse>>;\n    public updateLabel(id: string, request: LabelUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateLabel.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateLabel.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/labels/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<LabelResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LookupsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Retrieve a list of lookups for a specified entity.\n     * @param entity \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getLookups(entity: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<{ [key: string]: { [key: string]: any; }; }>;\n    public getLookups(entity: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<{ [key: string]: { [key: string]: any; }; }>>;\n    public getLookups(entity: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<{ [key: string]: { [key: string]: any; }; }>>;\n    public getLookups(entity: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (entity === null || entity === undefined) {\n            throw new Error('Required parameter entity was null or undefined when calling getLookups.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/lookups/${this.configuration.encodeParam({name: \"entity\", value: entity, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<{ [key: string]: { [key: string]: any; }; }>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ForwardGeocodeResponse } from '../model/forwardGeocodeResponse';\n// @ts-ignore\nimport { MapRouteResponse } from '../model/mapRouteResponse';\n// @ts-ignore\nimport { ReverseGeocodeResponse } from '../model/reverseGeocodeResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MapService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Perform a free text search against map addresses and zones.\n     * @param client The client UUID for whom geocoding is being done\n     * @param query The free text query you\\&#39;d like to search for\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public geocodeForward(client: string, query: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ForwardGeocodeResponse>;\n    public geocodeForward(client: string, query: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ForwardGeocodeResponse>>;\n    public geocodeForward(client: string, query: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ForwardGeocodeResponse>>;\n    public geocodeForward(client: string, query: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling geocodeForward.');\n        }\n        if (query === null || query === undefined) {\n            throw new Error('Required parameter query was null or undefined when calling geocodeForward.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (query !== undefined && query !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>query, 'query');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/map/geocode/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/forward`;\n        return this.httpClient.request<ForwardGeocodeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Perform a reverse geocode text search against map addresses.\n     * @param client The client UUID for whom geocoding is being done\n     * @param lat The latitude to search for\n     * @param lon The longitude to search for\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public geocodeReverse(client: string, lat: number, lon: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReverseGeocodeResponse>;\n    public geocodeReverse(client: string, lat: number, lon: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReverseGeocodeResponse>>;\n    public geocodeReverse(client: string, lat: number, lon: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReverseGeocodeResponse>>;\n    public geocodeReverse(client: string, lat: number, lon: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling geocodeReverse.');\n        }\n        if (lat === null || lat === undefined) {\n            throw new Error('Required parameter lat was null or undefined when calling geocodeReverse.');\n        }\n        if (lon === null || lon === undefined) {\n            throw new Error('Required parameter lon was null or undefined when calling geocodeReverse.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (lat !== undefined && lat !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>lat, 'lat');\n        }\n        if (lon !== undefined && lon !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>lon, 'lon');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/map/geocode/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/reverse`;\n        return this.httpClient.request<ReverseGeocodeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Route between two points on a map.\n     * @param client The client UUID for whom geocoding is being done\n     * @param strategy The routing strategy to employ while calculating the route, in the format &#x60;fastest,longest&#x60;\n     * @param coords The coordinate pairs to route between in the format &#x60;[lon,lat],[lon,lat]&#x60;\n     * @param src \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getRoute(client: string, strategy: string, coords: string, src?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MapRouteResponse>;\n    public getRoute(client: string, strategy: string, coords: string, src?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MapRouteResponse>>;\n    public getRoute(client: string, strategy: string, coords: string, src?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MapRouteResponse>>;\n    public getRoute(client: string, strategy: string, coords: string, src?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (client === null || client === undefined) {\n            throw new Error('Required parameter client was null or undefined when calling getRoute.');\n        }\n        if (strategy === null || strategy === undefined) {\n            throw new Error('Required parameter strategy was null or undefined when calling getRoute.');\n        }\n        if (coords === null || coords === undefined) {\n            throw new Error('Required parameter coords was null or undefined when calling getRoute.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (strategy !== undefined && strategy !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>strategy, 'strategy');\n        }\n        if (coords !== undefined && coords !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>coords, 'coords');\n        }\n        if (src !== undefined && src !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>src, 'src');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/map/routing/${this.configuration.encodeParam({name: \"client\", value: client, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/route`;\n        return this.httpClient.request<MapRouteResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { MapSetListResponse } from '../model/mapSetListResponse';\n// @ts-ignore\nimport { MapSetResponse } from '../model/mapSetResponse';\n// @ts-ignore\nimport { MapsetCreateRequest } from '../model/mapsetCreateRequest';\n// @ts-ignore\nimport { MapsetUpdateRequest } from '../model/mapsetUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MapSetsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new map set entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createMapSet(request: MapsetCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MapSetResponse>;\n    public createMapSet(request: MapsetCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MapSetResponse>>;\n    public createMapSet(request: MapsetCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MapSetResponse>>;\n    public createMapSet(request: MapsetCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createMapSet.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/mapsets`;\n        return this.httpClient.request<MapSetResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a map set by it\\&#39;s ID.\n     * @param id The Map Set UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getMapSet(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MapSetResponse>;\n    public getMapSet(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MapSetResponse>>;\n    public getMapSet(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MapSetResponse>>;\n    public getMapSet(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getMapSet.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/mapsets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<MapSetResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of map sets for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listMapSets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MapSetListResponse>;\n    public listMapSets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MapSetListResponse>>;\n    public listMapSets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MapSetListResponse>>;\n    public listMapSets(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listMapSets.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/mapsets`;\n        return this.httpClient.request<MapSetListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing map set entity\n     * @param id The UUID of the mapset\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateMapSet(id: string, request: MapsetUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MapSetResponse>;\n    public updateMapSet(id: string, request: MapsetUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MapSetResponse>>;\n    public updateMapSet(id: string, request: MapsetUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MapSetResponse>>;\n    public updateMapSet(id: string, request: MapsetUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateMapSet.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateMapSet.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/mapsets/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<MapSetResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { EventResponse } from '../model/eventResponse';\n// @ts-ignore\nimport { MediaInfoListResponse } from '../model/mediaInfoListResponse';\n// @ts-ignore\nimport { MediaInfoResponse } from '../model/mediaInfoResponse';\n// @ts-ignore\nimport { MediaVideoEventCreateRequest } from '../model/mediaVideoEventCreateRequest';\n// @ts-ignore\nimport { MediaVideoEventUpdateRequest } from '../model/mediaVideoEventUpdateRequest';\n// @ts-ignore\nimport { VideoLiveStreamRequest } from '../model/videoLiveStreamRequest';\n// @ts-ignore\nimport { VideoLiveStreamResponse } from '../model/videoLiveStreamResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MediaService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Cancel a pending or queued media item.\n     * @param id The media ID you are canceling\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public cancelMedia(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MediaInfoResponse>;\n    public cancelMedia(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MediaInfoResponse>>;\n    public cancelMedia(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MediaInfoResponse>>;\n    public cancelMedia(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling cancelMedia.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/cancel`;\n        return this.httpClient.request<MediaInfoResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new video event for a specified date time.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createVideoEvent(request: MediaVideoEventCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventResponse>;\n    public createVideoEvent(request: MediaVideoEventCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventResponse>>;\n    public createVideoEvent(request: MediaVideoEventCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventResponse>>;\n    public createVideoEvent(request: MediaVideoEventCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createVideoEvent.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media/video/event`;\n        return this.httpClient.request<EventResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a media item media file\n     * @param id The media ID you are deleting\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteMediaFile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MediaInfoResponse>;\n    public deleteMediaFile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MediaInfoResponse>>;\n    public deleteMediaFile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MediaInfoResponse>>;\n    public deleteMediaFile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteMediaFile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/file`;\n        return this.httpClient.request<MediaInfoResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a media information item.\n     * @param id The media ID you are requesting data for\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getMedia(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MediaInfoResponse>;\n    public getMedia(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MediaInfoResponse>>;\n    public getMedia(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MediaInfoResponse>>;\n    public getMedia(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getMedia.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<MediaInfoResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a media item.\n     * @param asset The UUID of the asset you are requesting media for.\n     * @param filename The filename of the media item.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getMediaFile(asset: string, filename: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public getMediaFile(asset: string, filename: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public getMediaFile(asset: string, filename: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public getMediaFile(asset: string, filename: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling getMediaFile.');\n        }\n        if (filename === null || filename === undefined) {\n            throw new Error('Required parameter filename was null or undefined when calling getMediaFile.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (filename !== undefined && filename !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filename, 'filename');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/file`;\n        return this.httpClient.request<any>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns information for a media item.\n     * @param asset The UUID of the asset you are requesting media for.\n     * @param filename The filename of the media item.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getMediaInfo(asset: string, filename: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MediaInfoResponse>;\n    public getMediaInfo(asset: string, filename: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MediaInfoResponse>>;\n    public getMediaInfo(asset: string, filename: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MediaInfoResponse>>;\n    public getMediaInfo(asset: string, filename: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling getMediaInfo.');\n        }\n        if (filename === null || filename === undefined) {\n            throw new Error('Required parameter filename was null or undefined when calling getMediaInfo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (filename !== undefined && filename !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filename, 'filename');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/info`;\n        return this.httpClient.request<MediaInfoResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * [DEPRECATED] Use getMediaInfo instead\n     * @param owner \n     * @param asset \n     * @param filename \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getMediaInfoDeprecated(owner: string, asset: string, filename: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MediaInfoResponse>;\n    public getMediaInfoDeprecated(owner: string, asset: string, filename: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MediaInfoResponse>>;\n    public getMediaInfoDeprecated(owner: string, asset: string, filename: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MediaInfoResponse>>;\n    public getMediaInfoDeprecated(owner: string, asset: string, filename: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling getMediaInfoDeprecated.');\n        }\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling getMediaInfoDeprecated.');\n        }\n        if (filename === null || filename === undefined) {\n            throw new Error('Required parameter filename was null or undefined when calling getMediaInfoDeprecated.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media/info/${this.configuration.encodeParam({name: \"owner\", value: owner, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"filename\", value: filename, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<MediaInfoResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of media information items for the specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listMedia(owner: string, offset?: number, limit?: number, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MediaInfoListResponse>;\n    public listMedia(owner: string, offset?: number, limit?: number, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MediaInfoListResponse>>;\n    public listMedia(owner: string, offset?: number, limit?: number, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MediaInfoListResponse>>;\n    public listMedia(owner: string, offset?: number, limit?: number, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listMedia.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media`;\n        return this.httpClient.request<MediaInfoListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Requests a live stream endpoint for a video.\n     * @param asset The UUID of the asset you are requesting media for.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public startVideoLiveStream(asset: string, request: VideoLiveStreamRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VideoLiveStreamResponse>;\n    public startVideoLiveStream(asset: string, request: VideoLiveStreamRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VideoLiveStreamResponse>>;\n    public startVideoLiveStream(asset: string, request: VideoLiveStreamRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VideoLiveStreamResponse>>;\n    public startVideoLiveStream(asset: string, request: VideoLiveStreamRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (asset === null || asset === undefined) {\n            throw new Error('Required parameter asset was null or undefined when calling startVideoLiveStream.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling startVideoLiveStream.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media/${this.configuration.encodeParam({name: \"asset\", value: asset, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/livestream`;\n        return this.httpClient.request<VideoLiveStreamResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Request a video from a camera enabled device for a particular event.\n     * @param owner The owner id of the company that owns the event\n     * @param event The GUID of the event for which you wish to retrieve the video\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateVideoEvent(owner: string, event: string, request: MediaVideoEventUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EventResponse>;\n    public updateVideoEvent(owner: string, event: string, request: MediaVideoEventUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EventResponse>>;\n    public updateVideoEvent(owner: string, event: string, request: MediaVideoEventUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EventResponse>>;\n    public updateVideoEvent(owner: string, event: string, request: MediaVideoEventUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling updateVideoEvent.');\n        }\n        if (event === null || event === undefined) {\n            throw new Error('Required parameter event was null or undefined when calling updateVideoEvent.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateVideoEvent.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/media/video/event/${this.configuration.encodeParam({name: \"owner\", value: owner, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"event\", value: event, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<EventResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { SuccessResponse } from '../model/successResponse';\n// @ts-ignore\nimport { TestNotificationsRequest } from '../model/testNotificationsRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class NotificationsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Sends dummy notifications to the requesting user\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public testNotification(request: TestNotificationsRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SuccessResponse>;\n    public testNotification(request: TestNotificationsRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SuccessResponse>>;\n    public testNotification(request: TestNotificationsRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SuccessResponse>>;\n    public testNotification(request: TestNotificationsRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling testNotification.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/notifications/test`;\n        return this.httpClient.request<SuccessResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { OverspeedProfileCreateRequest } from '../model/overspeedProfileCreateRequest';\n// @ts-ignore\nimport { OverspeedProfileListResponse } from '../model/overspeedProfileListResponse';\n// @ts-ignore\nimport { OverspeedProfileResponse } from '../model/overspeedProfileResponse';\n// @ts-ignore\nimport { OverspeedProfileUpdateRequest } from '../model/overspeedProfileUpdateRequest';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class OverspeedProfilesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Overspeed Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createOverspeedProfile(request: OverspeedProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<OverspeedProfileResponse>;\n    public createOverspeedProfile(request: OverspeedProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OverspeedProfileResponse>>;\n    public createOverspeedProfile(request: OverspeedProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OverspeedProfileResponse>>;\n    public createOverspeedProfile(request: OverspeedProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createOverspeedProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/overspeedprofiles`;\n        return this.httpClient.request<OverspeedProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns overspeed profile details for the specified id\n     * @param id The UUID of the overspeed profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getOverspeedProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<OverspeedProfileResponse>;\n    public getOverspeedProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OverspeedProfileResponse>>;\n    public getOverspeedProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OverspeedProfileResponse>>;\n    public getOverspeedProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getOverspeedProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/overspeedprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<OverspeedProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of overspeed profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listOverspeedProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<OverspeedProfileListResponse>;\n    public listOverspeedProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OverspeedProfileListResponse>>;\n    public listOverspeedProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OverspeedProfileListResponse>>;\n    public listOverspeedProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listOverspeedProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/overspeedprofiles`;\n        return this.httpClient.request<OverspeedProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Overspeed Profile entity\n     * @param id The UUID of the Overspeed Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateOverspeedProfile(id: string, request: OverspeedProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<OverspeedProfileResponse>;\n    public updateOverspeedProfile(id: string, request: OverspeedProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OverspeedProfileResponse>>;\n    public updateOverspeedProfile(id: string, request: OverspeedProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OverspeedProfileResponse>>;\n    public updateOverspeedProfile(id: string, request: OverspeedProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateOverspeedProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateOverspeedProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/overspeedprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<OverspeedProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ForbiddenError } from '../model/forbiddenError';\n// @ts-ignore\nimport { NotFoundError } from '../model/notFoundError';\n// @ts-ignore\nimport { QueueReportRequest } from '../model/queueReportRequest';\n// @ts-ignore\nimport { QueuedReportListResponse } from '../model/queuedReportListResponse';\n// @ts-ignore\nimport { QueuedReportResponse } from '../model/queuedReportResponse';\n// @ts-ignore\nimport { TooManyRequestsError } from '../model/tooManyRequestsError';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class QueuesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Cancel a queued or running report\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public cancelReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<QueuedReportResponse>;\n    public cancelReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<QueuedReportResponse>>;\n    public cancelReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<QueuedReportResponse>>;\n    public cancelReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling cancelReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/queues/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<QueuedReportResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getQueuedReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<QueuedReportResponse>;\n    public getQueuedReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<QueuedReportResponse>>;\n    public getQueuedReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<QueuedReportResponse>>;\n    public getQueuedReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getQueuedReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/queues/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<QueuedReportResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of queued reports for a specified owner.\n     * @param client The client id you are requesting reports for\n     * @param user \n     * @param server An optional server identifier (will be inferred from client settings if possible)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listQueuedReports(client?: string, user?: string, server?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<QueuedReportListResponse>;\n    public listQueuedReports(client?: string, user?: string, server?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<QueuedReportListResponse>>;\n    public listQueuedReports(client?: string, user?: string, server?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<QueuedReportListResponse>>;\n    public listQueuedReports(client?: string, user?: string, server?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (client !== undefined && client !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>client, 'client');\n        }\n        if (user !== undefined && user !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>user, 'user');\n        }\n        if (server !== undefined && server !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>server, 'server');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/queues`;\n        return this.httpClient.request<QueuedReportListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Queue a new report\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public queueReport(request: QueueReportRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<QueuedReportResponse>;\n    public queueReport(request: QueueReportRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<QueuedReportResponse>>;\n    public queueReport(request: QueueReportRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<QueuedReportResponse>>;\n    public queueReport(request: QueueReportRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling queueReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/queues`;\n        return this.httpClient.request<QueuedReportResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RedirectService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Handles SSO redirects.\n     * @param id The redirect ID\n     * @param options \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public redirect(id: string, options?: string, observe?: 'body', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public redirect(id: string, options?: string, observe?: 'response', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public redirect(id: string, options?: string, observe?: 'events', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public redirect(id: string, options?: string, observe: any = 'body', reportProgress: boolean = false, httpOptions?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling redirect.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (id !== undefined && id !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>id, 'id');\n        }\n        if (options !== undefined && options !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>options, 'options');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = httpOptions && httpOptions.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = httpOptions && httpOptions.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = httpOptions && httpOptions.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/redirect`;\n        return this.httpClient.request<any>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ReminderCreateRequest } from '../model/reminderCreateRequest';\n// @ts-ignore\nimport { ReminderListResponse } from '../model/reminderListResponse';\n// @ts-ignore\nimport { ReminderResponse } from '../model/reminderResponse';\n// @ts-ignore\nimport { ReminderUpdateRequest } from '../model/reminderUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RemindersService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new reminder entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createReminder(request: ReminderCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderResponse>;\n    public createReminder(request: ReminderCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderResponse>>;\n    public createReminder(request: ReminderCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderResponse>>;\n    public createReminder(request: ReminderCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createReminder.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders`;\n        return this.httpClient.request<ReminderResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes an existing reminder entity\n     * @param id The reminder UUID.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteReminder(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderResponse>;\n    public deleteReminder(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderResponse>>;\n    public deleteReminder(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderResponse>>;\n    public deleteReminder(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteReminder.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReminderResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a reminder by it\\&#39;s ID.\n     * @param id The reminder UUID.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getReminder(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderResponse>;\n    public getReminder(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderResponse>>;\n    public getReminder(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderResponse>>;\n    public getReminder(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getReminder.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReminderResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of reminders for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param target The target entity you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listReminders(owner: string, target?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderListResponse>;\n    public listReminders(owner: string, target?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderListResponse>>;\n    public listReminders(owner: string, target?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderListResponse>>;\n    public listReminders(owner: string, target?: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listReminders.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (target !== undefined && target !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>target, 'target');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders`;\n        return this.httpClient.request<ReminderListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing reminder entity\n     * @param id The reminder UUID.\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateReminder(id: string, request: ReminderUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReminderResponse>;\n    public updateReminder(id: string, request: ReminderUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReminderResponse>>;\n    public updateReminder(id: string, request: ReminderUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReminderResponse>>;\n    public updateReminder(id: string, request: ReminderUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateReminder.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateReminder.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reminders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReminderResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ReportDefinitionListResponse } from '../model/reportDefinitionListResponse';\n// @ts-ignore\nimport { ReportDefinitionResponse } from '../model/reportDefinitionResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ReportDefinitionsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Retrieve a report definition by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getReportDefinition(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportDefinitionResponse>;\n    public getReportDefinition(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportDefinitionResponse>>;\n    public getReportDefinition(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportDefinitionResponse>>;\n    public getReportDefinition(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getReportDefinition.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reportdefinitions/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReportDefinitionResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of report definitions for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listReportDefinitions(owner: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportDefinitionListResponse>;\n    public listReportDefinitions(owner: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportDefinitionListResponse>>;\n    public listReportDefinitions(owner: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportDefinitionListResponse>>;\n    public listReportDefinitions(owner: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listReportDefinitions.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reportdefinitions`;\n        return this.httpClient.request<ReportDefinitionListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ReportTemplateCreateRequest } from '../model/reportTemplateCreateRequest';\n// @ts-ignore\nimport { ReportTemplateListResponse } from '../model/reportTemplateListResponse';\n// @ts-ignore\nimport { ReportTemplateResponse } from '../model/reportTemplateResponse';\n// @ts-ignore\nimport { ReportTemplateUpdateRequest } from '../model/reportTemplateUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ReportTemplatesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new report template\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createReportTemplate(request: ReportTemplateCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateResponse>;\n    public createReportTemplate(request: ReportTemplateCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateResponse>>;\n    public createReportTemplate(request: ReportTemplateCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateResponse>>;\n    public createReportTemplate(request: ReportTemplateCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createReportTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates`;\n        return this.httpClient.request<ReportTemplateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes a report template\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteReportTemplate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateResponse>;\n    public deleteReportTemplate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateResponse>>;\n    public deleteReportTemplate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateResponse>>;\n    public deleteReportTemplate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteReportTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReportTemplateResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a report template by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getReportTemplate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateResponse>;\n    public getReportTemplate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateResponse>>;\n    public getReportTemplate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateResponse>>;\n    public getReportTemplate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getReportTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReportTemplateResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of report templates for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listReportTemplates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateListResponse>;\n    public listReportTemplates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateListResponse>>;\n    public listReportTemplates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateListResponse>>;\n    public listReportTemplates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listReportTemplates.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates`;\n        return this.httpClient.request<ReportTemplateListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing report template\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateReportTemplate(id: string, request: ReportTemplateUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ReportTemplateResponse>;\n    public updateReportTemplate(id: string, request: ReportTemplateUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ReportTemplateResponse>>;\n    public updateReportTemplate(id: string, request: ReportTemplateUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ReportTemplateResponse>>;\n    public updateReportTemplate(id: string, request: ReportTemplateUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateReportTemplate.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateReportTemplate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/reporttemplates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ReportTemplateResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { AnalyticsBaseReportResponse } from '../model/analyticsBaseReportResponse';\n// @ts-ignore\nimport { AnalyticsBaseReportsListResponse } from '../model/analyticsBaseReportsListResponse';\n// @ts-ignore\nimport { CompletedReportDataRequest } from '../model/completedReportDataRequest';\n// @ts-ignore\nimport { CompletedReportListResponse } from '../model/completedReportListResponse';\n// @ts-ignore\nimport { CompletedReportRequest } from '../model/completedReportRequest';\n// @ts-ignore\nimport { CompletedReportResponse } from '../model/completedReportResponse';\n// @ts-ignore\nimport { CompletedReportUpdateRequest } from '../model/completedReportUpdateRequest';\n// @ts-ignore\nimport { ForbiddenError } from '../model/forbiddenError';\n// @ts-ignore\nimport { NotFoundError } from '../model/notFoundError';\n// @ts-ignore\nimport { QueueReportRequest } from '../model/queueReportRequest';\n// @ts-ignore\nimport { QueuedReportListResponse } from '../model/queuedReportListResponse';\n// @ts-ignore\nimport { QueuedReportResponse } from '../model/queuedReportResponse';\n// @ts-ignore\nimport { TooManyRequestsError } from '../model/tooManyRequestsError';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ReportsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Cancel a queued or running report\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public cancelReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<QueuedReportResponse>;\n    public cancelReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<QueuedReportResponse>>;\n    public cancelReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<QueuedReportResponse>>;\n    public cancelReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling cancelReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/queues/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<QueuedReportResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve an analytics base report by its ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getAnalyticsBaseReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AnalyticsBaseReportResponse>;\n    public getAnalyticsBaseReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AnalyticsBaseReportResponse>>;\n    public getAnalyticsBaseReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AnalyticsBaseReportResponse>>;\n    public getAnalyticsBaseReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getAnalyticsBaseReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/analytics/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<AnalyticsBaseReportResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompletedReportResponse>;\n    public getCompletedReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompletedReportResponse>>;\n    public getCompletedReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompletedReportResponse>>;\n    public getCompletedReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompletedReportResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the binary data for a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param filename The filename and type your want the to be returned as, can be \\&#39;.pdf\\&#39;, \\&#39;.csv\\&#39; or \\&#39;.json\\&#39;\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReportData(id: string, filename: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getCompletedReportData(id: string, filename: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getCompletedReportData(id: string, filename: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getCompletedReportData(id: string, filename: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReportData.');\n        }\n        if (filename === null || filename === undefined) {\n            throw new Error('Required parameter filename was null or undefined when calling getCompletedReportData.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"filename\", value: filename, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the binary data for a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param filename The filename and type your want the to be returned as, can be \\&#39;.pdf\\&#39;, \\&#39;.csv\\&#39; or \\&#39;.json\\&#39;\n     * @param outputFormat \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReportDataStream(id: string, filename: string, outputFormat?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public getCompletedReportDataStream(id: string, filename: string, outputFormat?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public getCompletedReportDataStream(id: string, filename: string, outputFormat?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public getCompletedReportDataStream(id: string, filename: string, outputFormat?: string, observe: any = 'body', reportProgress: boolean = false, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReportDataStream.');\n        }\n        if (filename === null || filename === undefined) {\n            throw new Error('Required parameter filename was null or undefined when calling getCompletedReportDataStream.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (outputFormat !== undefined && outputFormat !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>outputFormat, 'outputFormat');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = httpOptions && httpOptions.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = httpOptions && httpOptions.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = httpOptions && httpOptions.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/stream/${this.configuration.encodeParam({name: \"filename\", value: filename, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<any>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve the binary data for a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param filename The filename and type your want the data to be returned as, can be \\&#39;.pdf\\&#39;, \\&#39;.csv\\&#39; or \\&#39;.json\\&#39;\n     * @param options \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReportDataWithOptions(id: string, filename: string, options: CompletedReportDataRequest, observe?: 'body', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<{ [key: string]: any; }>;\n    public getCompletedReportDataWithOptions(id: string, filename: string, options: CompletedReportDataRequest, observe?: 'response', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<{ [key: string]: any; }>>;\n    public getCompletedReportDataWithOptions(id: string, filename: string, options: CompletedReportDataRequest, observe?: 'events', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<{ [key: string]: any; }>>;\n    public getCompletedReportDataWithOptions(id: string, filename: string, options: CompletedReportDataRequest, observe: any = 'body', reportProgress: boolean = false, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReportDataWithOptions.');\n        }\n        if (filename === null || filename === undefined) {\n            throw new Error('Required parameter filename was null or undefined when calling getCompletedReportDataWithOptions.');\n        }\n        if (options === null || options === undefined) {\n            throw new Error('Required parameter options was null or undefined when calling getCompletedReportDataWithOptions.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = httpOptions && httpOptions.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = httpOptions && httpOptions.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = httpOptions && httpOptions.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"filename\", value: filename, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<{ [key: string]: any; }>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: options,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param options \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCompletedReportWithOptions(id: string, options: CompletedReportRequest, observe?: 'body', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompletedReportResponse>;\n    public getCompletedReportWithOptions(id: string, options: CompletedReportRequest, observe?: 'response', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompletedReportResponse>>;\n    public getCompletedReportWithOptions(id: string, options: CompletedReportRequest, observe?: 'events', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompletedReportResponse>>;\n    public getCompletedReportWithOptions(id: string, options: CompletedReportRequest, observe: any = 'body', reportProgress: boolean = false, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getCompletedReportWithOptions.');\n        }\n        if (options === null || options === undefined) {\n            throw new Error('Required parameter options was null or undefined when calling getCompletedReportWithOptions.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = httpOptions && httpOptions.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = httpOptions && httpOptions.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = httpOptions && httpOptions.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompletedReportResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: options,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a queued report by it\\&#39;s ID.\n     * @param id The UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getQueuedReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<QueuedReportResponse>;\n    public getQueuedReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<QueuedReportResponse>>;\n    public getQueuedReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<QueuedReportResponse>>;\n    public getQueuedReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getQueuedReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/queues/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<QueuedReportResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of base reports for a specified owner, client or user.\n     * @param owner \n     * @param client \n     * @param user \n     * @param offset \n     * @param limit \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listAnalyticsBaseReports(owner?: string, client?: string, user?: string, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<AnalyticsBaseReportsListResponse>;\n    public listAnalyticsBaseReports(owner?: string, client?: string, user?: string, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AnalyticsBaseReportsListResponse>>;\n    public listAnalyticsBaseReports(owner?: string, client?: string, user?: string, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AnalyticsBaseReportsListResponse>>;\n    public listAnalyticsBaseReports(owner?: string, client?: string, user?: string, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (client !== undefined && client !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>client, 'client');\n        }\n        if (user !== undefined && user !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>user, 'user');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/analytics`;\n        return this.httpClient.request<AnalyticsBaseReportsListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of queued reports for a specified owner.\n     * @param start \n     * @param end \n     * @param client The client id you are requesting reports for\n     * @param user \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listCompletedReports(start: string, end: string, client?: string, user?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompletedReportListResponse>;\n    public listCompletedReports(start: string, end: string, client?: string, user?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompletedReportListResponse>>;\n    public listCompletedReports(start: string, end: string, client?: string, user?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompletedReportListResponse>>;\n    public listCompletedReports(start: string, end: string, client?: string, user?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (start === null || start === undefined) {\n            throw new Error('Required parameter start was null or undefined when calling listCompletedReports.');\n        }\n        if (end === null || end === undefined) {\n            throw new Error('Required parameter end was null or undefined when calling listCompletedReports.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (start !== undefined && start !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>start, 'start');\n        }\n        if (end !== undefined && end !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>end, 'end');\n        }\n        if (client !== undefined && client !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>client, 'client');\n        }\n        if (user !== undefined && user !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>user, 'user');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history`;\n        return this.httpClient.request<CompletedReportListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of queued reports for a specified owner.\n     * @param client The client id you are requesting reports for\n     * @param user \n     * @param server An optional server identifier (will be inferred from client settings if possible)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listQueuedReports(client?: string, user?: string, server?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<QueuedReportListResponse>;\n    public listQueuedReports(client?: string, user?: string, server?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<QueuedReportListResponse>>;\n    public listQueuedReports(client?: string, user?: string, server?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<QueuedReportListResponse>>;\n    public listQueuedReports(client?: string, user?: string, server?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (client !== undefined && client !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>client, 'client');\n        }\n        if (user !== undefined && user !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>user, 'user');\n        }\n        if (server !== undefined && server !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>server, 'server');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/queues`;\n        return this.httpClient.request<QueuedReportListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Queue a new report\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public queueReport(request: QueueReportRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<QueuedReportResponse>;\n    public queueReport(request: QueueReportRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<QueuedReportResponse>>;\n    public queueReport(request: QueueReportRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<QueuedReportResponse>>;\n    public queueReport(request: QueueReportRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling queueReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/queues`;\n        return this.httpClient.request<QueuedReportResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Rebuilds a base report\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public rebuildAnalyticsBaseReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public rebuildAnalyticsBaseReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public rebuildAnalyticsBaseReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public rebuildAnalyticsBaseReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling rebuildAnalyticsBaseReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/analytics/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/rebuild`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a report by it\\&#39;s ID.\n     * @param id The UUID of the report to update\n     * @param report The data with which to update an existing report.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCompletedReport(id: string, report: CompletedReportUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CompletedReportResponse>;\n    public updateCompletedReport(id: string, report: CompletedReportUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CompletedReportResponse>>;\n    public updateCompletedReport(id: string, report: CompletedReportUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CompletedReportResponse>>;\n    public updateCompletedReport(id: string, report: CompletedReportUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateCompletedReport.');\n        }\n        if (report === null || report === undefined) {\n            throw new Error('Required parameter report was null or undefined when calling updateCompletedReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/reports/history/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<CompletedReportResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: report,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { RoadProfileCreateRequest } from '../model/roadProfileCreateRequest';\n// @ts-ignore\nimport { RoadProfileListResponse } from '../model/roadProfileListResponse';\n// @ts-ignore\nimport { RoadProfileResponse } from '../model/roadProfileResponse';\n// @ts-ignore\nimport { RoadProfileUpdateRequest } from '../model/roadProfileUpdateRequest';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RoadProfilesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Road Profile entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createRoadProfile(request: RoadProfileCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RoadProfileResponse>;\n    public createRoadProfile(request: RoadProfileCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RoadProfileResponse>>;\n    public createRoadProfile(request: RoadProfileCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RoadProfileResponse>>;\n    public createRoadProfile(request: RoadProfileCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createRoadProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/roadprofiles`;\n        return this.httpClient.request<RoadProfileResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns road profile details for the specified id\n     * @param id The UUID of the road profile\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getRoadProfile(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RoadProfileResponse>;\n    public getRoadProfile(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RoadProfileResponse>>;\n    public getRoadProfile(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RoadProfileResponse>>;\n    public getRoadProfile(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getRoadProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/roadprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<RoadProfileResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of road profiles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse Load items from the parent as well\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listRoadProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RoadProfileListResponse>;\n    public listRoadProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RoadProfileListResponse>>;\n    public listRoadProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RoadProfileListResponse>>;\n    public listRoadProfiles(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listRoadProfiles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/roadprofiles`;\n        return this.httpClient.request<RoadProfileListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Road Profile entity\n     * @param id The UUID of the Road Profile\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateRoadProfile(id: string, request: RoadProfileUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RoadProfileResponse>;\n    public updateRoadProfile(id: string, request: RoadProfileUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RoadProfileResponse>>;\n    public updateRoadProfile(id: string, request: RoadProfileUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RoadProfileResponse>>;\n    public updateRoadProfile(id: string, request: RoadProfileUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateRoadProfile.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateRoadProfile.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/roadprofiles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<RoadProfileResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ScheduledReportCreateRequest } from '../model/scheduledReportCreateRequest';\n// @ts-ignore\nimport { ScheduledReportListResponse } from '../model/scheduledReportListResponse';\n// @ts-ignore\nimport { ScheduledReportResponse } from '../model/scheduledReportResponse';\n// @ts-ignore\nimport { ScheduledReportUpdateRequest } from '../model/scheduledReportUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ScheduledReportsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new scheduled report entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createScheduledReport(request: ScheduledReportCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ScheduledReportResponse>;\n    public createScheduledReport(request: ScheduledReportCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScheduledReportResponse>>;\n    public createScheduledReport(request: ScheduledReportCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScheduledReportResponse>>;\n    public createScheduledReport(request: ScheduledReportCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createScheduledReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/scheduledreports`;\n        return this.httpClient.request<ScheduledReportResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns scheduled report details for the specified id\n     * @param id The UUID of the scheduled report\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getScheduledReport(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ScheduledReportResponse>;\n    public getScheduledReport(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScheduledReportResponse>>;\n    public getScheduledReport(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScheduledReportResponse>>;\n    public getScheduledReport(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getScheduledReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/scheduledreports/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ScheduledReportResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of scheduled reports for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listScheduledReports(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ScheduledReportListResponse>;\n    public listScheduledReports(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScheduledReportListResponse>>;\n    public listScheduledReports(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScheduledReportListResponse>>;\n    public listScheduledReports(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listScheduledReports.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/scheduledreports`;\n        return this.httpClient.request<ScheduledReportListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing scheduled report entity\n     * @param id The UUID of the scheduled report\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateScheduledReport(id: string, request: ScheduledReportUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ScheduledReportResponse>;\n    public updateScheduledReport(id: string, request: ScheduledReportUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScheduledReportResponse>>;\n    public updateScheduledReport(id: string, request: ScheduledReportUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScheduledReportResponse>>;\n    public updateScheduledReport(id: string, request: ScheduledReportUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateScheduledReport.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateScheduledReport.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/scheduledreports/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ScheduledReportResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { EntitySearchResponse } from '../model/entitySearchResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SearchService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Perform a free text search against the entities available to the user.\n     * @param query The free text query you\\&#39;d like to search for\n     * @param deleted Specify whether to include deleted items in the response\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public searchEntities(query: string, deleted?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<EntitySearchResponse>;\n    public searchEntities(query: string, deleted?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<EntitySearchResponse>>;\n    public searchEntities(query: string, deleted?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<EntitySearchResponse>>;\n    public searchEntities(query: string, deleted?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (query === null || query === undefined) {\n            throw new Error('Required parameter query was null or undefined when calling searchEntities.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (query !== undefined && query !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>query, 'query');\n        }\n        if (deleted !== undefined && deleted !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>deleted, 'deleted');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/search/entities`;\n        return this.httpClient.request<EntitySearchResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { SimCardCreateRequest } from '../model/simCardCreateRequest';\n// @ts-ignore\nimport { SimCardListResponse } from '../model/simCardListResponse';\n// @ts-ignore\nimport { SimCardResponse } from '../model/simCardResponse';\n// @ts-ignore\nimport { SimCardUpdateRequest } from '../model/simCardUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SimCardsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new SIM card\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSimCard(request: SimCardCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SimCardResponse>;\n    public createSimCard(request: SimCardCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SimCardResponse>>;\n    public createSimCard(request: SimCardCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SimCardResponse>>;\n    public createSimCard(request: SimCardCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createSimCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/simcards`;\n        return this.httpClient.request<SimCardResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns SIM card details for the specified id\n     * @param id The UUID of the SIM card\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSimCard(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SimCardResponse>;\n    public getSimCard(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SimCardResponse>>;\n    public getSimCard(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SimCardResponse>>;\n    public getSimCard(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getSimCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/simcards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SimCardResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of SIM cards for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSimCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SimCardListResponse>;\n    public listSimCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SimCardListResponse>>;\n    public listSimCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SimCardListResponse>>;\n    public listSimCards(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listSimCards.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/simcards`;\n        return this.httpClient.request<SimCardListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing SIM card\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateSimCard(id: string, request: SimCardUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SimCardResponse>;\n    public updateSimCard(id: string, request: SimCardUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SimCardResponse>>;\n    public updateSimCard(id: string, request: SimCardUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SimCardResponse>>;\n    public updateSimCard(id: string, request: SimCardUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateSimCard.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateSimCard.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/simcards/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SimCardResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { SmsGatewayProviderCreateRequest } from '../model/smsGatewayProviderCreateRequest';\n// @ts-ignore\nimport { SmsGatewayProviderListResponse } from '../model/smsGatewayProviderListResponse';\n// @ts-ignore\nimport { SmsGatewayProviderResponse } from '../model/smsGatewayProviderResponse';\n// @ts-ignore\nimport { SmsGatewayProviderUpdateRequest } from '../model/smsGatewayProviderUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SmsGatewayProvidersService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new sms gateway provider entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSmsGatewayProvider(request: SmsGatewayProviderCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderResponse>;\n    public createSmsGatewayProvider(request: SmsGatewayProviderCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderResponse>>;\n    public createSmsGatewayProvider(request: SmsGatewayProviderCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderResponse>>;\n    public createSmsGatewayProvider(request: SmsGatewayProviderCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createSmsGatewayProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayproviders`;\n        return this.httpClient.request<SmsGatewayProviderResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns sms gateway provider details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSmsGatewayProvider(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderResponse>;\n    public getSmsGatewayProvider(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderResponse>>;\n    public getSmsGatewayProvider(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderResponse>>;\n    public getSmsGatewayProvider(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getSmsGatewayProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SmsGatewayProviderResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of sms gateway providers.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSmsGatewayProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderListResponse>;\n    public listSmsGatewayProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderListResponse>>;\n    public listSmsGatewayProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderListResponse>>;\n    public listSmsGatewayProviders(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listSmsGatewayProviders.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayproviders`;\n        return this.httpClient.request<SmsGatewayProviderListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing sms gateway provider entity\n     * @param id The UUID of the sms gateway provider\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateSmsGatewayProvider(id: string, request: SmsGatewayProviderUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderResponse>;\n    public updateSmsGatewayProvider(id: string, request: SmsGatewayProviderUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderResponse>>;\n    public updateSmsGatewayProvider(id: string, request: SmsGatewayProviderUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderResponse>>;\n    public updateSmsGatewayProvider(id: string, request: SmsGatewayProviderUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateSmsGatewayProvider.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateSmsGatewayProvider.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayproviders/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SmsGatewayProviderResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { SmsGatewayProviderTypeListResponse } from '../model/smsGatewayProviderTypeListResponse';\n// @ts-ignore\nimport { SmsGatewayProviderTypeResponse } from '../model/smsGatewayProviderTypeResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SmsGatewayProvidersTypesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Returns sms gateway provider type details for the specified id\n     * @param id The UUID of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSmsGatewayProviderType(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderTypeResponse>;\n    public getSmsGatewayProviderType(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderTypeResponse>>;\n    public getSmsGatewayProviderType(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderTypeResponse>>;\n    public getSmsGatewayProviderType(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getSmsGatewayProviderType.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayprovidertypes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SmsGatewayProviderTypeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of sms gateway provider types.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSmsGatewayProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SmsGatewayProviderTypeListResponse>;\n    public listSmsGatewayProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SmsGatewayProviderTypeListResponse>>;\n    public listSmsGatewayProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SmsGatewayProviderTypeListResponse>>;\n    public listSmsGatewayProviderTypes(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listSmsGatewayProviderTypes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/smsgatewayprovidertypes`;\n        return this.httpClient.request<SmsGatewayProviderTypeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { SslCertificateCreateRequest } from '../model/sslCertificateCreateRequest';\n// @ts-ignore\nimport { SslCertificateListResponse } from '../model/sslCertificateListResponse';\n// @ts-ignore\nimport { SslCertificateProvisionResponse } from '../model/sslCertificateProvisionResponse';\n// @ts-ignore\nimport { SslCertificateResponse } from '../model/sslCertificateResponse';\n// @ts-ignore\nimport { SslCertificateUpdateRequest } from '../model/sslCertificateUpdateRequest';\n// @ts-ignore\nimport { SslCertificateValidationResponse } from '../model/sslCertificateValidationResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SslCertificatesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new ssl certificate entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSslCertificate(request: SslCertificateCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateResponse>;\n    public createSslCertificate(request: SslCertificateCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateResponse>>;\n    public createSslCertificate(request: SslCertificateCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateResponse>>;\n    public createSslCertificate(request: SslCertificateCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates`;\n        return this.httpClient.request<SslCertificateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns ssl certificate details for the specified id\n     * @param id The UUID of the ssl certificate\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSslCertificate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateResponse>;\n    public getSslCertificate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateResponse>>;\n    public getSslCertificate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateResponse>>;\n    public getSslCertificate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SslCertificateResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of ssl certificates.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listSslCertificates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateListResponse>;\n    public listSslCertificates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateListResponse>>;\n    public listSslCertificates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateListResponse>>;\n    public listSslCertificates(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listSslCertificates.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates`;\n        return this.httpClient.request<SslCertificateListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Attempts to provision the ssl certificate\n     * @param id The UUID of the ssl certificate\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public provisionSslCertificate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateProvisionResponse>;\n    public provisionSslCertificate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateProvisionResponse>>;\n    public provisionSslCertificate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateProvisionResponse>>;\n    public provisionSslCertificate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling provisionSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/provision`;\n        return this.httpClient.request<SslCertificateProvisionResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing ssl certificate entity\n     * @param id The UUID of the ssl certificate\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateSslCertificate(id: string, request: SslCertificateUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateResponse>;\n    public updateSslCertificate(id: string, request: SslCertificateUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateResponse>>;\n    public updateSslCertificate(id: string, request: SslCertificateUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateResponse>>;\n    public updateSslCertificate(id: string, request: SslCertificateUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateSslCertificate.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SslCertificateResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Validates the ssl certificate and all prerequisites\n     * @param id The UUID of the ssl certificate\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public validateSslCertificate(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SslCertificateValidationResponse>;\n    public validateSslCertificate(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SslCertificateValidationResponse>>;\n    public validateSslCertificate(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SslCertificateValidationResponse>>;\n    public validateSslCertificate(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling validateSslCertificate.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/sslcertificates/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/validate`;\n        return this.httpClient.request<SslCertificateValidationResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { CellSetResponse } from '../model/cellSetResponse';\n// @ts-ignore\nimport { ForbiddenError } from '../model/forbiddenError';\n// @ts-ignore\nimport { NotFoundError } from '../model/notFoundError';\n// @ts-ignore\nimport { StatsEntityOutputOptions } from '../model/statsEntityOutputOptions';\n// @ts-ignore\nimport { TooManyRequestsError } from '../model/tooManyRequestsError';\n// @ts-ignore\nimport { UnexpectedError } from '../model/unexpectedError';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class StatsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Retrieve data for a stats report.\n     * @param type \n     * @param id The type of the entity. The UUID of the entity. The stats metric.\n     * @param metric \n     * @param options \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getOutputForEntity(type: 'client' | 'vendor' | 'distributor' | 'system' | 'user' | 'device', id: string, metric: 'devices' | 'users' | 'assets' | 'companion-cameras' | 'distributors' | 'vendors' | 'clients' | 'records' | 'bytes' | 'connections' | 'minutes', options: StatsEntityOutputOptions, observe?: 'body', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CellSetResponse>;\n    public getOutputForEntity(type: 'client' | 'vendor' | 'distributor' | 'system' | 'user' | 'device', id: string, metric: 'devices' | 'users' | 'assets' | 'companion-cameras' | 'distributors' | 'vendors' | 'clients' | 'records' | 'bytes' | 'connections' | 'minutes', options: StatsEntityOutputOptions, observe?: 'response', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CellSetResponse>>;\n    public getOutputForEntity(type: 'client' | 'vendor' | 'distributor' | 'system' | 'user' | 'device', id: string, metric: 'devices' | 'users' | 'assets' | 'companion-cameras' | 'distributors' | 'vendors' | 'clients' | 'records' | 'bytes' | 'connections' | 'minutes', options: StatsEntityOutputOptions, observe?: 'events', reportProgress?: boolean, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CellSetResponse>>;\n    public getOutputForEntity(type: 'client' | 'vendor' | 'distributor' | 'system' | 'user' | 'device', id: string, metric: 'devices' | 'users' | 'assets' | 'companion-cameras' | 'distributors' | 'vendors' | 'clients' | 'records' | 'bytes' | 'connections' | 'minutes', options: StatsEntityOutputOptions, observe: any = 'body', reportProgress: boolean = false, httpOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (type === null || type === undefined) {\n            throw new Error('Required parameter type was null or undefined when calling getOutputForEntity.');\n        }\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getOutputForEntity.');\n        }\n        if (metric === null || metric === undefined) {\n            throw new Error('Required parameter metric was null or undefined when calling getOutputForEntity.');\n        }\n        if (options === null || options === undefined) {\n            throw new Error('Required parameter options was null or undefined when calling getOutputForEntity.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = httpOptions && httpOptions.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = httpOptions && httpOptions.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = httpOptions && httpOptions.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/stats/entity/${this.configuration.encodeParam({name: \"type\", value: type, in: \"path\", style: \"simple\", explode: false, dataType: \"'client' | 'vendor' | 'distributor' | 'system' | 'user' | 'device'\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/${this.configuration.encodeParam({name: \"metric\", value: metric, in: \"path\", style: \"simple\", explode: false, dataType: \"'devices' | 'users' | 'assets' | 'companion-cameras' | 'distributors' | 'vendors' | 'clients' | 'records' | 'bytes' | 'connections' | 'minutes'\", dataFormat: undefined})}`;\n        return this.httpClient.request<CellSetResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: options,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { TaskCreateRequest } from '../model/taskCreateRequest';\n// @ts-ignore\nimport { TaskListResponse } from '../model/taskListResponse';\n// @ts-ignore\nimport { TaskResponse } from '../model/taskResponse';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TasksService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Cancels a task\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public cancelTask(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TaskResponse>;\n    public cancelTask(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TaskResponse>>;\n    public cancelTask(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TaskResponse>>;\n    public cancelTask(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling cancelTask.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/tasks/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TaskResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new task\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createTask(request: TaskCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TaskResponse>;\n    public createTask(request: TaskCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TaskResponse>>;\n    public createTask(request: TaskCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TaskResponse>>;\n    public createTask(request: TaskCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createTask.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/tasks`;\n        return this.httpClient.request<TaskResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns a task for the specified id\n     * @param id The UUID of the task\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTask(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TaskResponse>;\n    public getTask(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TaskResponse>>;\n    public getTask(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TaskResponse>>;\n    public getTask(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getTask.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/tasks/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<TaskResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of ACTIVE tasks for a specific entity.\n     * @param entity The entity id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listTasks(entity: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<TaskListResponse>;\n    public listTasks(entity: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TaskListResponse>>;\n    public listTasks(entity: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TaskListResponse>>;\n    public listTasks(entity: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (entity === null || entity === undefined) {\n            throw new Error('Required parameter entity was null or undefined when calling listTasks.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (entity !== undefined && entity !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>entity, 'entity');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/tasks`;\n        return this.httpClient.request<TaskListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { DomainThemeResponse } from '../model/domainThemeResponse';\n// @ts-ignore\nimport { ThemeCreateRequest } from '../model/themeCreateRequest';\n// @ts-ignore\nimport { ThemeListResponse } from '../model/themeListResponse';\n// @ts-ignore\nimport { ThemeResponse } from '../model/themeResponse';\n// @ts-ignore\nimport { ThemeUpdateRequest } from '../model/themeUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ThemesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Theme entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createTheme(request: ThemeCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThemeResponse>;\n    public createTheme(request: ThemeCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThemeResponse>>;\n    public createTheme(request: ThemeCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThemeResponse>>;\n    public createTheme(request: ThemeCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createTheme.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes`;\n        return this.httpClient.request<ThemeResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns Theme details for the specified id\n     * @param id The UUID of the Theme\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTheme(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThemeResponse>;\n    public getTheme(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThemeResponse>>;\n    public getTheme(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThemeResponse>>;\n    public getTheme(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getTheme.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ThemeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns client details for the specified id\n     * @param domain The domain name to look up\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getThemeForDomain(domain: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<DomainThemeResponse>;\n    public getThemeForDomain(domain: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<DomainThemeResponse>>;\n    public getThemeForDomain(domain: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<DomainThemeResponse>>;\n    public getThemeForDomain(domain: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (domain === null || domain === undefined) {\n            throw new Error('Required parameter domain was null or undefined when calling getThemeForDomain.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes/domain/${this.configuration.encodeParam({name: \"domain\", value: domain, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<DomainThemeResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of themes for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param recurse \n     * @param offset \n     * @param limit \n     * @param sort \n     * @param filter \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listThemes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThemeListResponse>;\n    public listThemes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThemeListResponse>>;\n    public listThemes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThemeListResponse>>;\n    public listThemes(owner: string, recurse?: boolean, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listThemes.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (recurse !== undefined && recurse !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>recurse, 'recurse');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes`;\n        return this.httpClient.request<ThemeListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Theme entity\n     * @param id The UUID of the Theme\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateTheme(id: string, request: ThemeUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThemeResponse>;\n    public updateTheme(id: string, request: ThemeUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThemeResponse>>;\n    public updateTheme(id: string, request: ThemeUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThemeResponse>>;\n    public updateTheme(id: string, request: ThemeUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateTheme.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateTheme.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/themes/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ThemeResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TranslateService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Exports the language strings for the specified language.\n     * @param language The language code\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public exportLanguage(language: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<{ [key: string]: { [key: string]: any; }; }>;\n    public exportLanguage(language: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<{ [key: string]: { [key: string]: any; }; }>>;\n    public exportLanguage(language: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<{ [key: string]: { [key: string]: any; }; }>>;\n    public exportLanguage(language: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (language === null || language === undefined) {\n            throw new Error('Required parameter language was null or undefined when calling exportLanguage.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/translate/${this.configuration.encodeParam({name: \"language\", value: language, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/export`;\n        return this.httpClient.request<{ [key: string]: { [key: string]: any; }; }>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { UserRoleCreateRequest } from '../model/userRoleCreateRequest';\n// @ts-ignore\nimport { UserRoleListResponse } from '../model/userRoleListResponse';\n// @ts-ignore\nimport { UserRoleResponse } from '../model/userRoleResponse';\n// @ts-ignore\nimport { UserRoleUpdateRequest } from '../model/userRoleUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserRolesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new user role entity\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createUserRole(request: UserRoleCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleResponse>;\n    public createUserRole(request: UserRoleCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleResponse>>;\n    public createUserRole(request: UserRoleCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleResponse>>;\n    public createUserRole(request: UserRoleCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createUserRole.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles`;\n        return this.httpClient.request<UserRoleResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a user role\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteUserRole(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleResponse>;\n    public deleteUserRole(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleResponse>>;\n    public deleteUserRole(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleResponse>>;\n    public deleteUserRole(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteUserRole.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserRoleResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns export task details for the specified id\n     * @param id The UUID of the user role\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUserRole(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleResponse>;\n    public getUserRole(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleResponse>>;\n    public getUserRole(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleResponse>>;\n    public getUserRole(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getUserRole.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserRoleResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of user roles for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listUserRoles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleListResponse>;\n    public listUserRoles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleListResponse>>;\n    public listUserRoles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleListResponse>>;\n    public listUserRoles(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listUserRoles.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles`;\n        return this.httpClient.request<UserRoleListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing user role entity\n     * @param id The UUID of the user role\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateUserRole(id: string, request: UserRoleUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserRoleResponse>;\n    public updateUserRole(id: string, request: UserRoleUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserRoleResponse>>;\n    public updateUserRole(id: string, request: UserRoleUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserRoleResponse>>;\n    public updateUserRole(id: string, request: UserRoleUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateUserRole.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateUserRole.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/userroles/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserRoleResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { SuccessResponse } from '../model/successResponse';\n// @ts-ignore\nimport { UserApiKeyCreateRequest } from '../model/userApiKeyCreateRequest';\n// @ts-ignore\nimport { UserApiKeyCreateResponse } from '../model/userApiKeyCreateResponse';\n// @ts-ignore\nimport { UserCreateRequest } from '../model/userCreateRequest';\n// @ts-ignore\nimport { UserCreateResponse } from '../model/userCreateResponse';\n// @ts-ignore\nimport { UserListResponse } from '../model/userListResponse';\n// @ts-ignore\nimport { UserPoliciesResponse } from '../model/userPoliciesResponse';\n// @ts-ignore\nimport { UserResetRequest } from '../model/userResetRequest';\n// @ts-ignore\nimport { UserResetResponse } from '../model/userResetResponse';\n// @ts-ignore\nimport { UserResponse } from '../model/userResponse';\n// @ts-ignore\nimport { UserUpdateRequest } from '../model/userUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UsersService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new API key\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApiKey(id: string, request: UserApiKeyCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserApiKeyCreateResponse>;\n    public createApiKey(id: string, request: UserApiKeyCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserApiKeyCreateResponse>>;\n    public createApiKey(id: string, request: UserApiKeyCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserApiKeyCreateResponse>>;\n    public createApiKey(id: string, request: UserApiKeyCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling createApiKey.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createApiKey.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/apikeys`;\n        return this.httpClient.request<UserApiKeyCreateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates a new user\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createUser(request: UserCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserCreateResponse>;\n    public createUser(request: UserCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserCreateResponse>>;\n    public createUser(request: UserCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserCreateResponse>>;\n    public createUser(request: UserCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createUser.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users`;\n        return this.httpClient.request<UserCreateResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes an API key\n     * @param id \n     * @param keyid \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteApiKey(id: string, keyid: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SuccessResponse>;\n    public deleteApiKey(id: string, keyid: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SuccessResponse>>;\n    public deleteApiKey(id: string, keyid: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SuccessResponse>>;\n    public deleteApiKey(id: string, keyid: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteApiKey.');\n        }\n        if (keyid === null || keyid === undefined) {\n            throw new Error('Required parameter keyid was null or undefined when calling deleteApiKey.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/apikeys/${this.configuration.encodeParam({name: \"keyid\", value: keyid, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SuccessResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes a previously configured OTP method for a user.\n     * @param id \n     * @param method \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteOTPMethod(id: string, method: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<SuccessResponse>;\n    public deleteOTPMethod(id: string, method: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SuccessResponse>>;\n    public deleteOTPMethod(id: string, method: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SuccessResponse>>;\n    public deleteOTPMethod(id: string, method: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteOTPMethod.');\n        }\n        if (method === null || method === undefined) {\n            throw new Error('Required parameter method was null or undefined when calling deleteOTPMethod.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/otp/${this.configuration.encodeParam({name: \"method\", value: method, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<SuccessResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a user avatar.\n     * @param id The user UUID.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteUserAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteUserAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteUserAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteUserAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteUserAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns user details for the specified id\n     * @param id The UUID of the user\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUser(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserResponse>;\n    public getUser(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserResponse>>;\n    public getUser(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserResponse>>;\n    public getUser(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getUser.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the user avatar in binary format\n     * @param id The UUID of the user\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUserAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getUserAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getUserAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getUserAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getUserAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns active security policies for the current user\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUserPolicies(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserPoliciesResponse>;\n    public getUserPolicies(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserPoliciesResponse>>;\n    public getUserPolicies(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserPoliciesResponse>>;\n    public getUserPolicies(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getUserPolicies.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/policies`;\n        return this.httpClient.request<UserPoliciesResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of users for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listUsers(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserListResponse>;\n    public listUsers(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserListResponse>>;\n    public listUsers(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserListResponse>>;\n    public listUsers(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listUsers.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users`;\n        return this.httpClient.request<UserListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Optionally suspends the user and sends them a password reset email.\n     * @param id The UUID of the user\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public resetUser(id: string, request: UserResetRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserResetResponse>;\n    public resetUser(id: string, request: UserResetRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserResetResponse>>;\n    public resetUser(id: string, request: UserResetRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserResetResponse>>;\n    public resetUser(id: string, request: UserResetRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling resetUser.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling resetUser.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/reset`;\n        return this.httpClient.request<UserResetResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing user\n     * @param id The UUID of the user\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateUser(id: string, request: UserUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<UserResponse>;\n    public updateUser(id: string, request: UserUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<UserResponse>>;\n    public updateUser(id: string, request: UserUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<UserResponse>>;\n    public updateUser(id: string, request: UserUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateUser.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateUser.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<UserResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified user\\&#39;s avatar.\n     * @param id The user UUID you are requesting data for.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateUserAvatar(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateUserAvatar(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateUserAvatar(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateUserAvatar(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateUserAvatar.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/users/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/avatar`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { VendorCreateRequest } from '../model/vendorCreateRequest';\n// @ts-ignore\nimport { VendorDetailsUpdateRequest } from '../model/vendorDetailsUpdateRequest';\n// @ts-ignore\nimport { VendorListResponse } from '../model/vendorListResponse';\n// @ts-ignore\nimport { VendorResponse } from '../model/vendorResponse';\n// @ts-ignore\nimport { VendorUpdateRequest } from '../model/vendorUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class VendorsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new vendor account\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createVendor(request: VendorCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorResponse>;\n    public createVendor(request: VendorCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorResponse>>;\n    public createVendor(request: VendorCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorResponse>>;\n    public createVendor(request: VendorCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createVendor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors`;\n        return this.httpClient.request<VendorResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Permanently deletes a custom vendor logo. The logo will revert to the vendor\\&#39;s parent logo.\n     * @param id The vendor UUID.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteVendorLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public deleteVendorLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public deleteVendorLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public deleteVendorLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteVendorLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling deleteVendorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns vendor details for the specified id\n     * @param id The UUID of the vendor\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getVendor(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorResponse>;\n    public getVendor(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorResponse>>;\n    public getVendor(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorResponse>>;\n    public getVendor(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getVendor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<VendorResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Return the specified vendor\\&#39;s logo in binary format. Should the vendor not have a custom logo, the logo of the distributor will be supplied.\n     * @param id The vendor UUID you are requesting data for.\n     * @param size The size of the returned image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getVendorLogo(id: string, size?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<string>;\n    public getVendorLogo(id: string, size?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;\n    public getVendorLogo(id: string, size?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;\n    public getVendorLogo(id: string, size?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getVendorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<string>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of vendors for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param counts A list of entity types to return counts for that belong to this vendor, comma delimited, i.e. &#x60;counts&#x3D;client,asset,device&#x60;. Each additional entity affects the performance of the query and should be used sparingly.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listVendors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorListResponse>;\n    public listVendors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorListResponse>>;\n    public listVendors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorListResponse>>;\n    public listVendors(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, counts?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listVendors.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n        if (counts !== undefined && counts !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>counts, 'counts');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors`;\n        return this.httpClient.request<VendorListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing vendor account\n     * @param id The UUID of the vendor\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateVendor(id: string, request: VendorUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorResponse>;\n    public updateVendor(id: string, request: VendorUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorResponse>>;\n    public updateVendor(id: string, request: VendorUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorResponse>>;\n    public updateVendor(id: string, request: VendorUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateVendor.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateVendor.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<VendorResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing vendor account details. Unlike updateVendor, this route is available to vendor users.\n     * @param id The UUID of the vendor\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateVendorDetails(id: string, request: VendorDetailsUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<VendorResponse>;\n    public updateVendorDetails(id: string, request: VendorDetailsUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<VendorResponse>>;\n    public updateVendorDetails(id: string, request: VendorDetailsUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<VendorResponse>>;\n    public updateVendorDetails(id: string, request: VendorDetailsUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateVendorDetails.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateVendorDetails.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/details`;\n        return this.httpClient.request<VendorResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the specified vendor\\&#39;s logo.\n     * @param id The vendor UUID you are requesting data for.\n     * @param size The size of the image. Can be either \\&quot;small\\&quot; or \\&quot;large\\&quot;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateVendorLogo(id: string, size: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;\n    public updateVendorLogo(id: string, size: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;\n    public updateVendorLogo(id: string, size: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;\n    public updateVendorLogo(id: string, size: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateVendorLogo.');\n        }\n        if (size === null || size === undefined) {\n            throw new Error('Required parameter size was null or undefined when calling updateVendorLogo.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (size !== undefined && size !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>size, 'size');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/accounts/vendors/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}/logo`;\n        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ZoneGroupCreateRequest } from '../model/zoneGroupCreateRequest';\n// @ts-ignore\nimport { ZoneGroupListResponse } from '../model/zoneGroupListResponse';\n// @ts-ignore\nimport { ZoneGroupResponse } from '../model/zoneGroupResponse';\n// @ts-ignore\nimport { ZoneGroupUpdateRequest } from '../model/zoneGroupUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ZoneGroupsService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new Zone Group\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createZoneGroup(request: ZoneGroupCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupResponse>;\n    public createZoneGroup(request: ZoneGroupCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupResponse>>;\n    public createZoneGroup(request: ZoneGroupCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupResponse>>;\n    public createZoneGroup(request: ZoneGroupCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createZoneGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups`;\n        return this.httpClient.request<ZoneGroupResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a Zone Group\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteZoneGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupResponse>;\n    public deleteZoneGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupResponse>>;\n    public deleteZoneGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupResponse>>;\n    public deleteZoneGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling deleteZoneGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneGroupResponse>('delete', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns zone group details for the specified id\n     * @param id The UUID of the zone group\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getZoneGroup(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupResponse>;\n    public getZoneGroup(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupResponse>>;\n    public getZoneGroup(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupResponse>>;\n    public getZoneGroup(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getZoneGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneGroupResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of zone groups for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listZoneGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupListResponse>;\n    public listZoneGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupListResponse>>;\n    public listZoneGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupListResponse>>;\n    public listZoneGroups(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listZoneGroups.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups`;\n        return this.httpClient.request<ZoneGroupListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing Zone Group\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateZoneGroup(id: string, request: ZoneGroupUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneGroupResponse>;\n    public updateZoneGroup(id: string, request: ZoneGroupUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneGroupResponse>>;\n    public updateZoneGroup(id: string, request: ZoneGroupUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneGroupResponse>>;\n    public updateZoneGroup(id: string, request: ZoneGroupUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateZoneGroup.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateZoneGroup.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zonegroups/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneGroupResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext \n        }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\n// @ts-ignore\nimport { ZoneCreateRequest } from '../model/zoneCreateRequest';\n// @ts-ignore\nimport { ZoneListResponse } from '../model/zoneListResponse';\n// @ts-ignore\nimport { ZoneResponse } from '../model/zoneResponse';\n// @ts-ignore\nimport { ZoneUpdateRequest } from '../model/zoneUpdateRequest';\n\n// @ts-ignore\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ZonesService {\n\n    protected basePath = '';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;\n            if (firstBasePath != undefined) {\n                basePath = firstBasePath;\n            }\n\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    // @ts-ignore\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates a new zone\n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createZone(request: ZoneCreateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneResponse>;\n    public createZone(request: ZoneCreateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneResponse>>;\n    public createZone(request: ZoneCreateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneResponse>>;\n    public createZone(request: ZoneCreateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling createZone.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zones`;\n        return this.httpClient.request<ZoneResponse>('post', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a Map Set by it\\&#39;s ID.\n     * @param id The Map Set UUID to retrieve.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getZone(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneResponse>;\n    public getZone(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneResponse>>;\n    public getZone(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneResponse>>;\n    public getZone(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling getZone.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zones/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve a list of zones for a specified owner.\n     * @param owner The owner id you are requesting data for\n     * @param offset An offset into the result set, useful for pagination\n     * @param limit Limit the number of results to this value.\n     * @param sort Sorting column or attribute name with an optional direction, e.g. &#x60;sort&#x3D;name:desc&#x60;\n     * @param filter A filter to apply to the data in RQL format.\n     * @param bounds A bounding rectangle to restrict the result set to in string format as &#x60;left,top,right,bottom&#x60;\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public listZones(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, bounds?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneListResponse>;\n    public listZones(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, bounds?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneListResponse>>;\n    public listZones(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, bounds?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneListResponse>>;\n    public listZones(owner: string, offset?: number, limit?: number, sort?: string, filter?: string, bounds?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (owner === null || owner === undefined) {\n            throw new Error('Required parameter owner was null or undefined when calling listZones.');\n        }\n\n        let localVarQueryParameters = new HttpParams({encoder: this.encoder});\n        if (owner !== undefined && owner !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>owner, 'owner');\n        }\n        if (offset !== undefined && offset !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>offset, 'offset');\n        }\n        if (limit !== undefined && limit !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>limit, 'limit');\n        }\n        if (sort !== undefined && sort !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>sort, 'sort');\n        }\n        if (filter !== undefined && filter !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>filter, 'filter');\n        }\n        if (bounds !== undefined && bounds !== null) {\n          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,\n            <any>bounds, 'bounds');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zones`;\n        return this.httpClient.request<ZoneListResponse>('get', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                params: localVarQueryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates an existing zone\n     * @param id \n     * @param request \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateZone(id: string, request: ZoneUpdateRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ZoneResponse>;\n    public updateZone(id: string, request: ZoneUpdateRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ZoneResponse>>;\n    public updateZone(id: string, request: ZoneUpdateRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ZoneResponse>>;\n    public updateZone(id: string, request: ZoneUpdateRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling updateZone.');\n        }\n        if (request === null || request === undefined) {\n            throw new Error('Required parameter request was null or undefined when calling updateZone.');\n        }\n\n        let localVarHeaders = this.defaultHeaders;\n\n        let localVarCredential: string | undefined;\n        // authentication (access_token) required\n        localVarCredential = this.configuration.lookupCredential('access_token');\n        if (localVarCredential) {\n            localVarHeaders = localVarHeaders.set('x-access-token', localVarCredential);\n        }\n\n        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (localVarHttpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (localVarHttpHeaderAcceptSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);\n        }\n\n        let localVarHttpContext: HttpContext | undefined = options && options.context;\n        if (localVarHttpContext === undefined) {\n            localVarHttpContext = new HttpContext();\n        }\n\n        let localVarTransferCache: boolean | undefined = options && options.transferCache;\n        if (localVarTransferCache === undefined) {\n            localVarTransferCache = true;\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' | 'blob' = 'json';\n        if (localVarHttpHeaderAcceptSelected) {\n            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {\n                responseType_ = 'text';\n            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {\n                responseType_ = 'json';\n            } else {\n                responseType_ = 'blob';\n            }\n        }\n\n        let localVarPath = `/entities/zones/${this.configuration.encodeParam({name: \"id\", value: id, in: \"path\", style: \"simple\", explode: false, dataType: \"string\", dataFormat: undefined})}`;\n        return this.httpClient.request<ZoneResponse>('put', `${this.configuration.basePath}${localVarPath}`,\n            {\n                context: localVarHttpContext,\n                body: request,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: localVarHeaders,\n                observe: observe,\n                transferCache: localVarTransferCache,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface AlertAction { \n  [key: string]: any | any;\n\n\n    type: AlertAction.TypeEnum;\n    id: string;\n    options: { [key: string]: any; };\n}\nexport namespace AlertAction {\n    export type TypeEnum = 'request_video' | 'request_photo' | 'label_current_trip';\n    export const TypeEnum = {\n        RequestVideo: 'request_video' as TypeEnum,\n        RequestPhoto: 'request_photo' as TypeEnum,\n        LabelCurrentTrip: 'label_current_trip' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { AlertNotify } from './alertNotify';\nimport { AlertAction } from './alertAction';\nimport { EventFilter } from './eventFilter';\n\n\nexport interface AlertCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this alert\n     */\n    name?: string | null;\n    /**\n     * The current state of this alert\n     */\n    state?: AlertCreateRequest.StateEnum | null;\n    costCentre?: IdName;\n    /**\n     * The priority of this alert\n     */\n    priority?: AlertCreateRequest.PriorityEnum | null;\n    filter?: EventFilter;\n    /**\n     * A list of users and roles that will be notified if this alert triggers.\n     */\n    notify?: Array<AlertNotify> | null;\n    /**\n     * A list of actions to be performed once this alert triggers.\n     */\n    actions?: Array<AlertAction> | null;\n    /**\n     * The client that owns this Alert\n     */\n    ownerId: string;\n}\nexport namespace AlertCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type PriorityEnum = 'low' | 'medium' | 'high';\n    export const PriorityEnum = {\n        Low: 'low' as PriorityEnum,\n        Medium: 'medium' as PriorityEnum,\n        High: 'high' as PriorityEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\nimport { EventFilter } from './eventFilter';\n\n\nexport interface AlertListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this alert\n     */\n    name: string;\n    /**\n     * The current state of this alert\n     */\n    state: AlertListItem.StateEnum;\n    costCentre: IdName;\n    /**\n     * The priority of this alert\n     */\n    priority: AlertListItem.PriorityEnum;\n    filter?: EventFilter;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace AlertListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type PriorityEnum = 'low' | 'medium' | 'high';\n    export const PriorityEnum = {\n        Low: 'low' as PriorityEnum,\n        Medium: 'medium' as PriorityEnum,\n        High: 'high' as PriorityEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface AlertNotify { \n  [key: string]: any | any;\n\n\n    type: AlertNotify.TypeEnum;\n    id: string;\n    name: string;\n}\nexport namespace AlertNotify {\n    export type TypeEnum = 'user' | 'role';\n    export const TypeEnum = {\n        User: 'user' as TypeEnum,\n        Role: 'role' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { AlertNotify } from './alertNotify';\nimport { AlertAction } from './alertAction';\nimport { IdNameType } from './idNameType';\nimport { EventFilter } from './eventFilter';\n\n\nexport interface AlertResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this alert\n     */\n    name?: string | null;\n    /**\n     * The current state of this alert\n     */\n    state?: AlertResponse.StateEnum | null;\n    costCentre?: IdName;\n    /**\n     * The priority of this alert\n     */\n    priority?: AlertResponse.PriorityEnum | null;\n    filter?: EventFilter;\n    /**\n     * A list of users and roles that will be notified if this alert triggers.\n     */\n    notify?: Array<AlertNotify> | null;\n    /**\n     * A list of actions to be performed once this alert triggers.\n     */\n    actions?: Array<AlertAction> | null;\n    entity?: EntityInfo;\n}\nexport namespace AlertResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type PriorityEnum = 'low' | 'medium' | 'high';\n    export const PriorityEnum = {\n        Low: 'low' as PriorityEnum,\n        Medium: 'medium' as PriorityEnum,\n        High: 'high' as PriorityEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { AlertNotify } from './alertNotify';\nimport { AlertAction } from './alertAction';\nimport { EventFilter } from './eventFilter';\n\n\nexport interface AlertUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this alert\n     */\n    name?: string | null;\n    /**\n     * The current state of this alert\n     */\n    state?: AlertUpdateRequest.StateEnum | null;\n    costCentre?: IdName;\n    /**\n     * The priority of this alert\n     */\n    priority?: AlertUpdateRequest.PriorityEnum | null;\n    filter?: EventFilter;\n    /**\n     * A list of users and roles that will be notified if this alert triggers.\n     */\n    notify?: Array<AlertNotify> | null;\n    /**\n     * A list of actions to be performed once this alert triggers.\n     */\n    actions?: Array<AlertAction> | null;\n}\nexport namespace AlertUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type PriorityEnum = 'low' | 'medium' | 'high';\n    export const PriorityEnum = {\n        Low: 'low' as PriorityEnum,\n        Medium: 'medium' as PriorityEnum,\n        High: 'high' as PriorityEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\nimport { AnalyticsBaseReportDashboard } from './analyticsBaseReportDashboard';\n\n\nexport interface AnalyticsBaseReportResponse { \n  [key: string]: any | any;\n\n\n    id: string;\n    name: string;\n    title: string;\n    owner: IdNameType;\n    user: IdName;\n    origin: IdNameType;\n    client: IdName;\n    taskId: number;\n    date: string;\n    completionDate: string;\n    status: AnalyticsBaseReportResponse.StatusEnum;\n    progress: number;\n    completedTasks: number;\n    totalTasks: number;\n    firstPassComplete: boolean;\n    priority: number;\n    mode: AnalyticsBaseReportResponse.ModeEnum;\n    maxRunning: number;\n    runEndDate: string;\n    lastCompletedDate: string;\n    dashboards?: Array<AnalyticsBaseReportDashboard> | null;\n}\nexport namespace AnalyticsBaseReportResponse {\n    export type StatusEnum = 'queued' | 'running' | 'completed' | 'aborted' | 'failed' | 'retry';\n    export const StatusEnum = {\n        Queued: 'queued' as StatusEnum,\n        Running: 'running' as StatusEnum,\n        Completed: 'completed' as StatusEnum,\n        Aborted: 'aborted' as StatusEnum,\n        Failed: 'failed' as StatusEnum,\n        Retry: 'retry' as StatusEnum\n    };\n    export type ModeEnum = 'single' | 'repeat';\n    export const ModeEnum = {\n        Single: 'single' as ModeEnum,\n        Repeat: 'repeat' as ModeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface AnalyticsDataSourceOptions { \n  [key: string]: any | any;\n\n\n    /**\n     * Definition ID of the analytics report which the widget is compatible with\n     */\n    definitionId: string;\n    /**\n     * The parameter definition string used to generate widget settings\n     */\n    parameterDefinition?: string | null;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n    filters?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The time rollup level of the report\n     */\n    rollup?: AnalyticsDataSourceOptions.RollupEnum | null;\n}\nexport namespace AnalyticsDataSourceOptions {\n    export type RollupEnum = 'hour' | 'day';\n    export const RollupEnum = {\n        Hour: 'hour' as RollupEnum,\n        Day: 'day' as RollupEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AnalyticsLevels } from './analyticsLevels';\n\n\nexport interface AnalyticsDimension { \n  [key: string]: any | any;\n\n\n    dim: AnalyticsDimension.DimEnum;\n    level: number;\n    filter: Array<string>;\n    levels: AnalyticsLevels;\n}\nexport namespace AnalyticsDimension {\n    export type DimEnum = 'time' | 'asset' | 'costCentre' | 'zoneCostCentre' | 'assetGroup' | 'zoneGroup' | 'device' | 'ioType' | 'alert' | 'event' | 'assetState' | 'assetCategory0' | 'assetCategory1' | 'assetCategory2' | 'assetCategory3' | 'assetCategory4' | 'overspeed' | 'shift' | 'company' | 'geography' | 'deviceType';\n    export const DimEnum = {\n        Time: 'time' as DimEnum,\n        Asset: 'asset' as DimEnum,\n        CostCentre: 'costCentre' as DimEnum,\n        ZoneCostCentre: 'zoneCostCentre' as DimEnum,\n        AssetGroup: 'assetGroup' as DimEnum,\n        ZoneGroup: 'zoneGroup' as DimEnum,\n        Device: 'device' as DimEnum,\n        IoType: 'ioType' as DimEnum,\n        Alert: 'alert' as DimEnum,\n        Event: 'event' as DimEnum,\n        AssetState: 'assetState' as DimEnum,\n        AssetCategory0: 'assetCategory0' as DimEnum,\n        AssetCategory1: 'assetCategory1' as DimEnum,\n        AssetCategory2: 'assetCategory2' as DimEnum,\n        AssetCategory3: 'assetCategory3' as DimEnum,\n        AssetCategory4: 'assetCategory4' as DimEnum,\n        Overspeed: 'overspeed' as DimEnum,\n        Shift: 'shift' as DimEnum,\n        Company: 'company' as DimEnum,\n        Geography: 'geography' as DimEnum,\n        DeviceType: 'deviceType' as DimEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AnalyticsOutputRangeFilter } from './analyticsOutputRangeFilter';\n\n\nexport interface AnalyticsOutputFilter { \n  [key: string]: any | any;\n\n\n    mode: AnalyticsOutputFilter.ModeEnum;\n    items?: Array<string> | null;\n    range?: AnalyticsOutputRangeFilter;\n}\nexport namespace AnalyticsOutputFilter {\n    export type ModeEnum = 'include' | 'exclude' | 'range';\n    export const ModeEnum = {\n        Include: 'include' as ModeEnum,\n        Exclude: 'exclude' as ModeEnum,\n        Range: 'range' as ModeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AnalyticsSortOptions } from './analyticsSortOptions';\nimport { AnalyticsOutputFilters } from './analyticsOutputFilters';\n\n\nexport interface AnalyticsOutputRequest { \n  [key: string]: any | any;\n\n\n    rowLevel: number;\n    groupLevel: number;\n    time: string;\n    flipped: boolean;\n    measures: Array<string>;\n    sort: AnalyticsSortOptions;\n    row?: AnalyticsOutputRequest.RowEnum | null;\n    group?: AnalyticsOutputRequest.GroupEnum | null;\n    filters?: AnalyticsOutputFilters;\n}\nexport namespace AnalyticsOutputRequest {\n    export type RowEnum = 'time' | 'asset' | 'costCentre' | 'zoneCostCentre' | 'assetGroup' | 'zoneGroup' | 'device' | 'ioType' | 'alert' | 'event' | 'assetState' | 'assetCategory0' | 'assetCategory1' | 'assetCategory2' | 'assetCategory3' | 'assetCategory4' | 'overspeed' | 'shift' | 'company' | 'geography' | 'deviceType';\n    export const RowEnum = {\n        Time: 'time' as RowEnum,\n        Asset: 'asset' as RowEnum,\n        CostCentre: 'costCentre' as RowEnum,\n        ZoneCostCentre: 'zoneCostCentre' as RowEnum,\n        AssetGroup: 'assetGroup' as RowEnum,\n        ZoneGroup: 'zoneGroup' as RowEnum,\n        Device: 'device' as RowEnum,\n        IoType: 'ioType' as RowEnum,\n        Alert: 'alert' as RowEnum,\n        Event: 'event' as RowEnum,\n        AssetState: 'assetState' as RowEnum,\n        AssetCategory0: 'assetCategory0' as RowEnum,\n        AssetCategory1: 'assetCategory1' as RowEnum,\n        AssetCategory2: 'assetCategory2' as RowEnum,\n        AssetCategory3: 'assetCategory3' as RowEnum,\n        AssetCategory4: 'assetCategory4' as RowEnum,\n        Overspeed: 'overspeed' as RowEnum,\n        Shift: 'shift' as RowEnum,\n        Company: 'company' as RowEnum,\n        Geography: 'geography' as RowEnum,\n        DeviceType: 'deviceType' as RowEnum\n    };\n    export type GroupEnum = 'time' | 'asset' | 'costCentre' | 'zoneCostCentre' | 'assetGroup' | 'zoneGroup' | 'device' | 'ioType' | 'alert' | 'event' | 'assetState' | 'assetCategory0' | 'assetCategory1' | 'assetCategory2' | 'assetCategory3' | 'assetCategory4' | 'overspeed' | 'shift' | 'company' | 'geography' | 'deviceType';\n    export const GroupEnum = {\n        Time: 'time' as GroupEnum,\n        Asset: 'asset' as GroupEnum,\n        CostCentre: 'costCentre' as GroupEnum,\n        ZoneCostCentre: 'zoneCostCentre' as GroupEnum,\n        AssetGroup: 'assetGroup' as GroupEnum,\n        ZoneGroup: 'zoneGroup' as GroupEnum,\n        Device: 'device' as GroupEnum,\n        IoType: 'ioType' as GroupEnum,\n        Alert: 'alert' as GroupEnum,\n        Event: 'event' as GroupEnum,\n        AssetState: 'assetState' as GroupEnum,\n        AssetCategory0: 'assetCategory0' as GroupEnum,\n        AssetCategory1: 'assetCategory1' as GroupEnum,\n        AssetCategory2: 'assetCategory2' as GroupEnum,\n        AssetCategory3: 'assetCategory3' as GroupEnum,\n        AssetCategory4: 'assetCategory4' as GroupEnum,\n        Overspeed: 'overspeed' as GroupEnum,\n        Shift: 'shift' as GroupEnum,\n        Company: 'company' as GroupEnum,\n        Geography: 'geography' as GroupEnum,\n        DeviceType: 'deviceType' as GroupEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AnalyticsSortOptions } from './analyticsSortOptions';\nimport { AnalyticsOutputFilters } from './analyticsOutputFilters';\nimport { AnalyticsTable } from './analyticsTable';\nimport { MeasureDescription } from './measureDescription';\nimport { AnalyticsDimension } from './analyticsDimension';\nimport { PieChartOptions } from './pieChartOptions';\nimport { AnalyticsUpdateSettings } from './analyticsUpdateSettings';\nimport { ChartOptions } from './chartOptions';\nimport { CalculatedMeasureSettings } from './calculatedMeasureSettings';\nimport { StatChartOptions } from './statChartOptions';\n\n\nexport interface AnalyticsOutputSettings { \n  [key: string]: any | any;\n\n\n    name: string;\n    description: string;\n    dateRange: string;\n    row: AnalyticsDimension;\n    group: AnalyticsDimension;\n    flipped: boolean;\n    measures: Array<MeasureDescription>;\n    table: AnalyticsTable;\n    sort: AnalyticsSortOptions;\n    graph?: ChartOptions;\n    pie?: PieChartOptions;\n    stat?: StatChartOptions;\n    calculatedMeasures?: CalculatedMeasureSettings;\n    filters?: AnalyticsOutputFilters;\n    timeOptions?: Array<AnalyticsOutputSettings.TimeOptionsEnum> | null;\n    shiftsEnabled?: boolean | null;\n    doNotTemplate?: boolean | null;\n    updates?: AnalyticsUpdateSettings;\n}\nexport namespace AnalyticsOutputSettings {\n    export type TimeOptionsEnum = 'days' | 'hours';\n    export const TimeOptionsEnum = {\n        Days: 'days' as TimeOptionsEnum,\n        Hours: 'hours' as TimeOptionsEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface AnalyticsSettingsRequest { \n  [key: string]: any | any;\n\n\n    row: AnalyticsSettingsRequest.RowEnum;\n    group: AnalyticsSettingsRequest.GroupEnum;\n}\nexport namespace AnalyticsSettingsRequest {\n    export type RowEnum = 'time' | 'asset' | 'costCentre' | 'zoneCostCentre' | 'assetGroup' | 'zoneGroup' | 'device' | 'ioType' | 'alert' | 'event' | 'assetState' | 'assetCategory0' | 'assetCategory1' | 'assetCategory2' | 'assetCategory3' | 'assetCategory4' | 'overspeed' | 'shift' | 'company' | 'geography' | 'deviceType';\n    export const RowEnum = {\n        Time: 'time' as RowEnum,\n        Asset: 'asset' as RowEnum,\n        CostCentre: 'costCentre' as RowEnum,\n        ZoneCostCentre: 'zoneCostCentre' as RowEnum,\n        AssetGroup: 'assetGroup' as RowEnum,\n        ZoneGroup: 'zoneGroup' as RowEnum,\n        Device: 'device' as RowEnum,\n        IoType: 'ioType' as RowEnum,\n        Alert: 'alert' as RowEnum,\n        Event: 'event' as RowEnum,\n        AssetState: 'assetState' as RowEnum,\n        AssetCategory0: 'assetCategory0' as RowEnum,\n        AssetCategory1: 'assetCategory1' as RowEnum,\n        AssetCategory2: 'assetCategory2' as RowEnum,\n        AssetCategory3: 'assetCategory3' as RowEnum,\n        AssetCategory4: 'assetCategory4' as RowEnum,\n        Overspeed: 'overspeed' as RowEnum,\n        Shift: 'shift' as RowEnum,\n        Company: 'company' as RowEnum,\n        Geography: 'geography' as RowEnum,\n        DeviceType: 'deviceType' as RowEnum\n    };\n    export type GroupEnum = 'time' | 'asset' | 'costCentre' | 'zoneCostCentre' | 'assetGroup' | 'zoneGroup' | 'device' | 'ioType' | 'alert' | 'event' | 'assetState' | 'assetCategory0' | 'assetCategory1' | 'assetCategory2' | 'assetCategory3' | 'assetCategory4' | 'overspeed' | 'shift' | 'company' | 'geography' | 'deviceType';\n    export const GroupEnum = {\n        Time: 'time' as GroupEnum,\n        Asset: 'asset' as GroupEnum,\n        CostCentre: 'costCentre' as GroupEnum,\n        ZoneCostCentre: 'zoneCostCentre' as GroupEnum,\n        AssetGroup: 'assetGroup' as GroupEnum,\n        ZoneGroup: 'zoneGroup' as GroupEnum,\n        Device: 'device' as GroupEnum,\n        IoType: 'ioType' as GroupEnum,\n        Alert: 'alert' as GroupEnum,\n        Event: 'event' as GroupEnum,\n        AssetState: 'assetState' as GroupEnum,\n        AssetCategory0: 'assetCategory0' as GroupEnum,\n        AssetCategory1: 'assetCategory1' as GroupEnum,\n        AssetCategory2: 'assetCategory2' as GroupEnum,\n        AssetCategory3: 'assetCategory3' as GroupEnum,\n        AssetCategory4: 'assetCategory4' as GroupEnum,\n        Overspeed: 'overspeed' as GroupEnum,\n        Shift: 'shift' as GroupEnum,\n        Company: 'company' as GroupEnum,\n        Geography: 'geography' as GroupEnum,\n        DeviceType: 'deviceType' as GroupEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface AnalyticsSortOptions { \n  [key: string]: any | any;\n\n\n    type: AnalyticsSortOptions.TypeEnum;\n    direction: AnalyticsSortOptions.DirectionEnum;\n    limit?: number | null;\n    measureKey?: string | null;\n}\nexport namespace AnalyticsSortOptions {\n    export type TypeEnum = 'alphabetic' | 'numeric';\n    export const TypeEnum = {\n        Alphabetic: 'alphabetic' as TypeEnum,\n        Numeric: 'numeric' as TypeEnum\n    };\n    export type DirectionEnum = 'asc' | 'desc';\n    export const DirectionEnum = {\n        Asc: 'asc' as DirectionEnum,\n        Desc: 'desc' as DirectionEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetCounterValues } from './assetCounterValues';\nimport { AssetLocation } from './assetLocation';\nimport { IdName } from './idName';\nimport { AssetGeoLock } from './assetGeoLock';\nimport { AssetParameters } from './assetParameters';\nimport { AssetZoneTarget } from './assetZoneTarget';\nimport { Contact } from './contact';\n\nexport interface AssetCreateRequest {\n  [key: string]: any | any;\n\n  /**\n   * A client unique name for this asset. This can be any value that is relevant for the client.\n   */\n  name: string;\n  /**\n   * The name of the icon to use for the asset on the map. Manually added.\n   */\n  mapIconName?: string;\n  assetType: IdName;\n  /**\n   * The color of the icon for this asset\n   */\n  color?: AssetCreateRequest.ColorEnum | null;\n  tags?: Array<string> | null;\n  costCentre: IdName;\n  ratingProfile?: IdName;\n  /**\n   * One or more asset state profiles to use for this asset\n   */\n  assetStateProfiles?: Array<IdName> | null;\n  overspeedProfile?: IdName;\n  geoLockProfile?: IdName;\n  roadProfile?: IdName;\n  /**\n   * One of more asset groups that this asset belongs to\n   */\n  groups: Array<IdName>;\n  /**\n   * Up to 5 different categories that this asset belongs to\n   */\n  categories?: Array<IdName> | null;\n  /**\n   * One or more clients to which this asset has been shared.\n   */\n  sharedWith?: Array<IdName> | null;\n  assetTag?: IdName;\n  /**\n   * The current state of the asset object\n   */\n  state?: AssetCreateRequest.StateEnum | null;\n  fields?: { [key: string]: object };\n  parameters?: AssetParameters;\n  geoLock?: AssetGeoLock;\n  /**\n   * One or more contacts that are relevant to this asset\n   */\n  contacts?: Array<Contact> | null;\n  location?: AssetLocation;\n  /**\n   * A list of zones and routes that are relevant to this asset\n   */\n  zones?: Array<AssetZoneTarget> | null;\n  /**\n   * A list of labels that will be applied to trips from this asset by default.\n   */\n  defaultTripLabels?: Array<string> | null;\n  ownerId: string;\n  counterValues?: AssetCounterValues;\n}\nexport namespace AssetCreateRequest {\n  export type ColorEnum =\n    | 'blue'\n    | 'lightblue'\n    | 'green'\n    | 'olive'\n    | 'orange'\n    | 'pink'\n    | 'purple'\n    | 'red'\n    | 'teal'\n    | 'yellow'\n    | 'white'\n    | 'gray';\n  export const ColorEnum = {\n    Blue: 'blue' as ColorEnum,\n    Lightblue: 'lightblue' as ColorEnum,\n    Green: 'green' as ColorEnum,\n    Olive: 'olive' as ColorEnum,\n    Orange: 'orange' as ColorEnum,\n    Pink: 'pink' as ColorEnum,\n    Purple: 'purple' as ColorEnum,\n    Red: 'red' as ColorEnum,\n    Teal: 'teal' as ColorEnum,\n    Yellow: 'yellow' as ColorEnum,\n    White: 'white' as ColorEnum,\n    Gray: 'gray' as ColorEnum,\n  };\n  export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n  export const StateEnum = {\n    Inactive: 'inactive' as StateEnum,\n    Active: 'active' as StateEnum,\n    Suspended: 'suspended' as StateEnum,\n    Deleted: 'deleted' as StateEnum,\n  };\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { AssetGeoLock } from './assetGeoLock';\n\nexport interface AssetListItem {\n  [key: string]: any | any;\n\n  /**\n   * The unique ID for this asset\n   */\n  id: string;\n  /**\n   * A client unique name for this asset. This can be any value that is relevant for the client.\n   */\n  name: string;\n  /**\n   * The name of the icon to use for the asset on the map. Manually added.\n   */\n  mapIconName: string;\n  owner: IdName;\n  /**\n   * One or more clients to which this asset has been shared.\n   */\n  sharedWith: Array<IdName>;\n  assetType: IdName;\n  /**\n   * One of more asset groups that this asset belongs to\n   */\n  groups: Array<IdName>;\n  /**\n   * Up to 5 different categories that this asset belongs to\n   */\n  categories: Array<IdName>;\n  costCentre: IdName;\n  /**\n   * One or more devices that provide telemetry data for this asset.\n   */\n  devices: Array<IdName>;\n  assetTag: string;\n  tags: Array<string>;\n  fields: { [key: string]: object };\n  /**\n   * The color of the icon for this asset\n   */\n  color: AssetListItem.ColorEnum;\n  /**\n   * The current state of the asset object\n   */\n  state: AssetListItem.StateEnum;\n  geoLock?: AssetGeoLock;\n  /**\n   * The number of cameras connected to this asset\n   */\n  cameras: number;\n}\nexport namespace AssetListItem {\n  export type ColorEnum =\n    | 'blue'\n    | 'lightblue'\n    | 'green'\n    | 'olive'\n    | 'orange'\n    | 'pink'\n    | 'purple'\n    | 'red'\n    | 'teal'\n    | 'yellow'\n    | 'white'\n    | 'gray';\n  export const ColorEnum = {\n    Blue: 'blue' as ColorEnum,\n    Lightblue: 'lightblue' as ColorEnum,\n    Green: 'green' as ColorEnum,\n    Olive: 'olive' as ColorEnum,\n    Orange: 'orange' as ColorEnum,\n    Pink: 'pink' as ColorEnum,\n    Purple: 'purple' as ColorEnum,\n    Red: 'red' as ColorEnum,\n    Teal: 'teal' as ColorEnum,\n    Yellow: 'yellow' as ColorEnum,\n    White: 'white' as ColorEnum,\n    Gray: 'gray' as ColorEnum,\n  };\n  export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n  export const StateEnum = {\n    Inactive: 'inactive' as StateEnum,\n    Active: 'active' as StateEnum,\n    Suspended: 'suspended' as StateEnum,\n    Deleted: 'deleted' as StateEnum,\n  };\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetRatingPenalty } from './assetRatingPenalty';\n\n\nexport interface AssetRatingProfileCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: AssetRatingProfileCreateRequest.StateEnum | null;\n    /**\n     * The penalty items for this profile\n     */\n    items?: Array<AssetRatingPenalty> | null;\n    /**\n     * The client that owns this Asset Rating Profile\n     */\n    ownerId: string;\n}\nexport namespace AssetRatingProfileCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetRatingPenalty } from './assetRatingPenalty';\nimport { IdNameType } from './idNameType';\n\n\nexport interface AssetRatingProfileListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: AssetRatingProfileListItem.StateEnum | null;\n    /**\n     * The penalty items for this profile\n     */\n    items?: Array<AssetRatingPenalty> | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace AssetRatingProfileListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { AssetRatingPenalty } from './assetRatingPenalty';\nimport { IdNameType } from './idNameType';\n\n\nexport interface AssetRatingProfileResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: AssetRatingProfileResponse.StateEnum | null;\n    /**\n     * The penalty items for this profile\n     */\n    items?: Array<AssetRatingPenalty> | null;\n    entity: EntityInfo;\n}\nexport namespace AssetRatingProfileResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetRatingPenalty } from './assetRatingPenalty';\n\n\nexport interface AssetRatingProfileUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: AssetRatingProfileUpdateRequest.StateEnum | null;\n    /**\n     * The penalty items for this profile\n     */\n    items?: Array<AssetRatingPenalty> | null;\n}\nexport namespace AssetRatingProfileUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetLocation } from './assetLocation';\nimport { IdName } from './idName';\nimport { AssetLinkage } from './assetLinkage';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\nimport { AssetGeoLock } from './assetGeoLock';\nimport { AssetParameters } from './assetParameters';\nimport { AssetZoneTarget } from './assetZoneTarget';\nimport { Contact } from './contact';\n\nexport interface AssetResponse {\n  [key: string]: any | any;\n\n  /**\n   * The unique UUID of this entity\n   */\n  id: string;\n  owner: IdNameType;\n  /**\n   * A client unique name for this asset. This can be any value that is relevant for the client.\n   */\n  name?: string | null;\n  /**\n   * The name of the icon to use for the asset on the map. Manually added.\n   */\n  mapIconName: string;\n  assetType?: IdName;\n  /**\n   * The color of the icon for this asset\n   */\n  color?: AssetResponse.ColorEnum | null;\n  tags?: Array<string> | null;\n  costCentre?: IdName;\n  ratingProfile?: IdName;\n  /**\n   * One or more asset state profiles to use for this asset\n   */\n  assetStateProfiles?: Array<IdName> | null;\n  overspeedProfile?: IdName;\n  geoLockProfile?: IdName;\n  roadProfile?: IdName;\n  /**\n   * One of more asset groups that this asset belongs to\n   */\n  groups?: Array<IdName> | null;\n  /**\n   * Up to 5 different categories that this asset belongs to\n   */\n  categories?: Array<IdName> | null;\n  /**\n   * One or more clients to which this asset has been shared.\n   */\n  sharedWith?: Array<IdName> | null;\n  assetTag?: IdName;\n  /**\n   * The current state of the asset object\n   */\n  state?: AssetResponse.StateEnum | null;\n  fields?: { [key: string]: object };\n  parameters?: AssetParameters;\n  geoLock?: AssetGeoLock;\n  /**\n   * One or more contacts that are relevant to this asset\n   */\n  contacts?: Array<Contact> | null;\n  location?: AssetLocation;\n  /**\n   * A list of zones and routes that are relevant to this asset\n   */\n  zones?: Array<AssetZoneTarget> | null;\n  /**\n   * A list of labels that will be applied to trips from this asset by default.\n   */\n  defaultTripLabels?: Array<string> | null;\n  /**\n   * One or more devices that provide telemetry data for this asset.  Can only be modified using the `updateDevice` operation.\n   */\n  devices?: Array<IdName> | null;\n  linkedFrom?: AssetLinkage;\n  /**\n   * A list of assets this asset it linked to, can only be modified with the `linkAssets` operation.\n   */\n  linkedTo?: Array<AssetLinkage> | null;\n  entity: EntityInfo;\n}\nexport namespace AssetResponse {\n  export type ColorEnum =\n    | 'blue'\n    | 'lightblue'\n    | 'green'\n    | 'olive'\n    | 'orange'\n    | 'pink'\n    | 'purple'\n    | 'red'\n    | 'teal'\n    | 'yellow'\n    | 'white'\n    | 'gray';\n  export const ColorEnum = {\n    Blue: 'blue' as ColorEnum,\n    Lightblue: 'lightblue' as ColorEnum,\n    Green: 'green' as ColorEnum,\n    Olive: 'olive' as ColorEnum,\n    Orange: 'orange' as ColorEnum,\n    Pink: 'pink' as ColorEnum,\n    Purple: 'purple' as ColorEnum,\n    Red: 'red' as ColorEnum,\n    Teal: 'teal' as ColorEnum,\n    Yellow: 'yellow' as ColorEnum,\n    White: 'white' as ColorEnum,\n    Gray: 'gray' as ColorEnum,\n  };\n  export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n  export const StateEnum = {\n    Inactive: 'inactive' as StateEnum,\n    Active: 'active' as StateEnum,\n    Suspended: 'suspended' as StateEnum,\n    Deleted: 'deleted' as StateEnum,\n  };\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetStateItem } from './assetStateItem';\n\n\nexport interface AssetStateProfileCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: AssetStateProfileCreateRequest.StateEnum | null;\n    /**\n     * The state items for this profile\n     */\n    items?: Array<AssetStateItem> | null;\n    /**\n     * The client that owns this Asset State Profile\n     */\n    ownerId: string;\n}\nexport namespace AssetStateProfileCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetStateItem } from './assetStateItem';\nimport { IdNameType } from './idNameType';\n\n\nexport interface AssetStateProfileListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name: string;\n    /**\n     * The current state of this entity\n     */\n    state: AssetStateProfileListItem.StateEnum;\n    /**\n     * The state items for this profile\n     */\n    items: Array<AssetStateItem>;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace AssetStateProfileListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetStateItem } from './assetStateItem';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface AssetStateProfileResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: AssetStateProfileResponse.StateEnum | null;\n    /**\n     * The state items for this profile\n     */\n    items?: Array<AssetStateItem> | null;\n    entity: EntityInfo;\n}\nexport namespace AssetStateProfileResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetStateItem } from './assetStateItem';\n\n\nexport interface AssetStateProfileUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: AssetStateProfileUpdateRequest.StateEnum | null;\n    /**\n     * The state items for this profile\n     */\n    items?: Array<AssetStateItem> | null;\n}\nexport namespace AssetStateProfileUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface AssetTagCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A friendly name to identify this tag\n     */\n    name?: string | null;\n    /**\n     * The serial number of the Asset Tag that is used to uniquely identify it.\n     */\n    serialNumber: string;\n    assetTagType: IdName;\n    /**\n     * The asset tag operation mode. Options are \\'movable\\' for movable assets, \\'fixed\\' for fixed assets and \\'stock\\' for temporary stock control uses.\n     */\n    mode: AssetTagCreateRequest.ModeEnum;\n    /**\n     * The current state of the object\n     */\n    state?: AssetTagCreateRequest.StateEnum | null;\n    asset?: IdName;\n    fields?: { [key: string]: object; };\n    ownerId: string;\n}\nexport namespace AssetTagCreateRequest {\n    export type ModeEnum = 'movable' | 'fixed' | 'stock';\n    export const ModeEnum = {\n        Movable: 'movable' as ModeEnum,\n        Fixed: 'fixed' as ModeEnum,\n        Stock: 'stock' as ModeEnum\n    };\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface AssetTagListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID for this Asset Tag\n     */\n    id: string;\n    owner: IdName;\n    /**\n     * The serial number of the Asset Tag that is used to uniquely identify it.\n     */\n    name: string;\n    /**\n     * The serial number of the Asset Tag that is used to uniquely identify it.\n     */\n    serialNumber: string;\n    assetTagType: IdName;\n    /**\n     * The asset tag operation mode. Options are \\'movable\\' for movable assets, \\'fixed\\' for fixed assets and \\'stock\\' for temporary stock control uses.\n     */\n    mode: AssetTagListItem.ModeEnum;\n    /**\n     * The current state of the object\n     */\n    state: AssetTagListItem.StateEnum;\n    asset: IdName;\n    fields: { [key: string]: object; };\n}\nexport namespace AssetTagListItem {\n    export type ModeEnum = 'movable' | 'fixed' | 'stock';\n    export const ModeEnum = {\n        Movable: 'movable' as ModeEnum,\n        Fixed: 'fixed' as ModeEnum,\n        Stock: 'stock' as ModeEnum\n    };\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface AssetTagResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A friendly name to identify this tag\n     */\n    name?: string | null;\n    /**\n     * The serial number of the Asset Tag that is used to uniquely identify it.\n     */\n    serialNumber?: string | null;\n    assetTagType?: IdName;\n    /**\n     * The asset tag operation mode. Options are \\'movable\\' for movable assets, \\'fixed\\' for fixed assets and \\'stock\\' for temporary stock control uses.\n     */\n    mode?: AssetTagResponse.ModeEnum | null;\n    /**\n     * The current state of the object\n     */\n    state?: AssetTagResponse.StateEnum | null;\n    asset?: IdName;\n    fields?: { [key: string]: object; };\n    entity: EntityInfo;\n}\nexport namespace AssetTagResponse {\n    export type ModeEnum = 'movable' | 'fixed' | 'stock';\n    export const ModeEnum = {\n        Movable: 'movable' as ModeEnum,\n        Fixed: 'fixed' as ModeEnum,\n        Stock: 'stock' as ModeEnum\n    };\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface AssetTagUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A friendly name to identify this tag\n     */\n    name?: string | null;\n    /**\n     * The serial number of the Asset Tag that is used to uniquely identify it.\n     */\n    serialNumber?: string | null;\n    assetTagType?: IdName;\n    /**\n     * The asset tag operation mode. Options are \\'movable\\' for movable assets, \\'fixed\\' for fixed assets and \\'stock\\' for temporary stock control uses.\n     */\n    mode?: AssetTagUpdateRequest.ModeEnum | null;\n    /**\n     * The current state of the object\n     */\n    state?: AssetTagUpdateRequest.StateEnum | null;\n    asset?: IdName;\n    fields?: { [key: string]: object; };\n}\nexport namespace AssetTagUpdateRequest {\n    export type ModeEnum = 'movable' | 'fixed' | 'stock';\n    export const ModeEnum = {\n        Movable: 'movable' as ModeEnum,\n        Fixed: 'fixed' as ModeEnum,\n        Stock: 'stock' as ModeEnum\n    };\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AssetCounterValues } from './assetCounterValues';\nimport { AssetLocation } from './assetLocation';\nimport { IdName } from './idName';\nimport { AssetGeoLock } from './assetGeoLock';\nimport { AssetParameters } from './assetParameters';\nimport { AssetZoneTarget } from './assetZoneTarget';\nimport { Contact } from './contact';\n\nexport interface AssetUpdateRequest {\n  [key: string]: any | any;\n\n  /**\n   * A client unique name for this asset. This can be any value that is relevant for the client.\n   */\n  name?: string | null;\n  /**\n   * The name of the icon to use for the asset on the map. Manually added.\n   */\n  mapIconName?: string;\n  assetType?: IdName;\n  /**\n   * The color of the icon for this asset\n   */\n  color?: AssetUpdateRequest.ColorEnum | null;\n  tags?: Array<string> | null;\n  costCentre?: IdName;\n  ratingProfile?: IdName;\n  /**\n   * One or more asset state profiles to use for this asset\n   */\n  assetStateProfiles?: Array<IdName> | null;\n  overspeedProfile?: IdName;\n  geoLockProfile?: IdName;\n  roadProfile?: IdName;\n  /**\n   * One of more asset groups that this asset belongs to\n   */\n  groups?: Array<IdName> | null;\n  /**\n   * Up to 5 different categories that this asset belongs to\n   */\n  categories?: Array<IdName> | null;\n  /**\n   * One or more clients to which this asset has been shared.\n   */\n  sharedWith?: Array<IdName> | null;\n  assetTag?: IdName;\n  /**\n   * The current state of the asset object\n   */\n  state?: AssetUpdateRequest.StateEnum | null;\n  fields?: { [key: string]: object };\n  parameters?: AssetParameters;\n  geoLock?: AssetGeoLock;\n  /**\n   * One or more contacts that are relevant to this asset\n   */\n  contacts?: Array<Contact> | null;\n  location?: AssetLocation;\n  /**\n   * A list of zones and routes that are relevant to this asset\n   */\n  zones?: Array<AssetZoneTarget> | null;\n  /**\n   * A list of labels that will be applied to trips from this asset by default.\n   */\n  defaultTripLabels?: Array<string> | null;\n  counterValues?: AssetCounterValues;\n}\nexport namespace AssetUpdateRequest {\n  export type ColorEnum =\n    | 'blue'\n    | 'lightblue'\n    | 'green'\n    | 'olive'\n    | 'orange'\n    | 'pink'\n    | 'purple'\n    | 'red'\n    | 'teal'\n    | 'yellow'\n    | 'white'\n    | 'gray';\n  export const ColorEnum = {\n    Blue: 'blue' as ColorEnum,\n    Lightblue: 'lightblue' as ColorEnum,\n    Green: 'green' as ColorEnum,\n    Olive: 'olive' as ColorEnum,\n    Orange: 'orange' as ColorEnum,\n    Pink: 'pink' as ColorEnum,\n    Purple: 'purple' as ColorEnum,\n    Red: 'red' as ColorEnum,\n    Teal: 'teal' as ColorEnum,\n    Yellow: 'yellow' as ColorEnum,\n    White: 'white' as ColorEnum,\n    Gray: 'gray' as ColorEnum,\n  };\n  export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n  export const StateEnum = {\n    Inactive: 'inactive' as StateEnum,\n    Active: 'active' as StateEnum,\n    Suspended: 'suspended' as StateEnum,\n    Deleted: 'deleted' as StateEnum,\n  };\n}\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface AssetZoneTarget { \n  [key: string]: any | any;\n\n\n    zoneType?: AssetZoneTarget.ZoneTypeEnum | null;\n    targetSelectionType?: AssetZoneTarget.TargetSelectionTypeEnum | null;\n    targetId?: string | null;\n    targetName?: string | null;\n}\nexport namespace AssetZoneTarget {\n    export type ZoneTypeEnum = 'location' | 'keepin' | 'nogo' | 'route';\n    export const ZoneTypeEnum = {\n        Location: 'location' as ZoneTypeEnum,\n        Keepin: 'keepin' as ZoneTypeEnum,\n        Nogo: 'nogo' as ZoneTypeEnum,\n        Route: 'route' as ZoneTypeEnum\n    };\n    export type TargetSelectionTypeEnum = 'any' | 'group' | 'specific';\n    export const TargetSelectionTypeEnum = {\n        Any: 'any' as TargetSelectionTypeEnum,\n        Group: 'group' as TargetSelectionTypeEnum,\n        Specific: 'specific' as TargetSelectionTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AuditEventKeyValue } from './auditEventKeyValue';\n\n\nexport interface AuditEventChange { \n  [key: string]: any | any;\n\n\n    action: AuditEventChange.ActionEnum;\n    field: string;\n    name: string;\n    oldValue?: AuditEventKeyValue;\n    newValue?: AuditEventKeyValue;\n}\nexport namespace AuditEventChange {\n    export type ActionEnum = 'added' | 'modified' | 'removed';\n    export const ActionEnum = {\n        Added: 'added' as ActionEnum,\n        Modified: 'modified' as ActionEnum,\n        Removed: 'removed' as ActionEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AuditEventChange } from './auditEventChange';\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface AuditEventResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique ID for the event\n     */\n    id: string;\n    owner: IdNameType;\n    entity: IdNameType;\n    user: IdName;\n    /**\n     * The UTC date when the event was recorded in the system\n     */\n    date: string;\n    /**\n     * The class of the event\n     */\n    eventClass: string;\n    /**\n     * The type of event in the given class\n     */\n    eventType: AuditEventResponse.EventTypeEnum;\n    /**\n     * A list of changes that were applied\n     */\n    changes: Array<AuditEventChange>;\n}\nexport namespace AuditEventResponse {\n    export type EventTypeEnum = 'created' | 'modified' | 'deleted';\n    export const EventTypeEnum = {\n        Created: 'created' as EventTypeEnum,\n        Modified: 'modified' as EventTypeEnum,\n        Deleted: 'deleted' as EventTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface AuthEndpoint { \n  [key: string]: any | any;\n\n\n    /**\n     * The ID for the endpoint.\n     */\n    id: string;\n    /**\n     * Type type of endpoint\n     */\n    type: AuthEndpoint.TypeEnum;\n    /**\n     * A friendly name for the endpoint.\n     */\n    name: string;\n    /**\n     * The endpoint url, i.e. https://accounts.google.com\n     */\n    endpoint: string;\n    /**\n     * The endpoint client id\n     */\n    clientId: string;\n}\nexport namespace AuthEndpoint {\n    export type TypeEnum = 'local' | 'oidc';\n    export const TypeEnum = {\n        Local: 'local' as TypeEnum,\n        Oidc: 'oidc' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AuthEndpoint } from './authEndpoint';\n\n\nexport interface AuthInfo { \n  [key: string]: any | any;\n\n\n    /**\n     * The types of authentication that are available\n     */\n    availableAuth: Array<AuthInfo.AvailableAuthEnum>;\n    /**\n     * 3rd party endpoints which can handle authentication\n     */\n    endpoints: Array<AuthEndpoint>;\n}\nexport namespace AuthInfo {\n    export type AvailableAuthEnum = 'local' | 'oidc';\n    export const AvailableAuthEnum = {\n        Local: 'local' as AvailableAuthEnum,\n        Oidc: 'oidc' as AvailableAuthEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface CalculatedMeasure { \n  [key: string]: any | any;\n\n\n    id: string;\n    name: string;\n    expression: string;\n    average: boolean;\n    total: boolean;\n    format: CalculatedMeasure.FormatEnum;\n}\nexport namespace CalculatedMeasure {\n    export type FormatEnum = 'distance' | 'speed' | 'volume' | 'number' | 'integer' | 'duration' | 'consumption' | 'distanceRate';\n    export const FormatEnum = {\n        Distance: 'distance' as FormatEnum,\n        Speed: 'speed' as FormatEnum,\n        Volume: 'volume' as FormatEnum,\n        Number: 'number' as FormatEnum,\n        Integer: 'integer' as FormatEnum,\n        Duration: 'duration' as FormatEnum,\n        Consumption: 'consumption' as FormatEnum,\n        DistanceRate: 'distanceRate' as FormatEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ColumnFormatting } from './columnFormatting';\n\n\nexport interface CellProperties { \n  [key: string]: any | any;\n\n\n    raw?: object | null;\n    format?: ColumnFormatting;\n    doNotShowOnChart?: boolean | null;\n    type: CellProperties.TypeEnum;\n    seriesKey?: string | null;\n    uniquename?: string | null;\n    dimension?: string | null;\n    level?: string | null;\n}\nexport namespace CellProperties {\n    export type TypeEnum = 'average' | 'max' | 'min' | 'total' | 'data';\n    export const TypeEnum = {\n        Average: 'average' as TypeEnum,\n        Max: 'max' as TypeEnum,\n        Min: 'min' as TypeEnum,\n        Total: 'total' as TypeEnum,\n        Data: 'data' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { CellSetFilters } from './cellSetFilters';\nimport { CellSetAverage } from './cellSetAverage';\nimport { CellValue } from './cellValue';\n\n\nexport interface CellSet { \n  [key: string]: any | any;\n\n\n    rowLevels: number;\n    filters: CellSetFilters;\n    average?: CellSetAverage;\n    cellset: Array<Array<CellValue>>;\n    status: CellSet.StatusEnum;\n}\nexport namespace CellSet {\n    export type StatusEnum = 'error' | 'running' | 'generating' | 'completed';\n    export const StatusEnum = {\n        Error: 'error' as StatusEnum,\n        Running: 'running' as StatusEnum,\n        Generating: 'generating' as StatusEnum,\n        Completed: 'completed' as StatusEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { CellProperties } from './cellProperties';\n\n\nexport interface CellValue { \n  [key: string]: any | any;\n\n\n    value: object;\n    type: CellValue.TypeEnum;\n    properties: CellProperties;\n}\nexport namespace CellValue {\n    export type TypeEnum = 'DATA_CELL' | 'ROW_HEADER' | 'ROW_HEADER_HEADER' | 'COLUMN_HEADER' | 'COLUMN_HEADER_HEADER';\n    export const TypeEnum = {\n        DataCell: 'DATA_CELL' as TypeEnum,\n        RowHeader: 'ROW_HEADER' as TypeEnum,\n        RowHeaderHeader: 'ROW_HEADER_HEADER' as TypeEnum,\n        ColumnHeader: 'COLUMN_HEADER' as TypeEnum,\n        ColumnHeaderHeader: 'COLUMN_HEADER_HEADER' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { TargetLine } from './targetLine';\n\n\nexport interface ChartSeriesItem { \n  [key: string]: any | any;\n\n\n    visible: boolean;\n    average?: boolean | null;\n    type: string;\n    orientation?: ChartSeriesItem.OrientationEnum | null;\n    fill?: boolean | null;\n    color?: string | null;\n    yAxis?: ChartSeriesItem.YAxisEnum | null;\n    targetLines?: Array<TargetLine> | null;\n}\nexport namespace ChartSeriesItem {\n    export type OrientationEnum = 'horizontal' | 'vertical';\n    export const OrientationEnum = {\n        Horizontal: 'horizontal' as OrientationEnum,\n        Vertical: 'vertical' as OrientationEnum\n    };\n    export type YAxisEnum = 'left' | 'right';\n    export const YAxisEnum = {\n        Left: 'left' as YAxisEnum,\n        Right: 'right' as YAxisEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface ChartXAxisLabels { \n  [key: string]: any | any;\n\n\n    layout: ChartXAxisLabels.LayoutEnum;\n}\nexport namespace ChartXAxisLabels {\n    export type LayoutEnum = 'horizontal' | 'auto';\n    export const LayoutEnum = {\n        Horizontal: 'horizontal' as LayoutEnum,\n        Auto: 'auto' as LayoutEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { ClientMeasurementUnits } from './clientMeasurementUnits';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { ShiftPattern } from './shiftPattern';\nimport { IdName } from './idName';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { ClientMeta } from './clientMeta';\nimport { EntityInfo } from './entityInfo';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\n/**\n * The ClientCreateRequest is used to create a new entity.\n */\nexport interface ClientCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: ClientCreateRequest.StateEnum | null;\n    entity?: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    mapSet?: IdName;\n    features?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * A user friendly pin that uniquely identifies this client.\n     */\n    pin?: string | null;\n    /**\n     * The group that this client belongs to\n     */\n    group?: string | null;\n    /**\n     * UUID\\'s of the device types that this client is allowed to use. An empty list means all device types.\n     */\n    availableDeviceTypes?: Array<IdName> | null;\n    meta?: ClientMeta;\n    shiftPattern?: ShiftPattern;\n    measurementUnits?: ClientMeasurementUnits;\n    ownerId: string;\n}\nexport namespace ClientCreateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\n/**\n * Summary client information returned in lists.\n */\nexport interface ClientListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The client\\'s unique UUID\n     */\n    id: string;\n    /**\n     * The client\\'s display name\n     */\n    name: string;\n    /**\n     * The client website (if available)\n     */\n    website: string;\n    owner: IdName;\n    /**\n     * The group to which this client belongs.\n     */\n    group: string;\n    /**\n     * The state of this client.\n     */\n    state: ClientListItem.StateEnum;\n    counts?: { [key: string]: number; };\n    /**\n     * The date this client was created.\n     */\n    creationDate: string;\n    /**\n     * The date that this client was last modified.\n     */\n    modifiedDate: string;\n}\nexport namespace ClientListItem {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface ClientMeasurementUnits { \n  [key: string]: any | any;\n\n\n    distanceUnit?: ClientMeasurementUnits.DistanceUnitEnum | null;\n    altitudeUnit?: ClientMeasurementUnits.AltitudeUnitEnum | null;\n    speedUnit?: ClientMeasurementUnits.SpeedUnitEnum | null;\n    areaUnit?: ClientMeasurementUnits.AreaUnitEnum | null;\n    volumeUnit?: ClientMeasurementUnits.VolumeUnitEnum | null;\n    weightUnit?: ClientMeasurementUnits.WeightUnitEnum | null;\n    timeUnit?: ClientMeasurementUnits.TimeUnitEnum | null;\n    dateUnit?: ClientMeasurementUnits.DateUnitEnum | null;\n    temperatureUnit?: ClientMeasurementUnits.TemperatureUnitEnum | null;\n}\nexport namespace ClientMeasurementUnits {\n    export type DistanceUnitEnum = 'kilometres' | 'metres' | 'feet' | 'inches' | 'miles' | 'nauticalMiles' | 'yards';\n    export const DistanceUnitEnum = {\n        Kilometres: 'kilometres' as DistanceUnitEnum,\n        Metres: 'metres' as DistanceUnitEnum,\n        Feet: 'feet' as DistanceUnitEnum,\n        Inches: 'inches' as DistanceUnitEnum,\n        Miles: 'miles' as DistanceUnitEnum,\n        NauticalMiles: 'nauticalMiles' as DistanceUnitEnum,\n        Yards: 'yards' as DistanceUnitEnum\n    };\n    export type AltitudeUnitEnum = 'metres' | 'kilometres' | 'feet' | 'inches' | 'miles' | 'nauticalMiles' | 'yards';\n    export const AltitudeUnitEnum = {\n        Metres: 'metres' as AltitudeUnitEnum,\n        Kilometres: 'kilometres' as AltitudeUnitEnum,\n        Feet: 'feet' as AltitudeUnitEnum,\n        Inches: 'inches' as AltitudeUnitEnum,\n        Miles: 'miles' as AltitudeUnitEnum,\n        NauticalMiles: 'nauticalMiles' as AltitudeUnitEnum,\n        Yards: 'yards' as AltitudeUnitEnum\n    };\n    export type SpeedUnitEnum = 'kilometresPerHour' | 'metresPerSecond' | 'milesPerHour' | 'knots';\n    export const SpeedUnitEnum = {\n        KilometresPerHour: 'kilometresPerHour' as SpeedUnitEnum,\n        MetresPerSecond: 'metresPerSecond' as SpeedUnitEnum,\n        MilesPerHour: 'milesPerHour' as SpeedUnitEnum,\n        Knots: 'knots' as SpeedUnitEnum\n    };\n    export type AreaUnitEnum = 'squareKilometres' | 'acres' | 'hectares' | 'squareFeet' | 'squaremetres' | 'squareInches' | 'squareMiles' | 'squareYards';\n    export const AreaUnitEnum = {\n        SquareKilometres: 'squareKilometres' as AreaUnitEnum,\n        Acres: 'acres' as AreaUnitEnum,\n        Hectares: 'hectares' as AreaUnitEnum,\n        SquareFeet: 'squareFeet' as AreaUnitEnum,\n        Squaremetres: 'squaremetres' as AreaUnitEnum,\n        SquareInches: 'squareInches' as AreaUnitEnum,\n        SquareMiles: 'squareMiles' as AreaUnitEnum,\n        SquareYards: 'squareYards' as AreaUnitEnum\n    };\n    export type VolumeUnitEnum = 'litres' | 'cubicmetres' | 'cubicFeet' | 'gallons' | 'ounces' | 'gallonsUs' | 'ouncesUs';\n    export const VolumeUnitEnum = {\n        Litres: 'litres' as VolumeUnitEnum,\n        Cubicmetres: 'cubicmetres' as VolumeUnitEnum,\n        CubicFeet: 'cubicFeet' as VolumeUnitEnum,\n        Gallons: 'gallons' as VolumeUnitEnum,\n        Ounces: 'ounces' as VolumeUnitEnum,\n        GallonsUs: 'gallonsUs' as VolumeUnitEnum,\n        OuncesUs: 'ouncesUs' as VolumeUnitEnum\n    };\n    export type WeightUnitEnum = 'kilograms' | 'ounces' | 'pounds' | 'tonnes';\n    export const WeightUnitEnum = {\n        Kilograms: 'kilograms' as WeightUnitEnum,\n        Ounces: 'ounces' as WeightUnitEnum,\n        Pounds: 'pounds' as WeightUnitEnum,\n        Tonnes: 'tonnes' as WeightUnitEnum\n    };\n    export type TimeUnitEnum = 'HHmmss' | 'Hmmss' | 'hmmssa';\n    export const TimeUnitEnum = {\n        HHmmss: 'HHmmss' as TimeUnitEnum,\n        Hmmss: 'Hmmss' as TimeUnitEnum,\n        Hmmssa: 'hmmssa' as TimeUnitEnum\n    };\n    export type DateUnitEnum = 'yyyymmdd1' | 'yyyymmdd2' | 'yyyymmdd3' | 'ddmmyyyy1' | 'ddmmyyyy2' | 'ddmmyyyy3' | 'dmyyyy1' | 'dmyyyy2' | 'dmyyyy3' | 'mmddyyyy1' | 'mdyyyy1';\n    export const DateUnitEnum = {\n        Yyyymmdd1: 'yyyymmdd1' as DateUnitEnum,\n        Yyyymmdd2: 'yyyymmdd2' as DateUnitEnum,\n        Yyyymmdd3: 'yyyymmdd3' as DateUnitEnum,\n        Ddmmyyyy1: 'ddmmyyyy1' as DateUnitEnum,\n        Ddmmyyyy2: 'ddmmyyyy2' as DateUnitEnum,\n        Ddmmyyyy3: 'ddmmyyyy3' as DateUnitEnum,\n        Dmyyyy1: 'dmyyyy1' as DateUnitEnum,\n        Dmyyyy2: 'dmyyyy2' as DateUnitEnum,\n        Dmyyyy3: 'dmyyyy3' as DateUnitEnum,\n        Mmddyyyy1: 'mmddyyyy1' as DateUnitEnum,\n        Mdyyyy1: 'mdyyyy1' as DateUnitEnum\n    };\n    export type TemperatureUnitEnum = 'celsius' | 'fahrenheit';\n    export const TemperatureUnitEnum = {\n        Celsius: 'celsius' as TemperatureUnitEnum,\n        Fahrenheit: 'fahrenheit' as TemperatureUnitEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { ClientMeasurementUnits } from './clientMeasurementUnits';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { ShiftPattern } from './shiftPattern';\nimport { IdName } from './idName';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { ClientMeta } from './clientMeta';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\n/**\n * The ClientResponse contains details for a client entity.\n */\nexport interface ClientResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: ClientResponse.StateEnum | null;\n    entity: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    mapSet?: IdName;\n    features?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * A user friendly pin that uniquely identifies this client.\n     */\n    pin?: string | null;\n    /**\n     * The group that this client belongs to\n     */\n    group?: string | null;\n    /**\n     * UUID\\'s of the device types that this client is allowed to use. An empty list means all device types.\n     */\n    availableDeviceTypes?: Array<IdName> | null;\n    meta?: ClientMeta;\n    shiftPattern?: ShiftPattern;\n    measurementUnits?: ClientMeasurementUnits;\n}\nexport namespace ClientResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { ClientMeasurementUnits } from './clientMeasurementUnits';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { ShiftPattern } from './shiftPattern';\nimport { IdName } from './idName';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { ClientMeta } from './clientMeta';\nimport { EntityInfo } from './entityInfo';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\n/**\n * The ClientUpdateRequest is used to update an existing entity. All fields are optional and can be individually supplied to the update method.\n */\nexport interface ClientUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: ClientUpdateRequest.StateEnum | null;\n    entity?: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    mapSet?: IdName;\n    features?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * A user friendly pin that uniquely identifies this client.\n     */\n    pin?: string | null;\n    /**\n     * The group that this client belongs to\n     */\n    group?: string | null;\n    /**\n     * UUID\\'s of the device types that this client is allowed to use. An empty list means all device types.\n     */\n    availableDeviceTypes?: Array<IdName> | null;\n    meta?: ClientMeta;\n    shiftPattern?: ShiftPattern;\n    measurementUnits?: ClientMeasurementUnits;\n}\nexport namespace ClientUpdateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\n\n\nexport interface CompanyDataRetentionSettings { \n  [key: string]: any | any;\n\n\n    source?: IdNameType;\n    /**\n     * The amount of days, months or years to retain data for\n     */\n    retainFor?: number | null;\n    /**\n     * The unit of the retainFor value\n     */\n    retainForUnit?: CompanyDataRetentionSettings.RetainForUnitEnum | null;\n    /**\n     * [READ-ONLY] The current event horizon before which all data will be deleted\n     */\n    horizonDate?: string | null;\n}\nexport namespace CompanyDataRetentionSettings {\n    export type RetainForUnitEnum = 'days' | 'months' | 'years';\n    export const RetainForUnitEnum = {\n        Days: 'days' as RetainForUnitEnum,\n        Months: 'months' as RetainForUnitEnum,\n        Years: 'years' as RetainForUnitEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\nexport interface CompanyResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: CompanyResponse.StateEnum | null;\n    entity?: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    /**\n     * The type of company\n     */\n    type: CompanyResponse.TypeEnum;\n}\nexport namespace CompanyResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type TypeEnum = 'distributor' | 'vendor' | 'client';\n    export const TypeEnum = {\n        Distributor: 'distributor' as TypeEnum,\n        Vendor: 'vendor' as TypeEnum,\n        Client: 'client' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ReportConfig } from './reportConfig';\nimport { IdNameType } from './idNameType';\nimport { ReportOutputOptions } from './reportOutputOptions';\n\n\nexport interface CompletedReportResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique ID of this report definition\n     */\n    id: string;\n    owner: IdNameType;\n    user: IdName;\n    client: IdName;\n    /**\n     * The base report name\n     */\n    name: string;\n    /**\n     * The report title as set by the user\n     */\n    title: string;\n    /**\n     * The reporting subsystem that generates this report\n     */\n    source: CompletedReportResponse.SourceEnum;\n    /**\n     * The status of this report\n     */\n    status: CompletedReportResponse.StatusEnum;\n    /**\n     * The ISO date/time that this report was queued\n     */\n    queueDate: string;\n    /**\n     * The ISO date/time that this report\\'s state last changed\n     */\n    updateDate: string;\n    /**\n     * The output format for this report\n     */\n    outputFormat: CompletedReportResponse.OutputFormatEnum;\n    /**\n     * The progress percentage of this report\n     */\n    progress: number;\n    /**\n     * report queue order, will change sometimes while queued\n     */\n    order: number;\n    /**\n     * The report priority: 0 = urgent, 1 = high, 2 = normal, 3 = low, 4+ = none (sorted as an integer)\n     */\n    priority: number;\n    config: ReportConfig;\n    /**\n     * What triggered the report\n     */\n    triggeredBy: CompletedReportResponse.TriggeredByEnum;\n    /**\n     * The UUID of a base report in analytics (if any) this report is linked to\n     */\n    baseReportId?: string | null;\n    outputOptions?: ReportOutputOptions;\n}\nexport namespace CompletedReportResponse {\n    export type SourceEnum = 'dataset' | 'analytics';\n    export const SourceEnum = {\n        Dataset: 'dataset' as SourceEnum,\n        Analytics: 'analytics' as SourceEnum\n    };\n    export type StatusEnum = 'queued' | 'running' | 'completed' | 'aborted' | 'failed' | 'retry';\n    export const StatusEnum = {\n        Queued: 'queued' as StatusEnum,\n        Running: 'running' as StatusEnum,\n        Completed: 'completed' as StatusEnum,\n        Aborted: 'aborted' as StatusEnum,\n        Failed: 'failed' as StatusEnum,\n        Retry: 'retry' as StatusEnum\n    };\n    export type OutputFormatEnum = 'pdf' | 'xlsx' | 'xml' | 'csv' | 'raw' | 'json' | 'raw_compact' | 'source';\n    export const OutputFormatEnum = {\n        Pdf: 'pdf' as OutputFormatEnum,\n        Xlsx: 'xlsx' as OutputFormatEnum,\n        Xml: 'xml' as OutputFormatEnum,\n        Csv: 'csv' as OutputFormatEnum,\n        Raw: 'raw' as OutputFormatEnum,\n        Json: 'json' as OutputFormatEnum,\n        RawCompact: 'raw_compact' as OutputFormatEnum,\n        Source: 'source' as OutputFormatEnum\n    };\n    export type TriggeredByEnum = 'user' | 'schedule' | 'dashboard';\n    export const TriggeredByEnum = {\n        User: 'user' as TriggeredByEnum,\n        Schedule: 'schedule' as TriggeredByEnum,\n        Dashboard: 'dashboard' as TriggeredByEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * Contacts can be assigned to assets and will be displayed along side any asset related information.\n */\nexport interface Contact { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique id for this contact\n     */\n    id: string;\n    /**\n     * The type of contact\n     */\n    type: Contact.TypeEnum;\n    /**\n     * The name of the contact person or company\n     */\n    name: string;\n    /**\n     * The contact person\\'s email address\n     */\n    emailAddress?: string | null;\n    /**\n     * The mobile phone number of the contact\n     */\n    phoneMobile?: string | null;\n    /**\n     * An optional office number for the contact\n     */\n    phoneOffice?: string | null;\n    /**\n     * Any notes regarding this contact\n     */\n    notes?: string | null;\n}\nexport namespace Contact {\n    export type TypeEnum = 'emergency' | 'administrative' | 'technical' | 'operational' | 'management' | 'owner';\n    export const TypeEnum = {\n        Emergency: 'emergency' as TypeEnum,\n        Administrative: 'administrative' as TypeEnum,\n        Technical: 'technical' as TypeEnum,\n        Operational: 'operational' as TypeEnum,\n        Management: 'management' as TypeEnum,\n        Owner: 'owner' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DashboardWidget } from './dashboardWidget';\n\n\nexport interface DashboardCreateRequest { \n  [key: string]: any | any;\n\n\n    user?: IdName;\n    /**\n     * The name of the dashboard.\n     */\n    name?: string | null;\n    /**\n     * A short description of the dashboard.\n     */\n    description: string;\n    /**\n     * Whether or not other users can see the dashboard\n     */\n    'public'?: boolean | null;\n    options?: { [key: string]: { [key: string]: any; }; };\n    widgets?: { [key: string]: DashboardWidget; };\n    parent?: IdName;\n    source?: IdName;\n    /**\n     * The company level of the dashboard target audience\n     */\n    level: DashboardCreateRequest.LevelEnum;\n    ownerId: string;\n    costCentre?: IdName;\n}\nexport namespace DashboardCreateRequest {\n    export type LevelEnum = 'system' | 'distributor' | 'vendor' | 'client';\n    export const LevelEnum = {\n        System: 'system' as LevelEnum,\n        Distributor: 'distributor' as LevelEnum,\n        Vendor: 'vendor' as LevelEnum,\n        Client: 'client' as LevelEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface DashboardListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID for this Dashboard\n     */\n    id: string;\n    owner: IdNameType;\n    parent?: IdName;\n    source?: IdName;\n    costCentre?: IdName;\n    /**\n     * The company level the dashboard is intended for\n     */\n    level?: DashboardListItem.LevelEnum | null;\n    user: IdName;\n    /**\n     * The name of the dashboard.\n     */\n    name: string;\n    /**\n     * Whethere or not other users can see the dashboard\n     */\n    'public': boolean;\n    /**\n     * A short description of the dashboard.\n     */\n    description: string;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace DashboardListItem {\n    export type LevelEnum = 'system' | 'distributor' | 'vendor' | 'client';\n    export const LevelEnum = {\n        System: 'system' as LevelEnum,\n        Distributor: 'distributor' as LevelEnum,\n        Vendor: 'vendor' as LevelEnum,\n        Client: 'client' as LevelEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DashboardWidget } from './dashboardWidget';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface DashboardResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    user?: IdName;\n    /**\n     * The name of the dashboard.\n     */\n    name?: string | null;\n    /**\n     * A short description of the dashboard.\n     */\n    description?: string | null;\n    /**\n     * Whether or not other users can see the dashboard\n     */\n    'public'?: boolean | null;\n    options?: { [key: string]: { [key: string]: any; }; };\n    widgets?: { [key: string]: DashboardWidget; };\n    parent?: IdName;\n    source?: IdName;\n    /**\n     * The company level of the dashboard target audience\n     */\n    level?: DashboardResponse.LevelEnum | null;\n    costCentre?: IdName;\n    entity: EntityInfo;\n}\nexport namespace DashboardResponse {\n    export type LevelEnum = 'system' | 'distributor' | 'vendor' | 'client';\n    export const LevelEnum = {\n        System: 'system' as LevelEnum,\n        Distributor: 'distributor' as LevelEnum,\n        Vendor: 'vendor' as LevelEnum,\n        Client: 'client' as LevelEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface DashboardTemplateListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID for this Dashboard\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The state of the entity\n     */\n    state: DashboardTemplateListItem.StateEnum;\n    user: IdName;\n    /**\n     * The name of the dashboard.\n     */\n    name: string;\n    /**\n     * A short description of the dashboard.\n     */\n    description: string;\n    /**\n     * Determines if the dashboard can be added by downstream users\n     */\n    'public'?: boolean | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace DashboardTemplateListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DashboardWidget } from './dashboardWidget';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface DashboardTemplateResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    user?: IdName;\n    /**\n     * The name of the dashboard.\n     */\n    name?: string | null;\n    /**\n     * A short description of the dashboard.\n     */\n    description?: string | null;\n    /**\n     * Determines if the template can be added by downstream users\n     */\n    'public'?: boolean | null;\n    options?: { [key: string]: { [key: string]: any; }; };\n    widgets?: { [key: string]: DashboardWidget; };\n    /**\n     * The state of dashboard template\n     */\n    state?: DashboardTemplateResponse.StateEnum | null;\n    entity: EntityInfo;\n}\nexport namespace DashboardTemplateResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DashboardWidget } from './dashboardWidget';\n\n\nexport interface DashboardTemplateUpdateRequest { \n  [key: string]: any | any;\n\n\n    user?: IdName;\n    /**\n     * The name of the dashboard.\n     */\n    name?: string | null;\n    /**\n     * A short description of the dashboard.\n     */\n    description?: string | null;\n    /**\n     * Determines if the template can be added by downstream users\n     */\n    'public'?: boolean | null;\n    options?: { [key: string]: { [key: string]: any; }; };\n    widgets?: { [key: string]: DashboardWidget; };\n    /**\n     * The state of dashboard template\n     */\n    state?: DashboardTemplateUpdateRequest.StateEnum | null;\n}\nexport namespace DashboardTemplateUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DashboardWidget } from './dashboardWidget';\n\n\nexport interface DashboardUpdateRequest { \n  [key: string]: any | any;\n\n\n    user?: IdName;\n    /**\n     * The name of the dashboard.\n     */\n    name?: string | null;\n    /**\n     * A short description of the dashboard.\n     */\n    description?: string | null;\n    /**\n     * Whether or not other users can see the dashboard\n     */\n    'public'?: boolean | null;\n    options?: { [key: string]: { [key: string]: any; }; };\n    widgets?: { [key: string]: DashboardWidget; };\n    parent?: IdName;\n    source?: IdName;\n    /**\n     * The company level of the dashboard target audience\n     */\n    level?: DashboardUpdateRequest.LevelEnum | null;\n}\nexport namespace DashboardUpdateRequest {\n    export type LevelEnum = 'system' | 'distributor' | 'vendor' | 'client';\n    export const LevelEnum = {\n        System: 'system' as LevelEnum,\n        Distributor: 'distributor' as LevelEnum,\n        Vendor: 'vendor' as LevelEnum,\n        Client: 'client' as LevelEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { DashboardWidgetDataSource } from './dashboardWidgetDataSource';\nimport { DashboardWidgetPlacement } from './dashboardWidgetPlacement';\nimport { WidgetOptions } from './widgetOptions';\n\n\nexport interface DashboardWidget { \n  [key: string]: any | any;\n\n\n    /**\n     * Inherited widgets are tied to a parent dashboard and cannot have their `widgetType` or `options` modified, as  they are tracked with the parent dashboard widget.\n     */\n    inherited?: boolean | null;\n    /**\n     * If a widget was cloned from another widget, the ID of the source widget will be stored here.\n     */\n    sourceId?: string | null;\n    /**\n     * The name of the widget.\n     */\n    name?: string | null;\n    /**\n     * A short description of the widget.\n     */\n    description?: string | null;\n    /**\n     * The type of widget\n     */\n    widgetType?: DashboardWidget.WidgetTypeEnum | null;\n    options?: WidgetOptions;\n    /**\n     * Should the widget be displayed on the dashboard or not.\n     */\n    hidden?: boolean | null;\n    placement?: DashboardWidgetPlacement;\n    dataSource?: DashboardWidgetDataSource;\n}\nexport namespace DashboardWidget {\n    export type WidgetTypeEnum = 'chart' | 'grid' | 'text' | 'stat' | 'pie';\n    export const WidgetTypeEnum = {\n        Chart: 'chart' as WidgetTypeEnum,\n        Grid: 'grid' as WidgetTypeEnum,\n        Text: 'text' as WidgetTypeEnum,\n        Stat: 'stat' as WidgetTypeEnum,\n        Pie: 'pie' as WidgetTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { DashboardWidgetDataSourceOptions } from './dashboardWidgetDataSourceOptions';\nimport { WidgetExtraData } from './widgetExtraData';\n\n\nexport interface DashboardWidgetDataSource { \n  [key: string]: any | any;\n\n\n    id?: string | null;\n    type: DashboardWidgetDataSource.TypeEnum;\n    options: DashboardWidgetDataSourceOptions;\n    data?: WidgetExtraData;\n}\nexport namespace DashboardWidgetDataSource {\n    export type TypeEnum = 'analytics-report' | 'analytics-mock';\n    export const TypeEnum = {\n        Report: 'analytics-report' as TypeEnum,\n        Mock: 'analytics-mock' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * The DeviceBitmapConfiguration is used to pick out specific bits from a telemetry value and create a new  telemetry input with the extracted value. target_input = (source_input >> bitshift) & bitmask For example, to get the 3rd bit (indexed as 2) as a digital input (0 or 1), you\\'d specify: target_input = (source_input >> 2) & 0x01\n */\nexport interface DeviceBitmapConfiguration { \n  [key: string]: any | any;\n\n\n    /**\n     * The source input from which to retreive the source value\n     */\n    source_input: string;\n    /**\n     * The number of bits to be shifted right in the source value\n     */\n    bitshift: number;\n    /**\n     * The bitmask to be applied to after shifting\n     */\n    bitmask: number;\n    /**\n     * The new input that will store the resulting value\n     */\n    target_input: string;\n    /**\n     * The IO type of the new value\n     */\n    target_type: DeviceBitmapConfiguration.TargetTypeEnum;\n}\nexport namespace DeviceBitmapConfiguration {\n    export type TargetTypeEnum = 'digital_input' | 'digital_output' | 'can_input' | 'value_input';\n    export const TargetTypeEnum = {\n        DigitalInput: 'digital_input' as TargetTypeEnum,\n        DigitalOutput: 'digital_output' as TargetTypeEnum,\n        CanInput: 'can_input' as TargetTypeEnum,\n        ValueInput: 'value_input' as TargetTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DeviceAccessory } from './deviceAccessory';\nimport { DeviceParameters } from './deviceParameters';\n\n\nexport interface DeviceConfigProfileCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: DeviceConfigProfileCreateRequest.StateEnum | null;\n    deviceType?: IdName;\n    parameters?: DeviceParameters;\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * Device accessories add extra optional functionality to a device.\n     */\n    accessories?: { [key: string]: DeviceAccessory; };\n    /**\n     * The client that owns this DeviceConfig Profile\n     */\n    ownerId: string;\n}\nexport namespace DeviceConfigProfileCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface DeviceConfigProfileListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: DeviceConfigProfileListItem.StateEnum | null;\n    deviceType?: IdName;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace DeviceConfigProfileListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { DeviceAccessory } from './deviceAccessory';\nimport { IdNameType } from './idNameType';\nimport { DeviceParameters } from './deviceParameters';\n\n\nexport interface DeviceConfigProfileResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: DeviceConfigProfileResponse.StateEnum | null;\n    deviceType?: IdName;\n    parameters?: DeviceParameters;\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * Device accessories add extra optional functionality to a device.\n     */\n    accessories?: { [key: string]: DeviceAccessory; };\n    entity: EntityInfo;\n    features?: { [key: string]: { [key: string]: any; }; };\n}\nexport namespace DeviceConfigProfileResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DeviceAccessory } from './deviceAccessory';\nimport { DeviceParameters } from './deviceParameters';\n\n\nexport interface DeviceConfigProfileUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: DeviceConfigProfileUpdateRequest.StateEnum | null;\n    deviceType?: IdName;\n    parameters?: DeviceParameters;\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * Device accessories add extra optional functionality to a device.\n     */\n    accessories?: { [key: string]: DeviceAccessory; };\n}\nexport namespace DeviceConfigProfileUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DeviceAccessory } from './deviceAccessory';\nimport { DeviceParameters } from './deviceParameters';\n\n\nexport interface DeviceCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The serial or IMEI of the device that is used to uniquely identify it. The value used will depend on the device type.\n     */\n    name?: string | null;\n    /**\n     * The current state of the device object\n     */\n    state?: DeviceCreateRequest.StateEnum | null;\n    deviceType: IdName;\n    provider?: IdName;\n    asset?: IdName;\n    simcard?: IdName;\n    configProfile?: IdName;\n    parameters?: DeviceParameters;\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * Device accessories add extra optional functionality to a device.\n     */\n    accessories?: { [key: string]: DeviceAccessory; };\n    fields?: { [key: string]: object; };\n    ownerId: string;\n}\nexport namespace DeviceCreateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface DeviceListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID for this device\n     */\n    id: string;\n    /**\n     * The serial or IMEI of the device that is used to uniquely identify it. The value used will depend on the device type.\n     */\n    name: string;\n    owner: IdName;\n    deviceType?: IdName;\n    provider?: IdName;\n    asset?: IdName;\n    simcard?: IdName;\n    configProfile?: IdName;\n    fields: { [key: string]: object; };\n    /**\n     * The current state of the device object\n     */\n    state: DeviceListItem.StateEnum;\n}\nexport namespace DeviceListItem {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface DeviceProviderCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The name of the device provider.\n     */\n    name?: string | null;\n    /**\n     * The current state of the device provider object\n     */\n    state?: DeviceProviderCreateRequest.StateEnum | null;\n    deviceProviderType?: IdName;\n    ownerId: string;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n}\nexport namespace DeviceProviderCreateRequest {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface DeviceProviderListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the device provider.\n     */\n    name?: string | null;\n    /**\n     * The current state of the device provider object\n     */\n    state?: DeviceProviderListItem.StateEnum | null;\n    deviceProviderType?: IdName;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace DeviceProviderListItem {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface DeviceProviderResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the device provider.\n     */\n    name?: string | null;\n    /**\n     * The current state of the device provider object\n     */\n    state?: DeviceProviderResponse.StateEnum | null;\n    deviceProviderType?: IdName;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n    entity: EntityInfo;\n}\nexport namespace DeviceProviderResponse {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\n\n\nexport interface DeviceProviderTypeListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique ID of this device provider type\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name: string;\n    /**\n     * A unique tag for this entity\n     */\n    tag: string;\n    /**\n     * The company types that this provider type can be instantiated in. Valid values are \\'client\\', \\'vendor\\' and \\'distributor\\'\n     */\n    companyTypes: Array<string>;\n    /**\n     * The current state of the object\n     */\n    state?: DeviceProviderTypeListItem.StateEnum | null;\n}\nexport namespace DeviceProviderTypeListItem {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\n\n\nexport interface DeviceProviderTypeResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique ID of this device provider type\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name: string;\n    /**\n     * A unique tag for this entity\n     */\n    tag: string;\n    /**\n     * The company types that this provider type can be instantiated in. Valid values are \\'client\\', \\'vendor\\' and \\'distributor\\'\n     */\n    companyTypes: Array<string>;\n    /**\n     * The current state of the object\n     */\n    state?: DeviceProviderTypeResponse.StateEnum | null;\n    /**\n     * A JSON string that describes the parameter input fields for this device provider type\n     */\n    parameters: string;\n}\nexport namespace DeviceProviderTypeResponse {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface DeviceProviderUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The name of the device provider.\n     */\n    name?: string | null;\n    /**\n     * The current state of the device provider object\n     */\n    state?: DeviceProviderUpdateRequest.StateEnum | null;\n    deviceProviderType?: IdName;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n}\nexport namespace DeviceProviderUpdateRequest {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { DeviceAccessory } from './deviceAccessory';\nimport { IdNameType } from './idNameType';\nimport { DeviceParameters } from './deviceParameters';\n\n\nexport interface DeviceResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The serial or IMEI of the device that is used to uniquely identify it. The value used will depend on the device type.\n     */\n    name?: string | null;\n    /**\n     * The current state of the device object\n     */\n    state?: DeviceResponse.StateEnum | null;\n    deviceType?: IdName;\n    provider?: IdName;\n    asset?: IdName;\n    simcard?: IdName;\n    configProfile?: IdName;\n    parameters?: DeviceParameters;\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * Device accessories add extra optional functionality to a device.\n     */\n    accessories?: { [key: string]: DeviceAccessory; };\n    fields?: { [key: string]: object; };\n    features?: { [key: string]: { [key: string]: any; }; };\n    entity: EntityInfo;\n}\nexport namespace DeviceResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DeviceTypeAccessory } from './deviceTypeAccessory';\nimport { DeviceTypeFeature } from './deviceTypeFeature';\nimport { DeviceTypeIOCapabilities } from './deviceTypeIOCapabilities';\n\n\nexport interface DeviceTypeCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * A short name for this device type (usually just a model number)\n     */\n    shortName?: string | null;\n    parent?: IdName;\n    /**\n     * A unique tag for this entity\n     */\n    tag?: string | null;\n    /**\n     * The current state of the device type object\n     */\n    state?: DeviceTypeCreateRequest.StateEnum | null;\n    deviceProviderType?: IdName;\n    ioCapabilities?: DeviceTypeIOCapabilities;\n    /**\n     * A form definition for custom settings in this device type\n     */\n    settingsDefinition?: string | null;\n    accessories?: { [key: string]: DeviceTypeAccessory; };\n    features?: { [key: string]: DeviceTypeFeature; };\n    ownerId: string;\n}\nexport namespace DeviceTypeCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface DeviceTypeListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * A short name for this device type (usually just a model number)\n     */\n    shortName?: string | null;\n    parent?: IdName;\n    /**\n     * A unique tag for this entity\n     */\n    tag?: string | null;\n    /**\n     * The current state of the device type object\n     */\n    state?: DeviceTypeListItem.StateEnum | null;\n    deviceProviderType?: IdName;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace DeviceTypeListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { DeviceTypeAccessory } from './deviceTypeAccessory';\nimport { IdNameType } from './idNameType';\nimport { DeviceTypeFeature } from './deviceTypeFeature';\nimport { DeviceTypeIOCapabilities } from './deviceTypeIOCapabilities';\n\n\nexport interface DeviceTypeResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * A short name for this device type (usually just a model number)\n     */\n    shortName?: string | null;\n    parent?: IdName;\n    /**\n     * A unique tag for this entity\n     */\n    tag?: string | null;\n    /**\n     * The current state of the device type object\n     */\n    state?: DeviceTypeResponse.StateEnum | null;\n    deviceProviderType?: IdName;\n    ioCapabilities?: DeviceTypeIOCapabilities;\n    /**\n     * A form definition for custom settings in this device type\n     */\n    settingsDefinition?: string | null;\n    accessories?: { [key: string]: DeviceTypeAccessory; };\n    features?: { [key: string]: DeviceTypeFeature; };\n    entity: EntityInfo;\n}\nexport namespace DeviceTypeResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DeviceTypeAccessory } from './deviceTypeAccessory';\nimport { DeviceTypeFeature } from './deviceTypeFeature';\nimport { DeviceTypeIOCapabilities } from './deviceTypeIOCapabilities';\n\n\nexport interface DeviceTypeUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * A short name for this device type (usually just a model number)\n     */\n    shortName?: string | null;\n    parent?: IdName;\n    /**\n     * A unique tag for this entity\n     */\n    tag?: string | null;\n    /**\n     * The current state of the device type object\n     */\n    state?: DeviceTypeUpdateRequest.StateEnum | null;\n    deviceProviderType?: IdName;\n    ioCapabilities?: DeviceTypeIOCapabilities;\n    /**\n     * A form definition for custom settings in this device type\n     */\n    settingsDefinition?: string | null;\n    accessories?: { [key: string]: DeviceTypeAccessory; };\n    features?: { [key: string]: DeviceTypeFeature; };\n}\nexport namespace DeviceTypeUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { DeviceAccessory } from './deviceAccessory';\nimport { DeviceParameters } from './deviceParameters';\n\n\nexport interface DeviceUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The serial or IMEI of the device that is used to uniquely identify it. The value used will depend on the device type.\n     */\n    name?: string | null;\n    /**\n     * The current state of the device object\n     */\n    state?: DeviceUpdateRequest.StateEnum | null;\n    deviceType?: IdName;\n    provider?: IdName;\n    asset?: IdName;\n    simcard?: IdName;\n    configProfile?: IdName;\n    parameters?: DeviceParameters;\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * Device accessories add extra optional functionality to a device.\n     */\n    accessories?: { [key: string]: DeviceAccessory; };\n    fields?: { [key: string]: object; };\n}\nexport namespace DeviceUpdateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { IdName } from './idName';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { EntityInfo } from './entityInfo';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\nexport interface DistributorCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: DistributorCreateRequest.StateEnum | null;\n    entity?: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    /**\n     * [DEPRECATED] Use the listCompanyGroups operation instead\n     */\n    vendorGroups?: Array<IdName> | null;\n    features?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * A list of maps sets that are available to this distributor\n     */\n    availableMapSets?: Array<IdName> | null;\n    /**\n     * A list of email providers that are available to this distributor\n     */\n    availableEmailProviders?: Array<IdNameState> | null;\n    ownerId: string;\n}\nexport namespace DistributorCreateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\n/**\n * Summary distributor information returned in lists.\n */\nexport interface DistributorListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The distributor\\'s unique ID\n     */\n    id: string;\n    /**\n     * The distributor\\'s display name\n     */\n    name: string;\n    /**\n     * The distributor website (if available)\n     */\n    website: string;\n    owner: IdName;\n    /**\n     * The state of this distributor\n     */\n    state: DistributorListItem.StateEnum;\n    counts?: { [key: string]: number; };\n    /**\n     * The date this distributor was created\n     */\n    creationDate: string;\n    /**\n     * The date that this distributor was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace DistributorListItem {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { IdName } from './idName';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\nexport interface DistributorResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: DistributorResponse.StateEnum | null;\n    entity: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    /**\n     * [DEPRECATED] Use the listCompanyGroups operation instead\n     */\n    vendorGroups?: Array<IdName> | null;\n    features?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * A list of maps sets that are available to this distributor\n     */\n    availableMapSets?: Array<IdName> | null;\n    /**\n     * A list of email providers that are available to this distributor\n     */\n    availableEmailProviders?: Array<IdNameState> | null;\n}\nexport namespace DistributorResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { IdName } from './idName';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { EntityInfo } from './entityInfo';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\nexport interface DistributorUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: DistributorUpdateRequest.StateEnum | null;\n    entity?: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    /**\n     * [DEPRECATED] Use the listCompanyGroups operation instead\n     */\n    vendorGroups?: Array<IdName> | null;\n    features?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * A list of maps sets that are available to this distributor\n     */\n    availableMapSets?: Array<IdName> | null;\n    /**\n     * A list of email providers that are available to this distributor\n     */\n    availableEmailProviders?: Array<IdNameState> | null;\n}\nexport namespace DistributorUpdateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface EmailProviderCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The name of the email provider\n     */\n    name?: string | null;\n    type?: IdName;\n    /**\n     * The state of the email provider\n     */\n    state?: EmailProviderCreateRequest.StateEnum | null;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The client that owns this email provider\n     */\n    ownerId: string;\n}\nexport namespace EmailProviderCreateRequest {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface EmailProviderListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the email provider\n     */\n    name?: string | null;\n    type?: IdName;\n    /**\n     * The state of the email provider\n     */\n    state?: EmailProviderListItem.StateEnum | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace EmailProviderListItem {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface EmailProviderResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the email provider\n     */\n    name?: string | null;\n    type?: IdName;\n    /**\n     * The state of the email provider\n     */\n    state?: EmailProviderResponse.StateEnum | null;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n    entity: EntityInfo;\n}\nexport namespace EmailProviderResponse {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\n\n\nexport interface EmailProviderTypeListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the email provider type\n     */\n    name: string;\n    /**\n     * The tag to apply to the email provider type\n     */\n    tag: string;\n    /**\n     * The parameters used by the email provider type\n     */\n    parameterDefinition?: string | null;\n    /**\n     * The state of the email provider type\n     */\n    state?: EmailProviderTypeListItem.StateEnum | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace EmailProviderTypeListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface EmailProviderTypeResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the email provider type\n     */\n    name: string;\n    /**\n     * The tag to apply to the email provider type\n     */\n    tag: string;\n    /**\n     * The parameters used by the email provider type\n     */\n    parameterDefinition?: string | null;\n    /**\n     * The state of the email provider type\n     */\n    state?: EmailProviderTypeResponse.StateEnum | null;\n    entity: EntityInfo;\n}\nexport namespace EmailProviderTypeResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface EmailProviderUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The name of the email provider\n     */\n    name?: string | null;\n    type?: IdName;\n    /**\n     * The state of the email provider\n     */\n    state?: EmailProviderUpdateRequest.StateEnum | null;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n}\nexport namespace EmailProviderUpdateRequest {\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface EmailServerConfiguration { \n  [key: string]: any | any;\n\n\n    smtpEnabled?: boolean | null;\n    smtpServer?: string | null;\n    smtpPort?: number | null;\n    fromAddress?: string | null;\n    fromName?: string | null;\n    username?: string | null;\n    password?: string | null;\n    enableSsl?: boolean | null;\n    state?: EmailServerConfiguration.StateEnum | null;\n}\nexport namespace EmailServerConfiguration {\n    export type StateEnum = 'active' | 'suspended';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface EventActorFilter { \n  [key: string]: any | any;\n\n\n    actorType: EventActorFilter.ActorTypeEnum;\n    actorTypeId: string;\n    actorTypeName: string;\n    actorSelectionType: EventActorFilter.ActorSelectionTypeEnum;\n    actorId: string;\n    actorName?: string | null;\n    text: string;\n}\nexport namespace EventActorFilter {\n    export type ActorTypeEnum = 'asset' | 'user' | 'client';\n    export const ActorTypeEnum = {\n        Asset: 'asset' as ActorTypeEnum,\n        User: 'user' as ActorTypeEnum,\n        Client: 'client' as ActorTypeEnum\n    };\n    export type ActorSelectionTypeEnum = 'any' | 'group' | 'accessGroup' | 'specific';\n    export const ActorSelectionTypeEnum = {\n        Any: 'any' as ActorSelectionTypeEnum,\n        Group: 'group' as ActorSelectionTypeEnum,\n        AccessGroup: 'accessGroup' as ActorSelectionTypeEnum,\n        Specific: 'specific' as ActorSelectionTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface EventMedia { \n  [key: string]: any | any;\n\n\n    input: string;\n    date: string;\n    user?: IdName;\n    mediaType: EventMedia.MediaTypeEnum;\n    filename: string;\n    error?: string | null;\n}\nexport namespace EventMedia {\n    export type MediaTypeEnum = 'video' | 'photo';\n    export const MediaTypeEnum = {\n        Video: 'video' as MediaTypeEnum,\n        Photo: 'photo' as MediaTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface EventTargetFilter { \n  [key: string]: any | any;\n\n\n    targetType?: string | null;\n    targetTypeId?: string | null;\n    targetTypeName?: string | null;\n    targetSelectionType: EventTargetFilter.TargetSelectionTypeEnum;\n    targetId?: string | null;\n    targetName?: string | null;\n    text?: string | null;\n}\nexport namespace EventTargetFilter {\n    export type TargetSelectionTypeEnum = 'any' | 'group' | 'specific';\n    export const TargetSelectionTypeEnum = {\n        Any: 'any' as TargetSelectionTypeEnum,\n        Group: 'group' as TargetSelectionTypeEnum,\n        Specific: 'specific' as TargetSelectionTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EventActorFilter } from './eventActorFilter';\n\n\nexport interface ExportTaskCreateRequest { \n  [key: string]: any | any;\n\n\n    client?: IdName;\n    /**\n     * The name of the export task\n     */\n    name?: string | null;\n    /**\n     * The state of the export task\n     */\n    state?: ExportTaskCreateRequest.StateEnum | null;\n    /**\n     * The delivery method of the export tasks\n     */\n    deliveryMethod?: ExportTaskCreateRequest.DeliveryMethodEnum | null;\n    /**\n     * The filters used to get the assets to be included in the export task\n     */\n    assets?: Array<EventActorFilter> | null;\n    /**\n     * The document types to include in the export task\n     */\n    documentTypes?: Array<string> | null;\n    /**\n     * The document layout version\n     */\n    documentVersion?: ExportTaskCreateRequest.DocumentVersionEnum | null;\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The client or vendor that owns this entity\n     */\n    ownerId: string;\n}\nexport namespace ExportTaskCreateRequest {\n    export type StateEnum = 'suspended' | 'active' | 'deleted';\n    export const StateEnum = {\n        Suspended: 'suspended' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type DeliveryMethodEnum = 'http' | 'stream' | 'firehose';\n    export const DeliveryMethodEnum = {\n        Http: 'http' as DeliveryMethodEnum,\n        Stream: 'stream' as DeliveryMethodEnum,\n        Firehose: 'firehose' as DeliveryMethodEnum\n    };\n    export type DocumentVersionEnum = 'v1' | 'v2';\n    export const DocumentVersionEnum = {\n        V1: 'v1' as DocumentVersionEnum,\n        V2: 'v2' as DocumentVersionEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EventActorFilter } from './eventActorFilter';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ExportTaskListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    client?: IdName;\n    /**\n     * The name of the export task\n     */\n    name?: string | null;\n    /**\n     * The state of the export task\n     */\n    state?: ExportTaskListItem.StateEnum | null;\n    /**\n     * The delivery method of the export tasks\n     */\n    deliveryMethod?: ExportTaskListItem.DeliveryMethodEnum | null;\n    /**\n     * The filters used to get the assets to be included in the export task\n     */\n    assets?: Array<EventActorFilter> | null;\n    /**\n     * The document types to include in the export task\n     */\n    documentTypes?: Array<string> | null;\n    /**\n     * The document layout version\n     */\n    documentVersion?: ExportTaskListItem.DocumentVersionEnum | null;\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * Export task username\n     */\n    username?: string | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace ExportTaskListItem {\n    export type StateEnum = 'suspended' | 'active' | 'deleted';\n    export const StateEnum = {\n        Suspended: 'suspended' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type DeliveryMethodEnum = 'http' | 'stream' | 'firehose';\n    export const DeliveryMethodEnum = {\n        Http: 'http' as DeliveryMethodEnum,\n        Stream: 'stream' as DeliveryMethodEnum,\n        Firehose: 'firehose' as DeliveryMethodEnum\n    };\n    export type DocumentVersionEnum = 'v1' | 'v2';\n    export const DocumentVersionEnum = {\n        V1: 'v1' as DocumentVersionEnum,\n        V2: 'v2' as DocumentVersionEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EventActorFilter } from './eventActorFilter';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ExportTaskResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    client?: IdName;\n    /**\n     * The name of the export task\n     */\n    name?: string | null;\n    /**\n     * The state of the export task\n     */\n    state?: ExportTaskResponse.StateEnum | null;\n    /**\n     * The delivery method of the export tasks\n     */\n    deliveryMethod?: ExportTaskResponse.DeliveryMethodEnum | null;\n    /**\n     * The filters used to get the assets to be included in the export task\n     */\n    assets?: Array<EventActorFilter> | null;\n    /**\n     * The document types to include in the export task\n     */\n    documentTypes?: Array<string> | null;\n    /**\n     * The document layout version\n     */\n    documentVersion?: ExportTaskResponse.DocumentVersionEnum | null;\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The connection endpoint for the export task\n     */\n    endpoint?: string | null;\n    /**\n     * Export task username\n     */\n    username?: string | null;\n    /**\n     * Export task password\n     */\n    password?: string | null;\n    entity: EntityInfo;\n}\nexport namespace ExportTaskResponse {\n    export type StateEnum = 'suspended' | 'active' | 'deleted';\n    export const StateEnum = {\n        Suspended: 'suspended' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type DeliveryMethodEnum = 'http' | 'stream' | 'firehose';\n    export const DeliveryMethodEnum = {\n        Http: 'http' as DeliveryMethodEnum,\n        Stream: 'stream' as DeliveryMethodEnum,\n        Firehose: 'firehose' as DeliveryMethodEnum\n    };\n    export type DocumentVersionEnum = 'v1' | 'v2';\n    export const DocumentVersionEnum = {\n        V1: 'v1' as DocumentVersionEnum,\n        V2: 'v2' as DocumentVersionEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EventActorFilter } from './eventActorFilter';\n\n\nexport interface ExportTaskUpdateRequest { \n  [key: string]: any | any;\n\n\n    client?: IdName;\n    /**\n     * The name of the export task\n     */\n    name?: string | null;\n    /**\n     * The state of the export task\n     */\n    state?: ExportTaskUpdateRequest.StateEnum | null;\n    /**\n     * The delivery method of the export tasks\n     */\n    deliveryMethod?: ExportTaskUpdateRequest.DeliveryMethodEnum | null;\n    /**\n     * The filters used to get the assets to be included in the export task\n     */\n    assets?: Array<EventActorFilter> | null;\n    /**\n     * The document types to include in the export task\n     */\n    documentTypes?: Array<string> | null;\n    /**\n     * The document layout version\n     */\n    documentVersion?: ExportTaskUpdateRequest.DocumentVersionEnum | null;\n    settings?: { [key: string]: { [key: string]: any; }; };\n}\nexport namespace ExportTaskUpdateRequest {\n    export type StateEnum = 'suspended' | 'active' | 'deleted';\n    export const StateEnum = {\n        Suspended: 'suspended' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type DeliveryMethodEnum = 'http' | 'stream' | 'firehose';\n    export const DeliveryMethodEnum = {\n        Http: 'http' as DeliveryMethodEnum,\n        Stream: 'stream' as DeliveryMethodEnum,\n        Firehose: 'firehose' as DeliveryMethodEnum\n    };\n    export type DocumentVersionEnum = 'v1' | 'v2';\n    export const DocumentVersionEnum = {\n        V1: 'v1' as DocumentVersionEnum,\n        V2: 'v2' as DocumentVersionEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { GeocoderBounds } from './geocoderBounds';\nimport { GeocoderAddress } from './geocoderAddress';\n\n\n/**\n * A forward geocode search result item\n */\nexport interface ForwardGeocodeResult { \n  [key: string]: any | any;\n\n\n    type: ForwardGeocodeResult.TypeEnum;\n    id?: string | null;\n    text: string;\n    lon: number;\n    lat: number;\n    bounds?: GeocoderBounds;\n    address?: GeocoderAddress;\n}\nexport namespace ForwardGeocodeResult {\n    export type TypeEnum = 'location' | 'keepin' | 'nogo' | 'route' | 'address';\n    export const TypeEnum = {\n        Location: 'location' as TypeEnum,\n        Keepin: 'keepin' as TypeEnum,\n        Nogo: 'nogo' as TypeEnum,\n        Route: 'route' as TypeEnum,\n        Address: 'address' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface FuelCardCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The serial number of the fuel card that is used to uniquely identify it.\n     */\n    name?: string | null;\n    /**\n     * The brand of fuel card\n     */\n    brandName?: string | null;\n    /**\n     * The name embossed on the fuel card\n     */\n    embossedName?: string | null;\n    /**\n     * The expiry date of the fuel card in the format YYYY/MM/DD\n     */\n    expiryDate?: string | null;\n    /**\n     * A short description of the fuel card.\n     */\n    description?: string | null;\n    /**\n     * The current state of the object\n     */\n    state?: FuelCardCreateRequest.StateEnum | null;\n    fields?: { [key: string]: object; };\n    asset?: IdName;\n    ownerId: string;\n}\nexport namespace FuelCardCreateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface FuelCardListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The serial number of the fuel card that is used to uniquely identify it.\n     */\n    name?: string | null;\n    /**\n     * The brand of fuel card\n     */\n    brandName?: string | null;\n    /**\n     * The name embossed on the fuel card\n     */\n    embossedName?: string | null;\n    /**\n     * The expiry date of the fuel card in the format YYYY/MM/DD\n     */\n    expiryDate?: string | null;\n    /**\n     * A short description of the fuel card.\n     */\n    description?: string | null;\n    /**\n     * The current state of the object\n     */\n    state?: FuelCardListItem.StateEnum | null;\n    fields?: { [key: string]: object; };\n    asset?: IdName;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace FuelCardListItem {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface FuelCardResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The serial number of the fuel card that is used to uniquely identify it.\n     */\n    name?: string | null;\n    /**\n     * The brand of fuel card\n     */\n    brandName?: string | null;\n    /**\n     * The name embossed on the fuel card\n     */\n    embossedName?: string | null;\n    /**\n     * The expiry date of the fuel card in the format YYYY/MM/DD\n     */\n    expiryDate?: string | null;\n    /**\n     * A short description of the fuel card.\n     */\n    description?: string | null;\n    /**\n     * The current state of the object\n     */\n    state?: FuelCardResponse.StateEnum | null;\n    fields?: { [key: string]: object; };\n    asset?: IdName;\n    entity: EntityInfo;\n}\nexport namespace FuelCardResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface FuelCardUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The serial number of the fuel card that is used to uniquely identify it.\n     */\n    name?: string | null;\n    /**\n     * The brand of fuel card\n     */\n    brandName?: string | null;\n    /**\n     * The name embossed on the fuel card\n     */\n    embossedName?: string | null;\n    /**\n     * The expiry date of the fuel card in the format YYYY/MM/DD\n     */\n    expiryDate?: string | null;\n    /**\n     * A short description of the fuel card.\n     */\n    description?: string | null;\n    /**\n     * The current state of the object\n     */\n    state?: FuelCardUpdateRequest.StateEnum | null;\n    fields?: { [key: string]: object; };\n    asset?: IdName;\n}\nexport namespace FuelCardUpdateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { GeoLockTimeItem } from './geoLockTimeItem';\n\n\nexport interface GeoLockProfileCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: GeoLockProfileCreateRequest.StateEnum | null;\n    /**\n     * The radius of the geo lock (in kilometers)\n     */\n    radiusKm?: number | null;\n    /**\n     * The geo lock times for this profile\n     */\n    times?: Array<GeoLockTimeItem> | null;\n    /**\n     * The client that owns this geo lock profile\n     */\n    ownerId: string;\n}\nexport namespace GeoLockProfileCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { GeoLockTimeItem } from './geoLockTimeItem';\nimport { IdNameType } from './idNameType';\n\n\nexport interface GeoLockProfileListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: GeoLockProfileListItem.StateEnum | null;\n    /**\n     * The radius of the geo lock (in kilometers)\n     */\n    radiusKm?: number | null;\n    /**\n     * The geo lock times for this profile\n     */\n    times?: Array<GeoLockTimeItem> | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace GeoLockProfileListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { GeoLockTimeItem } from './geoLockTimeItem';\nimport { IdNameType } from './idNameType';\n\n\nexport interface GeoLockProfileResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: GeoLockProfileResponse.StateEnum | null;\n    /**\n     * The radius of the geo lock (in kilometers)\n     */\n    radiusKm?: number | null;\n    /**\n     * The geo lock times for this profile\n     */\n    times?: Array<GeoLockTimeItem> | null;\n    entity: EntityInfo;\n}\nexport namespace GeoLockProfileResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { GeoLockTimeItem } from './geoLockTimeItem';\n\n\nexport interface GeoLockProfileUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: GeoLockProfileUpdateRequest.StateEnum | null;\n    /**\n     * The radius of the geo lock (in kilometers)\n     */\n    radiusKm?: number | null;\n    /**\n     * The geo lock times for this profile\n     */\n    times?: Array<GeoLockTimeItem> | null;\n}\nexport namespace GeoLockProfileUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ErrorBase } from './errorBase';\n\n\nexport interface IdNameState { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique ID of the object\n     */\n    id: string;\n    /**\n     * The name of the object (can be undefined if an error occurs)\n     */\n    name?: string | null;\n    /**\n     * The name of the object (can be undefined if an error occurs)\n     */\n    state?: IdNameState.StateEnum | null;\n    err?: ErrorBase;\n}\nexport namespace IdNameState {\n    export type StateEnum = 'active' | 'inactive' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Inactive: 'inactive' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IoTypeTextConfig } from './ioTypeTextConfig';\nimport { IdName } from './idName';\nimport { IoTypeRateConfig } from './ioTypeRateConfig';\n\n\nexport interface IoTypeCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: IoTypeCreateRequest.StateEnum | null;\n    /**\n     * The type of the IO type\n     */\n    type?: IoTypeCreateRequest.TypeEnum | null;\n    /**\n     * Optional units that this I/O type is measured in\n     */\n    unit?: string | null;\n    /**\n     * The type of smoothing to apply to this input\n     */\n    smoothingType?: IoTypeCreateRequest.SmoothingTypeEnum | null;\n    text?: IoTypeTextConfig;\n    rate?: IoTypeRateConfig;\n    /**\n     * A dictionary of lookup values. Only relevant for \\\"value_input\\\" types.\n     */\n    lookups?: Array<IdName> | null;\n    /**\n     * The client or vendor that owns this entity\n     */\n    ownerId: string;\n}\nexport namespace IoTypeCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type TypeEnum = 'digital_input' | 'digital_output' | 'analog_input' | 'temperature_input' | 'can_input' | 'counter_input' | 'camera_input' | 'value_input';\n    export const TypeEnum = {\n        DigitalInput: 'digital_input' as TypeEnum,\n        DigitalOutput: 'digital_output' as TypeEnum,\n        AnalogInput: 'analog_input' as TypeEnum,\n        TemperatureInput: 'temperature_input' as TypeEnum,\n        CanInput: 'can_input' as TypeEnum,\n        CounterInput: 'counter_input' as TypeEnum,\n        CameraInput: 'camera_input' as TypeEnum,\n        ValueInput: 'value_input' as TypeEnum\n    };\n    export type SmoothingTypeEnum = 'none' | 'moving_average_5' | 'moving_average_10' | 'moving_average_20' | 'moving_average_50' | 'moving_average_100' | 'moving_average_200';\n    export const SmoothingTypeEnum = {\n        None: 'none' as SmoothingTypeEnum,\n        MovingAverage5: 'moving_average_5' as SmoothingTypeEnum,\n        MovingAverage10: 'moving_average_10' as SmoothingTypeEnum,\n        MovingAverage20: 'moving_average_20' as SmoothingTypeEnum,\n        MovingAverage50: 'moving_average_50' as SmoothingTypeEnum,\n        MovingAverage100: 'moving_average_100' as SmoothingTypeEnum,\n        MovingAverage200: 'moving_average_200' as SmoothingTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IoTypeTextConfig } from './ioTypeTextConfig';\nimport { IdName } from './idName';\nimport { IoTypeRateConfig } from './ioTypeRateConfig';\nimport { IdNameType } from './idNameType';\n\n\nexport interface IoTypeListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: IoTypeListItem.StateEnum | null;\n    /**\n     * The type of the IO type\n     */\n    type?: IoTypeListItem.TypeEnum | null;\n    /**\n     * Optional units that this I/O type is measured in\n     */\n    unit?: string | null;\n    /**\n     * The type of smoothing to apply to this input\n     */\n    smoothingType?: IoTypeListItem.SmoothingTypeEnum | null;\n    text?: IoTypeTextConfig;\n    rate?: IoTypeRateConfig;\n    /**\n     * A dictionary of lookup values. Only relevant for \\\"value_input\\\" types.\n     */\n    lookups?: Array<IdName> | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace IoTypeListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type TypeEnum = 'digital_input' | 'digital_output' | 'analog_input' | 'temperature_input' | 'can_input' | 'counter_input' | 'camera_input' | 'value_input';\n    export const TypeEnum = {\n        DigitalInput: 'digital_input' as TypeEnum,\n        DigitalOutput: 'digital_output' as TypeEnum,\n        AnalogInput: 'analog_input' as TypeEnum,\n        TemperatureInput: 'temperature_input' as TypeEnum,\n        CanInput: 'can_input' as TypeEnum,\n        CounterInput: 'counter_input' as TypeEnum,\n        CameraInput: 'camera_input' as TypeEnum,\n        ValueInput: 'value_input' as TypeEnum\n    };\n    export type SmoothingTypeEnum = 'none' | 'moving_average_5' | 'moving_average_10' | 'moving_average_20' | 'moving_average_50' | 'moving_average_100' | 'moving_average_200';\n    export const SmoothingTypeEnum = {\n        None: 'none' as SmoothingTypeEnum,\n        MovingAverage5: 'moving_average_5' as SmoothingTypeEnum,\n        MovingAverage10: 'moving_average_10' as SmoothingTypeEnum,\n        MovingAverage20: 'moving_average_20' as SmoothingTypeEnum,\n        MovingAverage50: 'moving_average_50' as SmoothingTypeEnum,\n        MovingAverage100: 'moving_average_100' as SmoothingTypeEnum,\n        MovingAverage200: 'moving_average_200' as SmoothingTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface IoTypeRateConfig { \n  [key: string]: any | any;\n\n\n    /**\n     * The type of rate conversion to do\n     */\n    type?: IoTypeRateConfig.TypeEnum | null;\n    /**\n     * A multiplier for the value\n     */\n    multiplier?: number | null;\n    /**\n     * The unit once the rate conversion is done\n     */\n    unit?: string | null;\n}\nexport namespace IoTypeRateConfig {\n    export type TypeEnum = 'none' | 'val_per_km' | 'km_per_val' | 'val_per_mile' | 'mile_per_val' | 'val_per_hour' | 'hour_per_val';\n    export const TypeEnum = {\n        None: 'none' as TypeEnum,\n        ValPerKm: 'val_per_km' as TypeEnum,\n        KmPerVal: 'km_per_val' as TypeEnum,\n        ValPerMile: 'val_per_mile' as TypeEnum,\n        MilePerVal: 'mile_per_val' as TypeEnum,\n        ValPerHour: 'val_per_hour' as TypeEnum,\n        HourPerVal: 'hour_per_val' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IoTypeTextConfig } from './ioTypeTextConfig';\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { IoTypeRateConfig } from './ioTypeRateConfig';\nimport { IdNameType } from './idNameType';\n\n\nexport interface IoTypeResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: IoTypeResponse.StateEnum | null;\n    /**\n     * The type of the IO type\n     */\n    type?: IoTypeResponse.TypeEnum | null;\n    /**\n     * Optional units that this I/O type is measured in\n     */\n    unit?: string | null;\n    /**\n     * The type of smoothing to apply to this input\n     */\n    smoothingType?: IoTypeResponse.SmoothingTypeEnum | null;\n    text?: IoTypeTextConfig;\n    rate?: IoTypeRateConfig;\n    /**\n     * A dictionary of lookup values. Only relevant for \\\"value_input\\\" types.\n     */\n    lookups?: Array<IdName> | null;\n    entity: EntityInfo;\n}\nexport namespace IoTypeResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type TypeEnum = 'digital_input' | 'digital_output' | 'analog_input' | 'temperature_input' | 'can_input' | 'counter_input' | 'camera_input' | 'value_input';\n    export const TypeEnum = {\n        DigitalInput: 'digital_input' as TypeEnum,\n        DigitalOutput: 'digital_output' as TypeEnum,\n        AnalogInput: 'analog_input' as TypeEnum,\n        TemperatureInput: 'temperature_input' as TypeEnum,\n        CanInput: 'can_input' as TypeEnum,\n        CounterInput: 'counter_input' as TypeEnum,\n        CameraInput: 'camera_input' as TypeEnum,\n        ValueInput: 'value_input' as TypeEnum\n    };\n    export type SmoothingTypeEnum = 'none' | 'moving_average_5' | 'moving_average_10' | 'moving_average_20' | 'moving_average_50' | 'moving_average_100' | 'moving_average_200';\n    export const SmoothingTypeEnum = {\n        None: 'none' as SmoothingTypeEnum,\n        MovingAverage5: 'moving_average_5' as SmoothingTypeEnum,\n        MovingAverage10: 'moving_average_10' as SmoothingTypeEnum,\n        MovingAverage20: 'moving_average_20' as SmoothingTypeEnum,\n        MovingAverage50: 'moving_average_50' as SmoothingTypeEnum,\n        MovingAverage100: 'moving_average_100' as SmoothingTypeEnum,\n        MovingAverage200: 'moving_average_200' as SmoothingTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IoTypeTextConfig } from './ioTypeTextConfig';\nimport { IdName } from './idName';\nimport { IoTypeRateConfig } from './ioTypeRateConfig';\n\n\nexport interface IoTypeUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: IoTypeUpdateRequest.StateEnum | null;\n    /**\n     * The type of the IO type\n     */\n    type?: IoTypeUpdateRequest.TypeEnum | null;\n    /**\n     * Optional units that this I/O type is measured in\n     */\n    unit?: string | null;\n    /**\n     * The type of smoothing to apply to this input\n     */\n    smoothingType?: IoTypeUpdateRequest.SmoothingTypeEnum | null;\n    text?: IoTypeTextConfig;\n    rate?: IoTypeRateConfig;\n    /**\n     * A dictionary of lookup values. Only relevant for \\\"value_input\\\" types.\n     */\n    lookups?: Array<IdName> | null;\n}\nexport namespace IoTypeUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type TypeEnum = 'digital_input' | 'digital_output' | 'analog_input' | 'temperature_input' | 'can_input' | 'counter_input' | 'camera_input' | 'value_input';\n    export const TypeEnum = {\n        DigitalInput: 'digital_input' as TypeEnum,\n        DigitalOutput: 'digital_output' as TypeEnum,\n        AnalogInput: 'analog_input' as TypeEnum,\n        TemperatureInput: 'temperature_input' as TypeEnum,\n        CanInput: 'can_input' as TypeEnum,\n        CounterInput: 'counter_input' as TypeEnum,\n        CameraInput: 'camera_input' as TypeEnum,\n        ValueInput: 'value_input' as TypeEnum\n    };\n    export type SmoothingTypeEnum = 'none' | 'moving_average_5' | 'moving_average_10' | 'moving_average_20' | 'moving_average_50' | 'moving_average_100' | 'moving_average_200';\n    export const SmoothingTypeEnum = {\n        None: 'none' as SmoothingTypeEnum,\n        MovingAverage5: 'moving_average_5' as SmoothingTypeEnum,\n        MovingAverage10: 'moving_average_10' as SmoothingTypeEnum,\n        MovingAverage20: 'moving_average_20' as SmoothingTypeEnum,\n        MovingAverage50: 'moving_average_50' as SmoothingTypeEnum,\n        MovingAverage100: 'moving_average_100' as SmoothingTypeEnum,\n        MovingAverage200: 'moving_average_200' as SmoothingTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { LabelValuePayload } from './labelValuePayload';\n\n\nexport interface LabelCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A lowercase alphanumeric label value\n     */\n    label?: string | null;\n    /**\n     * A friendly descriptive name for label\n     */\n    name?: string | null;\n    /**\n     * An optional color for this label\n     */\n    color?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: LabelCreateRequest.StateEnum | null;\n    /**\n     * A list of sub labels that are mutually exclusive\n     */\n    values?: Array<LabelValuePayload> | null;\n    /**\n     * The entities to which this label applies\n     */\n    entities?: Array<string> | null;\n    /**\n     * The client or vendor that owns this entity\n     */\n    ownerId: string;\n}\nexport namespace LabelCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { LabelValuePayload } from './labelValuePayload';\nimport { IdNameType } from './idNameType';\n\n\nexport interface LabelListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A lowercase alphanumeric label value\n     */\n    label?: string | null;\n    /**\n     * A friendly descriptive name for label\n     */\n    name?: string | null;\n    /**\n     * An optional color for this label\n     */\n    color?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: LabelListItem.StateEnum | null;\n    /**\n     * A list of sub labels that are mutually exclusive\n     */\n    values?: Array<LabelValuePayload> | null;\n    /**\n     * The entities to which this label applies\n     */\n    entities?: Array<string> | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace LabelListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { LabelValuePayload } from './labelValuePayload';\nimport { IdNameType } from './idNameType';\n\n\nexport interface LabelResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A lowercase alphanumeric label value\n     */\n    label?: string | null;\n    /**\n     * A friendly descriptive name for label\n     */\n    name?: string | null;\n    /**\n     * An optional color for this label\n     */\n    color?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: LabelResponse.StateEnum | null;\n    /**\n     * A list of sub labels that are mutually exclusive\n     */\n    values?: Array<LabelValuePayload> | null;\n    /**\n     * The entities to which this label applies\n     */\n    entities?: Array<string> | null;\n    entity: EntityInfo;\n}\nexport namespace LabelResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { LabelValuePayload } from './labelValuePayload';\n\n\nexport interface LabelUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A lowercase alphanumeric label value\n     */\n    label?: string | null;\n    /**\n     * A friendly descriptive name for label\n     */\n    name?: string | null;\n    /**\n     * An optional color for this label\n     */\n    color?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: LabelUpdateRequest.StateEnum | null;\n    /**\n     * A list of sub labels that are mutually exclusive\n     */\n    values?: Array<LabelValuePayload> | null;\n    /**\n     * The entities to which this label applies\n     */\n    entities?: Array<string> | null;\n}\nexport namespace LabelUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { MapRouteSegment } from './mapRouteSegment';\n\n\n/**\n * A complete route result\n */\nexport interface MapRoute { \n  [key: string]: any | any;\n\n\n    /**\n     * The strategy that was used to calculate the route\n     */\n    strategy: MapRoute.StrategyEnum;\n    /**\n     * One or more segments in the route\n     */\n    segments: Array<MapRouteSegment>;\n}\nexport namespace MapRoute {\n    export type StrategyEnum = 'fastest' | 'shortest';\n    export const StrategyEnum = {\n        Fastest: 'fastest' as StrategyEnum,\n        Shortest: 'shortest' as StrategyEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface MapSetLayer { \n  [key: string]: any | any;\n\n\n    /**\n     * The name of the map layer\n     */\n    name: string;\n    /**\n     * The projection of the map\n     */\n    projection: string;\n    /**\n     * The minimum zoom level supported by this map layer\n     */\n    minZoom: number;\n    /**\n     * The maximum zoom level supported by this map layer\n     */\n    maxZoom: number;\n    /**\n     * The map server type\n     */\n    serverType: MapSetLayer.ServerTypeEnum;\n    /**\n     * The order of the layer amongst it\\'s peers\n     */\n    order: number;\n    /**\n     * The image type of the map tiles\n     */\n    imageType: MapSetLayer.ImageTypeEnum;\n    /**\n     * The name of the layer to present to the map server\n     */\n    layerName: string;\n    /**\n     * A list of map server urls\n     */\n    servers: Array<string>;\n    /**\n     * An optional list of layers to overlay on this layer\n     */\n    overlays: Array<MapSetLayer>;\n    /**\n     * The source attribution text to overlay on this map layer\n     */\n    attribution?: string | null;\n}\nexport namespace MapSetLayer {\n    export type ServerTypeEnum = 'google' | 'wms' | 'osm' | 'wmts' | 'dds' | 'tms' | 'mbs';\n    export const ServerTypeEnum = {\n        Google: 'google' as ServerTypeEnum,\n        Wms: 'wms' as ServerTypeEnum,\n        Osm: 'osm' as ServerTypeEnum,\n        Wmts: 'wmts' as ServerTypeEnum,\n        Dds: 'dds' as ServerTypeEnum,\n        Tms: 'tms' as ServerTypeEnum,\n        Mbs: 'mbs' as ServerTypeEnum\n    };\n    export type ImageTypeEnum = 'png' | 'jpg' | 'jpeg' | 'gif' | 'mvt';\n    export const ImageTypeEnum = {\n        Png: 'png' as ImageTypeEnum,\n        Jpg: 'jpg' as ImageTypeEnum,\n        Jpeg: 'jpeg' as ImageTypeEnum,\n        Gif: 'gif' as ImageTypeEnum,\n        Mvt: 'mvt' as ImageTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\nimport { MapSetLayer } from './mapSetLayer';\n\n\nexport interface MapSetListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this map set\n     */\n    name?: string | null;\n    /**\n     * One or more layers available in this map set\n     */\n    layers?: Array<MapSetLayer> | null;\n    /**\n     * The state of this map set\n     */\n    state?: MapSetListItem.StateEnum | null;\n    /**\n     * One or more overlays for this map set\n     */\n    overlays?: Array<MapSetLayer> | null;\n    /**\n     * The url to use for static maps when this map set is selected\n     */\n    staticMapURL?: string | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace MapSetListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\nimport { MapSetLayer } from './mapSetLayer';\n\n\nexport interface MapSetResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this map set\n     */\n    name?: string | null;\n    /**\n     * One or more layers available in this map set\n     */\n    layers?: Array<MapSetLayer> | null;\n    /**\n     * The state of this map set\n     */\n    state?: MapSetResponse.StateEnum | null;\n    /**\n     * One or more overlays for this map set\n     */\n    overlays?: Array<MapSetLayer> | null;\n    /**\n     * The url to use for static maps when this map set is selected\n     */\n    staticMapURL?: string | null;\n    entity: EntityInfo;\n}\nexport namespace MapSetResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { MapSetLayer } from './mapSetLayer';\n\n\nexport interface MapsetCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this map set\n     */\n    name?: string | null;\n    /**\n     * One or more layers available in this map set\n     */\n    layers?: Array<MapSetLayer> | null;\n    /**\n     * The state of this map set\n     */\n    state?: MapsetCreateRequest.StateEnum | null;\n    /**\n     * One or more overlays for this map set\n     */\n    overlays?: Array<MapSetLayer> | null;\n    /**\n     * The url to use for static maps when this map set is selected\n     */\n    staticMapURL?: string | null;\n    /**\n     * The client that owns this map set\n     */\n    ownerId: string;\n}\nexport namespace MapsetCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { MapSetLayer } from './mapSetLayer';\n\n\nexport interface MapsetUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this map set\n     */\n    name?: string | null;\n    /**\n     * One or more layers available in this map set\n     */\n    layers?: Array<MapSetLayer> | null;\n    /**\n     * The state of this map set\n     */\n    state?: MapsetUpdateRequest.StateEnum | null;\n    /**\n     * One or more overlays for this map set\n     */\n    overlays?: Array<MapSetLayer> | null;\n    /**\n     * The url to use for static maps when this map set is selected\n     */\n    staticMapURL?: string | null;\n}\nexport namespace MapsetUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface MeasureDescription { \n  [key: string]: any | any;\n\n\n    /**\n     * The key of the measure\n     */\n    key: string;\n    /**\n     * The name of the measure\n     */\n    value: string;\n    /**\n     * The formatting type of  the measure. Durations are hh:mm:ss. Numbers can be postive or negative values to 2 decimal places, integers can be postive or negative; and percent is an integer between 0 and 100\n     */\n    format?: MeasureDescription.FormatEnum | null;\n    /**\n     * Whether or not the measure is generic. This is useful to indicate that the measure is specific to a client and should not be used in dashboard templates\n     */\n    generic?: boolean | null;\n    /**\n     * The date YYYY/MM/DD HH:mm:ss (UTC) from which the measure is valid\n     */\n    validFrom?: string | null;\n    /**\n     * The date YYYY/MM/DD HH:mm:ss (UTC) to which the measure is valid\n     */\n    validTo?: string | null;\n}\nexport namespace MeasureDescription {\n    export type FormatEnum = 'duration' | 'number' | 'integer' | 'percent';\n    export const FormatEnum = {\n        Duration: 'duration' as FormatEnum,\n        Number: 'number' as FormatEnum,\n        Integer: 'integer' as FormatEnum,\n        Percent: 'percent' as FormatEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\n/**\n * Information about a media item\n */\nexport interface MediaInfoResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The internal ID of the media item\n     */\n    id: string;\n    owner: IdName;\n    asset: IdName;\n    requester: IdNameType;\n    /**\n     * The MIME type of this media\n     */\n    mimeType: string;\n    /**\n     * The filename of the media item\n     */\n    filename: string;\n    /**\n     * The camera input from which this media was recorded\n     */\n    input: string;\n    /**\n     * The ISO date at which this media was started\n     */\n    date: string;\n    /**\n     * The duration of the media item\n     */\n    duration: number;\n    /**\n     * The status of the media item\n     */\n    status: MediaInfoResponse.StatusEnum;\n    /**\n     * The UUID of an event that is linked to this media item\n     */\n    eventId: string;\n    /**\n     * The class of the event that is linked to this media item\n     */\n    eventClass: string;\n    /**\n     * The type of the event that is linked to this media item\n     */\n    eventType: string;\n    /**\n     * The latitude where this event was triggered\n     */\n    lat: number;\n    /**\n     * The longitude where this event was triggered\n     */\n    lon: number;\n    /**\n     * The geocoded address of where this event was triggered\n     */\n    address: string;\n    /**\n     * a list of custom field values attached to this event\n     */\n    fields: { [key: string]: any; };\n    /**\n     * The name of the device provider that handled this media item\n     */\n    provider: string;\n    /**\n     * The progress of media retrieval (not all devices support this property)\n     */\n    progress: number;\n    entity: EntityInfo;\n    /**\n     * Device specific information about this media item\n     */\n    data?: { [key: string]: any; } | null;\n}\nexport namespace MediaInfoResponse {\n    export type StatusEnum = 'queued' | 'pending' | 'uploading' | 'available' | 'downloading' | 'processing' | 'ready' | 'failed' | 'unavailable' | 'canceled' | 'deleted';\n    export const StatusEnum = {\n        Queued: 'queued' as StatusEnum,\n        Pending: 'pending' as StatusEnum,\n        Uploading: 'uploading' as StatusEnum,\n        Available: 'available' as StatusEnum,\n        Downloading: 'downloading' as StatusEnum,\n        Processing: 'processing' as StatusEnum,\n        Ready: 'ready' as StatusEnum,\n        Failed: 'failed' as StatusEnum,\n        Unavailable: 'unavailable' as StatusEnum,\n        Canceled: 'canceled' as StatusEnum,\n        Deleted: 'deleted' as StatusEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface NotificationActions { \n  [key: string]: any | any;\n\n\n    low?: NotificationActions.LowEnum | null;\n    medium?: NotificationActions.MediumEnum | null;\n    high?: NotificationActions.HighEnum | null;\n}\nexport namespace NotificationActions {\n    export type LowEnum = 'none' | 'email' | 'sms' | 'emailsms';\n    export const LowEnum = {\n        None: 'none' as LowEnum,\n        Email: 'email' as LowEnum,\n        Sms: 'sms' as LowEnum,\n        Emailsms: 'emailsms' as LowEnum\n    };\n    export type MediumEnum = 'none' | 'email' | 'sms' | 'emailsms';\n    export const MediumEnum = {\n        None: 'none' as MediumEnum,\n        Email: 'email' as MediumEnum,\n        Sms: 'sms' as MediumEnum,\n        Emailsms: 'emailsms' as MediumEnum\n    };\n    export type HighEnum = 'none' | 'email' | 'sms' | 'emailsms';\n    export const HighEnum = {\n        None: 'none' as HighEnum,\n        Email: 'email' as HighEnum,\n        Sms: 'sms' as HighEnum,\n        Emailsms: 'emailsms' as HighEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { OTPMethodSettings } from './oTPMethodSettings';\n\n\n/**\n * Settings for One Time Password requirements\n */\nexport interface OTPSettings { \n  [key: string]: any | any;\n\n\n    /**\n     * The one time password methods that are allowed\n     */\n    methods: { [key: string]: OTPMethodSettings; };\n    /**\n     * Define who is forced to enable OTP. If set to \\\"optional\\\", users can opt themselves into OTP but do not need to do so.\n     */\n    mandatoryFor: OTPSettings.MandatoryForEnum;\n    /**\n     * The number of days grace that will be given to new users when their account is created before they are forced to enable OTP on their account.\n     */\n    gracePeriodDays: number;\n}\nexport namespace OTPSettings {\n    export type MandatoryForEnum = 'optional' | 'everyone' | 'administrators';\n    export const MandatoryForEnum = {\n        Optional: 'optional' as MandatoryForEnum,\n        Everyone: 'everyone' as MandatoryForEnum,\n        Administrators: 'administrators' as MandatoryForEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { OverspeedBandItem } from './overspeedBandItem';\n\n\nexport interface OverspeedProfileCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: OverspeedProfileCreateRequest.StateEnum | null;\n    /**\n     * The overspeed band items for this profile\n     */\n    items?: Array<OverspeedBandItem> | null;\n    /**\n     * The client that owns this Overspeed Profile\n     */\n    ownerId: string;\n}\nexport namespace OverspeedProfileCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { OverspeedBandItem } from './overspeedBandItem';\nimport { IdNameType } from './idNameType';\n\n\nexport interface OverspeedProfileListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: OverspeedProfileListItem.StateEnum | null;\n    /**\n     * The overspeed band items for this profile\n     */\n    items?: Array<OverspeedBandItem> | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace OverspeedProfileListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { OverspeedBandItem } from './overspeedBandItem';\nimport { IdNameType } from './idNameType';\n\n\nexport interface OverspeedProfileResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: OverspeedProfileResponse.StateEnum | null;\n    /**\n     * The overspeed band items for this profile\n     */\n    items?: Array<OverspeedBandItem> | null;\n    entity: EntityInfo;\n}\nexport namespace OverspeedProfileResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { OverspeedBandItem } from './overspeedBandItem';\n\n\nexport interface OverspeedProfileUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: OverspeedProfileUpdateRequest.StateEnum | null;\n    /**\n     * The overspeed band items for this profile\n     */\n    items?: Array<OverspeedBandItem> | null;\n}\nexport namespace OverspeedProfileUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { PieChartSeriesItem } from './pieChartSeriesItem';\nimport { ChartLabel } from './chartLabel';\n\n\nexport interface PieChartOptions { \n  [key: string]: any | any;\n\n\n    label: ChartLabel;\n    series: { [key: string]: PieChartSeriesItem; };\n    dataLabels?: boolean | null;\n    data: PieChartOptions.DataEnum;\n    fill: boolean;\n}\nexport namespace PieChartOptions {\n    export type DataEnum = 'average' | 'total';\n    export const DataEnum = {\n        Average: 'average' as DataEnum,\n        Total: 'total' as DataEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface PolicyStatement { \n  [key: string]: any | any;\n\n\n    /**\n     * An optional UUID for the policy statement\n     */\n    id?: string | null;\n    /**\n     * The type of policy\n     */\n    effect: PolicyStatement.EffectEnum;\n    /**\n     * The actions the policy operates on\n     */\n    actions: Array<string>;\n    /**\n     * The resources to which the policy applies\n     */\n    resources: Array<string>;\n}\nexport namespace PolicyStatement {\n    export type EffectEnum = 'allow' | 'deny';\n    export const EffectEnum = {\n        Allow: 'allow' as EffectEnum,\n        Deny: 'deny' as EffectEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ReportConfig } from './reportConfig';\n\n\nexport interface QueueReportRequest { \n  [key: string]: any | any;\n\n\n    clientId: string;\n    source: QueueReportRequest.SourceEnum;\n    serverId?: string | null;\n    name: string;\n    title: string;\n    outputFormat: QueueReportRequest.OutputFormatEnum;\n    config: ReportConfig;\n}\nexport namespace QueueReportRequest {\n    export type SourceEnum = 'dataset' | 'analytics';\n    export const SourceEnum = {\n        Dataset: 'dataset' as SourceEnum,\n        Analytics: 'analytics' as SourceEnum\n    };\n    export type OutputFormatEnum = 'pdf' | 'xlsx' | 'xml' | 'csv' | 'raw' | 'json' | 'raw_compact' | 'source';\n    export const OutputFormatEnum = {\n        Pdf: 'pdf' as OutputFormatEnum,\n        Xlsx: 'xlsx' as OutputFormatEnum,\n        Xml: 'xml' as OutputFormatEnum,\n        Csv: 'csv' as OutputFormatEnum,\n        Raw: 'raw' as OutputFormatEnum,\n        Json: 'json' as OutputFormatEnum,\n        RawCompact: 'raw_compact' as OutputFormatEnum,\n        Source: 'source' as OutputFormatEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ReportConfig } from './reportConfig';\nimport { IdNameType } from './idNameType';\n\n\nexport interface QueuedReportResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique ID of this report definition\n     */\n    id: string;\n    owner: IdNameType;\n    user: IdName;\n    client: IdName;\n    /**\n     * The base report name\n     */\n    name: string;\n    /**\n     * The report title as set by the user\n     */\n    title: string;\n    /**\n     * The reporting subsystem that generates this report\n     */\n    source: QueuedReportResponse.SourceEnum;\n    /**\n     * The status of this report\n     */\n    status: QueuedReportResponse.StatusEnum;\n    /**\n     * The ISO date/time that this report was queued\n     */\n    queueDate: string;\n    /**\n     * The ISO date/time that this report\\'s state last changed\n     */\n    updateDate: string;\n    /**\n     * The output format for this report\n     */\n    outputFormat: QueuedReportResponse.OutputFormatEnum;\n    /**\n     * The progress percentage of this report\n     */\n    progress: number;\n    /**\n     * report queue order, will change sometimes while queued\n     */\n    order: number;\n    /**\n     * The report priority: 0 = urgent, 1 = high, 2 = normal, 3 = low, 4+ = none (sorted as an integer)\n     */\n    priority: number;\n    config: ReportConfig;\n    /**\n     * What triggered the report\n     */\n    triggeredBy: QueuedReportResponse.TriggeredByEnum;\n    /**\n     * The UUID of a base report in analytics (if any) this report is linked to\n     */\n    baseReportId?: string | null;\n}\nexport namespace QueuedReportResponse {\n    export type SourceEnum = 'dataset' | 'analytics';\n    export const SourceEnum = {\n        Dataset: 'dataset' as SourceEnum,\n        Analytics: 'analytics' as SourceEnum\n    };\n    export type StatusEnum = 'queued' | 'running' | 'completed' | 'aborted' | 'failed' | 'retry';\n    export const StatusEnum = {\n        Queued: 'queued' as StatusEnum,\n        Running: 'running' as StatusEnum,\n        Completed: 'completed' as StatusEnum,\n        Aborted: 'aborted' as StatusEnum,\n        Failed: 'failed' as StatusEnum,\n        Retry: 'retry' as StatusEnum\n    };\n    export type OutputFormatEnum = 'pdf' | 'xlsx' | 'xml' | 'csv' | 'raw' | 'json' | 'raw_compact' | 'source';\n    export const OutputFormatEnum = {\n        Pdf: 'pdf' as OutputFormatEnum,\n        Xlsx: 'xlsx' as OutputFormatEnum,\n        Xml: 'xml' as OutputFormatEnum,\n        Csv: 'csv' as OutputFormatEnum,\n        Raw: 'raw' as OutputFormatEnum,\n        Json: 'json' as OutputFormatEnum,\n        RawCompact: 'raw_compact' as OutputFormatEnum,\n        Source: 'source' as OutputFormatEnum\n    };\n    export type TriggeredByEnum = 'user' | 'schedule' | 'dashboard';\n    export const TriggeredByEnum = {\n        User: 'user' as TriggeredByEnum,\n        Schedule: 'schedule' as TriggeredByEnum,\n        Dashboard: 'dashboard' as TriggeredByEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface RebuildDashboardWidgetResponse { \n  [key: string]: any | any;\n\n\n    status: RebuildDashboardWidgetResponse.StatusEnum;\n}\nexport namespace RebuildDashboardWidgetResponse {\n    export type StatusEnum = 'ok' | 'failed';\n    export const StatusEnum = {\n        Ok: 'ok' as StatusEnum,\n        Failed: 'failed' as StatusEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ReminderReset } from './reminderReset';\nimport { ReminderTriggerValue } from './reminderTriggerValue';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ReminderCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this reminder\n     */\n    name?: string | null;\n    target?: IdNameType;\n    /**\n     * Specify the trigger type of the reminder, which can be either time, odometer or engine hours.\n     */\n    type?: ReminderCreateRequest.TypeEnum | null;\n    /**\n     * The reminder mode. If set to once, the reminder will be disabled as soon as it has triggered at least once.\n     */\n    mode?: ReminderCreateRequest.ModeEnum | null;\n    /**\n     * The timezone to use for time based triggers.\n     */\n    timeZoneId?: string | null;\n    trigger?: ReminderTriggerValue;\n    reset?: ReminderReset;\n    /**\n     * Whether the reminder is still enabled (will be false for reminders with mode set to `once` that have already triggered.\n     */\n    enabled?: boolean | null;\n    /**\n     * The client that owns this reminder\n     */\n    ownerId: string;\n}\nexport namespace ReminderCreateRequest {\n    export type TypeEnum = 'odo' | 'hours' | 'time';\n    export const TypeEnum = {\n        Odo: 'odo' as TypeEnum,\n        Hours: 'hours' as TypeEnum,\n        Time: 'time' as TypeEnum\n    };\n    export type ModeEnum = 'once' | 'repeating';\n    export const ModeEnum = {\n        Once: 'once' as ModeEnum,\n        Repeating: 'repeating' as ModeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ReminderReset } from './reminderReset';\nimport { ReminderTriggerValue } from './reminderTriggerValue';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ReminderListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this reminder\n     */\n    name?: string | null;\n    target?: IdNameType;\n    /**\n     * Specify the trigger type of the reminder, which can be either time, odometer or engine hours.\n     */\n    type?: ReminderListItem.TypeEnum | null;\n    /**\n     * The reminder mode. If set to once, the reminder will be disabled as soon as it has triggered at least once.\n     */\n    mode?: ReminderListItem.ModeEnum | null;\n    /**\n     * The timezone to use for time based triggers.\n     */\n    timeZoneId?: string | null;\n    trigger?: ReminderTriggerValue;\n    reset?: ReminderReset;\n    /**\n     * Whether the reminder is still enabled (will be false for reminders with mode set to `once` that have already triggered.\n     */\n    enabled?: boolean | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace ReminderListItem {\n    export type TypeEnum = 'odo' | 'hours' | 'time';\n    export const TypeEnum = {\n        Odo: 'odo' as TypeEnum,\n        Hours: 'hours' as TypeEnum,\n        Time: 'time' as TypeEnum\n    };\n    export type ModeEnum = 'once' | 'repeating';\n    export const ModeEnum = {\n        Once: 'once' as ModeEnum,\n        Repeating: 'repeating' as ModeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ReminderResetWeekly } from './reminderResetWeekly';\nimport { ReminderResetMonthly } from './reminderResetMonthly';\nimport { ReminderResetDaily } from './reminderResetDaily';\n\n\nexport interface ReminderReset { \n  [key: string]: any | any;\n\n\n    /**\n     * The type of reset for the reminder. Affects which of the reset fields need to be completed.\n     */\n    type?: ReminderReset.TypeEnum | null;\n    counter?: number | null;\n    daily?: ReminderResetDaily;\n    weekly?: ReminderResetWeekly;\n    monthly?: ReminderResetMonthly;\n}\nexport namespace ReminderReset {\n    export type TypeEnum = 'none' | 'daily' | 'weekly' | 'monthly';\n    export const TypeEnum = {\n        None: 'none' as TypeEnum,\n        Daily: 'daily' as TypeEnum,\n        Weekly: 'weekly' as TypeEnum,\n        Monthly: 'monthly' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ReminderReset } from './reminderReset';\nimport { ReminderTriggerValue } from './reminderTriggerValue';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ReminderResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this reminder\n     */\n    name?: string | null;\n    target?: IdNameType;\n    /**\n     * Specify the trigger type of the reminder, which can be either time, odometer or engine hours.\n     */\n    type?: ReminderResponse.TypeEnum | null;\n    /**\n     * The reminder mode. If set to once, the reminder will be disabled as soon as it has triggered at least once.\n     */\n    mode?: ReminderResponse.ModeEnum | null;\n    /**\n     * The timezone to use for time based triggers.\n     */\n    timeZoneId?: string | null;\n    trigger?: ReminderTriggerValue;\n    reset?: ReminderReset;\n    /**\n     * Whether the reminder is still enabled (will be false for reminders with mode set to `once` that have already triggered.\n     */\n    enabled?: boolean | null;\n    /**\n     * The date/time when the reminder last triggered.\n     */\n    lastTriggered?: string | null;\n    entity: EntityInfo;\n}\nexport namespace ReminderResponse {\n    export type TypeEnum = 'odo' | 'hours' | 'time';\n    export const TypeEnum = {\n        Odo: 'odo' as TypeEnum,\n        Hours: 'hours' as TypeEnum,\n        Time: 'time' as TypeEnum\n    };\n    export type ModeEnum = 'once' | 'repeating';\n    export const ModeEnum = {\n        Once: 'once' as ModeEnum,\n        Repeating: 'repeating' as ModeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ReminderReset } from './reminderReset';\nimport { ReminderTriggerValue } from './reminderTriggerValue';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ReminderUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this reminder\n     */\n    name?: string | null;\n    target?: IdNameType;\n    /**\n     * Specify the trigger type of the reminder, which can be either time, odometer or engine hours.\n     */\n    type?: ReminderUpdateRequest.TypeEnum | null;\n    /**\n     * The reminder mode. If set to once, the reminder will be disabled as soon as it has triggered at least once.\n     */\n    mode?: ReminderUpdateRequest.ModeEnum | null;\n    /**\n     * The timezone to use for time based triggers.\n     */\n    timeZoneId?: string | null;\n    trigger?: ReminderTriggerValue;\n    reset?: ReminderReset;\n    /**\n     * Whether the reminder is still enabled (will be false for reminders with mode set to `once` that have already triggered.\n     */\n    enabled?: boolean | null;\n}\nexport namespace ReminderUpdateRequest {\n    export type TypeEnum = 'odo' | 'hours' | 'time';\n    export const TypeEnum = {\n        Odo: 'odo' as TypeEnum,\n        Hours: 'hours' as TypeEnum,\n        Time: 'time' as TypeEnum\n    };\n    export type ModeEnum = 'once' | 'repeating';\n    export const ModeEnum = {\n        Once: 'once' as ModeEnum,\n        Repeating: 'repeating' as ModeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * Describes column options\n */\nexport interface ReportDefinitionColumnOptions { \n  [key: string]: any | any;\n\n\n    /**\n     * The id of the column\n     */\n    id: string;\n    /**\n     * The title of the column\n     */\n    title: string;\n    /**\n     * The width of the column\n     */\n    width: number;\n    /**\n     * Indicates whether this column is suggested as a default\n     */\n    def: boolean;\n    /**\n     * Indicates whether this column is required\n     */\n    required: boolean;\n    /**\n     * The text alignment, either \\'Left\\', \\'Center\\' or \\'Right\\'\n     */\n    align: ReportDefinitionColumnOptions.AlignEnum;\n    /**\n     * The calculated measures expression to use\n     */\n    expression?: string | null;\n}\nexport namespace ReportDefinitionColumnOptions {\n    export type AlignEnum = 'Left' | 'Center' | 'Right';\n    export const AlignEnum = {\n        Left: 'Left' as AlignEnum,\n        Center: 'Center' as AlignEnum,\n        Right: 'Right' as AlignEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\nimport { ReportDefinitionStyleOptions } from './reportDefinitionStyleOptions';\n\n\n/**\n * A ReportDefinition describes a runnable report, it\\'s parameters and layout options\n */\nexport interface ReportDefinitionResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique ID of this report definition\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this report\n     */\n    name: string;\n    /**\n     * A description of the report\n     */\n    description: string;\n    /**\n     * A list of tags that describe this report\n     */\n    tags: Array<string>;\n    /**\n     * The reporting subsystem that generates this report\n     */\n    source: ReportDefinitionResponse.SourceEnum;\n    /**\n     * Indicates whether this report can be scheduled\n     */\n    schedulable: boolean;\n    /**\n     * One or more report styles that can be selected for this report\n     */\n    styles: Array<ReportDefinitionStyleOptions>;\n}\nexport namespace ReportDefinitionResponse {\n    export type SourceEnum = 'dataset' | 'analytics';\n    export const SourceEnum = {\n        Dataset: 'dataset' as SourceEnum,\n        Analytics: 'analytics' as SourceEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface ReportTemplateConfig { \n  [key: string]: any | any;\n\n\n    /**\n     * The output format for this report\n     */\n    outputFormat: ReportTemplateConfig.OutputFormatEnum;\n    /**\n     * The ID of the report defininition that was used to create this report\n     */\n    definitionId: string;\n    /**\n     * The style of the report that was selected\n     */\n    styleId: string;\n    /**\n     * The parameters that were passed to the report\n     */\n    parameters: { [key: string]: any; };\n    /**\n     * The report fields that should be visible and modifyable by the end user\n     */\n    editableFields: Array<string>;\n}\nexport namespace ReportTemplateConfig {\n    export type OutputFormatEnum = 'pdf' | 'xlsx' | 'xml' | 'csv' | 'raw' | 'json' | 'raw_compact' | 'source';\n    export const OutputFormatEnum = {\n        Pdf: 'pdf' as OutputFormatEnum,\n        Xlsx: 'xlsx' as OutputFormatEnum,\n        Xml: 'xml' as OutputFormatEnum,\n        Csv: 'csv' as OutputFormatEnum,\n        Raw: 'raw' as OutputFormatEnum,\n        Json: 'json' as OutputFormatEnum,\n        RawCompact: 'raw_compact' as OutputFormatEnum,\n        Source: 'source' as OutputFormatEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { GeocoderBounds } from './geocoderBounds';\nimport { ZonePoint } from './zonePoint';\nimport { GeocoderAddress } from './geocoderAddress';\n\n\n/**\n * A reverse geocode search result item\n */\nexport interface ReverseGeocodeResult { \n  [key: string]: any | any;\n\n\n    type: ReverseGeocodeResult.TypeEnum;\n    id?: string | null;\n    text: string;\n    lon: number;\n    lat: number;\n    bounds?: GeocoderBounds;\n    address?: GeocoderAddress;\n    geometry?: Array<ZonePoint> | null;\n    /**\n     * speed limit in km/h\n     */\n    speed?: number | null;\n}\nexport namespace ReverseGeocodeResult {\n    export type TypeEnum = 'location' | 'keepin' | 'nogo' | 'route' | 'address';\n    export const TypeEnum = {\n        Location: 'location' as TypeEnum,\n        Keepin: 'keepin' as TypeEnum,\n        Nogo: 'nogo' as TypeEnum,\n        Route: 'route' as TypeEnum,\n        Address: 'address' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { RoadSpeedModifierEntry } from './roadSpeedModifierEntry';\n\n\nexport interface RoadProfileCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: RoadProfileCreateRequest.StateEnum | null;\n    /**\n     * The road speed modifiers for this profile\n     */\n    speedModifiers?: Array<RoadSpeedModifierEntry> | null;\n    /**\n     * The client that owns this Road Profile\n     */\n    ownerId: string;\n}\nexport namespace RoadProfileCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\nimport { RoadSpeedModifierEntry } from './roadSpeedModifierEntry';\n\n\nexport interface RoadProfileListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: RoadProfileListItem.StateEnum | null;\n    /**\n     * The road speed modifiers for this profile\n     */\n    speedModifiers?: Array<RoadSpeedModifierEntry> | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace RoadProfileListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\nimport { RoadSpeedModifierEntry } from './roadSpeedModifierEntry';\n\n\nexport interface RoadProfileResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: RoadProfileResponse.StateEnum | null;\n    /**\n     * The road speed modifiers for this profile\n     */\n    speedModifiers?: Array<RoadSpeedModifierEntry> | null;\n    entity: EntityInfo;\n}\nexport namespace RoadProfileResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { RoadSpeedModifierEntry } from './roadSpeedModifierEntry';\n\n\nexport interface RoadProfileUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: RoadProfileUpdateRequest.StateEnum | null;\n    /**\n     * The road speed modifiers for this profile\n     */\n    speedModifiers?: Array<RoadSpeedModifierEntry> | null;\n}\nexport namespace RoadProfileUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EventFilter } from './eventFilter';\n\n\nexport interface RoadSpeedModifierEntry { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique ID of this road speed modifier\n     */\n    id: string;\n    /**\n     * A descriptive name for this road speed modifier\n     */\n    name: string;\n    filter: EventFilter;\n    /**\n     * The new road speed that will be applied if the filter matches.\n     */\n    speed: number;\n    /**\n     * The speed unit, either km/h or miles per hour\n     */\n    unit: RoadSpeedModifierEntry.UnitEnum;\n}\nexport namespace RoadSpeedModifierEntry {\n    export type UnitEnum = 'kmh' | 'mph';\n    export const UnitEnum = {\n        Kmh: 'kmh' as UnitEnum,\n        Mph: 'mph' as UnitEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface Schedule { \n  [key: string]: any | any;\n\n\n    /**\n     * The type of schedule\n     */\n    scheduleType?: Schedule.ScheduleTypeEnum | null;\n    /**\n     * The time of schedule initation. Also sets the time at which reports run.\n     */\n    startTime?: string | null;\n    /**\n     * For daily and hourly scheduled, every {{every}} x hours/days\n     */\n    every?: number | null;\n    /**\n     * For weekly schedules, the days of the week in which to run (0-6 where 0 = sunday). For monthly schedule, a single value with the day of the month to run on.\n     */\n    days?: Array<number> | null;\n    /**\n     * For monthly schedules, the month number (1-12) in which to run.\n     */\n    months?: Array<number> | null;\n}\nexport namespace Schedule {\n    export type ScheduleTypeEnum = 'once' | 'hourly' | 'daily' | 'weekly' | 'monthly';\n    export const ScheduleTypeEnum = {\n        Once: 'once' as ScheduleTypeEnum,\n        Hourly: 'hourly' as ScheduleTypeEnum,\n        Daily: 'daily' as ScheduleTypeEnum,\n        Weekly: 'weekly' as ScheduleTypeEnum,\n        Monthly: 'monthly' as ScheduleTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ScheduledReportReport } from './scheduledReportReport';\nimport { Schedule } from './schedule';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ScheduledReportCreateRequest { \n  [key: string]: any | any;\n\n\n    user?: IdName;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: ScheduledReportCreateRequest.StateEnum | null;\n    /**\n     * The type of scheduled report.\n     */\n    scheduleType?: ScheduledReportCreateRequest.ScheduleTypeEnum | null;\n    schedule?: Schedule;\n    reports?: { [key: string]: ScheduledReportReport; };\n    /**\n     * The recipients that will receive an email with the completed reports\n     */\n    recipients?: Array<IdNameType> | null;\n    /**\n     * The client or vendor that owns this entity\n     */\n    ownerId: string;\n}\nexport namespace ScheduledReportCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type ScheduleTypeEnum = 'report' | 'analytics';\n    export const ScheduleTypeEnum = {\n        Report: 'report' as ScheduleTypeEnum,\n        Analytics: 'analytics' as ScheduleTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { Schedule } from './schedule';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ScheduledReportListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    user?: IdName;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity.\n     */\n    state?: ScheduledReportListItem.StateEnum | null;\n    /**\n     * The type of scheduled report.\n     */\n    scheduleType?: ScheduledReportListItem.ScheduleTypeEnum | null;\n    schedule?: Schedule;\n    /**\n     * The number of reports attached to this schedule.\n     */\n    reports?: number | null;\n    /**\n     * The number of recipients that will receive an email with the completed reports.\n     */\n    recipients?: number | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace ScheduledReportListItem {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type ScheduleTypeEnum = 'report' | 'analytics';\n    export const ScheduleTypeEnum = {\n        Report: 'report' as ScheduleTypeEnum,\n        Analytics: 'analytics' as ScheduleTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ReportConfig } from './reportConfig';\n\n\nexport interface ScheduledReportReport { \n  [key: string]: any | any;\n\n\n    /**\n     * The report title as set by the user\n     */\n    title?: string | null;\n    /**\n     * The output format for this report\n     */\n    outputFormat?: ScheduledReportReport.OutputFormatEnum | null;\n    config?: ReportConfig;\n}\nexport namespace ScheduledReportReport {\n    export type OutputFormatEnum = 'pdf' | 'xlsx' | 'xml' | 'csv' | 'raw' | 'json' | 'raw_compact' | 'source';\n    export const OutputFormatEnum = {\n        Pdf: 'pdf' as OutputFormatEnum,\n        Xlsx: 'xlsx' as OutputFormatEnum,\n        Xml: 'xml' as OutputFormatEnum,\n        Csv: 'csv' as OutputFormatEnum,\n        Raw: 'raw' as OutputFormatEnum,\n        Json: 'json' as OutputFormatEnum,\n        RawCompact: 'raw_compact' as OutputFormatEnum,\n        Source: 'source' as OutputFormatEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ScheduledReportReport } from './scheduledReportReport';\nimport { EntityInfo } from './entityInfo';\nimport { Schedule } from './schedule';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ScheduledReportResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    user?: IdName;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: ScheduledReportResponse.StateEnum | null;\n    /**\n     * The type of scheduled report.\n     */\n    scheduleType?: ScheduledReportResponse.ScheduleTypeEnum | null;\n    schedule?: Schedule;\n    reports?: { [key: string]: ScheduledReportReport; };\n    /**\n     * The recipients that will receive an email with the completed reports\n     */\n    recipients?: Array<IdNameType> | null;\n    entity: EntityInfo;\n}\nexport namespace ScheduledReportResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type ScheduleTypeEnum = 'report' | 'analytics';\n    export const ScheduleTypeEnum = {\n        Report: 'report' as ScheduleTypeEnum,\n        Analytics: 'analytics' as ScheduleTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ScheduledReportReport } from './scheduledReportReport';\nimport { Schedule } from './schedule';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ScheduledReportUpdateRequest { \n  [key: string]: any | any;\n\n\n    user?: IdName;\n    /**\n     * A unique name for this entity\n     */\n    name?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: ScheduledReportUpdateRequest.StateEnum | null;\n    /**\n     * The type of scheduled report.\n     */\n    scheduleType?: ScheduledReportUpdateRequest.ScheduleTypeEnum | null;\n    schedule?: Schedule;\n    reports?: { [key: string]: ScheduledReportReport; };\n    /**\n     * The recipients that will receive an email with the completed reports\n     */\n    recipients?: Array<IdNameType> | null;\n}\nexport namespace ScheduledReportUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type ScheduleTypeEnum = 'report' | 'analytics';\n    export const ScheduleTypeEnum = {\n        Report: 'report' as ScheduleTypeEnum,\n        Analytics: 'analytics' as ScheduleTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface SimCardCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The serial number of the SIM card that is used to uniquely identify it.\n     */\n    name?: string | null;\n    /**\n     * The name of the telecommunications network.\n     */\n    networkName: string;\n    /**\n     * The direct mobile number for this SIM card. Must be in international format starting with +.\n     */\n    number: string;\n    /**\n     * A short description of the sim card.\n     */\n    description: string;\n    /**\n     * The current state of the object\n     */\n    state?: SimCardCreateRequest.StateEnum | null;\n    fields?: { [key: string]: object; };\n    ownerId: string;\n}\nexport namespace SimCardCreateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface SimCardListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID for this SIM card\n     */\n    id: string;\n    owner: IdName;\n    /**\n     * The serial number of the SIM card that is used to uniquely identify it.\n     */\n    name: string;\n    /**\n     * The name of the telecommunications network.\n     */\n    networkName: string;\n    /**\n     * The direct mobile number for this SIM card. Must be in international format starting with +.\n     */\n    number: string;\n    /**\n     * A short description of the sim card.\n     */\n    description: string;\n    /**\n     * The current state of the object\n     */\n    state: SimCardListItem.StateEnum;\n    device: IdName;\n    fields: { [key: string]: object; };\n}\nexport namespace SimCardListItem {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface SimCardResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The serial number of the SIM card that is used to uniquely identify it.\n     */\n    name?: string | null;\n    /**\n     * The name of the telecommunications network.\n     */\n    networkName?: string | null;\n    /**\n     * The direct mobile number for this SIM card. Must be in international format starting with +.\n     */\n    number?: string | null;\n    /**\n     * A short description of the sim card.\n     */\n    description?: string | null;\n    /**\n     * The current state of the object\n     */\n    state?: SimCardResponse.StateEnum | null;\n    fields?: { [key: string]: object; };\n    device?: IdName;\n    entity: EntityInfo;\n}\nexport namespace SimCardResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface SimCardUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The serial number of the SIM card that is used to uniquely identify it.\n     */\n    name?: string | null;\n    /**\n     * The name of the telecommunications network.\n     */\n    networkName?: string | null;\n    /**\n     * The direct mobile number for this SIM card. Must be in international format starting with +.\n     */\n    number?: string | null;\n    /**\n     * A short description of the sim card.\n     */\n    description?: string | null;\n    /**\n     * The current state of the object\n     */\n    state?: SimCardUpdateRequest.StateEnum | null;\n    fields?: { [key: string]: object; };\n}\nexport namespace SimCardUpdateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface SmsGatewayProviderCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The name of the sms gateway provider\n     */\n    name?: string | null;\n    type?: IdName;\n    /**\n     * Whether or not the sms gateway is oneway or twoway\n     */\n    direction?: SmsGatewayProviderCreateRequest.DirectionEnum | null;\n    /**\n     * The state this entity\n     */\n    state?: SmsGatewayProviderCreateRequest.StateEnum | null;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The client that owns this sms gateway provider\n     */\n    ownerId: string;\n}\nexport namespace SmsGatewayProviderCreateRequest {\n    export type DirectionEnum = 'oneway' | 'twoway';\n    export const DirectionEnum = {\n        Oneway: 'oneway' as DirectionEnum,\n        Twoway: 'twoway' as DirectionEnum\n    };\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface SmsGatewayProviderListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the sms gateway provider\n     */\n    name?: string | null;\n    type?: IdName;\n    /**\n     * Whether or not the sms gateway is oneway or twoway\n     */\n    direction?: SmsGatewayProviderListItem.DirectionEnum | null;\n    /**\n     * The state this entity\n     */\n    state?: SmsGatewayProviderListItem.StateEnum | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace SmsGatewayProviderListItem {\n    export type DirectionEnum = 'oneway' | 'twoway';\n    export const DirectionEnum = {\n        Oneway: 'oneway' as DirectionEnum,\n        Twoway: 'twoway' as DirectionEnum\n    };\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface SmsGatewayProviderResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the sms gateway provider\n     */\n    name?: string | null;\n    type?: IdName;\n    /**\n     * Whether or not the sms gateway is oneway or twoway\n     */\n    direction?: SmsGatewayProviderResponse.DirectionEnum | null;\n    /**\n     * The state this entity\n     */\n    state?: SmsGatewayProviderResponse.StateEnum | null;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n    entity: EntityInfo;\n}\nexport namespace SmsGatewayProviderResponse {\n    export type DirectionEnum = 'oneway' | 'twoway';\n    export const DirectionEnum = {\n        Oneway: 'oneway' as DirectionEnum,\n        Twoway: 'twoway' as DirectionEnum\n    };\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\n\n\nexport interface SmsGatewayProviderTypeListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the sms gateway provider type\n     */\n    name: string;\n    /**\n     * The tag to apply to the sms gateway provider type\n     */\n    tag: string;\n    /**\n     * The parameters used by the sms gateway type\n     */\n    parameterDefinition?: string | null;\n    /**\n     * Whether or not the sms gateway type is oneway or twoway\n     */\n    direction?: SmsGatewayProviderTypeListItem.DirectionEnum | null;\n    /**\n     * The state this entity\n     */\n    state?: SmsGatewayProviderTypeListItem.StateEnum | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace SmsGatewayProviderTypeListItem {\n    export type DirectionEnum = 'oneway' | 'twoway';\n    export const DirectionEnum = {\n        Oneway: 'oneway' as DirectionEnum,\n        Twoway: 'twoway' as DirectionEnum\n    };\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface SmsGatewayProviderTypeResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The name of the sms gateway provider type\n     */\n    name: string;\n    /**\n     * The tag to apply to the sms gateway provider type\n     */\n    tag: string;\n    /**\n     * The parameters used by the sms gateway type\n     */\n    parameterDefinition?: string | null;\n    /**\n     * Whether or not the sms gateway type is oneway or twoway\n     */\n    direction?: SmsGatewayProviderTypeResponse.DirectionEnum | null;\n    /**\n     * The state this entity\n     */\n    state?: SmsGatewayProviderTypeResponse.StateEnum | null;\n    entity: EntityInfo;\n}\nexport namespace SmsGatewayProviderTypeResponse {\n    export type DirectionEnum = 'oneway' | 'twoway';\n    export const DirectionEnum = {\n        Oneway: 'oneway' as DirectionEnum,\n        Twoway: 'twoway' as DirectionEnum\n    };\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\nexport interface SmsGatewayProviderUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The name of the sms gateway provider\n     */\n    name?: string | null;\n    type?: IdName;\n    /**\n     * Whether or not the sms gateway is oneway or twoway\n     */\n    direction?: SmsGatewayProviderUpdateRequest.DirectionEnum | null;\n    /**\n     * The state this entity\n     */\n    state?: SmsGatewayProviderUpdateRequest.StateEnum | null;\n    parameters?: { [key: string]: { [key: string]: any; }; };\n}\nexport namespace SmsGatewayProviderUpdateRequest {\n    export type DirectionEnum = 'oneway' | 'twoway';\n    export const DirectionEnum = {\n        Oneway: 'oneway' as DirectionEnum,\n        Twoway: 'twoway' as DirectionEnum\n    };\n    export type StateEnum = 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\n\n\nexport interface SslCertificateCreateRequest { \n  [key: string]: any | any;\n\n\n    company?: IdNameType;\n    /**\n     * The domain of the ssl certificate\n     */\n    domain?: string | null;\n    /**\n     * A field for capturing notes about the ssl certificate\n     */\n    notes?: string | null;\n    /**\n     * The state of the ssl certificate\n     */\n    state?: SslCertificateCreateRequest.StateEnum | null;\n    /**\n     * The company that owns this ssl certificate\n     */\n    ownerId: string;\n}\nexport namespace SslCertificateCreateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\n\n\nexport interface SslCertificateListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    company?: IdNameType;\n    /**\n     * The domain of the ssl certificate\n     */\n    domain?: string | null;\n    /**\n     * The state of the ssl certificate\n     */\n    state?: SslCertificateListItem.StateEnum | null;\n    /**\n     * The date the entity was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace SslCertificateListItem {\n    export type StateEnum = 'inactive' | 'active' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { IdNameType } from './idNameType';\n\n\nexport interface SslCertificateResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    company?: IdNameType;\n    /**\n     * The domain of the ssl certificate\n     */\n    domain?: string | null;\n    /**\n     * A field for capturing notes about the ssl certificate\n     */\n    notes?: string | null;\n    /**\n     * The state of the ssl certificate\n     */\n    state?: SslCertificateResponse.StateEnum | null;\n    entity: EntityInfo;\n}\nexport namespace SslCertificateResponse {\n    export type StateEnum = 'inactive' | 'active' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdNameType } from './idNameType';\n\n\nexport interface SslCertificateUpdateRequest { \n  [key: string]: any | any;\n\n\n    company?: IdNameType;\n    /**\n     * The domain of the ssl certificate\n     */\n    domain?: string | null;\n    /**\n     * A field for capturing notes about the ssl certificate\n     */\n    notes?: string | null;\n    /**\n     * The state of the ssl certificate\n     */\n    state?: SslCertificateUpdateRequest.StateEnum | null;\n}\nexport namespace SslCertificateUpdateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface StatChartOptions { \n  [key: string]: any | any;\n\n\n    data: StatChartOptions.DataEnum;\n    key?: string | null;\n    color?: string | null;\n    trend?: StatChartOptions.TrendEnum | null;\n    sparkline?: boolean | null;\n}\nexport namespace StatChartOptions {\n    export type DataEnum = 'average' | 'total' | 'first' | 'last';\n    export const DataEnum = {\n        Average: 'average' as DataEnum,\n        Total: 'total' as DataEnum,\n        First: 'first' as DataEnum,\n        Last: 'last' as DataEnum\n    };\n    export type TrendEnum = 'none' | 'percentage' | 'actual';\n    export const TrendEnum = {\n        None: 'none' as TrendEnum,\n        Percentage: 'percentage' as TrendEnum,\n        Actual: 'actual' as TrendEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface StatsEntityOutputOptions { \n  [key: string]: any | any;\n\n\n    groupLevel: StatsEntityOutputOptions.GroupLevelEnum;\n    rowLevel: StatsEntityOutputOptions.RowLevelEnum;\n    time: string;\n    flip: boolean;\n}\nexport namespace StatsEntityOutputOptions {\n    export type GroupLevelEnum = 'all' | 'type' | 'name' | 'company' | 'user' | 'distributor' | 'vendor' | 'client';\n    export const GroupLevelEnum = {\n        All: 'all' as GroupLevelEnum,\n        Type: 'type' as GroupLevelEnum,\n        Name: 'name' as GroupLevelEnum,\n        Company: 'company' as GroupLevelEnum,\n        User: 'user' as GroupLevelEnum,\n        Distributor: 'distributor' as GroupLevelEnum,\n        Vendor: 'vendor' as GroupLevelEnum,\n        Client: 'client' as GroupLevelEnum\n    };\n    export type RowLevelEnum = 'all' | 'year' | 'month' | 'day' | 'hour';\n    export const RowLevelEnum = {\n        All: 'all' as RowLevelEnum,\n        Year: 'year' as RowLevelEnum,\n        Month: 'month' as RowLevelEnum,\n        Day: 'day' as RowLevelEnum,\n        Hour: 'hour' as RowLevelEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface TargetLine { \n  [key: string]: any | any;\n\n\n    id: string;\n    name: string;\n    value: number;\n    color?: string | null;\n    borderWidth?: number | null;\n    borderDash?: Array<number> | null;\n    showLabel?: boolean | null;\n    type?: TargetLine.TypeEnum | null;\n}\nexport namespace TargetLine {\n    export type TypeEnum = 'dashed' | 'solid';\n    export const TypeEnum = {\n        Dashed: 'dashed' as TypeEnum,\n        Solid: 'solid' as TypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { TaskOptions } from './taskOptions';\nimport { IdName } from './idName';\nimport { TaskDates } from './taskDates';\nimport { IdNameType } from './idNameType';\n\n\nexport interface TaskResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique GUID for the task\n     */\n    id: string;\n    owner: IdNameType;\n    user?: IdName;\n    /**\n     * A number of entities that are linked to this task\n     */\n    linked: Array<IdNameType>;\n    options: TaskOptions;\n    /**\n     * The state of the task\n     */\n    state: TaskResponse.StateEnum;\n    date: TaskDates;\n    /**\n     * The type of the task\n     */\n    type: string;\n    data: { [key: string]: { [key: string]: any; }; };\n    results?: { [key: string]: { [key: string]: any; }; };\n}\nexport namespace TaskResponse {\n    export type StateEnum = 'pending' | 'executing' | 'waiting' | 'success' | 'canceling' | 'canceled' | 'failed' | 'timedout' | 'deferred';\n    export const StateEnum = {\n        Pending: 'pending' as StateEnum,\n        Executing: 'executing' as StateEnum,\n        Waiting: 'waiting' as StateEnum,\n        Success: 'success' as StateEnum,\n        Canceling: 'canceling' as StateEnum,\n        Canceled: 'canceled' as StateEnum,\n        Failed: 'failed' as StateEnum,\n        Timedout: 'timedout' as StateEnum,\n        Deferred: 'deferred' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface TestNotificationsRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The id of the company from which to send the test notification\n     */\n    ownerId?: string | null;\n    /**\n     * A list of notification channels to test\n     */\n    notificationChannels?: Array<TestNotificationsRequest.NotificationChannelsEnum> | null;\n    /**\n     * The url of the client application\n     */\n    siteUrl: string;\n}\nexport namespace TestNotificationsRequest {\n    export type NotificationChannelsEnum = 'email' | 'sms';\n    export const NotificationChannelsEnum = {\n        Email: 'email' as NotificationChannelsEnum,\n        Sms: 'sms' as NotificationChannelsEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeCustomHTMLTag } from './themeCustomHTMLTag';\n\n\nexport interface ThemeCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The ID of the base theme CSS\n     */\n    theme?: string | null;\n    /**\n     * The name of the theme\n     */\n    name?: string | null;\n    /**\n     * An optional description of the theme\n     */\n    description?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: ThemeCreateRequest.StateEnum | null;\n    /**\n     * A collection of CSS variables for the theme\n     */\n    variables?: { [key: string]: string; };\n    /**\n     * A collection of setting values for the theme\n     */\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The custom overwrites that will be injected after the theme css\n     */\n    customStyles?: string | null;\n    /**\n     * A list of custom HTML tags that are to be injected into the page for this theme\n     */\n    customTags?: Array<ThemeCustomHTMLTag> | null;\n    /**\n     * The client or vendor that owns this entity\n     */\n    ownerId: string;\n}\nexport namespace ThemeCreateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface ThemeCustomHTMLTag { \n  [key: string]: any | any;\n\n\n    /**\n     * A descriptive name for the custom tag\n     */\n    name: string;\n    /**\n     * The HTML tag type, i.e. \\'script\\' or \\'div\\'\n     */\n    tag: string;\n    /**\n     * A list of attributes for the tag\n     */\n    attributes: string;\n    /**\n     * The contents of the HTML Tag\n     */\n    contents: string;\n    /**\n     * The location where the tag should be inserted\n     */\n    location: ThemeCustomHTMLTag.LocationEnum;\n}\nexport namespace ThemeCustomHTMLTag {\n    export type LocationEnum = 'head' | 'body';\n    export const LocationEnum = {\n        Head: 'head' as LocationEnum,\n        Body: 'body' as LocationEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { EntityInfo } from './entityInfo';\nimport { ThemeCustomHTMLTag } from './themeCustomHTMLTag';\nimport { IdNameType } from './idNameType';\n\n\nexport interface ThemeResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The ID of the base theme CSS\n     */\n    theme?: string | null;\n    /**\n     * The name of the theme\n     */\n    name?: string | null;\n    /**\n     * An optional description of the theme\n     */\n    description?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: ThemeResponse.StateEnum | null;\n    /**\n     * A collection of CSS variables for the theme\n     */\n    variables?: { [key: string]: string; };\n    /**\n     * A collection of setting values for the theme\n     */\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The custom overwrites that will be injected after the theme css\n     */\n    customStyles?: string | null;\n    /**\n     * A list of custom HTML tags that are to be injected into the page for this theme\n     */\n    customTags?: Array<ThemeCustomHTMLTag> | null;\n    entity: EntityInfo;\n}\nexport namespace ThemeResponse {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeCustomHTMLTag } from './themeCustomHTMLTag';\n\n\nexport interface ThemeUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The ID of the base theme CSS\n     */\n    theme?: string | null;\n    /**\n     * The name of the theme\n     */\n    name?: string | null;\n    /**\n     * An optional description of the theme\n     */\n    description?: string | null;\n    /**\n     * The current state of this entity\n     */\n    state?: ThemeUpdateRequest.StateEnum | null;\n    /**\n     * A collection of CSS variables for the theme\n     */\n    variables?: { [key: string]: string; };\n    /**\n     * A collection of setting values for the theme\n     */\n    settings?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The custom overwrites that will be injected after the theme css\n     */\n    customStyles?: string | null;\n    /**\n     * A list of custom HTML tags that are to be injected into the page for this theme\n     */\n    customTags?: Array<ThemeCustomHTMLTag> | null;\n}\nexport namespace ThemeUpdateRequest {\n    export type StateEnum = 'active' | 'deleted';\n    export const StateEnum = {\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { TripRating } from './tripRating';\nimport { IdName } from './idName';\nimport { TripLocation } from './tripLocation';\nimport { TripStats } from './tripStats';\nimport { LabelValuePayload } from './labelValuePayload';\nimport { IdNameType } from './idNameType';\n\n\nexport interface TripResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * Unique id for this trip\n     */\n    id: string;\n    asset: IdName;\n    assetType: IdName;\n    /**\n     * The type of this trip\n     */\n    tripType: TripResponse.TripTypeEnum;\n    /**\n     * The ISO8601 UTC date that the trip was started\n     */\n    dateStart: string;\n    /**\n     * The ISO8601 UTC date that the trip was ended\n     */\n    dateEnd: string;\n    start: TripLocation;\n    end: TripLocation;\n    stats: TripStats;\n    rating?: TripRating;\n    /**\n     * The number of telemetry records that comprised this trip\n     */\n    records: number;\n    /**\n     * Any other assets that were linked to this trip\n     */\n    linkedAssets: Array<IdNameType>;\n    maxes: { [key: string]: number; };\n    /**\n     * An optional list of labels assigned to this trip\n     */\n    labels: Array<LabelValuePayload>;\n}\nexport namespace TripResponse {\n    export type TripTypeEnum = 'inactive' | 'active' | 'mixed';\n    export const TripTypeEnum = {\n        Inactive: 'inactive' as TripTypeEnum,\n        Active: 'active' as TripTypeEnum,\n        Mixed: 'mixed' as TripTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { NotificationSettings } from './notificationSettings';\nimport { UserPermissions } from './userPermissions';\n\n\nexport interface UserCreateRequest { \n  [key: string]: any | any;\n\n\n    name?: string | null;\n    /**\n     * The user\\'s email address, used to log into the system\n     */\n    emailAddress?: string | null;\n    /**\n     * An optional mobile number used for SMS notifications\n     */\n    mobile?: string | null;\n    /**\n     * The time zone identifier for the user (uses the tz database for timezones, see https://en.wikipedia.org/wiki/Tz_database)\n     */\n    timeZoneId?: string | null;\n    /**\n     * The language code for this user\n     */\n    language?: string | null;\n    /**\n     * The state of the user object\n     */\n    state?: UserCreateRequest.StateEnum | null;\n    notifySettings?: NotificationSettings;\n    defaultClient?: IdName;\n    /**\n     * A list of user roles that apply to this user\n     */\n    roles?: Array<IdName> | null;\n    costCentre?: IdName;\n    oidcTags?: { [key: string]: string; };\n    permissions?: UserPermissions;\n    /**\n     * The company that owns this user\n     */\n    ownerId: string;\n    /**\n     * The users password\n     */\n    password?: string | null;\n    /**\n     * Populate only if you wish to send an invitation email on account creation.  The full URL where the user will be redirected for completing their profile. Include a {token} template variable so the API can insert the reset token, and optionally a {domain} template variable into which the configured domain for this user will be inserted. i.e. https://{domain}/reset?token={token}\n     */\n    inviteUrl?: string | null;\n}\nexport namespace UserCreateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ApiKey } from './apiKey';\nimport { EntityInfo } from './entityInfo';\nimport { UnexpectedError } from './unexpectedError';\nimport { NotificationSettings } from './notificationSettings';\nimport { UserOtpMethod } from './userOtpMethod0';\nimport { IdNameType } from './idNameType';\nimport { UserPermissions } from './userPermissions';\n\n\nexport interface UserCreateResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    name?: string | null;\n    /**\n     * The user\\'s email address, used to log into the system\n     */\n    emailAddress?: string | null;\n    /**\n     * An optional mobile number used for SMS notifications\n     */\n    mobile?: string | null;\n    /**\n     * The time zone identifier for the user (uses the tz database for timezones, see https://en.wikipedia.org/wiki/Tz_database)\n     */\n    timeZoneId?: string | null;\n    /**\n     * The language code for this user\n     */\n    language?: string | null;\n    /**\n     * The state of the user object\n     */\n    state?: UserCreateResponse.StateEnum | null;\n    notifySettings?: NotificationSettings;\n    defaultClient?: IdName;\n    /**\n     * A list of user roles that apply to this user\n     */\n    roles?: Array<IdName> | null;\n    costCentre?: IdName;\n    oidcTags?: { [key: string]: string; };\n    permissions?: UserPermissions;\n    apiKeys?: { [key: string]: ApiKey; };\n    /**\n     * Lists the types of one time password methods that have been configured for this user\n     */\n    otp?: Array<UserOtpMethod> | null;\n    entity: EntityInfo;\n    inviteError?: UnexpectedError;\n}\nexport namespace UserCreateResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { IdNameType } from './idNameType';\n\n\nexport interface UserListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    name?: string | null;\n    /**\n     * The user\\'s email address, used to log into the system\n     */\n    emailAddress?: string | null;\n    /**\n     * An optional mobile number used for SMS notifications\n     */\n    mobile?: string | null;\n    /**\n     * The time zone identifier for the user (uses the tz datbase for timezones, see https://en.wikipedia.org/wiki/Tz_database)\n     */\n    timeZoneId?: string | null;\n    /**\n     * The language code for this user\n     */\n    language?: string | null;\n    /**\n     * The state of the user object\n     */\n    state?: UserListItem.StateEnum | null;\n    defaultClient?: IdName;\n    costCentre?: IdName;\n    /**\n     * The date the user was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace UserListItem {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ApiKey } from './apiKey';\nimport { EntityInfo } from './entityInfo';\nimport { UserSession } from './userSession';\nimport { NotificationSettings } from './notificationSettings';\nimport { UserOtpMethod } from './userOtpMethod0';\nimport { IdNameType } from './idNameType';\nimport { UserPermissions } from './userPermissions';\n\n\n/**\n * Information about a users profile\n */\nexport interface UserProfileResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    name?: string | null;\n    /**\n     * The user\\'s email address, used to log into the system\n     */\n    emailAddress?: string | null;\n    /**\n     * An optional mobile number used for SMS notifications\n     */\n    mobile?: string | null;\n    /**\n     * The time zone identifier for the user (uses the tz database for timezones, see https://en.wikipedia.org/wiki/Tz_database)\n     */\n    timeZoneId?: string | null;\n    /**\n     * The language code for this user\n     */\n    language?: string | null;\n    /**\n     * The state of the user object\n     */\n    state?: UserProfileResponse.StateEnum | null;\n    notifySettings?: NotificationSettings;\n    defaultClient?: IdName;\n    /**\n     * A list of user roles that apply to this user\n     */\n    roles?: Array<IdName> | null;\n    costCentre?: IdName;\n    oidcTags?: { [key: string]: string; };\n    permissions?: UserPermissions;\n    apiKeys?: { [key: string]: ApiKey; };\n    /**\n     * Lists the types of one time password methods that have been configured for this user\n     */\n    otp?: Array<UserOtpMethod> | null;\n    entity: EntityInfo;\n    /**\n     * A list of user session information\n     */\n    sessions: Array<UserSession>;\n}\nexport namespace UserProfileResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ApiKey } from './apiKey';\nimport { EntityInfo } from './entityInfo';\nimport { UnexpectedError } from './unexpectedError';\nimport { NotificationSettings } from './notificationSettings';\nimport { UserOtpMethod } from './userOtpMethod0';\nimport { IdNameType } from './idNameType';\nimport { UserPermissions } from './userPermissions';\n\n\nexport interface UserResetResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    name?: string | null;\n    /**\n     * The user\\'s email address, used to log into the system\n     */\n    emailAddress?: string | null;\n    /**\n     * An optional mobile number used for SMS notifications\n     */\n    mobile?: string | null;\n    /**\n     * The time zone identifier for the user (uses the tz database for timezones, see https://en.wikipedia.org/wiki/Tz_database)\n     */\n    timeZoneId?: string | null;\n    /**\n     * The language code for this user\n     */\n    language?: string | null;\n    /**\n     * The state of the user object\n     */\n    state?: UserResetResponse.StateEnum | null;\n    notifySettings?: NotificationSettings;\n    defaultClient?: IdName;\n    /**\n     * A list of user roles that apply to this user\n     */\n    roles?: Array<IdName> | null;\n    costCentre?: IdName;\n    oidcTags?: { [key: string]: string; };\n    permissions?: UserPermissions;\n    apiKeys?: { [key: string]: ApiKey; };\n    /**\n     * Lists the types of one time password methods that have been configured for this user\n     */\n    otp?: Array<UserOtpMethod> | null;\n    entity: EntityInfo;\n    resetError?: UnexpectedError;\n}\nexport namespace UserResetResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ApiKey } from './apiKey';\nimport { EntityInfo } from './entityInfo';\nimport { NotificationSettings } from './notificationSettings';\nimport { UserOtpMethod } from './userOtpMethod0';\nimport { IdNameType } from './idNameType';\nimport { UserPermissions } from './userPermissions';\n\n\nexport interface UserResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    name?: string | null;\n    /**\n     * The user\\'s email address, used to log into the system\n     */\n    emailAddress?: string | null;\n    /**\n     * An optional mobile number used for SMS notifications\n     */\n    mobile?: string | null;\n    /**\n     * The time zone identifier for the user (uses the tz database for timezones, see https://en.wikipedia.org/wiki/Tz_database)\n     */\n    timeZoneId?: string | null;\n    /**\n     * The language code for this user\n     */\n    language?: string | null;\n    /**\n     * The state of the user object\n     */\n    state?: UserResponse.StateEnum | null;\n    notifySettings?: NotificationSettings;\n    defaultClient?: IdName;\n    /**\n     * A list of user roles that apply to this user\n     */\n    roles?: Array<IdName> | null;\n    costCentre?: IdName;\n    oidcTags?: { [key: string]: string; };\n    permissions?: UserPermissions;\n    apiKeys?: { [key: string]: ApiKey; };\n    /**\n     * Lists the types of one time password methods that have been configured for this user\n     */\n    otp?: Array<UserOtpMethod> | null;\n    entity: EntityInfo;\n}\nexport namespace UserResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { NotificationSettings } from './notificationSettings';\nimport { UserPermissions } from './userPermissions';\n\n\nexport interface UserUpdateRequest { \n  [key: string]: any | any;\n\n\n    name?: string | null;\n    /**\n     * The user\\'s email address, used to log into the system\n     */\n    emailAddress?: string | null;\n    /**\n     * An optional mobile number used for SMS notifications\n     */\n    mobile?: string | null;\n    /**\n     * The time zone identifier for the user (uses the tz database for timezones, see https://en.wikipedia.org/wiki/Tz_database)\n     */\n    timeZoneId?: string | null;\n    /**\n     * The language code for this user\n     */\n    language?: string | null;\n    /**\n     * The state of the user object\n     */\n    state?: UserUpdateRequest.StateEnum | null;\n    notifySettings?: NotificationSettings;\n    defaultClient?: IdName;\n    /**\n     * A list of user roles that apply to this user\n     */\n    roles?: Array<IdName> | null;\n    costCentre?: IdName;\n    oidcTags?: { [key: string]: string; };\n    permissions?: UserPermissions;\n    /**\n     * The users password\n     */\n    password?: string | null;\n}\nexport namespace UserUpdateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { IdName } from './idName';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { EntityInfo } from './entityInfo';\nimport { EmailServerConfiguration } from './emailServerConfiguration';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\nexport interface VendorCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: VendorCreateRequest.StateEnum | null;\n    entity?: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    features?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The group to which this vendor belongs\n     */\n    group?: string | null;\n    /**\n     * A list of map sets that are made available to the client\\'s of this vendor.\n     */\n    availableMapSets?: Array<IdName> | null;\n    defaultMapSet?: IdName;\n    /**\n     * UUID\\'s of the device types that this vendor is allowed to use. An empty list means all device types.\n     */\n    availableDeviceTypes?: Array<IdName> | null;\n    /**\n     * A list of email providers that are made available to the client\\'s of this vendor.\n     */\n    availableEmailProviders?: Array<IdNameState> | null;\n    emailServer?: EmailServerConfiguration;\n    /**\n     * [DEPRECATED] Use the listCompanyGroups operation instead\n     */\n    clientGroups?: Array<IdName> | null;\n    ownerId: string;\n}\nexport namespace VendorCreateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\n\n\n/**\n * Summary vendor information returned in lists.\n */\nexport interface VendorListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The vendor\\'s unique ID\n     */\n    id: string;\n    /**\n     * The vendor\\'s display name\n     */\n    name: string;\n    /**\n     * The vendor website (if available)\n     */\n    website: string;\n    owner: IdName;\n    /**\n     * The group to which this vendor belongs\n     */\n    group: string;\n    /**\n     * The state of this vendor\n     */\n    state: VendorListItem.StateEnum;\n    counts?: { [key: string]: number; };\n    /**\n     * The date this vendor was created\n     */\n    creationDate: string;\n    /**\n     * The date that this vendor was last modified\n     */\n    modifiedDate: string;\n}\nexport namespace VendorListItem {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { IdName } from './idName';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { EntityInfo } from './entityInfo';\nimport { EmailServerConfiguration } from './emailServerConfiguration';\nimport { IdNameType } from './idNameType';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\nexport interface VendorResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: VendorResponse.StateEnum | null;\n    entity: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    features?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The group to which this vendor belongs\n     */\n    group?: string | null;\n    /**\n     * A list of map sets that are made available to the client\\'s of this vendor.\n     */\n    availableMapSets?: Array<IdName> | null;\n    defaultMapSet?: IdName;\n    /**\n     * UUID\\'s of the device types that this vendor is allowed to use. An empty list means all device types.\n     */\n    availableDeviceTypes?: Array<IdName> | null;\n    /**\n     * A list of email providers that are made available to the client\\'s of this vendor.\n     */\n    availableEmailProviders?: Array<IdNameState> | null;\n    emailServer?: EmailServerConfiguration;\n    /**\n     * [DEPRECATED] Use the listCompanyGroups operation instead\n     */\n    clientGroups?: Array<IdName> | null;\n}\nexport namespace VendorResponse {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { ThemeInfo } from './themeInfo';\nimport { OpenIdConnectIssuer } from './openIdConnectIssuer';\nimport { CustomFieldDefinition } from './customFieldDefinition';\nimport { UserPasswordPolicy } from './userPasswordPolicy';\nimport { CompanyAddress } from './companyAddress';\nimport { IdNameState } from './idNameState';\nimport { IdName } from './idName';\nimport { CompanyDataRetentionSettings } from './companyDataRetentionSettings';\nimport { CompanySSLCertificate } from './companySSLCertificate';\nimport { SoftLimits } from './softLimits';\nimport { EntityInfo } from './entityInfo';\nimport { EmailServerConfiguration } from './emailServerConfiguration';\nimport { CompanyMessages } from './companyMessages';\nimport { CompanySupportDetails } from './companySupportDetails';\n\n\nexport interface VendorUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * The display name of the company\n     */\n    name?: string | null;\n    /**\n     * A list of custom ID\\'s for this company. Can be queried using the getClientByTag, getVendorByTag and getDistributorByTag methods.\n     */\n    tags?: Array<string> | null;\n    /**\n     * The company website (if available)\n     */\n    website?: string | null;\n    /**\n     * The state of this company\n     */\n    state?: VendorUpdateRequest.StateEnum | null;\n    entity?: EntityInfo;\n    limits?: SoftLimits;\n    flags?: { [key: string]: { [key: string]: object; }; };\n    retention?: CompanyDataRetentionSettings;\n    passwordPolicy?: UserPasswordPolicy;\n    theme?: ThemeInfo;\n    address?: CompanyAddress;\n    /**\n     * The default timezone for this company\n     */\n    timeZoneId?: string | null;\n    customFields?: { [key: string]: Array<CustomFieldDefinition>; };\n    /**\n     * A list of custom domains to use for this company\n     */\n    domains?: Array<string> | null;\n    /**\n     * The default language to user for this client.\n     */\n    language?: string | null;\n    support?: CompanySupportDetails;\n    messages?: CompanyMessages;\n    oidc?: { [key: string]: OpenIdConnectIssuer; };\n    emailProvider?: IdNameState;\n    /**\n     * A list of ssl certificates provisioned for this company\n     */\n    sslCertificates?: Array<CompanySSLCertificate> | null;\n    features?: { [key: string]: { [key: string]: any; }; };\n    /**\n     * The group to which this vendor belongs\n     */\n    group?: string | null;\n    /**\n     * A list of map sets that are made available to the client\\'s of this vendor.\n     */\n    availableMapSets?: Array<IdName> | null;\n    defaultMapSet?: IdName;\n    /**\n     * UUID\\'s of the device types that this vendor is allowed to use. An empty list means all device types.\n     */\n    availableDeviceTypes?: Array<IdName> | null;\n    /**\n     * A list of email providers that are made available to the client\\'s of this vendor.\n     */\n    availableEmailProviders?: Array<IdNameState> | null;\n    emailServer?: EmailServerConfiguration;\n    /**\n     * [DEPRECATED] Use the listCompanyGroups operation instead\n     */\n    clientGroups?: Array<IdName> | null;\n}\nexport namespace VendorUpdateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'suspended' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Suspended: 'suspended' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ZonePoint } from './zonePoint';\n\n\nexport interface ZoneCreateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this entity\n     */\n    name: string;\n    group?: IdName;\n    costCentre?: IdName;\n    /**\n     * The state of this zone\n     */\n    state?: ZoneCreateRequest.StateEnum | null;\n    /**\n     * The type of zone\n     */\n    zoneType?: ZoneCreateRequest.ZoneTypeEnum | null;\n    /**\n     * A speed limit (in km/h) to apply to this zone. Any asset that enters this zone will have the road speed limit overriden by the zone speed limit.\n     */\n    speed?: number | null;\n    /**\n     * For zone proximity alerts, specifiy a distance in km from the center of the zone.\n     */\n    radius?: number | null;\n    /**\n     * The points for the zone polygon/polyline. Only populated on `get*` routes.\n     */\n    points?: Array<ZonePoint> | null;\n    /**\n     * The tag entity\n     */\n    tag?: string | null;\n    /**\n     * The client that owns this entity\n     */\n    ownerId: string;\n}\nexport namespace ZoneCreateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type ZoneTypeEnum = 'location' | 'keepin' | 'nogo' | 'route';\n    export const ZoneTypeEnum = {\n        Location: 'location' as ZoneTypeEnum,\n        Keepin: 'keepin' as ZoneTypeEnum,\n        Nogo: 'nogo' as ZoneTypeEnum,\n        Route: 'route' as ZoneTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ZoneBounds } from './zoneBounds';\nimport { ZonePoint } from './zonePoint';\nimport { IdNameType } from './idNameType';\nimport { ZoneCenter } from './zoneCenter';\n\n\nexport interface ZoneListItem { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this zone\n     */\n    name?: string | null;\n    group?: IdName;\n    costCentre?: IdName;\n    /**\n     * The state of this zone\n     */\n    state?: ZoneListItem.StateEnum | null;\n    /**\n     * The type of zone\n     */\n    zoneType?: ZoneListItem.ZoneTypeEnum | null;\n    /**\n     * A speed limit (in km/h) to apply to this zone. Any asset that enters this zone will have the road speed limit overriden by the zone speed limit.\n     */\n    speed?: number | null;\n    /**\n     * For zone proximity alerts, specifiy a distance in km from the center of the zone.\n     */\n    radius?: number | null;\n    /**\n     * The points for the zone polygon/polyline. Only populated on `get*` routes.\n     */\n    points?: Array<ZonePoint> | null;\n    /**\n     * The tag entity\n     */\n    tag?: string | null;\n    center?: ZoneCenter;\n    bounds?: ZoneBounds;\n    /**\n     * entity specific metadata\n     */\n    modifiedDate: string;\n}\nexport namespace ZoneListItem {\n    export type StateEnum = 'inactive' | 'active' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type ZoneTypeEnum = 'location' | 'keepin' | 'nogo' | 'route';\n    export const ZoneTypeEnum = {\n        Location: 'location' as ZoneTypeEnum,\n        Keepin: 'keepin' as ZoneTypeEnum,\n        Nogo: 'nogo' as ZoneTypeEnum,\n        Route: 'route' as ZoneTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { EntityInfo } from './entityInfo';\nimport { ZoneBounds } from './zoneBounds';\nimport { ZonePoint } from './zonePoint';\nimport { IdNameType } from './idNameType';\nimport { ZoneCenter } from './zoneCenter';\n\n\nexport interface ZoneResponse { \n  [key: string]: any | any;\n\n\n    /**\n     * The unique UUID of this entity\n     */\n    id: string;\n    owner: IdNameType;\n    /**\n     * A unique name for this zone\n     */\n    name?: string | null;\n    group?: IdName;\n    costCentre?: IdName;\n    /**\n     * The state of this zone\n     */\n    state?: ZoneResponse.StateEnum | null;\n    /**\n     * The type of zone\n     */\n    zoneType?: ZoneResponse.ZoneTypeEnum | null;\n    /**\n     * A speed limit (in km/h) to apply to this zone. Any asset that enters this zone will have the road speed limit overriden by the zone speed limit.\n     */\n    speed?: number | null;\n    /**\n     * For zone proximity alerts, specifiy a distance in km from the center of the zone.\n     */\n    radius?: number | null;\n    /**\n     * The points for the zone polygon/polyline. Only populated on `get*` routes.\n     */\n    points?: Array<ZonePoint> | null;\n    /**\n     * The tag entity\n     */\n    tag?: string | null;\n    center?: ZoneCenter;\n    bounds?: ZoneBounds;\n    entity: EntityInfo;\n}\nexport namespace ZoneResponse {\n    export type StateEnum = 'inactive' | 'active' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type ZoneTypeEnum = 'location' | 'keepin' | 'nogo' | 'route';\n    export const ZoneTypeEnum = {\n        Location: 'location' as ZoneTypeEnum,\n        Keepin: 'keepin' as ZoneTypeEnum,\n        Nogo: 'nogo' as ZoneTypeEnum,\n        Route: 'route' as ZoneTypeEnum\n    };\n}\n\n\n","/**\n * Fleet API Specification\n *\n * Contact: support@keytelematics.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { IdName } from './idName';\nimport { ZonePoint } from './zonePoint';\n\n\nexport interface ZoneUpdateRequest { \n  [key: string]: any | any;\n\n\n    /**\n     * A unique name for this zone\n     */\n    name?: string | null;\n    group?: IdName;\n    costCentre?: IdName;\n    /**\n     * The state of this zone\n     */\n    state?: ZoneUpdateRequest.StateEnum | null;\n    /**\n     * The type of zone\n     */\n    zoneType?: ZoneUpdateRequest.ZoneTypeEnum | null;\n    /**\n     * A speed limit (in km/h) to apply to this zone. Any asset that enters this zone will have the road speed limit overriden by the zone speed limit.\n     */\n    speed?: number | null;\n    /**\n     * For zone proximity alerts, specifiy a distance in km from the center of the zone.\n     */\n    radius?: number | null;\n    /**\n     * The points for the zone polygon/polyline. Only populated on `get*` routes.\n     */\n    points?: Array<ZonePoint> | null;\n    /**\n     * The tag entity\n     */\n    tag?: string | null;\n}\nexport namespace ZoneUpdateRequest {\n    export type StateEnum = 'inactive' | 'active' | 'deleted';\n    export const StateEnum = {\n        Inactive: 'inactive' as StateEnum,\n        Active: 'active' as StateEnum,\n        Deleted: 'deleted' as StateEnum\n    };\n    export type ZoneTypeEnum = 'location' | 'keepin' | 'nogo' | 'route';\n    export const ZoneTypeEnum = {\n        Location: 'location' as ZoneTypeEnum,\n        Keepin: 'keepin' as ZoneTypeEnum,\n        Nogo: 'nogo' as ZoneTypeEnum,\n        Route: 'route' as ZoneTypeEnum\n    };\n}\n\n\n","import { Injectable, inject } from '@angular/core';\nimport * as LZString from 'lz-string';\nimport { StorageMetadata, StorageItem } from '../models/storage.model';\nimport {\n  hasProperty,\n  isDefined,\n  isNullOrUndefined,\n  isNumber,\n  isObject,\n  isString,\n} from '../utils';\nimport { ApiUrlService } from '../../core/services/api-url.service';\nimport {\n  LOCAL_STORAGE_KEY_ACCESS_TOKEN,\n  LOCAL_STORAGE_KEY_REFRESH_TOKEN,\n  LOCAL_STORAGE_KEY_SELECTED_CLIENT,\n  LOCAL_STORAGE_KEY_SELECTED_CLIENT_ID,\n  LOCAL_STORAGE_KEY_TOKEN_EXPIRY,\n  LOCAL_STORAGE_KEY_USER_SESSION,\n  LOCAL_STORAGE_LAST_AUTHENTICATED_USER_ID,\n  LOCAL_STORAGE_SIDEBAR_STATE_KEY,\n} from '../../core/models';\n\nexport class StorageQuotaError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'StorageQuotaError';\n  }\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class LocalStorageService {\n  private static readonly MAX_ITEM_SIZE = 2 * 1024 * 1024; // 2MB\n  private static readonly STORAGE_LIMIT = 5 * 1024 * 1024; // 5MB\n  private static readonly COMPRESSION_THRESHOLD = 1024; // 1KB\n  private static readonly CURRENT_VERSION = 1;\n\n  // Keys that should be scoped per-user\n  private static readonly USER_SCOPED_KEYS = new Set([\n    LOCAL_STORAGE_KEY_SELECTED_CLIENT,\n    LOCAL_STORAGE_SIDEBAR_STATE_KEY,\n  ]);\n\n  // Keys that should never be namespaced (truly global)\n  private static readonly GLOBAL_KEYS = new Set([\n    LOCAL_STORAGE_LAST_AUTHENTICATED_USER_ID,\n  ]);\n\n  // Keys that should only be namespaced by API (shared across users on same API)\n  // Note: User sessions are API-scoped because they're available before profile loads\n  private static readonly API_SCOPED_KEYS = new Set([\n    LOCAL_STORAGE_KEY_ACCESS_TOKEN,\n    LOCAL_STORAGE_KEY_REFRESH_TOKEN,\n    LOCAL_STORAGE_KEY_TOKEN_EXPIRY,\n    LOCAL_STORAGE_KEY_USER_SESSION,\n    LOCAL_STORAGE_KEY_SELECTED_CLIENT_ID,\n  ]);\n\n  private readonly apiUrlService = inject(ApiUrlService);\n\n  // Store current user ID internally to avoid circular dependency\n  private currentUserId: string | null = null;\n\n  /**\n   * Sets the current user ID for namespacing.\n   * Should be called by AuthDataService after profile is loaded.\n   */\n  setCurrentUserId(userId: string | null): void {\n    this.currentUserId = userId;\n  }\n\n  /**\n   * Gets the current user ID for namespacing.\n   */\n  getCurrentUserId(): string | null {\n    return this.currentUserId;\n  }\n\n  /**\n   * Generates a namespaced key based on scope requirements.\n   * - GLOBAL_KEYS: No namespace\n   * - API_SCOPED_KEYS: API URL hash only\n   * - USER_SCOPED_KEYS: API URL hash + User ID\n   * - Default: API URL hash + User ID\n   *\n   * @param key - The original key\n   * @returns A namespaced key\n   */\n  private generateNamespacedKey(key: string): string {\n    try {\n      // Global keys - no namespace\n      if (LocalStorageService.GLOBAL_KEYS.has(key)) {\n        return key;\n      }\n\n      const apiUrl = this.apiUrlService.getCurrentApiUrl();\n      const apiHash = this.simpleHash(apiUrl);\n\n      // API-scoped keys - only API namespace\n      if (LocalStorageService.API_SCOPED_KEYS.has(key)) {\n        return `${apiHash}_${key}`;\n      }\n\n      // User-scoped keys - API + User namespace\n      if (LocalStorageService.USER_SCOPED_KEYS.has(key)) {\n        const userId = isDefined(this.currentUserId)\n          ? this.currentUserId\n          : 'pending';\n        return `${apiHash}_${userId}_${key}`;\n      }\n\n      // Default: API + User namespace\n      const userId = isDefined(this.currentUserId)\n        ? this.currentUserId\n        : 'anonymous';\n      return `${apiHash}_${userId}_${key}`;\n    } catch (error) {\n      console.warn(\n        'Could not generate namespaced key, using original key:',\n        error,\n      );\n      return key;\n    }\n  }\n\n  /**\n   * Simple hash function to create a short identifier from API URL\n   */\n  private simpleHash(str: string): string {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.codePointAt(i);\n      if (char !== undefined) {\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32-bit integer\n      }\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  /**\n   * Clears all user-scoped data for a specific user.\n   * @param userId - The user ID whose data should be cleared (optional, uses current if not provided)\n   */\n  clearUserScopedData(userId?: string): void {\n    try {\n      const apiUrl = this.apiUrlService.getCurrentApiUrl();\n      const apiHash = this.simpleHash(apiUrl);\n      const targetUserId = userId ?? this.currentUserId ?? 'pending';\n      const prefix = `${apiHash}_${targetUserId}_`;\n\n      // Find and remove all keys with this prefix\n      const keysToRemove: string[] = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (isDefined(key) && key.startsWith(prefix)) {\n          keysToRemove.push(key);\n        }\n      }\n      for (const key of keysToRemove) {\n        localStorage.removeItem(key);\n      }\n    } catch (error) {\n      console.error('Error clearing user-scoped data:', error);\n    }\n  }\n\n  /**\n   * Clears all API-scoped data (tokens, etc.) for the current API.\n   * Used during logout to clear authentication state.\n   */\n  clearApiScopedData(): void {\n    try {\n      const apiUrl = this.apiUrlService.getCurrentApiUrl();\n      const apiHash = this.simpleHash(apiUrl);\n\n      // Clear API-scoped keys\n      for (const key of LocalStorageService.API_SCOPED_KEYS) {\n        const storageKey = `${apiHash}_${key}`;\n        localStorage.removeItem(storageKey);\n      }\n    } catch (error) {\n      console.error('Error clearing API-scoped data:', error);\n    }\n  }\n\n  /**\n   * Checks if there's a user mismatch (different user trying to access data).\n   * Returns true if the last authenticated user is different from the current user.\n   */\n  detectUserMismatch(currentUserId: string): boolean {\n    const lastUserId = localStorage.getItem(\n      LOCAL_STORAGE_LAST_AUTHENTICATED_USER_ID,\n    );\n    return isDefined(lastUserId) && lastUserId !== currentUserId;\n  }\n\n  /**\n   * Records the current authenticated user ID.\n   */\n  setLastAuthenticatedUserId(userId: string): void {\n    localStorage.setItem(LOCAL_STORAGE_LAST_AUTHENTICATED_USER_ID, userId);\n  }\n\n  /**\n   * Migrates data from 'pending' namespace to actual user ID namespace.\n   * Called after successful login when user profile becomes available.\n   */\n  migrateFromPendingToUser(userId: string): void {\n    try {\n      const apiUrl = this.apiUrlService.getCurrentApiUrl();\n      const apiHash = this.simpleHash(apiUrl);\n      const pendingPrefix = `${apiHash}_pending_`;\n      const userPrefix = `${apiHash}_${userId}_`;\n\n      const keysToMigrate: { old: string; new: string }[] = [];\n\n      // Find all pending keys\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (isDefined(key) && key.startsWith(pendingPrefix)) {\n          const baseName = key.substring(pendingPrefix.length);\n          keysToMigrate.push({\n            old: key,\n            new: `${userPrefix}${baseName}`,\n          });\n        }\n      }\n\n      // Migrate each key\n      for (const { old: oldKey, new: newKey } of keysToMigrate) {\n        const value = localStorage.getItem(oldKey);\n        if (isDefined(value)) {\n          localStorage.setItem(newKey, value);\n          localStorage.removeItem(oldKey);\n        }\n      }\n    } catch (error) {\n      console.error('Error migrating from pending to user:', error);\n    }\n  }\n\n  /**\n   * Migrates an existing non-namespaced item to the current namespace.\n   * This is useful for migrating existing user preferences and settings.\n   *\n   * @param key - The key of the item to migrate\n   * @param removeOriginal - Whether to remove the original non-namespaced item (default: true)\n   * @returns true if migration was successful, false if no data found to migrate\n   */\n  migrateToNamespace(key: string, removeOriginal = true): boolean {\n    try {\n      // Get the existing non-namespaced data\n      const existingData = this.getItem(key, false);\n\n      if (existingData === null) {\n        return false; // No data to migrate\n      }\n\n      // Save it with namespace\n      this.setItem(key, existingData, undefined, true);\n\n      // Optionally remove the original\n      if (removeOriginal) {\n        this.removeItem(key, false);\n      }\n\n      return true;\n    } catch (error) {\n      console.error(`Failed to migrate localStorage key ${key}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Migrates multiple keys to the current namespace.\n   *\n   * @param keys - Array of keys to migrate\n   * @param removeOriginals - Whether to remove original non-namespaced items (default: true)\n   * @returns Object with migration results for each key\n   */\n  migrateMultipleToNamespace(\n    keys: string[],\n    removeOriginals = true,\n  ): Record<string, boolean> {\n    const results: Record<string, boolean> = {};\n\n    for (const key of keys) {\n      results[key] = this.migrateToNamespace(key, removeOriginals);\n    }\n\n    return results;\n  }\n\n  getItem<T>(key: string, useNamespace = true): T | null {\n    try {\n      const storageKey = useNamespace ? this.generateNamespacedKey(key) : key;\n      const value = localStorage.getItem(storageKey);\n      if (isNullOrUndefined(value)) return null;\n\n      // First try to parse as a StorageItem\n      let parsedValue: StorageItem<string>;\n      try {\n        parsedValue = JSON.parse(value);\n\n        // Check if it's actually a StorageItem by looking for metadata\n        if (!isObject(parsedValue) || !hasProperty(parsedValue, 'metadata')) {\n          // If not a StorageItem, return the parsed value directly\n          return JSON.parse(value) as T;\n        }\n      } catch {\n        // If parsing fails, return the raw value\n        return value as T;\n      }\n\n      // Check version\n      if (\n        parsedValue.metadata.version !== LocalStorageService.CURRENT_VERSION\n      ) {\n        console.warn(`Version mismatch for key: ${key}`);\n        this.removeItem(key);\n        return null;\n      }\n\n      // Check TTL\n      if (\n        hasProperty(parsedValue.metadata, 'expires') &&\n        isNumber(parsedValue.metadata.expires) &&\n        Date.now() > parsedValue.metadata.expires\n      ) {\n        this.removeItem(key);\n        return null;\n      }\n\n      let data = parsedValue.data;\n\n      // Decompress if needed\n      if (\n        hasProperty(parsedValue.metadata, 'compressed') &&\n        parsedValue.metadata.compressed === true\n      ) {\n        if (isString(data)) {\n          data = LZString.decompress(data);\n        }\n      }\n\n      // Parse the final data\n      return isString(data) ? (JSON.parse(data) as T) : (data as T);\n    } catch (error) {\n      console.warn(`Failed to retrieve item with key: ${key}`, error);\n      return null;\n    }\n  }\n\n  setItem<T>(\n    key: string,\n    value: T,\n    ttlMinutes?: number,\n    useNamespace = true,\n  ): void {\n    if (!isString(key) || !this.validateKey(key)) {\n      throw new Error('Invalid key provided');\n    }\n\n    const metadata: StorageMetadata = {\n      version: LocalStorageService.CURRENT_VERSION,\n      timestamp: Date.now(),\n      expires:\n        isDefined(ttlMinutes) && isNumber(ttlMinutes)\n          ? Date.now() + ttlMinutes * 60 * 1000\n          : undefined,\n    };\n\n    let stringValue = JSON.stringify(value);\n\n    // Compress if larger than threshold\n    if (stringValue.length > LocalStorageService.COMPRESSION_THRESHOLD) {\n      stringValue = LZString.compress(stringValue);\n      metadata.compressed = true;\n    }\n\n    const storageItem: StorageItem<string> = {\n      data: stringValue,\n      metadata,\n    };\n\n    const finalValue = JSON.stringify(storageItem);\n    const itemSize = new Blob([finalValue]).size;\n\n    if (itemSize > LocalStorageService.MAX_ITEM_SIZE) {\n      throw new StorageQuotaError(\n        `Item size (${itemSize} bytes) exceeds maximum allowed size`,\n      );\n    }\n\n    if (!this.hasAvailableSpace(itemSize)) {\n      throw new StorageQuotaError('Storage quota exceeded');\n    }\n\n    try {\n      const storageKey = useNamespace ? this.generateNamespacedKey(key) : key;\n      localStorage.setItem(storageKey, finalValue);\n    } catch (error) {\n      if (this.isQuotaExceededError(error)) {\n        throw new StorageQuotaError('Storage quota exceeded');\n      }\n      throw error;\n    }\n  }\n\n  removeItem(key: string, useNamespace = true): void {\n    try {\n      const storageKey = useNamespace ? this.generateNamespacedKey(key) : key;\n      localStorage.removeItem(storageKey);\n    } catch (error) {\n      console.error('Error removing from localStorage:', error);\n    }\n  }\n\n  clear(): void {\n    try {\n      localStorage.clear();\n    } catch (error) {\n      console.error('Error clearing localStorage:', error);\n    }\n  }\n\n  getCurrentUsage(): number {\n    let totalSize = 0;\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (isDefined(key) && isString(key)) {\n        const item = localStorage.getItem(key);\n        if (isDefined(item)) {\n          totalSize += new Blob([item]).size;\n        }\n      }\n    }\n    return totalSize;\n  }\n\n  private validateKey(key: string): boolean {\n    return isString(key) && key.length > 0;\n  }\n\n  private hasAvailableSpace(additionalBytes: number): boolean {\n    if (!isNumber(additionalBytes)) return false;\n\n    let totalSize = 0;\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (isDefined(key)) {\n        const item = localStorage.getItem(key);\n        if (isDefined(item)) {\n          totalSize += new Blob([item]).size;\n        }\n      }\n    }\n    return totalSize + additionalBytes <= LocalStorageService.STORAGE_LIMIT;\n  }\n\n  private isQuotaExceededError(error: unknown): boolean {\n    return (\n      isObject(error) &&\n      hasProperty(error, 'name') &&\n      isString(error['name']) &&\n      (error['name'] === 'QuotaExceededError' ||\n        error['name'] === 'NS_ERROR_DOM_QUOTA_REACHED')\n    );\n  }\n}\n","import { inject, Injectable, signal, effect } from '@angular/core';\nimport { LocalStorageService } from '../../shared/services/local-storage.service';\nimport { AuthUserResponse } from '../../api';\nimport {\n  LOCAL_STORAGE_KEY_SELECTED_CLIENT_ID,\n  LOCAL_STORAGE_KEY_USER_SESSION,\n} from '../models';\nimport { isDefined, isNullOrUndefined } from '../../shared/utils';\nimport { Router } from '@angular/router';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class UserSessionService {\n  private readonly localStorageService = inject(LocalStorageService);\n  private readonly router = inject(Router);\n  readonly userSessions = signal<AuthUserResponse[]>([]);\n  readonly currentUserSession = signal<AuthUserResponse | null>(null);\n\n  constructor() {\n    this.loadSessionsFromStorage();\n\n    effect(() => {\n      const session = this.currentUserSession();\n      if (session) {\n        // Store with API-scoped namespace\n        this.localStorageService.setItem(\n          LOCAL_STORAGE_KEY_SELECTED_CLIENT_ID,\n          session.id,\n          undefined,\n          true,\n        );\n      }\n    });\n  }\n\n  setUserSessions(sessions: AuthUserResponse[]): Promise<boolean> {\n    this.userSessions.set(sessions);\n    // Store with API-scoped namespace\n    this.localStorageService.setItem(\n      LOCAL_STORAGE_KEY_USER_SESSION,\n      JSON.stringify(sessions),\n      undefined,\n      true,\n    );\n\n    const lastSelectedId = this.localStorageService.getItem<string>(\n      LOCAL_STORAGE_KEY_SELECTED_CLIENT_ID,\n      true,\n    );\n    const sessionToSelect =\n      sessions.find((s) => s.id === lastSelectedId) ?? sessions[0];\n\n    if (sessions.length > 1 && isNullOrUndefined(lastSelectedId)) {\n      return this.router.navigate(['/auth', 'select-client']);\n    } else if (isDefined(sessionToSelect)) {\n      this.setCurrentUserSession(sessionToSelect.id);\n      return this.router.navigate(['/position']);\n    } else {\n      return this.router.navigate(['/auth', 'login']);\n    }\n  }\n\n  setCurrentUserSession(sessionId: string): void {\n    const session = this.userSessions().find((s) => s.id === sessionId);\n    if (isDefined(session)) {\n      this.currentUserSession.set(session);\n    }\n  }\n\n  private loadSessionsFromStorage(): void {\n    const sessionsStr = this.localStorageService.getItem<string>(\n      LOCAL_STORAGE_KEY_USER_SESSION,\n      true,\n    );\n    if (isDefined(sessionsStr)) {\n      const sessions = JSON.parse(sessionsStr) as AuthUserResponse[];\n      this.userSessions.set(sessions);\n\n      const selectedId = this.localStorageService.getItem<string>(\n        LOCAL_STORAGE_KEY_SELECTED_CLIENT_ID,\n        true,\n      );\n      if (isDefined(selectedId)) {\n        this.setCurrentUserSession(selectedId);\n      }\n    }\n  }\n\n  /**\n   * Reloads sessions from storage.\n   * Should be called after user profile is loaded to ensure correct namespace.\n   */\n  reloadSessionsFromStorage(): void {\n    this.loadSessionsFromStorage();\n  }\n\n  clearAllSessions(): void {\n    this.userSessions.set([]);\n    this.currentUserSession.set(null);\n    this.localStorageService.removeItem(LOCAL_STORAGE_KEY_USER_SESSION, true);\n    this.localStorageService.removeItem(\n      LOCAL_STORAGE_KEY_SELECTED_CLIENT_ID,\n      true,\n    );\n  }\n}\n"],"mappings":"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AAM;IACN,MAAM;IACN,cAAc;IACd,mBAAmB;IACnB,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;;EAEJ,eAAe;IACb,OAAO;IACP,MAAM;IACN,MAAM;IACN,aAAa;IACb,oBAAoB;IACpB,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;IACF,oBAAoB;IACpB,yBAAyB;;EAE3B,eAAe;IACb,OAAO;IACP,MAAM;IACN,MAAM;IACN,SAAS;IACT,gBAAgB;IAChB,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;IACF,eAAe;IACf,sBAAsB;;EAExB,eAAe;IACb,OAAO;IACP,MAAM;IACN,MAAM;IACN,cAAc;IACd,qBACE;IACF,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;;EAEJ,kBAAkB;IAChB,OAAO;IACP,MAAM;IACN,MAAM;IACN,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;;EAEJ,yBAAyB;IACvB,OAAO;IACP,MAAM;IACN,MAAM;IACN,MAAM;IACN,aACE;IACF,MAAM;IACN,aACE;IACF,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;;EAEJ,qBAAqB;IACnB,OAAO;IACP,MAAM;IACN,MAAM;IACN,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;IACF,YAAY;IACZ,mBACE;;EAEJ,kBAAkB;IAChB,OAAO;IACP,MAAM;IACN,MAAM;IACN,kBAAkB;IAClB,uBAAuB;IACvB,SAAS;IACT,gBACE;IACF,mBAAmB;IACnB,0BACE;IACF,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;;EAEJ,cAAc;IACZ,OAAO;IACP,MAAM;IACN,MAAM;IACN,cAAc;IACd,qBACE;IACF,kBAAkB;IAClB,uBAAuB;IACvB,qBAAqB;IACrB,4BACE;IACF,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;;EAEJ,iBAAiB;IACf,OAAO;IACP,MAAM;IACN,MAAM;IACN,MAAM;IACN,aACE;;EAEJ,iBAAiB;IACf,OAAO;IACP,MAAM;IACN,MAAM;IACN,OAAO;IACP,cACE;IACF,OAAO;IACP,cACE;;;AAIC,IAAM,uBAAuB;EAClC,QAAQ;IACN,iBAAiB;MACf,OAAO;MACP,MAAM;;IAER,iBAAiB;MACf,OAAO;MACP,MAAM;;IAER,qBAAqB;MACnB,OAAO;MACP,MAAM;;;EAGV,QAAQ;IACN,OAAO;IACP,KAAK;IACL,MAAM;IACN,QAAQ;IACR,SAAS;IACT,cACE;IACF,OAAO;IACP,YACE;;;;;AC5yCA,IAAO,0BAAP,MAAO,yBAAuB;EACjB,cAAc,OAAO,WAAW;;EAGhC,sBAAsB;;EACtB,oBAAoB;;EAC7B,sBAAiD;EAEzD,cAAA;AACE,SAAK,qBAAoB;EAC3B;;EAGA,YAAY,UAA6B;AACvC,iBAAa,QAAQ,gCAAgC,SAAS,WAAW;AACzE,iBAAa,QACX,iCACA,SAAS,YAAY;AAEvB,iBAAa,QACX,iCACC,KAAK,IAAG,IAAK,KAAK,mBAAmB,SAAQ,CAAE;AAElD,iBAAa,QACX,gCACA,KAAK,UAAU,SAAS,KAAK,CAAC;AAEhC,SAAK,qBAAoB;EAC3B;;EAGA,iBAAc;AACZ,WAAO,aAAa,QAAQ,8BAA8B;EAC5D;;EAGA,kBAAe;AACb,WAAO,aAAa,QAAQ,+BAA+B;EAC7D;EAEA,iBAAc;AACZ,UAAM,SAAS,aAAa,QAAQ,8BAA8B;AAClE,QAAI,CAAC,SAAS,MAAM;AAAG,aAAO;AAE9B,UAAM,kBAAkB,SAAS,QAAQ,EAAE;AAC3C,QAAI,MAAM,eAAe;AAAG,aAAO;AAEnC,WAAO,IAAI,KAAK,eAAe,EAAE,YAAW;EAC9C;;EAGA,iBAAc;AACZ,UAAM,SAAS,aAAa,QAAQ,8BAA8B;AAClE,QAAI,CAAC,SAAS,MAAM;AAAG,aAAO;AAE9B,UAAM,kBAAkB,SAAS,QAAQ,EAAE;AAC3C,WAAO,MAAM,eAAe,KAAK,KAAK,IAAG,IAAK;EAChD;;EAGA,cAAW;AACT,iBAAa,WAAW,8BAA8B;AACtD,iBAAa,WAAW,+BAA+B;AACvD,iBAAa,WAAW,8BAA8B;AACtD,QAAI,UAAU,KAAK,mBAAmB,GAAG;AACvC,mBAAa,KAAK,mBAAmB;AACrC,WAAK,sBAAsB;IAC7B;EACF;;EAGQ,uBAAoB;AAC1B,QAAI,KAAK,eAAc,GAAI;AACzB,WAAK,YAAW;AAChB;IACF;AAEA,UAAM,SAAS,aAAa,QAAQ,8BAA8B;AAClE,QAAI,CAAC,SAAS,MAAM,GAAG;AACrB,WAAK,YAAW;AAChB;IACF;AAEA,UAAM,kBAAkB,SAAS,QAAQ,EAAE;AAC3C,QAAI,MAAM,eAAe,GAAG;AAC1B,WAAK,YAAW;AAChB;IACF;AAEA,UAAM,UAAU,kBAAkB,KAAK,IAAG,IAAK,KAAK;AACpD,QAAI,UAAU,KAAK,mBAAmB,GAAG;AACvC,mBAAa,KAAK,mBAAmB;IACvC;AAEA,eAAW,MAAK;AACd,WAAK,aAAY,EAAG,UAAS;IAC/B,GAAG,OAAO;EACZ;;EAGQ,eAAY;AAClB,UAAM,eAAe,KAAK,gBAAe;AACzC,QAAI,CAAC,SAAS,YAAY,GAAG;AAC3B,WAAK,YAAW;AAChB,aAAO,WAAW,MAAM,4BAA4B;IACtD;AAEA,WAAO,KAAK,YAAY,aAAa,YAAY,EAAE,KACjD,UACE,CAAC,aAAkE;AACjE,WAAK,YAAY,QAAQ;AACzB,aAAO,GAAG,QAAQ;IACpB,CAAC,GAEH,WAAW,CAAC,UAAS;AACnB,WAAK,YAAW;AAChB,aAAO,WAAW,MAAM,KAAK;IAC/B,CAAC,CAAC;EAEN;;qCAvHW,0BAAuB;EAAA;4EAAvB,0BAAuB,SAAvB,yBAAuB,WAAA,YAFtB,OAAM,CAAA;;;sEAEP,yBAAuB,CAAA;UAHnC;WAAW;MACV,YAAY;KACb;;;;;ACqBK,IAAO,gBAAP,MAAoB;;;;EAItB;EACA;EACA;;;;EAIA;EACA;EACA;;;;EAIA;;;;;;;;EAQA;;;;;;EAMA;EAEA,YAAY,0BAAmD,CAAA,GAAE;AAC7D,SAAK,UAAU,wBAAwB;AACvC,SAAK,WAAW,wBAAwB;AACxC,SAAK,WAAW,wBAAwB;AACxC,SAAK,cAAc,wBAAwB;AAC3C,SAAK,WAAW,wBAAwB;AACxC,SAAK,kBAAkB,wBAAwB;AAC/C,SAAK,UAAU,wBAAwB;AACvC,QAAI,wBAAwB,aAAa;AACrC,WAAK,cAAc,wBAAwB;IAC/C,OACK;AACD,WAAK,cAAc,WAAS,KAAK,mBAAmB,KAAK;IAC7D;AACA,QAAI,wBAAwB,aAAa;AACrC,WAAK,cAAc,wBAAwB;IAC/C,OACK;AACD,WAAK,cAAc,CAAA;IACvB;AAGA,QAAI,CAAC,KAAK,YAAY,cAAc,GAAG;AACnC,WAAK,YAAY,cAAc,IAAI,MAAK;AACpC,YAAI,KAAK,YAAY,QAAQ,KAAK,YAAY,QAAW;AACrD,iBAAO;QACX,OAAO;AACH,iBAAO,KAAK,QAAQ,cAAc,KAAK,KAAK,QAAQ,gBAAgB;QACxE;MACJ;IACJ;EACJ;;;;;;;;EASO,wBAAyB,cAAsB;AAClD,QAAI,aAAa,WAAW,GAAG;AAC3B,aAAO;IACX;AAEA,UAAM,OAAO,aAAa,KAAK,CAAC,MAAc,KAAK,WAAW,CAAC,CAAC;AAChE,QAAI,SAAS,QAAW;AACpB,aAAO,aAAa,CAAC;IACzB;AACA,WAAO;EACX;;;;;;;;EASO,mBAAmB,SAAiB;AACvC,QAAI,QAAQ,WAAW,GAAG;AACtB,aAAO;IACX;AAEA,UAAM,OAAO,QAAQ,KAAK,CAAC,MAAc,KAAK,WAAW,CAAC,CAAC;AAC3D,QAAI,SAAS,QAAW;AACpB,aAAO,QAAQ,CAAC;IACpB;AACA,WAAO;EACX;;;;;;;;;;;EAYO,WAAW,MAAY;AAC1B,UAAM,WAAmB,IAAI,OAAO,4DAAiE,GAAG;AACxG,WAAO,SAAS,SAAS,SAAS,KAAK,IAAI,KAAK,KAAK,YAAW,MAAO;EAC3E;EAEO,iBAAiB,KAAW;AAC/B,UAAM,QAAQ,KAAK,YAAY,GAAG;AAClC,WAAO,OAAO,UAAU,aAClB,MAAK,IACL;EACV;EAEQ,mBAAmB,OAAY;AASnC,UAAM,QAAQ,MAAM,eAAe,eAAe,MAAM,iBAAiB,OAClE,MAAM,MAAe,YAAW,IACjC,MAAM;AAEZ,WAAO,mBAAmB,OAAO,KAAK,CAAC;EAC3C;;;;ACzKE,IAAO,2BAAP,MAA+B;EACjC,UAAU,GAAS;AACf,WAAO,mBAAmB,CAAC;EAC/B;EACA,YAAY,GAAS;AACjB,WAAO,mBAAmB,CAAC;EAC/B;EACA,UAAU,GAAS;AACf,WAAO,mBAAmB,CAAC;EAC/B;EACA,YAAY,GAAS;AACjB,WAAO,mBAAmB,CAAC;EAC/B;;;;AChBG,IAAM,YAAY,IAAI,eAAuB,UAAU;;;AC0GxD,IAAO,kBAAP,MAAO,iBAAe;EAOF;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAYO,aAAa,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAkC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,mBAAmB,SAAoC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA6B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,WAAW,SAA4B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,YAAY,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtV,WAAO,KAAK,WAAW,QAAyB,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,mBAAmB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA8B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,sBAAsB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AACnM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,gBAAgB,IAAY,QAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,QAAQ,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACpV,WAAO,KAAK,WAAW,QAAyB,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAChL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,KAAa,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,OAAO,OAAO,KAAK,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,cAAc,IAAY,MAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,WAAW,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAAyB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,eAAe,IAAY,MAAc,SAAmB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,mBAAmB,IAAY,MAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,QAAQ,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mEAAmE;IACvF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAsB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,cAAc,IAAY,MAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,YAAY,OAAe,QAAiB,OAAgB,MAAe,QAAiB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,kBAAkB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,iBAAiB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,cAAc,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,UAAU,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,YAAY,OAAe,QAAiB,OAAgB,MAAe,QAAiB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,UAAU,IAAY,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,oBAAoB,IAAY,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,mBAAmB,IAAY,SAAoC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,kBAAkB,IAAY,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,yBAAyB,IAAY,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,sBAAsB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AACnM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,WAAW,IAAY,SAA4B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAsB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAChL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,eAAe,IAAY,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,oBAAoB,IAAY,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAj6HS,kBAAe,mBAAA,UAAA,GAAA,mBAOyC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,kBAAe,SAAf,iBAAe,WAAA,YAFd,OAAM,CAAA;;;sEAEP,iBAAe,CAAA;UAH3B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;AC/EtG,IAAO,qBAAP,MAAO,oBAAkB;EAOL;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,iBAAiB,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,cAAc,IAAY,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,gBAAgB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAxZS,qBAAkB,mBAAA,UAAA,GAAA,mBAOsC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,qBAAkB,SAAlB,oBAAkB,WAAA,YAFjB,OAAM,CAAA;;;sEAEP,oBAAkB,CAAA;UAH9B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;AChCtG,IAAO,YAAP,MAAO,WAAS;EACX,OAAO,QAAQ,sBAAyC;AAC3D,WAAO;MACH,UAAU;MACV,WAAW,CAAE,EAAE,SAAS,eAAe,YAAY,qBAAoB,CAAE;;EAEjF;EAEA,YAAqC,cACZ,MAAgB;AACrC,QAAI,cAAc;AACd,YAAM,IAAI,MAAM,kEAAkE;IACtF;AACA,QAAI,CAAC,MAAM;AACP,YAAM,IAAI,MAAM,uHAC0C;IAC9D;EACJ;;qCAjBS,YAAS,mBAAA,YAAA,EAAA,GAAA,mBAAA,YAAA,CAAA,CAAA;EAAA;wEAAT,WAAS,CAAA;;;;sEAAT,WAAS,CAAA;UANrB;WAAS;MACR,SAAc,CAAA;MACd,cAAc,CAAA;MACd,SAAc,CAAA;MACd,WAAW,CAAA;KACZ;;UASiB;;UAAY;;UACZ;;;;;ACgBZ,IAAO,gBAAP,MAAO,eAAa;EAOA;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,WAAW,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,IAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,gBAAa,mBAAA,UAAA,GAAA,mBAO2C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,gBAAa,SAAb,eAAa,WAAA,YAFZ,OAAM,CAAA;;;sEAEP,eAAa,CAAA;UAHzB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACXtG,IAAO,mBAAP,MAAO,kBAAgB;EAOH;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,uBAAuB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACxL,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,yBAAyB,OAAgB,QAAiB,MAAe,QAAiB,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAEtQ,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0C,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjH;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,2BAA2B,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACxL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAxSS,mBAAgB,mBAAA,UAAA,GAAA,mBAOwC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,mBAAgB,SAAhB,kBAAgB,WAAA,YAFf,OAAM,CAAA;;;sEAEP,kBAAgB,CAAA;UAH5B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACHtG,IAAO,yBAAP,MAAO,wBAAsB;EAOT;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,oBAAoB,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,oBAAoB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA+B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,oBAAoB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,oBAAoB,IAAY,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAldS,yBAAsB,mBAAA,UAAA,GAAA,mBAOkC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,yBAAsB,SAAtB,wBAAsB,WAAA,YAFrB,OAAM,CAAA;;;sEAEP,wBAAsB,CAAA;UAHlC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACPtG,IAAO,qBAAP,MAAO,oBAAkB;EAOL;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,iBAAiB,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,gBAAgB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAldS,qBAAkB,mBAAA,UAAA,GAAA,mBAOsC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,qBAAkB,SAAlB,oBAAkB,WAAA,YAFjB,OAAM,CAAA;;;sEAEP,oBAAkB,CAAA;UAH9B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACLtG,IAAO,6BAAP,MAAO,4BAA0B;EAOb;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,yBAAyB,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,sBAAsB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,wBAAwB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,yBAAyB,IAAY,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,6BAA0B,mBAAA,UAAA,GAAA,mBAO8B,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,6BAA0B,SAA1B,4BAA0B,WAAA,YAFzB,OAAM,CAAA;;;sEAEP,4BAA0B,CAAA;UAHtC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACTtG,IAAO,4BAAP,MAAO,2BAAyB;EAOZ;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,wBAAwB,SAAyC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAmC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,uBAAuB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,wBAAwB,IAAY,SAAyC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,4BAAyB,mBAAA,UAAA,GAAA,mBAO+B,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,4BAAyB,SAAzB,2BAAyB,WAAA,YAFxB,OAAM,CAAA;;;sEAEP,2BAAyB,CAAA;UAHrC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACXtG,IAAO,uBAAP,MAAO,sBAAoB;EAOP;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAjNS,uBAAoB,mBAAA,UAAA,GAAA,mBAOoC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,uBAAoB,SAApB,sBAAoB,WAAA,YAFnB,OAAM,CAAA;;;sEAEP,sBAAoB,CAAA;UAHhC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACHtG,IAAO,mBAAP,MAAO,kBAAgB;EAOH;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,eAAe,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,cAAc,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,eAAe,IAAY,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,mBAAgB,mBAAA,UAAA,GAAA,mBAOwC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,mBAAgB,SAAhB,kBAAgB,WAAA,YAFf,OAAM,CAAA;;;sEAEP,kBAAgB,CAAA;UAH5B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACXtG,IAAO,oBAAP,MAAO,mBAAiB;EAOJ;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,aAAa,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAjNS,oBAAiB,mBAAA,UAAA,GAAA,mBAOuC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,oBAAiB,SAAjB,mBAAiB,WAAA,YAFhB,OAAM,CAAA;;;sEAEP,mBAAiB,CAAA;UAH7B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACatG,IAAO,gBAAP,MAAO,eAAa;EAOA;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,+BAA+B,IAAY,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjP,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+FAA+F;IACnH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oCAAoC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtM,WAAO,KAAK,WAAW,QAA0C,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClH;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,+BAA+B,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1M,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6FAA6F;IACjH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oCAAoC,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5M,WAAO,KAAK,WAAW,QAA0C,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpH;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,uBAAuB,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClM,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oCAAoC,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5M,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,WAAW,IAAY,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAA2B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,WAAW,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,8BAA8B,OAAgB,OAAgB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAE3R,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8C,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrH;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,UAAU,IAAY,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,WAAW,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtV,WAAO,KAAK,WAAW,QAA2B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,IAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,+BAA+B,OAAe,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6FAA6F;IACjH;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+FAA+F;IACnH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oCAAoC,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5M,WAAO,KAAK,WAAW,QAA0C,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjH;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA/yCS,gBAAa,mBAAA,UAAA,GAAA,mBAO2C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,gBAAa,SAAb,eAAa,WAAA,YAFZ,OAAM,CAAA;;;sEAEP,eAAa,CAAA;UAHzB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACOtG,IAAOC,eAAP,MAAO,aAAW;EAOE;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,eAAe,SAAoC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAyB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,QAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrL,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,aAAa,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAUO,qBAAqB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAEjL,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAUO,eAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAE3K,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAyB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,WAAW,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,QAAQ,QAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,aAAa,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAA6B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAyB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,OAAO,SAAsB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA6B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,QAAQ,SAAyB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,QAAgB,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzN,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,aAAa,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,UAAU,QAAgB,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,aAAa,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3gCS,cAAW,mBAAA,UAAA,GAAA,mBAO6C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,cAAW,SAAX,aAAW,WAAA,YAFV,OAAM,CAAA;;;sEAEPA,cAAW,CAAA;UAHvB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACjCtG,IAAO,iBAAP,MAAO,gBAAc;EAOD;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,KAAa,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,OAAO,OAAO,KAAK,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,cAAc,IAAY,MAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,YAAY,OAAe,QAAiB,OAAgB,MAAe,QAAiB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,oBAAoB,IAAY,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAtxBS,iBAAc,mBAAA,UAAA,GAAA,mBAO0C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,iBAAc,SAAd,gBAAc,WAAA,YAFb,OAAM,CAAA;;;sEAEP,gBAAc,CAAA;UAH1B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACTtG,IAAO,mBAAP,MAAO,kBAAgB;EAOH;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,WAAW,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAAyB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,eAAe,IAAY,MAAc,SAAmB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAnNS,mBAAgB,mBAAA,UAAA,GAAA,mBAOwC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,mBAAgB,SAAhB,kBAAgB,WAAA,YAFf,OAAM,CAAA;;;sEAEP,kBAAgB,CAAA;UAH5B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACTtG,IAAO,uBAAP,MAAO,sBAAoB;EAOP;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,mBAAmB,SAAoC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,mBAAmB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA8B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,kBAAkB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,mBAAmB,IAAY,SAAoC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAldS,uBAAoB,mBAAA,UAAA,GAAA,mBAOoC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,uBAAoB,SAApB,sBAAoB,WAAA,YAFnB,OAAM,CAAA;;;sEAEP,sBAAoB,CAAA;UAHhC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACPtG,IAAO,qBAAP,MAAO,oBAAkB;EAOL;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,iBAAiB,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,gBAAgB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAldS,qBAAkB,mBAAA,UAAA,GAAA,mBAOsC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,qBAAkB,SAAlB,oBAAkB,WAAA,YAFjB,OAAM,CAAA;;;sEAEP,oBAAkB,CAAA;UAH9B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACPtG,IAAO,4BAAP,MAAO,2BAAyB;EAOZ;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,wBAAwB,SAAyC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAmC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,uBAAuB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,wBAAwB,IAAY,SAAyC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhZS,4BAAyB,mBAAA,UAAA,GAAA,mBAO+B,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,4BAAyB,SAAzB,2BAAyB,WAAA,YAFxB,OAAM,CAAA;;;sEAEP,2BAAyB,CAAA;UAHrC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACLtG,IAAO,oBAAP,MAAO,mBAAiB;EAOJ;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,gBAAgB,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,eAAe,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,uBAAuB,IAAY,UAAkB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,YAAY,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjW,WAAO,KAAK,WAAW,QAAwC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChH;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,gBAAgB,IAAY,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA7hBS,oBAAiB,mBAAA,UAAA,GAAA,mBAOuC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,oBAAiB,SAAjB,mBAAiB,WAAA,YAFhB,OAAM,CAAA;;;sEAEP,mBAAiB,CAAA;UAH7B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACiBtG,IAAO,cAAP,MAAO,aAAW;EAOE;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAaO,iBAAiB,QAAgB,OAAe,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1O,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,gBAAgB,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrW,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,cAAc,OAAe,MAAc,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClO,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,QAAQ,OAAO,MAAM,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtV,WAAO,KAAK,WAAW,QAAsB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,aAAa,QAAgB,OAAe,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtO,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,YAAY,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjW,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,aAAa,QAAgB,UAAkB,WAAmC,OAAgB,OAAgB,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9R,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAChM,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,gBAAgB,IAAY,OAAe,KAAa,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,sBAAsB,SAAiB,QAAgB,UAAkB,WAAmC,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvR,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AACA,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,uFAAuF;IAC3G;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,WAAW,OAAO,SAAS,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,WAAW,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnW,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,aAAa,QAAgB,UAAkB,WAAmC,OAAgB,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9Q,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAChM,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,gBAAgB,IAAY,OAAe,KAAa,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,gBAAgB,QAAgB,UAAkB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/Q,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,uBAAuB,YAAoB,IAAY,OAAgB,KAAc,OAAgB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClR,QAAI,eAAe,QAAQ,eAAe,QAAW;AACjD,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AACA,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,cAAc,OAAO,YAAY,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3V,WAAO,KAAK,WAAW,QAAqB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5F;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,oBAAoB,UAAkB,WAAmC,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrP,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,oBAAoB,IAAY,OAAe,KAAa,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,YAAY,QAAgB,UAAkB,WAAmC,OAAgB,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7Q,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,eAAe,IAAY,OAAgB,KAAc,MAAe,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpP,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,iBAAiB,OAAe,MAAc,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrO,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,QAAQ,OAAO,MAAM,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtV,WAAO,KAAK,WAAW,QAAsB,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAr9CS,cAAW,mBAAA,UAAA,GAAA,mBAO6C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,cAAW,SAAX,aAAW,WAAA,YAFV,OAAM,CAAA;;;sEAEP,aAAW,CAAA;UAHvB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;AC/BtG,IAAO,8BAAP,MAAO,6BAA2B;EAOd;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,0BAA0B,SAA2C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAqC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,uBAAuB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,kCAAkC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACpM,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,yBAAyB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,uFAAuF;IAC3G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAyC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChH;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,0BAA0B,IAAY,SAA2C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,kCAAkC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACpM,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhZS,8BAA2B,mBAAA,UAAA,GAAA,mBAO6B,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,8BAA2B,SAA3B,6BAA2B,WAAA,YAF1B,OAAM,CAAA;;;sEAEP,6BAA2B,CAAA;UAHvC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACbtG,IAAO,6BAAP,MAAO,4BAA0B;EAOb;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,sBAAsB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,wBAAwB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCArOS,6BAA0B,mBAAA,UAAA,GAAA,mBAO8B,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,6BAA0B,SAA1B,4BAA0B,WAAA,YAFzB,OAAM,CAAA;;;sEAEP,4BAA0B,CAAA;UAHtC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACHtG,IAAO,yBAAP,MAAO,wBAAsB;EAOT;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,qBAAqB,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,oBAAoB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,qBAAqB,IAAY,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhZS,yBAAsB,mBAAA,UAAA,GAAA,mBAOkC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,yBAAsB,SAAtB,wBAAsB,WAAA,YAFrB,OAAM,CAAA;;;sEAEP,wBAAsB,CAAA;UAHlC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACPtG,IAAO,iBAAP,MAAO,gBAAc;EAOD;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,gBAAgB,YAAoB,YAAoB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpN,QAAI,eAAe,QAAQ,eAAe,QAAW;AACjD,YAAM,IAAI,MAAM,mFAAmF;IACvG;AACA,QAAI,eAAe,QAAQ,eAAe,QAAW;AACjD,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,cAAc,OAAO,YAAY,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,cAAc,OAAO,YAAY,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/W,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,YAAY,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAtdS,iBAAc,mBAAA,UAAA,GAAA,mBAO0C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,iBAAc,SAAd,gBAAc,WAAA,YAFb,OAAM,CAAA;;;sEAEP,gBAAc,CAAA;UAH1B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACLtG,IAAO,sBAAP,MAAO,qBAAmB;EAON;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,kBAAkB,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA6B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,sBAAsB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AACnM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,mBAAmB,IAAY,MAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,iBAAiB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,kBAAkB,IAAY,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,yBAAyB,IAAY,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,sBAAsB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AACnM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA/sBS,sBAAmB,mBAAA,UAAA,GAAA,mBAOqC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,sBAAmB,SAAnB,qBAAmB,WAAA,YAFlB,OAAM,CAAA;;;sEAEP,qBAAmB,CAAA;UAH/B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACTtG,IAAO,wBAAP,MAAO,uBAAqB;EAOR;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,oBAAoB,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,4BAA4B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC9L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,mBAAmB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,oBAAoB,IAAY,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,4BAA4B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC9L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,wBAAqB,mBAAA,UAAA,GAAA,mBAOmC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,wBAAqB,SAArB,uBAAqB,WAAA,YAFpB,OAAM,CAAA;;;sEAEP,uBAAqB,CAAA;UAHjC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACXtG,IAAO,6BAAP,MAAO,4BAA0B;EAOb;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,qBAAqB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,uBAAuB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCArOS,6BAA0B,mBAAA,UAAA,GAAA,mBAO8B,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,6BAA0B,SAA1B,4BAA0B,WAAA,YAFzB,OAAM,CAAA;;;sEAEP,4BAA0B,CAAA;UAHtC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACuStG,IAAO,kBAAP,MAAO,iBAAe;EAOF;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,oBAAoB,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,yBAAyB,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,wBAAwB,SAAyC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAmC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,wBAAwB,SAAyC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAmC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,0BAA0B,SAA2C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAqC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,oBAAoB,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,uBAAuB,SAAwC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,uFAAuF;IAC3G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA6B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,sBAAsB,SAAuC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,+BAA+B,IAAY,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjP,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+FAA+F;IACnH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oCAAoC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtM,WAAO,KAAK,WAAW,QAA0C,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClH;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,SAA+B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAyB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,yBAAyB,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,WAAW,SAA4B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAsB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,oBAAoB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA+B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,+BAA+B,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1M,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6FAA6F;IACjH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oCAAoC,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5M,WAAO,KAAK,WAAW,QAA0C,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpH;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,sBAAsB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,gBAAgB,YAAoB,YAAoB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpN,QAAI,eAAe,QAAQ,eAAe,QAAW;AACjD,YAAM,IAAI,MAAM,mFAAmF;IACvG;AACA,QAAI,eAAe,QAAQ,eAAe,QAAW;AACjD,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,cAAc,OAAO,YAAY,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,cAAc,OAAO,YAAY,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/W,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,uBAAuB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,kCAAkC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACpM,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,sBAAsB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,cAAc,IAAY,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,4BAA4B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC9L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,WAAW,QAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAqD,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5H;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,oBAAoB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,+BAA+B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjM,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,oBAAoB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,+BAA+B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjM,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,mBAAmB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,8BAA8B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAChM,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,uBAAuB,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClM,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oCAAoC,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5M,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,WAAW,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACxL,WAAO,KAAK,WAAW,QAAyB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,sBAAsB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,0BAA0B,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qCAAqC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvM,WAAO,KAAK,WAAW,QAAwC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,QAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9L,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrM,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,QAAQ,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mEAAmE;IACvF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAsB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,WAAW,IAAY,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAA2B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,WAAW,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,oBAAoB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,gBAAgB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,wBAAwB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,uBAAuB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,cAAc,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,WAAW,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,gBAAgB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,uBAAuB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,eAAe,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,yBAAyB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,uFAAuF;IAC3G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAyC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChH;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,wBAAwB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,oBAAoB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,gBAAgB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,YAAY,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,uBAAuB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,mBAAmB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,gBAAgB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,cAAc,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,oBAAoB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,YAAY,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,WAAW,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,YAAY,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,sBAAsB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAsC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,cAAc,OAAe,QAAiB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,sBAAsB,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjM,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAsC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,oBAAoB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,iBAAiB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,qBAAqB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,8BAA8B,OAAgB,OAAgB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAE3R,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8C,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrH;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,aAAa,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,4BAA4B,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4C,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnH;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,wBAAwB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,oBAAoB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,WAAW,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,eAAe,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,UAAU,OAAe,QAAiB,OAAgB,MAAe,QAAiB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,UAAU,IAAY,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,wBAAwB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAyC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjH;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,uBAAuB,IAAY,UAAkB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,YAAY,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjW,WAAO,KAAK,WAAW,QAAwC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChH;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,WAAW,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtV,WAAO,KAAK,WAAW,QAA2B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,IAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,IAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,oBAAoB,IAAY,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,yBAAyB,IAAY,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,wBAAwB,IAAY,SAAyC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,eAAe,IAAY,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,gBAAgB,IAAY,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,wBAAwB,IAAY,SAAyC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gCAAgC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAAmC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,0BAA0B,IAAY,SAA2C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,kCAAkC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACpM,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,qBAAqB,IAAY,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,oBAAoB,IAAY,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,4BAA4B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC9L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,eAAe,IAAY,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,qBAAqB,IAAY,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,IAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,uBAAuB,IAAY,SAAwC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,uFAAuF;IAC3G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,+BAA+B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjM,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,eAAe,IAAY,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,qBAAqB,IAAY,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,kBAAkB,IAAY,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,sBAAsB,IAAY,SAAuC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,8BAA8B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAChM,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,+BAA+B,OAAe,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6FAA6F;IACjH;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+FAA+F;IACnH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oCAAoC,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5M,WAAO,KAAK,WAAW,QAA0C,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjH;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,cAAc,IAAY,SAA+B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACxL,WAAO,KAAK,WAAW,QAAyB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,yBAAyB,IAAY,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,qBAAqB,IAAY,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,IAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,WAAW,IAAY,SAA4B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAsB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,gBAAgB,IAAY,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,uBAAuB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA0C,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClH;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA11aS,kBAAe,mBAAA,UAAA,GAAA,mBAOyC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,kBAAe,SAAf,iBAAe,WAAA,YAFd,OAAM,CAAA;;;sEAEP,iBAAe,CAAA;UAH3B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACjTtG,IAAO,qBAAP,MAAO,oBAAkB;EAOL;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,iBAAiB,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,gBAAgB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,yBAAyB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3L,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,qBAAkB,mBAAA,UAAA,GAAA,mBAOsC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,qBAAkB,SAAlB,oBAAkB,WAAA,YAFjB,OAAM,CAAA;;;sEAEP,oBAAkB,CAAA;UAH9B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACKtG,IAAO,eAAP,MAAO,cAAY;EAOC;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAaO,iBAAiB,QAAgB,OAAe,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1O,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,gBAAgB,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrW,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,aAAa,QAAgB,OAAe,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtO,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,YAAY,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjW,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,aAAa,QAAgB,UAAkB,WAAmC,OAAgB,OAAgB,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9R,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAChM,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,sBAAsB,SAAiB,QAAgB,UAAkB,WAAmC,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvR,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AACA,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,uFAAuF;IAC3G;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,WAAW,OAAO,SAAS,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,WAAW,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnW,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,aAAa,QAAgB,UAAkB,WAAmC,OAAgB,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9Q,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAChM,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,gBAAgB,QAAgB,UAAkB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/Q,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClM,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,oBAAoB,UAAkB,WAAmC,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrP,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,YAAY,QAAgB,UAAkB,WAAmC,OAAgB,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7Q,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AACA,QAAI,cAAc,QAAQ,cAAc,QAAW;AAC/C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,cAAc,UAAa,cAAc,MAAM;AACjD,gCAA0B,KAAK,gBAAgB,yBACxC,WAAW,WAAW;IAC/B;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAt0BS,eAAY,mBAAA,UAAA,GAAA,mBAO4C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,eAAY,SAAZ,cAAY,WAAA,YAFX,OAAM,CAAA;;;sEAEP,cAAY,CAAA;UAHxB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACnBtG,IAAO,mBAAP,MAAO,kBAAgB;EAOH;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,eAAe,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,cAAc,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,eAAe,IAAY,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,mBAAgB,mBAAA,UAAA,GAAA,mBAOwC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,mBAAgB,SAAhB,kBAAgB,WAAA,YAFf,OAAM,CAAA;;;sEAEP,kBAAgB,CAAA;UAH5B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACLtG,IAAO,yBAAP,MAAO,wBAAsB;EAOT;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,qBAAqB,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,oBAAoB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,qBAAqB,IAAY,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhZS,yBAAsB,mBAAA,UAAA,GAAA,mBAOkC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,yBAAsB,SAAtB,wBAAsB,WAAA,YAFrB,OAAM,CAAA;;;sEAEP,wBAAsB,CAAA;UAHlC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACPtG,IAAO,gBAAP,MAAO,eAAa;EAOA;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,kBAAkB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACpL,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,WAAW,OAAgB,UAAmB,UAAoB,QAAiB,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAE/P,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,IAAY,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,kBAAkB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACpL,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAvTS,gBAAa,mBAAA,UAAA,GAAA,mBAO2C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,gBAAa,SAAb,eAAa,WAAA,YAFZ,OAAM,CAAA;;;sEAEP,eAAa,CAAA;UAHzB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACetG,IAAO,iBAAP,MAAO,gBAAc;EAOD;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAaO,cAAc,OAAe,MAAc,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClO,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,QAAQ,OAAO,MAAM,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtV,WAAO,KAAK,WAAW,QAAsB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,gBAAgB,IAAY,OAAe,KAAa,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,mBAAmB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,uBAAuB,IAAY,UAAkB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrV,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,6BAA6B,IAAY,UAAkB,cAAuB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,8FAA8F;IAClH;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,iBAAiB,UAAa,iBAAiB,MAAM;AACvD,gCAA0B,KAAK,gBAAgB,yBACxC,cAAc,cAAc;IACrC;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,WAAW,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5V,WAAO,KAAK,WAAW,QAAa,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,kCAAkC,IAAY,UAAkB,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,aAAqG;AACrQ,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6FAA6F;IACjH;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,mGAAmG;IACvH;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kGAAkG;IACtH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,eAAe,YAAY;AACtF,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,eAAe,YAAY;AAC9E,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,eAAe,YAAY;AAC5E,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrV,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,8BAA8B,IAAY,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,aAAqG;AAC3O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8FAA8F;IAClH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,eAAe,YAAY;AACtF,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,eAAe,YAAY;AAC9E,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,eAAe,YAAY;AAC5E,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,gBAAgB,IAAY,OAAe,KAAa,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,uBAAuB,YAAoB,IAAY,OAAgB,KAAc,OAAgB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClR,QAAI,eAAe,QAAQ,eAAe,QAAW;AACjD,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AACA,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,cAAc,OAAO,YAAY,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC3V,WAAO,KAAK,WAAW,QAAqB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5F;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,oBAAoB,IAAY,OAAe,KAAa,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC7L,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,eAAe,IAAY,OAAgB,KAAc,MAAe,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpP,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,qBAAqB,OAAe,KAAa,QAAiB,MAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7O,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,iBAAiB,OAAe,MAAc,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrO,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,QAAQ,OAAO,MAAM,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtV,WAAO,KAAK,WAAW,QAAsB,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,sBAAsB,IAAY,QAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AACA,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCArwCS,iBAAc,mBAAA,UAAA,GAAA,mBAO0C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,iBAAc,SAAd,gBAAc,WAAA,YAFb,OAAM,CAAA;;;sEAEP,gBAAc,CAAA;UAH1B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;AC/BtG,IAAO,iBAAP,MAAO,gBAAc;EAOD;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,YAAY,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhZS,iBAAc,mBAAA,UAAA,GAAA,mBAO0C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,iBAAc,SAAd,gBAAc,WAAA,YAFb,OAAM,CAAA;;;sEAEP,gBAAc,CAAA;UAH1B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACPtG,IAAO,gBAAP,MAAO,eAAa;EAOA;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,WAAW,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,IAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhZS,gBAAa,mBAAA,UAAA,GAAA,mBAO2C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,gBAAa,SAAb,eAAa,WAAA,YAFZ,OAAM,CAAA;;;sEAEP,eAAa,CAAA;UAHzB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACftG,IAAO,iBAAP,MAAO,gBAAc;EAOD;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,WAAW,QAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAqD,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5H;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAnIS,iBAAc,mBAAA,UAAA,GAAA,mBAO0C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,iBAAc,SAAd,gBAAc,WAAA,YAFb,OAAM,CAAA;;;sEAEP,gBAAc,CAAA;UAH1B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACDtG,IAAO,aAAP,MAAO,YAAU;EAOG;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAYO,eAAe,QAAgB,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1M,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gBAAgB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,eAAe,QAAgB,KAAa,KAAa,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrN,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gBAAgB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,SAAS,QAAgB,UAAkB,QAAgB,KAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrO,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,gBAAgB,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAvUS,aAAU,mBAAA,UAAA,GAAA,mBAO8C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,aAAU,SAAV,YAAU,WAAA,YAFT,OAAM,CAAA;;;sEAEP,YAAU,CAAA;UAHtB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACLtG,IAAO,iBAAP,MAAO,gBAAc;EAOD;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,YAAY,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,iBAAc,mBAAA,UAAA,GAAA,mBAO0C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,iBAAc,SAAd,gBAAc,WAAA,YAFb,OAAM,CAAA;;;sEAEP,gBAAc,CAAA;UAH1B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACDtG,IAAO,eAAP,MAAO,cAAY;EAOC;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,YAAY,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,UAAU,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5K,WAAO,KAAK,WAAW,QAA2B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,SAAuC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,UAAU,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5K,WAAO,KAAK,WAAW,QAA2B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,UAAU,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5K,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,OAAe,UAAkB,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AACjM,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,UAAU,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClL,WAAO,KAAK,WAAW,QAAa,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,OAAe,UAAkB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1M,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,gCAA0B,KAAK,gBAAgB,yBACxC,UAAU,UAAU;IAC7B;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,UAAU,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClL,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,uBAAuB,OAAe,OAAe,UAAkB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnO,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,eAAe,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/e,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,UAAU,OAAe,QAAiB,OAAgB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvO,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,qBAAqB,OAAe,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,UAAU,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAClL,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,iBAAiB,OAAe,OAAe,SAAuC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvV,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA/1BS,eAAY,mBAAA,UAAA,GAAA,mBAO4C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,eAAY,SAAZ,cAAY,WAAA,YAFX,OAAM,CAAA;;;sEAEP,cAAY,CAAA;UAHxB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACjBtG,IAAO,uBAAP,MAAO,sBAAoB;EAOP;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,iBAAiB,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAyB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA7IS,uBAAoB,mBAAA,UAAA,GAAA,mBAOoC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,uBAAoB,SAApB,sBAAoB,WAAA,YAFnB,OAAM,CAAA;;;sEAEP,sBAAoB,CAAA;UAHhC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACDtG,IAAO,2BAAP,MAAO,0BAAwB;EAOX;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,uBAAuB,SAAwC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,uFAAuF;IAC3G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,oBAAoB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,+BAA+B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjM,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,sBAAsB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAsC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,uBAAuB,IAAY,SAAwC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,uFAAuF;IAC3G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,+BAA+B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjM,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhZS,2BAAwB,mBAAA,UAAA,GAAA,mBAOgC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,2BAAwB,SAAxB,0BAAwB,WAAA,YAFvB,OAAM,CAAA;;;sEAEP,0BAAwB,CAAA;UAHpC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACHtG,IAAO,gBAAP,MAAO,eAAa;EAOA;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,aAAa,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAA8B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,kBAAkB,QAAiB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAE/N,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhXS,gBAAa,mBAAA,UAAA,GAAA,mBAO2C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,gBAAa,SAAb,eAAa,WAAA,YAFZ,OAAM,CAAA;;;sEAEP,eAAa,CAAA;UAHzB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACrBtG,IAAO,kBAAP,MAAO,iBAAe;EAOF;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAYO,SAAS,IAAY,SAAkB,UAAe,QAAQ,iBAA0B,OAAO,aAA4F;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,OAAO,UAAa,OAAO,MAAM;AACnC,gCAA0B,KAAK,gBAAgB,yBACxC,IAAI,IAAI;IACjB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,eAAe,YAAY;AACtF,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,eAAe,YAAY;AAC9E,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,eAAe,YAAY;AAC5E,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAa,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA9IS,kBAAe,mBAAA,UAAA,GAAA,mBAOyC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,kBAAe,SAAf,iBAAe,WAAA,YAFd,OAAM,CAAA;;;sEAEP,iBAAe,CAAA;UAH3B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACCtG,IAAO,mBAAP,MAAO,kBAAgB;EAOH;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,eAAe,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,cAAc,OAAe,QAAiB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,eAAe,IAAY,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAvdS,mBAAgB,mBAAA,UAAA,GAAA,mBAOwC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,mBAAgB,SAAhB,kBAAgB,WAAA,YAFf,OAAM,CAAA;;;sEAEP,kBAAgB,CAAA;UAH5B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACXtG,IAAO,2BAAP,MAAO,0BAAwB;EAOX;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,oBAAoB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC5L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,+BAA+B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACjM,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,sBAAsB,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjM,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAsC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAjNS,2BAAwB,mBAAA,UAAA,GAAA,mBAOgC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,2BAAwB,SAAxB,0BAAwB,WAAA,YAFvB,OAAM,CAAA;;;sEAEP,0BAAwB,CAAA;UAHpC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACHtG,IAAO,yBAAP,MAAO,wBAAsB;EAOT;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,qBAAqB,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,qBAAqB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,oBAAoB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,qBAAqB,IAAY,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAldS,yBAAsB,mBAAA,UAAA,GAAA,mBAOkC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,yBAAsB,SAAtB,wBAAsB,WAAA,YAFrB,OAAM,CAAA;;;sEAEP,wBAAsB,CAAA;UAHlC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACatG,IAAO,iBAAP,MAAO,gBAAc;EAOD;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,aAAa,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAA8B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,uBAAuB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACxL,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,mBAAmB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,uBAAuB,IAAY,UAAkB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrV,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,6BAA6B,IAAY,UAAkB,cAAuB,UAAe,QAAQ,iBAA0B,OAAO,aAAqG;AAClP,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wFAAwF;IAC5G;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,8FAA8F;IAClH;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,iBAAiB,UAAa,iBAAiB,MAAM;AACvD,gCAA0B,KAAK,gBAAgB,yBACxC,cAAc,cAAc;IACrC;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,eAAe,YAAY;AACtF,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,eAAe,YAAY;AAC9E,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,eAAe,YAAY;AAC5E,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,WAAW,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5V,WAAO,KAAK,WAAW,QAAa,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,kCAAkC,IAAY,UAAkB,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,aAAqG;AACrQ,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6FAA6F;IACjH;AACA,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,mGAAmG;IACvH;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kGAAkG;IACtH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,eAAe,YAAY;AACtF,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,eAAe,YAAY;AAC9E,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,eAAe,YAAY;AAC5E,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrV,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,8BAA8B,IAAY,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,aAAqG;AAC3O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8FAA8F;IAClH;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,eAAe,YAAY;AACtF,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,eAAe,YAAY;AAC9E,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,eAAe,YAAY;AAC5E,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,yBAAyB,OAAgB,QAAiB,MAAe,QAAiB,OAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAEtQ,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0C,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjH;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAcO,qBAAqB,OAAe,KAAa,QAAiB,MAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7O,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AACA,QAAI,QAAQ,QAAQ,QAAQ,QAAW;AACnC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,QAAQ,UAAa,QAAQ,MAAM;AACrC,gCAA0B,KAAK,gBAAgB,yBACxC,KAAK,KAAK;IACnB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAaO,kBAAkB,QAAiB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAE/N,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAkC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,2BAA2B,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACxL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,sBAAsB,IAAY,QAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AACA,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAtpCS,iBAAc,mBAAA,UAAA,GAAA,mBAO0C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,iBAAc,SAAd,gBAAc,WAAA,YAFb,OAAM,CAAA;;;sEAEP,gBAAc,CAAA;UAH1B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACzBtG,IAAO,sBAAP,MAAO,qBAAmB;EAON;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,kBAAkB,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA6B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,iBAAiB,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChR,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,kBAAkB,IAAY,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7N,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,0BAA0B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhZS,sBAAmB,mBAAA,UAAA,GAAA,mBAOqC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,sBAAmB,SAAnB,qBAAmB,WAAA,YAFlB,OAAM,CAAA;;;sEAEP,qBAAmB,CAAA;UAH/B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACTtG,IAAO,0BAAP,MAAO,yBAAuB;EAOV;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,sBAAsB,SAAuC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAiC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACzG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,mBAAmB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,8BAA8B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAChM,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,qBAAqB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAqC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,sBAAsB,IAAY,SAAuC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,8BAA8B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAChM,WAAO,KAAK,WAAW,QAAiC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,0BAAuB,mBAAA,UAAA,GAAA,mBAOiC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,0BAAuB,SAAvB,yBAAuB,WAAA,YAFtB,OAAM,CAAA;;;sEAEP,yBAAuB,CAAA;UAHnC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACbtG,IAAO,gBAAP,MAAO,eAAa;EAOA;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAYO,eAAe,OAAe,SAAmB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA/IS,gBAAa,mBAAA,UAAA,GAAA,mBAO2C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,gBAAa,SAAb,eAAa,WAAA,YAFZ,OAAM,CAAA;;;sEAEP,eAAa,CAAA;UAHzB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACDtG,IAAO,kBAAP,MAAO,iBAAe;EAOF;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,cAAc,SAA+B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAyB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,WAAW,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACxL,WAAO,KAAK,WAAW,QAAyB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,aAAa,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,cAAc,IAAY,SAA+B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,sBAAsB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACxL,WAAO,KAAK,WAAW,QAAyB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,kBAAe,mBAAA,UAAA,GAAA,mBAOyC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,kBAAe,SAAf,iBAAe,WAAA,YAFd,OAAM,CAAA;;;sEAEP,iBAAe,CAAA;UAH3B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACPtG,IAAO,6BAAP,MAAO,4BAA0B;EAOb;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,yBAAyB,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/N,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,sBAAsB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,wBAAwB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,sFAAsF;IAC1G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,yBAAyB,IAAY,SAA0C,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3O,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oFAAoF;IACxG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,yFAAyF;IAC7G;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iCAAiC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACnM,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA3YS,6BAA0B,mBAAA,UAAA,GAAA,mBAO8B,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,6BAA0B,SAA1B,4BAA0B,WAAA,YAFzB,OAAM,CAAA;;;sEAEP,4BAA0B,CAAA;UAHtC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACXtG,IAAO,kCAAP,MAAO,iCAA+B;EAOlB;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,0BAA0B,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qCAAqC,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvM,WAAO,KAAK,WAAW,QAAwC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/G;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,4BAA4B,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0FAA0F;IAC9G;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4C,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnH;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCArOS,kCAA+B,mBAAA,UAAA,GAAA,mBAOyB,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,kCAA+B,SAA/B,iCAA+B,WAAA,YAF9B,OAAM,CAAA;;;sEAEP,iCAA+B,CAAA;UAH3C;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACCtG,IAAO,yBAAP,MAAO,wBAAsB;EAOT;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,qBAAqB,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAgC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACxG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,oBAAoB,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAoC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC3G;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,wBAAwB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAyC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjH;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,qBAAqB,IAAY,SAAsC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,qFAAqF;IACzG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAAgC,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,uBAAuB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,6BAA6B,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC/L,WAAO,KAAK,WAAW,QAA0C,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClH;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAzhBS,yBAAsB,mBAAA,UAAA,GAAA,mBAOkC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,yBAAsB,SAAtB,wBAAsB,WAAA,YAFrB,OAAM,CAAA;;;sEAEP,wBAAsB,CAAA;UAHlC;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACPtG,IAAO,eAAP,MAAO,cAAY;EAOC;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAcO,mBAAmB,MAA0E,IAAY,QAAyJ,SAAmC,UAAe,QAAQ,iBAA0B,OAAO,aAAqG;AACrc,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,gFAAgF;IACpG;AACA,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AACA,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,kFAAkF;IACtG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,mFAAmF;IACvG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,eAAe,YAAY;AACtF,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,eAAe,YAAY;AAC9E,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,eAAe,YAAY;AAC5E,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,iBAAiB,KAAK,cAAc,YAAY,EAAC,MAAM,QAAQ,OAAO,MAAM,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,sEAAsE,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,IAAI,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,mJAAmJ,YAAY,OAAS,CAAC,CAAC;AAC1qB,WAAO,KAAK,WAAW,QAAyB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAzJS,eAAY,mBAAA,UAAA,GAAA,mBAO4C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,eAAY,SAAZ,cAAY,WAAA,YAFX,OAAM,CAAA;;;sEAEP,cAAY,CAAA;UAHxB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACbtG,IAAO,eAAP,MAAO,cAAY;EAOC;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,WAAW,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,UAAU,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5K,WAAO,KAAK,WAAW,QAAsB,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,WAAW,SAA4B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAsB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,QAAQ,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mEAAmE;IACvF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,UAAU,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5K,WAAO,KAAK,WAAW,QAAsB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,UAAU,QAAgB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvP,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA7XS,eAAY,mBAAA,UAAA,GAAA,mBAO4C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,eAAY,SAAZ,cAAY,WAAA,YAFX,OAAM,CAAA;;;sEAEP,cAAY,CAAA;UAHxB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACHtG,IAAO,gBAAP,MAAO,eAAa;EAOA;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,YAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAuB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,SAAS,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,oEAAoE;IACxF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,kBAAkB,QAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC9L,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,iFAAiF;IACrG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,2BAA2B,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrM,WAAO,KAAK,WAAW,QAA6B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,WAAW,OAAe,SAAmB,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1Q,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,YAAY,UAAa,YAAY,MAAM;AAC7C,gCAA0B,KAAK,gBAAgB,yBACxC,SAAS,SAAS;IAC3B;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,YAAY,IAAY,SAA6B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,oBAAoB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtL,WAAO,KAAK,WAAW,QAAuB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhdS,gBAAa,mBAAA,UAAA,GAAA,mBAO2C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,gBAAa,SAAb,eAAa,WAAA,YAFZ,OAAM,CAAA;;;sEAEP,eAAa,CAAA;UAHzB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACjBtG,IAAO,mBAAP,MAAO,kBAAgB;EAOH;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,eAAe,UAAkB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7L,QAAI,aAAa,QAAQ,aAAa,QAAW;AAC7C,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,cAAc,KAAK,cAAc,YAAY,EAAC,MAAM,YAAY,OAAO,UAAU,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC5L,WAAO,KAAK,WAAW,QAAqD,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC5H;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA5HS,mBAAgB,mBAAA,UAAA,GAAA,mBAOwC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,mBAAgB,SAAhB,kBAAgB,WAAA,YAFf,OAAM,CAAA;;;sEAEP,kBAAgB,CAAA;UAH5B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACCtG,IAAO,mBAAP,MAAO,kBAAgB;EAOH;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,eAAe,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,eAAe,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,YAAY,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,uEAAuE;IAC3F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,cAAc,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC1P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,eAAe,IAAY,SAAgC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,uBAAuB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACzL,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAldS,mBAAgB,mBAAA,UAAA,GAAA,mBAOwC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,mBAAgB,SAAhB,kBAAgB,WAAA,YAFf,OAAM,CAAA;;;sEAEP,kBAAgB,CAAA;UAH5B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACOtG,IAAO,eAAP,MAAO,cAAY;EAOC;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAYO,aAAa,IAAY,SAAkC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAkC,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC1G;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,WAAW,SAA4B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACpG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,OAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACpM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,YAAY,KAAK,cAAc,YAAY,EAAC,MAAM,SAAS,OAAO,OAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACtV,WAAO,KAAK,WAAW,QAAyB,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,gBAAgB,IAAY,QAAgB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,WAAW,QAAQ,WAAW,QAAW;AACzC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC,QAAQ,KAAK,cAAc,YAAY,EAAC,MAAM,UAAU,OAAO,QAAQ,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACpV,WAAO,KAAK,WAAW,QAAyB,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAChL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,QAAQ,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mEAAmE;IACvF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAsB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,cAAc,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAA8B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,UAAU,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACtP,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,UAAU,IAAY,SAA2B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,WAAW,IAAY,SAA4B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAsB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,iBAAiB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAChL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA99BS,eAAY,mBAAA,UAAA,GAAA,mBAO4C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,eAAY,SAAZ,cAAY,WAAA,YAFX,OAAM,CAAA;;;sEAEP,cAAY,CAAA;UAHxB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACnBtG,IAAO,iBAAP,MAAO,gBAAc;EAOD;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,aAAa,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAwB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAChG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAa,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,UAAU,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAClL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,qEAAqE;IACzF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,cAAc,IAAY,MAAe,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrM,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,yEAAyE;IAC7F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAgB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACvF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,YAAY,OAAe,QAAiB,OAAgB,MAAe,QAAiB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,0EAA0E;IAC9F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA4B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,aAAa,IAAY,SAA8B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,oBAAoB,IAAY,SAAqC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACjO,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,+EAA+E;IACnG;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,oFAAoF;IACxG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAwB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC/F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,iBAAiB,IAAY,MAAc,UAAe,QAAQ,iBAA0B,OAAO,SAAwF;AAC9L,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,4EAA4E;IAChG;AACA,QAAI,SAAS,QAAQ,SAAS,QAAW;AACrC,YAAM,IAAI,MAAM,8EAA8E;IAClG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B,CAAA;AAEpC,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,qBAAqB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACvL,WAAO,KAAK,WAAW,QAAa,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrF;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCA/sBS,iBAAc,mBAAA,UAAA,GAAA,mBAO0C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,iBAAc,SAAd,gBAAc,WAAA,YAFb,OAAM,CAAA;;;sEAEP,gBAAc,CAAA;UAH1B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACTtG,IAAO,oBAAP,MAAO,mBAAiB;EAOJ;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,gBAAgB,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC7M,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA2B,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACnG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,gBAAgB,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACxL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,UAAU,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACrG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,aAAa,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACrL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAeO,eAAe,OAAe,QAAiB,OAAgB,MAAe,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC3P,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,6EAA6E;IACjG;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA+B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACtG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,gBAAgB,IAAY,SAAiC,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACzN,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,gFAAgF;IACpG;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,wBAAwB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AAC1L,WAAO,KAAK,WAAW,QAA2B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAClG;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAldS,oBAAiB,mBAAA,UAAA,GAAA,mBAOuC,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,oBAAiB,SAAjB,mBAAiB,WAAA,YAFhB,OAAM,CAAA;;;sEAEP,mBAAiB,CAAA;UAH7B;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACPtG,IAAO,eAAP,MAAO,cAAY;EAOC;EALZ,WAAW;EACd,iBAAiB,IAAI,YAAW;EAChC,gBAAgB,IAAI,cAAa;EACjC;EAEP,YAAsB,YAAsD,UAAuC,eAA4B;AAAzH,SAAA,aAAA;AAClB,QAAI,eAAe;AACf,WAAK,gBAAgB;IACzB;AACA,QAAI,OAAO,KAAK,cAAc,aAAa,UAAU;AACjD,YAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,SAAS,CAAC,IAAI;AAC9D,UAAI,iBAAiB,QAAW;AAC5B,mBAAW;MACf;AAEA,UAAI,OAAO,aAAa,UAAU;AAC9B,mBAAW,KAAK;MACpB;AACA,WAAK,cAAc,WAAW;IAClC;AACA,SAAK,UAAU,KAAK,cAAc,WAAW,IAAI,yBAAwB;EAC7E;;EAIQ,gBAAgB,YAAwB,OAAY,KAAY;AACpE,QAAI,OAAO,UAAU,YAAY,iBAAiB,SAAS,OAAO;AAC9D,mBAAa,KAAK,yBAAyB,YAAY,KAAK;IAChE,OAAO;AACH,mBAAa,KAAK,yBAAyB,YAAY,OAAO,GAAG;IACrE;AACA,WAAO;EACX;EAEQ,yBAAyB,YAAwB,OAAa,KAAY;AAC9E,QAAI,SAAS,MAAM;AACf,aAAO;IACX;AAEA,QAAI,OAAO,UAAU,UAAU;AAC3B,UAAI,MAAM,QAAQ,KAAK,GAAG;AACrB,cAAgB,QAAS,UAAQ,aAAa,KAAK,yBAAyB,YAAY,MAAM,GAAG,CAAC;MACvG,WAAW,iBAAiB,MAAM;AAC9B,YAAI,OAAO,MAAM;AACb,uBAAa,WAAW,OAAO,KAAM,MAAe,YAAW,EAAG,UAAU,GAAG,EAAE,CAAC;QACtF,OAAO;AACJ,gBAAM,MAAM,sCAAsC;QACrD;MACJ,OAAO;AACH,eAAO,KAAK,KAAK,EAAE,QAAS,OAAK,aAAa,KAAK,yBAC/C,YAAY,MAAM,CAAC,GAAG,OAAO,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;MAC9D;IACJ,WAAW,OAAO,MAAM;AACpB,mBAAa,WAAW,OAAO,KAAK,KAAK;IAC7C,OAAO;AACH,YAAM,MAAM,qDAAqD;IACrE;AACA,WAAO;EACX;EAWO,WAAW,SAA4B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACnM,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAAsB,QAAQ,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC9F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAWO,QAAQ,IAAY,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAChL,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,mEAAmE;IACvF;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAsB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7F;MACI,SAAS;MACT,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAgBO,UAAU,OAAe,QAAiB,OAAgB,MAAe,QAAiB,QAAiB,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AACvQ,QAAI,UAAU,QAAQ,UAAU,QAAW;AACvC,YAAM,IAAI,MAAM,wEAAwE;IAC5F;AAEA,QAAI,0BAA0B,IAAI,WAAW,EAAC,SAAS,KAAK,QAAO,CAAC;AACpE,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,gCAA0B,KAAK,gBAAgB,yBACxC,OAAO,OAAO;IACvB;AACA,QAAI,SAAS,UAAa,SAAS,MAAM;AACvC,gCAA0B,KAAK,gBAAgB,yBACxC,MAAM,MAAM;IACrB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AACA,QAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,gCAA0B,KAAK,gBAAgB,yBACxC,QAAQ,QAAQ;IACzB;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAGA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe;AACnB,WAAO,KAAK,WAAW,QAA0B,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IACjG;MACI,SAAS;MACT,QAAQ;MACR,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;EAYO,WAAW,IAAY,SAA4B,UAAe,QAAQ,iBAA0B,OAAO,SAAiG;AAC/M,QAAI,OAAO,QAAQ,OAAO,QAAW;AACjC,YAAM,IAAI,MAAM,sEAAsE;IAC1F;AACA,QAAI,YAAY,QAAQ,YAAY,QAAW;AAC3C,YAAM,IAAI,MAAM,2EAA2E;IAC/F;AAEA,QAAI,kBAAkB,KAAK;AAE3B,QAAI;AAEJ,yBAAqB,KAAK,cAAc,iBAAiB,cAAc;AACvE,QAAI,oBAAoB;AACpB,wBAAkB,gBAAgB,IAAI,kBAAkB,kBAAkB;IAC9E;AAEA,QAAI,mCAAuD,WAAW,QAAQ;AAC9E,QAAI,qCAAqC,QAAW;AAEhD,YAAM,oBAA8B;QAChC;;AAEJ,yCAAmC,KAAK,cAAc,mBAAmB,iBAAiB;IAC9F;AACA,QAAI,qCAAqC,QAAW;AAChD,wBAAkB,gBAAgB,IAAI,UAAU,gCAAgC;IACpF;AAEA,QAAI,sBAA+C,WAAW,QAAQ;AACtE,QAAI,wBAAwB,QAAW;AACnC,4BAAsB,IAAI,YAAW;IACzC;AAEA,QAAI,wBAA6C,WAAW,QAAQ;AACpE,QAAI,0BAA0B,QAAW;AACrC,8BAAwB;IAC5B;AAIA,UAAM,WAAqB;MACvB;;AAEJ,UAAM,0BAA8C,KAAK,cAAc,wBAAwB,QAAQ;AACvG,QAAI,4BAA4B,QAAW;AACvC,wBAAkB,gBAAgB,IAAI,gBAAgB,uBAAuB;IACjF;AAEA,QAAI,gBAA0C;AAC9C,QAAI,kCAAkC;AAClC,UAAI,iCAAiC,WAAW,MAAM,GAAG;AACrD,wBAAgB;MACpB,WAAW,KAAK,cAAc,WAAW,gCAAgC,GAAG;AACxE,wBAAgB;MACpB,OAAO;AACH,wBAAgB;MACpB;IACJ;AAEA,QAAI,eAAe,mBAAmB,KAAK,cAAc,YAAY,EAAC,MAAM,MAAM,OAAO,IAAI,IAAI,QAAQ,OAAO,UAAU,SAAS,OAAO,UAAU,UAAU,YAAY,OAAS,CAAC,CAAC;AACrL,WAAO,KAAK,WAAW,QAAsB,OAAO,GAAG,KAAK,cAAc,QAAQ,GAAG,YAAY,IAC7F;MACI,SAAS;MACT,MAAM;MACN,cAAmB;MACnB,iBAAiB,KAAK,cAAc;MACpC,SAAS;MACT;MACA,eAAe;MACf;KACH;EAET;;qCAhZS,eAAY,mBAAA,UAAA,GAAA,mBAO4C,WAAS,CAAA,GAAA,mBAAA,eAAA,CAAA,CAAA;EAAA;4EAPjE,eAAY,SAAZ,cAAY,WAAA,YAFX,OAAM,CAAA;;;sEAEP,cAAY,CAAA;UAHxB;WAAW;MACV,YAAY;KACb;;UAQkD;;UAAW;WAAO,SAAS;;UAA8B;;;;;ACxBtG,IAAW;CAAjB,SAAiBC,cAAW;AAEX,EAAAA,aAAA,WAAW;IACpB,cAAc;IACd,cAAc;IACd,kBAAkB;;AAE1B,GAPiB,gBAAA,cAAW,CAAA,EAAA;;;AC2BtB,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,oBAAA,eAAe;IACxB,KAAK;IACL,QAAQ;IACR,MAAM;;AAEd,GAZiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACJ7B,IAAW;CAAjB,SAAiBC,gBAAa;AAEb,EAAAA,eAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,eAAA,eAAe;IACxB,KAAK;IACL,QAAQ;IACR,MAAM;;AAEd,GAZiB,kBAAA,gBAAa,CAAA,EAAA;;;ACvBxB,IAAW;CAAjB,SAAiBC,cAAW;AAEX,EAAAA,aAAA,WAAW;IACpB,MAAM;IACN,MAAM;;AAEd,GANiB,gBAAA,cAAW,CAAA,EAAA;;;AC+BtB,IAAW;CAAjB,SAAiBC,gBAAa;AAEb,EAAAA,eAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,eAAA,eAAe;IACxB,KAAK;IACL,QAAQ;IACR,MAAM;;AAEd,GAZiB,kBAAA,gBAAa,CAAA,EAAA;;;ACRxB,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,oBAAA,eAAe;IACxB,KAAK;IACL,QAAQ;IACR,MAAM;;AAEd,GAZiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACF7B,IAAW;CAAjB,SAAiBC,8BAA2B;AAE3B,EAAAA,6BAAA,aAAa;IACtB,QAAQ;IACR,SAAS;IACT,WAAW;IACX,SAAS;IACT,QAAQ;IACR,OAAO;;AAGE,EAAAA,6BAAA,WAAW;IACpB,QAAQ;IACR,QAAQ;;AAEhB,GAfiB,gCAAA,8BAA2B,CAAA,EAAA;;;ACVtC,IAAW;CAAjB,SAAiBC,6BAA0B;AAE1B,EAAAA,4BAAA,aAAa;IACtB,MAAM;IACN,KAAK;;AAEb,GANiB,+BAAA,6BAA0B,CAAA,EAAA;;;ACTrC,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,UAAU;IACnB,MAAM;IACN,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,YAAY;IACZ,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,WAAW;IACX,OAAO;IACP,SAAS;IACT,WAAW;IACX,YAAY;;AAEpB,GAzBiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACD7B,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,WAAW;IACpB,SAAS;IACT,SAAS;IACT,OAAO;;AAEf,GAPiB,0BAAA,wBAAqB,CAAA,EAAA;;;ACOhC,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,UAAU;IACnB,MAAM;IACN,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,YAAY;IACZ,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,WAAW;IACX,OAAO;IACP,SAAS;IACT,WAAW;IACX,YAAY;;AAGH,EAAAA,wBAAA,YAAY;IACrB,MAAM;IACN,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,YAAY;IACZ,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,WAAW;IACX,OAAO;IACP,SAAS;IACT,WAAW;IACX,YAAY;;AAEpB,GAjDiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACiBjC,IAAW;CAAjB,SAAiBC,0BAAuB;AAEvB,EAAAA,yBAAA,kBAAkB;IAC3B,MAAM;IACN,OAAO;;AAEf,GANiB,4BAAA,0BAAuB,CAAA,EAAA;;;AC1BlC,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,UAAU;IACnB,MAAM;IACN,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,YAAY;IACZ,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,WAAW;IACX,OAAO;IACP,SAAS;IACT,WAAW;IACX,YAAY;;AAGH,EAAAA,0BAAA,YAAY;IACrB,MAAM;IACN,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,YAAY;IACZ,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,OAAO;IACP,YAAY;IACZ,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,gBAAgB;IAChB,WAAW;IACX,OAAO;IACP,SAAS;IACT,WAAW;IACX,YAAY;;AAEpB,GAjDiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACEnC,IAAW;CAAjB,SAAiBC,uBAAoB;AAEpB,EAAAA,sBAAA,WAAW;IACpB,YAAY;IACZ,SAAS;;AAGA,EAAAA,sBAAA,gBAAgB;IACzB,KAAK;IACL,MAAM;;AAEd,GAXiB,yBAAA,uBAAoB,CAAA,EAAA;;;AC2D/B,IAAW;CAAjB,SAAiBC,qBAAkB;AAcpB,EAAAA,oBAAA,YAAY;IACvB,MAAM;IACN,WAAW;IACX,OAAO;IACP,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,KAAK;IACL,MAAM;IACN,QAAQ;IACR,OAAO;IACP,MAAM;;AAGK,EAAAA,oBAAA,YAAY;IACvB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEb,GAnCiB,uBAAA,qBAAkB,CAAA,EAAA;;;AChB7B,IAAW;CAAjB,SAAiBC,gBAAa;AAcf,EAAAA,eAAA,YAAY;IACvB,MAAM;IACN,WAAW;IACX,OAAO;IACP,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,KAAK;IACL,MAAM;IACN,QAAQ;IACR,OAAO;IACP,MAAM;;AAGK,EAAAA,eAAA,YAAY;IACvB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEb,GAnCiB,kBAAA,gBAAa,CAAA,EAAA;;;AC9BxB,IAAW;CAAjB,SAAiBC,kCAA+B;AAE/B,EAAAA,iCAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,oCAAA,kCAA+B,CAAA,EAAA;;;ACM1C,IAAW;CAAjB,SAAiBC,6BAA0B;AAE1B,EAAAA,4BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,+BAAA,6BAA0B,CAAA,EAAA;;;ACFrC,IAAW;CAAjB,SAAiBC,6BAA0B;AAE1B,EAAAA,4BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,+BAAA,6BAA0B,CAAA,EAAA;;;ACRrC,IAAW;CAAjB,SAAiBC,kCAA+B;AAE/B,EAAAA,iCAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,oCAAA,kCAA+B,CAAA,EAAA;;;ACiE1C,IAAW;CAAjB,SAAiBC,gBAAa;AAcf,EAAAA,eAAA,YAAY;IACvB,MAAM;IACN,WAAW;IACX,OAAO;IACP,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,KAAK;IACL,MAAM;IACN,QAAQ;IACR,OAAO;IACP,MAAM;;AAGK,EAAAA,eAAA,YAAY;IACvB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEb,GAnCiB,kBAAA,gBAAa,CAAA,EAAA;;;AC7DxB,IAAW;CAAjB,SAAiBC,iCAA8B;AAE9B,EAAAA,gCAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,mCAAA,iCAA8B,CAAA,EAAA;;;ACMzC,IAAW;CAAjB,SAAiBC,4BAAyB;AAEzB,EAAAA,2BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,8BAAA,4BAAyB,CAAA,EAAA;;;ACFpC,IAAW;CAAjB,SAAiBC,4BAAyB;AAEzB,EAAAA,2BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,8BAAA,4BAAyB,CAAA,EAAA;;;ACRpC,IAAW;CAAjB,SAAiBC,iCAA8B;AAE9B,EAAAA,gCAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,mCAAA,iCAA8B,CAAA,EAAA;;;ACQzC,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,WAAW;IACpB,SAAS;IACT,OAAO;IACP,OAAO;;AAGE,EAAAA,uBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GAZiB,0BAAA,wBAAqB,CAAA,EAAA;;;ACIhC,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,WAAW;IACpB,SAAS;IACT,OAAO;IACP,OAAO;;AAGE,EAAAA,kBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GAZiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACG3B,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,WAAW;IACpB,SAAS;IACT,OAAO;IACP,OAAO;;AAGE,EAAAA,kBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GAZiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACR3B,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,WAAW;IACpB,SAAS;IACT,OAAO;IACP,OAAO;;AAGE,EAAAA,uBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GAZiB,0BAAA,wBAAqB,CAAA,EAAA;;;AC0ChC,IAAW;CAAjB,SAAiBC,qBAAkB;AAcpB,EAAAA,oBAAA,YAAY;IACvB,MAAM;IACN,WAAW;IACX,OAAO;IACP,OAAO;IACP,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,KAAK;IACL,MAAM;IACN,QAAQ;IACR,OAAO;IACP,MAAM;;AAGK,EAAAA,oBAAA,YAAY;IACvB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEb,GAnCiB,uBAAA,qBAAkB,CAAA,EAAA;;;AC1D7B,IAAW;CAAjB,SAAiBC,kBAAe;AAEf,EAAAA,iBAAA,eAAe;IACxB,UAAU;IACV,QAAQ;IACR,MAAM;IACN,OAAO;;AAGE,EAAAA,iBAAA,0BAA0B;IACnC,KAAK;IACL,OAAO;IACP,UAAU;;AAElB,GAdiB,oBAAA,kBAAe,CAAA,EAAA;;;ACE1B,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,aAAa;IACtB,OAAO;IACP,UAAU;IACV,SAAS;;AAEjB,GAPiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACoB3B,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,gBAAgB;IACzB,SAAS;IACT,UAAU;IACV,SAAS;;AAEjB,GAPiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACN7B,IAAW;CAAjB,SAAiBC,eAAY;AAEZ,EAAAA,cAAA,WAAW;IACpB,OAAO;IACP,MAAM;;AAEd,GANiB,iBAAA,eAAY,CAAA,EAAA;;;ACXvB,IAAW;CAAjB,SAAiBC,WAAQ;AAER,EAAAA,UAAA,oBAAoB;IAC7B,OAAO;IACP,MAAM;;AAEd,GANiB,aAAA,WAAQ,CAAA,EAAA;;;ACHnB,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,aAAa;IACtB,UAAU;IACV,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,SAAS;IACT,UAAU;IACV,aAAa;IACb,cAAc;;AAEtB,GAZiB,sBAAA,oBAAiB,CAAA,EAAA;;;ACG5B,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,WAAW;IACpB,SAAS;IACT,KAAK;IACL,KAAK;IACL,OAAO;IACP,MAAM;;AAEd,GATiB,mBAAA,iBAAc,CAAA,EAAA;;;ACDzB,IAAW;CAAjB,SAAiBC,UAAO;AAEP,EAAAA,SAAA,aAAa;IACtB,OAAO;IACP,SAAS;IACT,YAAY;IACZ,WAAW;;AAEnB,GARiB,YAAA,UAAO,CAAA,EAAA;;;ACJlB,IAAW;CAAjB,SAAiBC,YAAS;AAET,EAAAA,WAAA,WAAW;IACpB,UAAU;IACV,WAAW;IACX,iBAAiB;IACjB,cAAc;IACd,oBAAoB;;AAE5B,GATiB,cAAA,YAAS,CAAA,EAAA;;;ACKpB,IAAW;CAAjB,SAAiBC,kBAAe;AAEf,EAAAA,iBAAA,kBAAkB;IAC3B,YAAY;IACZ,UAAU;;AAGD,EAAAA,iBAAA,YAAY;IACrB,MAAM;IACN,OAAO;;AAEf,GAXiB,oBAAA,kBAAe,CAAA,EAAA;;;ACR1B,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,aAAa;IACtB,YAAY;IACZ,MAAM;;AAEd,GANiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACgF3B,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,wBAAA,sBAAmB,CAAA,EAAA;;;AC/C9B,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,mBAAA,iBAAc,CAAA,EAAA;;;ACzBzB,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,mBAAmB;IAC5B,YAAY;IACZ,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,OAAO;IACP,eAAe;IACf,OAAO;;AAGE,EAAAA,wBAAA,mBAAmB;IAC5B,QAAQ;IACR,YAAY;IACZ,MAAM;IACN,QAAQ;IACR,OAAO;IACP,eAAe;IACf,OAAO;;AAGE,EAAAA,wBAAA,gBAAgB;IACzB,mBAAmB;IACnB,iBAAiB;IACjB,cAAc;IACd,OAAO;;AAGE,EAAAA,wBAAA,eAAe;IACxB,kBAAkB;IAClB,OAAO;IACP,UAAU;IACV,YAAY;IACZ,cAAc;IACd,cAAc;IACd,aAAa;IACb,aAAa;;AAGJ,EAAAA,wBAAA,iBAAiB;IAC1B,QAAQ;IACR,aAAa;IACb,WAAW;IACX,SAAS;IACT,QAAQ;IACR,WAAW;IACX,UAAU;;AAGD,EAAAA,wBAAA,iBAAiB;IAC1B,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,QAAQ;;AAGC,EAAAA,wBAAA,eAAe;IACxB,QAAQ;IACR,OAAO;IACP,QAAQ;;AAGC,EAAAA,wBAAA,eAAe;IACxB,WAAW;IACX,WAAW;IACX,WAAW;IACX,WAAW;IACX,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,SAAS;IACT,WAAW;IACX,SAAS;;AAGA,EAAAA,wBAAA,sBAAsB;IAC/B,SAAS;IACT,YAAY;;AAEpB,GAjFiB,2BAAA,yBAAsB,CAAA,EAAA;;;AC6EjC,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,mBAAA,iBAAc,CAAA,EAAA;;;ACNzB,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,wBAAA,sBAAmB,CAAA,EAAA;;;AClE9B,IAAW;CAAjB,SAAiBC,+BAA4B;AAE5B,EAAAA,8BAAA,oBAAoB;IAC7B,MAAM;IACN,QAAQ;IACR,OAAO;;AAEf,GAPiB,iCAAA,+BAA4B,CAAA,EAAA;;;ACoDvC,IAAW;CAAjB,SAAiBC,kBAAe;AAEf,EAAAA,iBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAGA,EAAAA,iBAAA,WAAW;IACpB,aAAa;IACb,QAAQ;IACR,QAAQ;;AAEhB,GAdiB,oBAAA,kBAAe,CAAA,EAAA;;;ACL1B,IAAW;CAAjB,SAAiBC,0BAAuB;AAEvB,EAAAA,yBAAA,aAAa;IACtB,SAAS;IACT,WAAW;;AAGF,EAAAA,yBAAA,aAAa;IACtB,QAAQ;IACR,SAAS;IACT,WAAW;IACX,SAAS;IACT,QAAQ;IACR,OAAO;;AAGE,EAAAA,yBAAA,mBAAmB;IAC5B,KAAK;IACL,MAAM;IACN,KAAK;IACL,KAAK;IACL,KAAK;IACL,MAAM;IACN,YAAY;IACZ,QAAQ;;AAGC,EAAAA,yBAAA,kBAAkB;IAC3B,MAAM;IACN,UAAU;IACV,WAAW;;AAEnB,GAhCiB,4BAAA,0BAAuB,CAAA,EAAA;;;AC9BlC,IAAW;CAAjB,SAAiBC,UAAO;AAEP,EAAAA,SAAA,WAAW;IACpB,WAAW;IACX,gBAAgB;IAChB,WAAW;IACX,aAAa;IACb,YAAY;IACZ,OAAO;;AAEf,GAViB,YAAA,UAAO,CAAA,EAAA;;;ACNlB,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,YAAY;IACrB,QAAQ;IACR,aAAa;IACb,QAAQ;IACR,QAAQ;;AAEhB,GARiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACMjC,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,YAAY;IACrB,QAAQ;IACR,aAAa;IACb,QAAQ;IACR,QAAQ;;AAEhB,GARiB,sBAAA,oBAAiB,CAAA,EAAA;;;ACC5B,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,YAAY;IACrB,QAAQ;IACR,aAAa;IACb,QAAQ;IACR,QAAQ;;AAEhB,GARiB,sBAAA,oBAAiB,CAAA,EAAA;;;ACJ5B,IAAW;CAAjB,SAAiBC,4BAAyB;AAEzB,EAAAA,2BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,8BAAA,4BAAyB,CAAA,EAAA;;;ACCpC,IAAW;CAAjB,SAAiBC,4BAAyB;AAEzB,EAAAA,2BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,8BAAA,4BAAyB,CAAA,EAAA;;;ACRpC,IAAW;CAAjB,SAAiBC,iCAA8B;AAE9B,EAAAA,gCAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,mCAAA,iCAA8B,CAAA,EAAA;;;ACEzC,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,YAAY;IACrB,QAAQ;IACR,aAAa;IACb,QAAQ;IACR,QAAQ;;AAEhB,GARiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACOjC,IAAW;CAAjB,SAAiBC,kBAAe;AAEf,EAAAA,iBAAA,iBAAiB;IAC1B,OAAO;IACP,MAAM;IACN,MAAM;IACN,MAAM;IACN,KAAK;;AAEb,GATiB,oBAAA,kBAAe,CAAA,EAAA;;;ACxB1B,IAAW;CAAjB,SAAiBC,4BAAyB;AAEzB,EAAAA,2BAAA,WAAW;IACpB,QAAQ;IACR,MAAM;;AAEd,GANiB,8BAAA,4BAAyB,CAAA,EAAA;;;ACiBpC,IAAW;CAAjB,SAAiBC,4BAAyB;AAEzB,EAAAA,2BAAA,iBAAiB;IAC1B,cAAc;IACd,eAAe;IACf,UAAU;IACV,YAAY;;AAEpB,GARiB,8BAAA,4BAAyB,CAAA,EAAA;;;ACDpC,IAAW;CAAjB,SAAiBC,mCAAgC;AAEhC,EAAAA,kCAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,qCAAA,mCAAgC,CAAA,EAAA;;;ACF3C,IAAW;CAAjB,SAAiBC,8BAA2B;AAE3B,EAAAA,6BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,gCAAA,8BAA2B,CAAA,EAAA;;;ACOtC,IAAW;CAAjB,SAAiBC,8BAA2B;AAE3B,EAAAA,6BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,gCAAA,8BAA2B,CAAA,EAAA;;;ACTtC,IAAW;CAAjB,SAAiBC,mCAAgC;AAEhC,EAAAA,kCAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,qCAAA,mCAAgC,CAAA,EAAA;;;ACM3C,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACJ9B,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,mBAAA,iBAAc,CAAA,EAAA;;;ACRzB,IAAW;CAAjB,SAAiBC,8BAA2B;AAE3B,EAAAA,6BAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,gCAAA,8BAA2B,CAAA,EAAA;;;ACQtC,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACDjC,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACGjC,IAAW;CAAjB,SAAiBC,6BAA0B;AAE1B,EAAAA,4BAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,+BAAA,6BAA0B,CAAA,EAAA;;;ACIrC,IAAW;CAAjB,SAAiBC,6BAA0B;AAE1B,EAAAA,4BAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,+BAAA,6BAA0B,CAAA,EAAA;;;ACfrC,IAAW;CAAjB,SAAiBC,8BAA2B;AAE3B,EAAAA,6BAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,gCAAA,8BAA2B,CAAA,EAAA;;;ACqBtC,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,mBAAA,iBAAc,CAAA,EAAA;;;ACFzB,IAAW;CAAjB,SAAiBC,0BAAuB;AAEvB,EAAAA,yBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,4BAAA,0BAAuB,CAAA,EAAA;;;ACDlC,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACQ7B,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACR7B,IAAW;CAAjB,SAAiBC,0BAAuB;AAEvB,EAAAA,yBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,4BAAA,0BAAuB,CAAA,EAAA;;;ACNlC,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACgD9B,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACzCnC,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,wBAAA,sBAAmB,CAAA,EAAA;;;AC8C9B,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACN9B,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACvDnC,IAAW;CAAjB,SAAiBC,6BAA0B;AAE1B,EAAAA,4BAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,+BAAA,6BAA0B,CAAA,EAAA;;;ACKrC,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,0BAAA,wBAAqB,CAAA,EAAA;;;ACDhC,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,0BAAA,wBAAqB,CAAA,EAAA;;;ACOhC,IAAW;CAAjB,SAAiBC,4BAAyB;AAEzB,EAAAA,2BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,8BAAA,4BAAyB,CAAA,EAAA;;;ACFpC,IAAW;CAAjB,SAAiBC,4BAAyB;AAEzB,EAAAA,2BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,8BAAA,4BAAyB,CAAA,EAAA;;;ACbpC,IAAW;CAAjB,SAAiBC,6BAA0B;AAE1B,EAAAA,4BAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAPiB,+BAAA,6BAA0B,CAAA,EAAA;;;ACFrC,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,YAAY;IACrB,QAAQ;IACR,WAAW;;AAEnB,GANiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACFnC,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,gBAAgB;IACzB,OAAO;IACP,MAAM;IACN,QAAQ;;AAGC,EAAAA,kBAAA,yBAAyB;IAClC,KAAK;IACL,OAAO;IACP,aAAa;IACb,UAAU;;AAElB,GAdiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACA3B,IAAW;CAAjB,SAAiBC,aAAU;AAEV,EAAAA,YAAA,gBAAgB;IACzB,OAAO;IACP,OAAO;;AAEf,GANiB,eAAA,aAAU,CAAA,EAAA;;;ACArB,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,0BAA0B;IACnC,KAAK;IACL,OAAO;IACP,UAAU;;AAElB,GAPiB,sBAAA,oBAAiB,CAAA,EAAA;;;ACyB5B,IAAW;CAAjB,SAAiBC,0BAAuB;AAEvB,EAAAA,yBAAA,YAAY;IACrB,WAAW;IACX,QAAQ;IACR,SAAS;;AAGA,EAAAA,yBAAA,qBAAqB;IAC9B,MAAM;IACN,QAAQ;IACR,UAAU;;AAGD,EAAAA,yBAAA,sBAAsB;IAC/B,IAAI;IACJ,IAAI;;AAEZ,GAlBiB,4BAAA,0BAAuB,CAAA,EAAA;;;ACUlC,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,WAAW;IACX,QAAQ;IACR,SAAS;;AAGA,EAAAA,oBAAA,qBAAqB;IAC9B,MAAM;IACN,QAAQ;IACR,UAAU;;AAGD,EAAAA,oBAAA,sBAAsB;IAC/B,IAAI;IACJ,IAAI;;AAEZ,GAlBiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACM7B,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,WAAW;IACX,QAAQ;IACR,SAAS;;AAGA,EAAAA,oBAAA,qBAAqB;IAC9B,MAAM;IACN,QAAQ;IACR,UAAU;;AAGD,EAAAA,oBAAA,sBAAsB;IAC/B,IAAI;IACJ,IAAI;;AAEZ,GAlBiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACpB7B,IAAW;CAAjB,SAAiBC,0BAAuB;AAEvB,EAAAA,yBAAA,YAAY;IACrB,WAAW;IACX,QAAQ;IACR,SAAS;;AAGA,EAAAA,yBAAA,qBAAqB;IAC9B,MAAM;IACN,QAAQ;IACR,UAAU;;AAGD,EAAAA,yBAAA,sBAAsB;IAC/B,IAAI;IACJ,IAAI;;AAEZ,GAlBiB,4BAAA,0BAAuB,CAAA,EAAA;;;AChBlC,IAAW;CAAjB,SAAiBC,uBAAoB;AAEpB,EAAAA,sBAAA,WAAW;IACpB,UAAU;IACV,QAAQ;IACR,MAAM;IACN,OAAO;IACP,SAAS;;AAEjB,GATiB,yBAAA,uBAAoB,CAAA,EAAA;;;ACgB/B,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,0BAAA,wBAAqB,CAAA,EAAA;;;ACShC,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACF3B,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACR3B,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,0BAAA,wBAAqB,CAAA,EAAA;;;ACNhC,IAAW;CAAjB,SAAiBC,8BAA2B;AAE3B,EAAAA,6BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,gCAAA,8BAA2B,CAAA,EAAA;;;ACMtC,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACFjC,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACRjC,IAAW;CAAjB,SAAiBC,8BAA2B;AAE3B,EAAAA,6BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,gCAAA,8BAA2B,CAAA,EAAA;;;ACHtC,IAAW;CAAjB,SAAiBC,cAAW;AAEX,EAAAA,aAAA,YAAY;IACrB,QAAQ;IACR,UAAU;IACV,WAAW;IACX,SAAS;;AAEjB,GARiB,gBAAA,cAAW,CAAA,EAAA;;;ACmBtB,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,qBAAA,WAAW;IACpB,cAAc;IACd,eAAe;IACf,aAAa;IACb,kBAAkB;IAClB,UAAU;IACV,cAAc;IACd,aAAa;IACb,YAAY;;AAGH,EAAAA,qBAAA,oBAAoB;IAC7B,MAAM;IACN,gBAAgB;IAChB,iBAAiB;IACjB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,kBAAkB;;AAE1B,GA3BiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACM9B,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,gBAAA,WAAW;IACpB,cAAc;IACd,eAAe;IACf,aAAa;IACb,kBAAkB;IAClB,UAAU;IACV,cAAc;IACd,aAAa;IACb,YAAY;;AAGH,EAAAA,gBAAA,oBAAoB;IAC7B,MAAM;IACN,gBAAgB;IAChB,iBAAiB;IACjB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,kBAAkB;;AAE1B,GA3BiB,mBAAA,iBAAc,CAAA,EAAA;;;AC3BzB,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,WAAW;IACpB,MAAM;IACN,UAAU;IACV,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,YAAY;IACZ,YAAY;;AAEpB,GAXiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACyB3B,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,gBAAA,WAAW;IACpB,cAAc;IACd,eAAe;IACf,aAAa;IACb,kBAAkB;IAClB,UAAU;IACV,cAAc;IACd,aAAa;IACb,YAAY;;AAGH,EAAAA,gBAAA,oBAAoB;IAC7B,MAAM;IACN,gBAAgB;IAChB,iBAAiB;IACjB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,kBAAkB;;AAE1B,GA3BiB,mBAAA,iBAAc,CAAA,EAAA;;;ACRzB,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,qBAAA,WAAW;IACpB,cAAc;IACd,eAAe;IACf,aAAa;IACb,kBAAkB;IAClB,UAAU;IACV,cAAc;IACd,aAAa;IACb,YAAY;;AAGH,EAAAA,qBAAA,oBAAoB;IAC7B,MAAM;IACN,gBAAgB;IAChB,iBAAiB;IACjB,iBAAiB;IACjB,iBAAiB;IACjB,kBAAkB;IAClB,kBAAkB;;AAE1B,GA3BiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACA9B,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACM7B,IAAW;CAAjB,SAAiBC,gBAAa;AAEb,EAAAA,eAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,kBAAA,gBAAa,CAAA,EAAA;;;ACFxB,IAAW;CAAjB,SAAiBC,gBAAa;AAEb,EAAAA,eAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,kBAAA,gBAAa,CAAA,EAAA;;;ACRxB,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACb7B,IAAW;CAAjB,SAAiBC,WAAQ;AAER,EAAAA,UAAA,eAAe;IACxB,SAAS;IACT,UAAU;;AAElB,GANiB,aAAA,WAAQ,CAAA,EAAA;;;ACgCnB,IAAW;CAAjB,SAAiBC,cAAW;AAEX,EAAAA,aAAA,iBAAiB;IAC1B,QAAQ;IACR,KAAK;IACL,KAAK;IACL,MAAM;IACN,KAAK;IACL,KAAK;IACL,KAAK;;AAGI,EAAAA,aAAA,gBAAgB;IACzB,KAAK;IACL,KAAK;IACL,MAAM;IACN,KAAK;IACL,KAAK;;AAEb,GAnBiB,gBAAA,cAAW,CAAA,EAAA;;;ACbtB,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,mBAAA,iBAAc,CAAA,EAAA;;;ACFzB,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,mBAAA,iBAAc,CAAA,EAAA;;;ACJzB,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACJ9B,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACG9B,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,aAAa;IACtB,UAAU;IACV,QAAQ;IACR,SAAS;IACT,SAAS;;AAEjB,GARiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACsD7B,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,aAAa;IACtB,QAAQ;IACR,SAAS;IACT,WAAW;IACX,WAAW;IACX,aAAa;IACb,YAAY;IACZ,OAAO;IACP,QAAQ;IACR,aAAa;IACb,UAAU;IACV,SAAS;;AAEjB,GAfiB,sBAAA,oBAAiB,CAAA,EAAA;;;AC3E5B,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,UAAU;IACnB,MAAM;IACN,OAAO;IACP,KAAK;IACL,UAAU;;AAGD,EAAAA,qBAAA,aAAa;IACtB,MAAM;IACN,OAAO;IACP,KAAK;IACL,UAAU;;AAGD,EAAAA,qBAAA,WAAW;IACpB,MAAM;IACN,OAAO;IACP,KAAK;IACL,UAAU;;AAElB,GAtBiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACa9B,IAAW;CAAjB,SAAiBC,cAAW;AAEX,EAAAA,aAAA,mBAAmB;IAC5B,UAAU;IACV,UAAU;IACV,gBAAgB;;AAExB,GAPiB,gBAAA,cAAW,CAAA,EAAA;;;ACCtB,IAAW;CAAjB,SAAiBC,gCAA6B;AAE7B,EAAAA,+BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,kCAAA,gCAA6B,CAAA,EAAA;;;ACMxC,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACFnC,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACRnC,IAAW;CAAjB,SAAiBC,gCAA6B;AAE7B,EAAAA,+BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,kCAAA,gCAA6B,CAAA,EAAA;;;ACNxC,IAAW;CAAjB,SAAiBC,kBAAe;AAEf,EAAAA,iBAAA,WAAW;IACpB,SAAS;IACT,OAAO;;AAEf,GANiB,oBAAA,kBAAe,CAAA,EAAA;;;ACS1B,IAAW;CAAjB,SAAiBC,kBAAe;AAEf,EAAAA,iBAAA,aAAa;IACtB,OAAO;IACP,MAAM;;AAEd,GANiB,oBAAA,kBAAe,CAAA,EAAA;;;ACR1B,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,aAAa;IACtB,SAAS;IACT,WAAW;;AAGF,EAAAA,oBAAA,mBAAmB;IAC5B,KAAK;IACL,MAAM;IACN,KAAK;IACL,KAAK;IACL,KAAK;IACL,MAAM;IACN,YAAY;IACZ,QAAQ;;AAEhB,GAjBiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACmD7B,IAAW;CAAjB,SAAiBC,uBAAoB;AAEpB,EAAAA,sBAAA,aAAa;IACtB,SAAS;IACT,WAAW;;AAGF,EAAAA,sBAAA,aAAa;IACtB,QAAQ;IACR,SAAS;IACT,WAAW;IACX,SAAS;IACT,QAAQ;IACR,OAAO;;AAGE,EAAAA,sBAAA,mBAAmB;IAC5B,KAAK;IACL,MAAM;IACN,KAAK;IACL,KAAK;IACL,KAAK;IACL,MAAM;IACN,YAAY;IACZ,QAAQ;;AAGC,EAAAA,sBAAA,kBAAkB;IAC3B,MAAM;IACN,UAAU;IACV,WAAW;;AAEnB,GAhCiB,yBAAA,uBAAoB,CAAA,EAAA;;;AC1D/B,IAAW;CAAjB,SAAiBC,iCAA8B;AAE9B,EAAAA,gCAAA,aAAa;IACtB,IAAI;IACJ,QAAQ;;AAEhB,GANiB,mCAAA,iCAA8B,CAAA,EAAA;;;AC6BzC,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,WAAW;IACpB,KAAK;IACL,OAAO;IACP,MAAM;;AAGG,EAAAA,uBAAA,WAAW;IACpB,MAAM;IACN,WAAW;;AAEnB,GAZiB,0BAAA,wBAAqB,CAAA,EAAA;;;ACKhC,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,WAAW;IACpB,KAAK;IACL,OAAO;IACP,MAAM;;AAGG,EAAAA,kBAAA,WAAW;IACpB,MAAM;IACN,WAAW;;AAEnB,GAZiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACxB3B,IAAW;CAAjB,SAAiBC,gBAAa;AAEb,EAAAA,eAAA,WAAW;IACpB,MAAM;IACN,OAAO;IACP,QAAQ;IACR,SAAS;;AAEjB,GARiB,kBAAA,gBAAa,CAAA,EAAA;;;AC0BxB,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,WAAW;IACpB,KAAK;IACL,OAAO;IACP,MAAM;;AAGG,EAAAA,kBAAA,WAAW;IACpB,MAAM;IACN,WAAW;;AAEnB,GAZiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACX3B,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,WAAW;IACpB,KAAK;IACL,OAAO;IACP,MAAM;;AAGG,EAAAA,uBAAA,WAAW;IACpB,MAAM;IACN,WAAW;;AAEnB,GAZiB,0BAAA,wBAAqB,CAAA,EAAA;;;ACKhC,IAAW;CAAjB,SAAiBC,gCAA6B;AAE7B,EAAAA,+BAAA,YAAY;IACrB,MAAM;IACN,QAAQ;IACR,OAAO;;AAEf,GAPiB,kCAAA,gCAA6B,CAAA,EAAA;;;ACGxC,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,aAAa;IACtB,SAAS;IACT,WAAW;;AAEnB,GANiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACdnC,IAAW;CAAjB,SAAiBC,uBAAoB;AAEpB,EAAAA,sBAAA,mBAAmB;IAC5B,KAAK;IACL,MAAM;IACN,KAAK;IACL,KAAK;IACL,KAAK;IACL,MAAM;IACN,YAAY;IACZ,QAAQ;;AAEhB,GAZiB,yBAAA,uBAAoB,CAAA,EAAA;;;ACF/B,IAAW;CAAjB,SAAiBC,uBAAoB;AAEpB,EAAAA,sBAAA,WAAW;IACpB,UAAU;IACV,QAAQ;IACR,MAAM;IACN,OAAO;IACP,SAAS;;AAEjB,GATiB,yBAAA,uBAAoB,CAAA,EAAA;;;ACD/B,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACMnC,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACF9B,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACR9B,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACKnC,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,WAAW;IACpB,KAAK;IACL,KAAK;;AAEb,GANiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACEjC,IAAW;CAAjB,SAAiBC,WAAQ;AAER,EAAAA,UAAA,mBAAmB;IAC5B,MAAM;IACN,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,SAAS;;AAEjB,GATiB,aAAA,WAAQ,CAAA,EAAA;;;ACOnB,IAAW;CAAjB,SAAiBC,+BAA4B;AAE5B,EAAAA,8BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,8BAAA,mBAAmB;IAC5B,QAAQ;IACR,WAAW;;AAEnB,GAXiB,iCAAA,+BAA4B,CAAA,EAAA;;;ACOvC,IAAW;CAAjB,SAAiBC,0BAAuB;AAEvB,EAAAA,yBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,yBAAA,mBAAmB;IAC5B,QAAQ;IACR,WAAW;;AAEnB,GAXiB,4BAAA,0BAAuB,CAAA,EAAA;;;ACxBlC,IAAW;CAAjB,SAAiBC,wBAAqB;AAErB,EAAAA,uBAAA,mBAAmB;IAC5B,KAAK;IACL,MAAM;IACN,KAAK;IACL,KAAK;IACL,KAAK;IACL,MAAM;IACN,YAAY;IACZ,QAAQ;;AAEhB,GAZiB,0BAAA,wBAAqB,CAAA,EAAA;;;ACoBhC,IAAW;CAAjB,SAAiBC,0BAAuB;AAEvB,EAAAA,yBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,yBAAA,mBAAmB;IAC5B,QAAQ;IACR,WAAW;;AAEnB,GAXiB,4BAAA,0BAAuB,CAAA,EAAA;;;ACPlC,IAAW;CAAjB,SAAiBC,+BAA4B;AAE5B,EAAAA,8BAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAGA,EAAAA,8BAAA,mBAAmB;IAC5B,QAAQ;IACR,WAAW;;AAEnB,GAXiB,iCAAA,+BAA4B,CAAA,EAAA;;;ACDvC,IAAW;CAAjB,SAAiBC,uBAAoB;AAEpB,EAAAA,sBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,yBAAA,uBAAoB,CAAA,EAAA;;;ACM/B,IAAW;CAAjB,SAAiBC,kBAAe;AAEf,EAAAA,iBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,oBAAA,kBAAe,CAAA,EAAA;;;ACG1B,IAAW;CAAjB,SAAiBC,kBAAe;AAEf,EAAAA,iBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,oBAAA,kBAAe,CAAA,EAAA;;;ACV1B,IAAW;CAAjB,SAAiBC,uBAAoB;AAEpB,EAAAA,sBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,yBAAA,uBAAoB,CAAA,EAAA;;;ACF/B,IAAW;CAAjB,SAAiBC,kCAA+B;AAE/B,EAAAA,iCAAA,gBAAgB;IACzB,QAAQ;IACR,QAAQ;;AAGC,EAAAA,iCAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAZiB,oCAAA,kCAA+B,CAAA,EAAA;;;ACK1C,IAAW;CAAjB,SAAiBC,6BAA0B;AAE1B,EAAAA,4BAAA,gBAAgB;IACzB,QAAQ;IACR,QAAQ;;AAGC,EAAAA,4BAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAZiB,+BAAA,6BAA0B,CAAA,EAAA;;;ACDrC,IAAW;CAAjB,SAAiBC,6BAA0B;AAE1B,EAAAA,4BAAA,gBAAgB;IACzB,QAAQ;IACR,QAAQ;;AAGC,EAAAA,4BAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAZiB,+BAAA,6BAA0B,CAAA,EAAA;;;ACOrC,IAAW;CAAjB,SAAiBC,iCAA8B;AAE9B,EAAAA,gCAAA,gBAAgB;IACzB,QAAQ;IACR,QAAQ;;AAGC,EAAAA,gCAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GAXiB,mCAAA,iCAA8B,CAAA,EAAA;;;ACFzC,IAAW;CAAjB,SAAiBC,iCAA8B;AAE9B,EAAAA,gCAAA,gBAAgB;IACzB,QAAQ;IACR,QAAQ;;AAGC,EAAAA,gCAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GAXiB,mCAAA,iCAA8B,CAAA,EAAA;;;ACbzC,IAAW;CAAjB,SAAiBC,kCAA+B;AAE/B,EAAAA,iCAAA,gBAAgB;IACzB,QAAQ;IACR,QAAQ;;AAGC,EAAAA,iCAAA,YAAY;IACrB,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GAZiB,oCAAA,kCAA+B,CAAA,EAAA;;;ACG1C,IAAW;CAAjB,SAAiBC,8BAA2B;AAE3B,EAAAA,6BAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,SAAS;;AAEjB,GAPiB,gCAAA,8BAA2B,CAAA,EAAA;;;ACCtC,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,SAAS;;AAEjB,GAPiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACEjC,IAAW;CAAjB,SAAiBC,yBAAsB;AAEtB,EAAAA,wBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,SAAS;;AAEjB,GAPiB,2BAAA,yBAAsB,CAAA,EAAA;;;ACPjC,IAAW;CAAjB,SAAiBC,8BAA2B;AAE3B,EAAAA,6BAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,SAAS;;AAEjB,GAPiB,gCAAA,8BAA2B,CAAA,EAAA;;;ACTtC,IAAW;CAAjB,SAAiBC,mBAAgB;AAEhB,EAAAA,kBAAA,WAAW;IACpB,SAAS;IACT,OAAO;IACP,OAAO;IACP,MAAM;;AAGG,EAAAA,kBAAA,YAAY;IACrB,MAAM;IACN,YAAY;IACZ,QAAQ;;AAEhB,GAdiB,qBAAA,mBAAgB,CAAA,EAAA;;;ACD3B,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,iBAAiB;IAC1B,KAAK;IACL,MAAM;IACN,MAAM;IACN,SAAS;IACT,MAAM;IACN,aAAa;IACb,QAAQ;IACR,QAAQ;;AAGC,EAAAA,0BAAA,eAAe;IACxB,KAAK;IACL,MAAM;IACN,OAAO;IACP,KAAK;IACL,MAAM;;AAEd,GApBiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACInC,IAAW;CAAjB,SAAiBC,aAAU;AAEV,EAAAA,YAAA,WAAW;IACpB,QAAQ;IACR,OAAO;;AAEf,GANiB,eAAA,aAAU,CAAA,EAAA;;;ACkBrB,IAAW;CAAjB,SAAiBC,eAAY;AAEZ,EAAAA,cAAA,YAAY;IACrB,SAAS;IACT,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,UAAU;IACV,QAAQ;IACR,UAAU;IACV,UAAU;;AAElB,GAbiB,iBAAA,eAAY,CAAA,EAAA;;;ACdvB,IAAW;CAAjB,SAAiBC,2BAAwB;AAExB,EAAAA,0BAAA,2BAA2B;IACpC,OAAO;IACP,KAAK;;AAEb,GANiB,6BAAA,2BAAwB,CAAA,EAAA;;;ACyBnC,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACjB7B,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,eAAe;IACxB,MAAM;IACN,MAAM;;AAEd,GANiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACqB7B,IAAW;CAAjB,SAAiBC,gBAAa;AAEb,EAAAA,eAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,kBAAA,gBAAa,CAAA,EAAA;;;ACRxB,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,QAAQ;IACR,SAAS;;AAEjB,GANiB,uBAAA,qBAAkB,CAAA,EAAA;;;ACQ7B,IAAW;CAAjB,SAAiBC,eAAY;AAEZ,EAAAA,cAAA,eAAe;IACxB,UAAU;IACV,QAAQ;IACR,OAAO;;AAEf,GAPiB,iBAAA,eAAY,CAAA,EAAA;;;ACIvB,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,sBAAA,oBAAiB,CAAA,EAAA;;;ACK5B,IAAW;CAAjB,SAAiBC,qBAAkB;AAElB,EAAAA,oBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,uBAAA,qBAAkB,CAAA,EAAA;;;AChB7B,IAAW;CAAjB,SAAiBC,eAAY;AAEZ,EAAAA,cAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,iBAAA,eAAY,CAAA,EAAA;;;ACsBvB,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,wBAAA,sBAAmB,CAAA,EAAA;;;ACN9B,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,sBAAA,oBAAiB,CAAA,EAAA;;;ACF5B,IAAW;CAAjB,SAAiBC,eAAY;AAEZ,EAAAA,cAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,iBAAA,eAAY,CAAA,EAAA;;;ACXvB,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,sBAAA,oBAAiB,CAAA,EAAA;;;AC6C5B,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,wBAAA,sBAAmB,CAAA,EAAA;;;AChD9B,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,mBAAA,iBAAc,CAAA,EAAA;;;ACqDzB,IAAW;CAAjB,SAAiBC,iBAAc;AAEd,EAAAA,gBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,mBAAA,iBAAc,CAAA,EAAA;;;ACNzB,IAAW;CAAjB,SAAiBC,sBAAmB;AAEnB,EAAAA,qBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,WAAW;IACX,SAAS;;AAEjB,GARiB,wBAAA,sBAAmB,CAAA,EAAA;;;AC7C9B,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,SAAS;;AAGA,EAAAA,mBAAA,eAAe;IACxB,UAAU;IACV,QAAQ;IACR,MAAM;IACN,OAAO;;AAEf,GAdiB,sBAAA,oBAAiB,CAAA,EAAA;;;ACU5B,IAAW;CAAjB,SAAiBC,eAAY;AAEZ,EAAAA,cAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,SAAS;;AAGA,EAAAA,cAAA,eAAe;IACxB,UAAU;IACV,QAAQ;IACR,MAAM;IACN,OAAO;;AAEf,GAdiB,iBAAA,eAAY,CAAA,EAAA;;;ACFvB,IAAW;CAAjB,SAAiBC,eAAY;AAEZ,EAAAA,cAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,SAAS;;AAGA,EAAAA,cAAA,eAAe;IACxB,UAAU;IACV,QAAQ;IACR,MAAM;IACN,OAAO;;AAEf,GAdiB,iBAAA,eAAY,CAAA,EAAA;;;ACZvB,IAAW;CAAjB,SAAiBC,oBAAiB;AAEjB,EAAAA,mBAAA,YAAY;IACrB,UAAU;IACV,QAAQ;IACR,SAAS;;AAGA,EAAAA,mBAAA,eAAe;IACxB,UAAU;IACV,QAAQ;IACR,MAAM;IACN,OAAO;;AAEf,GAdiB,sBAAA,oBAAiB,CAAA,EAAA;;;AC/ClC,eAA0B;AAsBpB,IAAO,oBAAP,cAAiC,MAAK;EAC1C,YAAY,SAAe;AACzB,UAAM,OAAO;AACb,SAAK,OAAO;EACd;;AAMI,IAAO,sBAAP,MAAO,qBAAmB;EACtB,OAAgB,gBAAgB,IAAI,OAAO;;EAC3C,OAAgB,gBAAgB,IAAI,OAAO;;EAC3C,OAAgB,wBAAwB;;EACxC,OAAgB,kBAAkB;;EAGlC,OAAgB,mBAAmB,oBAAI,IAAI;IACjD;IACA;GACD;;EAGO,OAAgB,cAAc,oBAAI,IAAI;IAC5C;GACD;;;EAIO,OAAgB,kBAAkB,oBAAI,IAAI;IAChD;IACA;IACA;IACA;IACA;GACD;EAEgB,gBAAgB,OAAO,aAAa;;EAG7C,gBAA+B;;;;;EAMvC,iBAAiB,QAAqB;AACpC,SAAK,gBAAgB;EACvB;;;;EAKA,mBAAgB;AACd,WAAO,KAAK;EACd;;;;;;;;;;;EAYQ,sBAAsB,KAAW;AACvC,QAAI;AAEF,UAAI,qBAAoB,YAAY,IAAI,GAAG,GAAG;AAC5C,eAAO;MACT;AAEA,YAAM,SAAS,KAAK,cAAc,iBAAgB;AAClD,YAAM,UAAU,KAAK,WAAW,MAAM;AAGtC,UAAI,qBAAoB,gBAAgB,IAAI,GAAG,GAAG;AAChD,eAAO,GAAG,OAAO,IAAI,GAAG;MAC1B;AAGA,UAAI,qBAAoB,iBAAiB,IAAI,GAAG,GAAG;AACjD,cAAMC,UAAS,UAAU,KAAK,aAAa,IACvC,KAAK,gBACL;AACJ,eAAO,GAAG,OAAO,IAAIA,OAAM,IAAI,GAAG;MACpC;AAGA,YAAM,SAAS,UAAU,KAAK,aAAa,IACvC,KAAK,gBACL;AACJ,aAAO,GAAG,OAAO,IAAI,MAAM,IAAI,GAAG;IACpC,SAAS,OAAO;AACd,cAAQ,KACN,0DACA,KAAK;AAEP,aAAO;IACT;EACF;;;;EAKQ,WAAW,KAAW;AAC5B,QAAI,OAAO;AACX,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,YAAM,OAAO,IAAI,YAAY,CAAC;AAC9B,UAAI,SAAS,QAAW;AACtB,gBAAQ,QAAQ,KAAK,OAAO;AAC5B,eAAO,OAAO;MAChB;IACF;AACA,WAAO,KAAK,IAAI,IAAI,EAAE,SAAS,EAAE;EACnC;;;;;EAMA,oBAAoB,QAAe;AACjC,QAAI;AACF,YAAM,SAAS,KAAK,cAAc,iBAAgB;AAClD,YAAM,UAAU,KAAK,WAAW,MAAM;AACtC,YAAM,eAAe,UAAU,KAAK,iBAAiB;AACrD,YAAM,SAAS,GAAG,OAAO,IAAI,YAAY;AAGzC,YAAM,eAAyB,CAAA;AAC/B,eAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,cAAM,MAAM,aAAa,IAAI,CAAC;AAC9B,YAAI,UAAU,GAAG,KAAK,IAAI,WAAW,MAAM,GAAG;AAC5C,uBAAa,KAAK,GAAG;QACvB;MACF;AACA,iBAAW,OAAO,cAAc;AAC9B,qBAAa,WAAW,GAAG;MAC7B;IACF,SAAS,OAAO;AACd,cAAQ,MAAM,oCAAoC,KAAK;IACzD;EACF;;;;;EAMA,qBAAkB;AAChB,QAAI;AACF,YAAM,SAAS,KAAK,cAAc,iBAAgB;AAClD,YAAM,UAAU,KAAK,WAAW,MAAM;AAGtC,iBAAW,OAAO,qBAAoB,iBAAiB;AACrD,cAAM,aAAa,GAAG,OAAO,IAAI,GAAG;AACpC,qBAAa,WAAW,UAAU;MACpC;IACF,SAAS,OAAO;AACd,cAAQ,MAAM,mCAAmC,KAAK;IACxD;EACF;;;;;EAMA,mBAAmB,eAAqB;AACtC,UAAM,aAAa,aAAa,QAC9B,wCAAwC;AAE1C,WAAO,UAAU,UAAU,KAAK,eAAe;EACjD;;;;EAKA,2BAA2B,QAAc;AACvC,iBAAa,QAAQ,0CAA0C,MAAM;EACvE;;;;;EAMA,yBAAyB,QAAc;AACrC,QAAI;AACF,YAAM,SAAS,KAAK,cAAc,iBAAgB;AAClD,YAAM,UAAU,KAAK,WAAW,MAAM;AACtC,YAAM,gBAAgB,GAAG,OAAO;AAChC,YAAM,aAAa,GAAG,OAAO,IAAI,MAAM;AAEvC,YAAM,gBAAgD,CAAA;AAGtD,eAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,cAAM,MAAM,aAAa,IAAI,CAAC;AAC9B,YAAI,UAAU,GAAG,KAAK,IAAI,WAAW,aAAa,GAAG;AACnD,gBAAM,WAAW,IAAI,UAAU,cAAc,MAAM;AACnD,wBAAc,KAAK;YACjB,KAAK;YACL,KAAK,GAAG,UAAU,GAAG,QAAQ;WAC9B;QACH;MACF;AAGA,iBAAW,EAAE,KAAK,QAAQ,KAAK,OAAM,KAAM,eAAe;AACxD,cAAM,QAAQ,aAAa,QAAQ,MAAM;AACzC,YAAI,UAAU,KAAK,GAAG;AACpB,uBAAa,QAAQ,QAAQ,KAAK;AAClC,uBAAa,WAAW,MAAM;QAChC;MACF;IACF,SAAS,OAAO;AACd,cAAQ,MAAM,yCAAyC,KAAK;IAC9D;EACF;;;;;;;;;EAUA,mBAAmB,KAAa,iBAAiB,MAAI;AACnD,QAAI;AAEF,YAAM,eAAe,KAAK,QAAQ,KAAK,KAAK;AAE5C,UAAI,iBAAiB,MAAM;AACzB,eAAO;MACT;AAGA,WAAK,QAAQ,KAAK,cAAc,QAAW,IAAI;AAG/C,UAAI,gBAAgB;AAClB,aAAK,WAAW,KAAK,KAAK;MAC5B;AAEA,aAAO;IACT,SAAS,OAAO;AACd,cAAQ,MAAM,sCAAsC,GAAG,KAAK,KAAK;AACjE,aAAO;IACT;EACF;;;;;;;;EASA,2BACE,MACA,kBAAkB,MAAI;AAEtB,UAAM,UAAmC,CAAA;AAEzC,eAAW,OAAO,MAAM;AACtB,cAAQ,GAAG,IAAI,KAAK,mBAAmB,KAAK,eAAe;IAC7D;AAEA,WAAO;EACT;EAEA,QAAW,KAAa,eAAe,MAAI;AACzC,QAAI;AACF,YAAM,aAAa,eAAe,KAAK,sBAAsB,GAAG,IAAI;AACpE,YAAM,QAAQ,aAAa,QAAQ,UAAU;AAC7C,UAAI,kBAAkB,KAAK;AAAG,eAAO;AAGrC,UAAI;AACJ,UAAI;AACF,sBAAc,KAAK,MAAM,KAAK;AAG9B,YAAI,CAAC,SAAS,WAAW,KAAK,CAAC,YAAY,aAAa,UAAU,GAAG;AAEnE,iBAAO,KAAK,MAAM,KAAK;QACzB;MACF,QAAQ;AAEN,eAAO;MACT;AAGA,UACE,YAAY,SAAS,YAAY,qBAAoB,iBACrD;AACA,gBAAQ,KAAK,6BAA6B,GAAG,EAAE;AAC/C,aAAK,WAAW,GAAG;AACnB,eAAO;MACT;AAGA,UACE,YAAY,YAAY,UAAU,SAAS,KAC3C,SAAS,YAAY,SAAS,OAAO,KACrC,KAAK,IAAG,IAAK,YAAY,SAAS,SAClC;AACA,aAAK,WAAW,GAAG;AACnB,eAAO;MACT;AAEA,UAAI,OAAO,YAAY;AAGvB,UACE,YAAY,YAAY,UAAU,YAAY,KAC9C,YAAY,SAAS,eAAe,MACpC;AACA,YAAI,SAAS,IAAI,GAAG;AAClB,iBAAgB,oBAAW,IAAI;QACjC;MACF;AAGA,aAAO,SAAS,IAAI,IAAK,KAAK,MAAM,IAAI,IAAW;IACrD,SAAS,OAAO;AACd,cAAQ,KAAK,qCAAqC,GAAG,IAAI,KAAK;AAC9D,aAAO;IACT;EACF;EAEA,QACE,KACA,OACA,YACA,eAAe,MAAI;AAEnB,QAAI,CAAC,SAAS,GAAG,KAAK,CAAC,KAAK,YAAY,GAAG,GAAG;AAC5C,YAAM,IAAI,MAAM,sBAAsB;IACxC;AAEA,UAAM,WAA4B;MAChC,SAAS,qBAAoB;MAC7B,WAAW,KAAK,IAAG;MACnB,SACE,UAAU,UAAU,KAAK,SAAS,UAAU,IACxC,KAAK,IAAG,IAAK,aAAa,KAAK,MAC/B;;AAGR,QAAI,cAAc,KAAK,UAAU,KAAK;AAGtC,QAAI,YAAY,SAAS,qBAAoB,uBAAuB;AAClE,oBAAuB,kBAAS,WAAW;AAC3C,eAAS,aAAa;IACxB;AAEA,UAAM,cAAmC;MACvC,MAAM;MACN;;AAGF,UAAM,aAAa,KAAK,UAAU,WAAW;AAC7C,UAAM,WAAW,IAAI,KAAK,CAAC,UAAU,CAAC,EAAE;AAExC,QAAI,WAAW,qBAAoB,eAAe;AAChD,YAAM,IAAI,kBACR,cAAc,QAAQ,sCAAsC;IAEhE;AAEA,QAAI,CAAC,KAAK,kBAAkB,QAAQ,GAAG;AACrC,YAAM,IAAI,kBAAkB,wBAAwB;IACtD;AAEA,QAAI;AACF,YAAM,aAAa,eAAe,KAAK,sBAAsB,GAAG,IAAI;AACpE,mBAAa,QAAQ,YAAY,UAAU;IAC7C,SAAS,OAAO;AACd,UAAI,KAAK,qBAAqB,KAAK,GAAG;AACpC,cAAM,IAAI,kBAAkB,wBAAwB;MACtD;AACA,YAAM;IACR;EACF;EAEA,WAAW,KAAa,eAAe,MAAI;AACzC,QAAI;AACF,YAAM,aAAa,eAAe,KAAK,sBAAsB,GAAG,IAAI;AACpE,mBAAa,WAAW,UAAU;IACpC,SAAS,OAAO;AACd,cAAQ,MAAM,qCAAqC,KAAK;IAC1D;EACF;EAEA,QAAK;AACH,QAAI;AACF,mBAAa,MAAK;IACpB,SAAS,OAAO;AACd,cAAQ,MAAM,gCAAgC,KAAK;IACrD;EACF;EAEA,kBAAe;AACb,QAAI,YAAY;AAChB,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,YAAM,MAAM,aAAa,IAAI,CAAC;AAC9B,UAAI,UAAU,GAAG,KAAK,SAAS,GAAG,GAAG;AACnC,cAAM,OAAO,aAAa,QAAQ,GAAG;AACrC,YAAI,UAAU,IAAI,GAAG;AACnB,uBAAa,IAAI,KAAK,CAAC,IAAI,CAAC,EAAE;QAChC;MACF;IACF;AACA,WAAO;EACT;EAEQ,YAAY,KAAW;AAC7B,WAAO,SAAS,GAAG,KAAK,IAAI,SAAS;EACvC;EAEQ,kBAAkB,iBAAuB;AAC/C,QAAI,CAAC,SAAS,eAAe;AAAG,aAAO;AAEvC,QAAI,YAAY;AAChB,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,YAAM,MAAM,aAAa,IAAI,CAAC;AAC9B,UAAI,UAAU,GAAG,GAAG;AAClB,cAAM,OAAO,aAAa,QAAQ,GAAG;AACrC,YAAI,UAAU,IAAI,GAAG;AACnB,uBAAa,IAAI,KAAK,CAAC,IAAI,CAAC,EAAE;QAChC;MACF;IACF;AACA,WAAO,YAAY,mBAAmB,qBAAoB;EAC5D;EAEQ,qBAAqB,OAAc;AACzC,WACE,SAAS,KAAK,KACd,YAAY,OAAO,MAAM,KACzB,SAAS,MAAM,MAAM,CAAC,MACrB,MAAM,MAAM,MAAM,wBACjB,MAAM,MAAM,MAAM;EAExB;;qCAtbW,sBAAmB;EAAA;4EAAnB,sBAAmB,SAAnB,qBAAmB,WAAA,YAFlB,OAAM,CAAA;;;sEAEP,qBAAmB,CAAA;UAH/B;WAAW;MACV,YAAY;KACb;;;;;ACnBK,IAAO,qBAAP,MAAO,oBAAkB;EACZ,sBAAsB,OAAO,mBAAmB;EAChD,SAAS,OAAO,MAAM;EAC9B,eAAe,OAA2B,CAAA,GAAE,GAAA,YAAA,CAAA,EAAA,WAAA,eAAA,CAAA,IAAA,CAAA,CAAA;EAC5C,qBAAqB,OAAgC,MAAI,GAAA,YAAA,CAAA,EAAA,WAAA,qBAAA,CAAA,IAAA,CAAA,CAAA;EAElE,cAAA;AACE,SAAK,wBAAuB;AAE5B,WAAO,MAAK;AACV,YAAM,UAAU,KAAK,mBAAkB;AACvC,UAAI,SAAS;AAEX,aAAK,oBAAoB,QACvB,sCACA,QAAQ,IACR,QACA,IAAI;MAER;IACF,CAAC;EACH;EAEA,gBAAgB,UAA4B;AAC1C,SAAK,aAAa,IAAI,QAAQ;AAE9B,SAAK,oBAAoB,QACvB,gCACA,KAAK,UAAU,QAAQ,GACvB,QACA,IAAI;AAGN,UAAM,iBAAiB,KAAK,oBAAoB,QAC9C,sCACA,IAAI;AAEN,UAAM,kBACJ,SAAS,KAAK,CAAC,MAAM,EAAE,OAAO,cAAc,KAAK,SAAS,CAAC;AAE7D,QAAI,SAAS,SAAS,KAAK,kBAAkB,cAAc,GAAG;AAC5D,aAAO,KAAK,OAAO,SAAS,CAAC,SAAS,eAAe,CAAC;IACxD,WAAW,UAAU,eAAe,GAAG;AACrC,WAAK,sBAAsB,gBAAgB,EAAE;AAC7C,aAAO,KAAK,OAAO,SAAS,CAAC,WAAW,CAAC;IAC3C,OAAO;AACL,aAAO,KAAK,OAAO,SAAS,CAAC,SAAS,OAAO,CAAC;IAChD;EACF;EAEA,sBAAsB,WAAiB;AACrC,UAAM,UAAU,KAAK,aAAY,EAAG,KAAK,CAAC,MAAM,EAAE,OAAO,SAAS;AAClE,QAAI,UAAU,OAAO,GAAG;AACtB,WAAK,mBAAmB,IAAI,OAAO;IACrC;EACF;EAEQ,0BAAuB;AAC7B,UAAM,cAAc,KAAK,oBAAoB,QAC3C,gCACA,IAAI;AAEN,QAAI,UAAU,WAAW,GAAG;AAC1B,YAAM,WAAW,KAAK,MAAM,WAAW;AACvC,WAAK,aAAa,IAAI,QAAQ;AAE9B,YAAM,aAAa,KAAK,oBAAoB,QAC1C,sCACA,IAAI;AAEN,UAAI,UAAU,UAAU,GAAG;AACzB,aAAK,sBAAsB,UAAU;MACvC;IACF;EACF;;;;;EAMA,4BAAyB;AACvB,SAAK,wBAAuB;EAC9B;EAEA,mBAAgB;AACd,SAAK,aAAa,IAAI,CAAA,CAAE;AACxB,SAAK,mBAAmB,IAAI,IAAI;AAChC,SAAK,oBAAoB,WAAW,gCAAgC,IAAI;AACxE,SAAK,oBAAoB,WACvB,sCACA,IAAI;EAER;;qCA5FW,qBAAkB;EAAA;4EAAlB,qBAAkB,SAAlB,oBAAkB,WAAA,YAFjB,OAAM,CAAA;;;sEAEP,oBAAkB,CAAA;UAH9B;WAAW;MACV,YAAY;KACb;;;","names":["LZString","ErrorReasons","AuthService","AlertAction","AlertCreateRequest","AlertListItem","AlertNotify","AlertResponse","AlertUpdateRequest","AnalyticsBaseReportResponse","AnalyticsDataSourceOptions","AnalyticsDimension","AnalyticsOutputFilter","AnalyticsOutputRequest","AnalyticsOutputSettings","AnalyticsSettingsRequest","AnalyticsSortOptions","AssetCreateRequest","AssetListItem","AssetRatingProfileCreateRequest","AssetRatingProfileListItem","AssetRatingProfileResponse","AssetRatingProfileUpdateRequest","AssetResponse","AssetStateProfileCreateRequest","AssetStateProfileListItem","AssetStateProfileResponse","AssetStateProfileUpdateRequest","AssetTagCreateRequest","AssetTagListItem","AssetTagResponse","AssetTagUpdateRequest","AssetUpdateRequest","AssetZoneTarget","AuditEventChange","AuditEventResponse","AuthEndpoint","AuthInfo","CalculatedMeasure","CellProperties","CellSet","CellValue","ChartSeriesItem","ChartXAxisLabels","ClientCreateRequest","ClientListItem","ClientMeasurementUnits","ClientResponse","ClientUpdateRequest","CompanyDataRetentionSettings","CompanyResponse","CompletedReportResponse","Contact","DashboardCreateRequest","DashboardListItem","DashboardResponse","DashboardTemplateListItem","DashboardTemplateResponse","DashboardTemplateUpdateRequest","DashboardUpdateRequest","DashboardWidget","DashboardWidgetDataSource","DeviceBitmapConfiguration","DeviceConfigProfileCreateRequest","DeviceConfigProfileListItem","DeviceConfigProfileResponse","DeviceConfigProfileUpdateRequest","DeviceCreateRequest","DeviceListItem","DeviceProviderCreateRequest","DeviceProviderListItem","DeviceProviderResponse","DeviceProviderTypeListItem","DeviceProviderTypeResponse","DeviceProviderUpdateRequest","DeviceResponse","DeviceTypeCreateRequest","DeviceTypeListItem","DeviceTypeResponse","DeviceTypeUpdateRequest","DeviceUpdateRequest","DistributorCreateRequest","DistributorListItem","DistributorResponse","DistributorUpdateRequest","EmailProviderCreateRequest","EmailProviderListItem","EmailProviderResponse","EmailProviderTypeListItem","EmailProviderTypeResponse","EmailProviderUpdateRequest","EmailServerConfiguration","EventActorFilter","EventMedia","EventTargetFilter","ExportTaskCreateRequest","ExportTaskListItem","ExportTaskResponse","ExportTaskUpdateRequest","ForwardGeocodeResult","FuelCardCreateRequest","FuelCardListItem","FuelCardResponse","FuelCardUpdateRequest","GeoLockProfileCreateRequest","GeoLockProfileListItem","GeoLockProfileResponse","GeoLockProfileUpdateRequest","IdNameState","IoTypeCreateRequest","IoTypeListItem","IoTypeRateConfig","IoTypeResponse","IoTypeUpdateRequest","LabelCreateRequest","LabelListItem","LabelResponse","LabelUpdateRequest","MapRoute","MapSetLayer","MapSetListItem","MapSetResponse","MapsetCreateRequest","MapsetUpdateRequest","MeasureDescription","MediaInfoResponse","NotificationActions","OTPSettings","OverspeedProfileCreateRequest","OverspeedProfileListItem","OverspeedProfileResponse","OverspeedProfileUpdateRequest","PieChartOptions","PolicyStatement","QueueReportRequest","QueuedReportResponse","RebuildDashboardWidgetResponse","ReminderCreateRequest","ReminderListItem","ReminderReset","ReminderResponse","ReminderUpdateRequest","ReportDefinitionColumnOptions","ReportDefinitionResponse","ReportTemplateConfig","ReverseGeocodeResult","RoadProfileCreateRequest","RoadProfileListItem","RoadProfileResponse","RoadProfileUpdateRequest","RoadSpeedModifierEntry","Schedule","ScheduledReportCreateRequest","ScheduledReportListItem","ScheduledReportReport","ScheduledReportResponse","ScheduledReportUpdateRequest","SimCardCreateRequest","SimCardListItem","SimCardResponse","SimCardUpdateRequest","SmsGatewayProviderCreateRequest","SmsGatewayProviderListItem","SmsGatewayProviderResponse","SmsGatewayProviderTypeListItem","SmsGatewayProviderTypeResponse","SmsGatewayProviderUpdateRequest","SslCertificateCreateRequest","SslCertificateListItem","SslCertificateResponse","SslCertificateUpdateRequest","StatChartOptions","StatsEntityOutputOptions","TargetLine","TaskResponse","TestNotificationsRequest","ThemeCreateRequest","ThemeCustomHTMLTag","ThemeResponse","ThemeUpdateRequest","TripResponse","UserCreateRequest","UserCreateResponse","UserListItem","UserProfileResponse","UserResetResponse","UserResponse","UserUpdateRequest","VendorCreateRequest","VendorListItem","VendorResponse","VendorUpdateRequest","ZoneCreateRequest","ZoneListItem","ZoneResponse","ZoneUpdateRequest","userId"],"x_google_ignoreList":[0]}
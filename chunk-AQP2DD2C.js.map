{
  "version": 3,
  "sources": ["src/app/features/administration/services/broadcast-event-messages.service.ts"],
  "sourcesContent": ["import { Injectable, Type } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport { BaseEntity } from '../../../shared/models';\nimport { SystemHealthData } from '../models';\n\nexport interface GridItemSelectedMessage {\n  item: BaseEntity;\n  componentType: Type<unknown>;\n}\n\nexport interface TreeItemSelectedMessage {\n  item: BaseEntity;\n  componentType: Type<unknown>;\n}\n\nexport interface DetailsPanelClosedMessage {\n  reason?: string;\n}\n\nexport interface GridFilterAndSelectMessage {\n  entityType: string;\n  entityId: string;\n  entityName: string;\n  filterField?: string; // defaults to 'name'\n}\n\nexport interface BroadcastMessageType {\n  'grid-item-selected': GridItemSelectedMessage;\n  'tree-item-selected': TreeItemSelectedMessage;\n  'details-panel-closed': DetailsPanelClosedMessage;\n  'view-entity-in-tree': {\n    entity: BaseEntity;\n  };\n  'entity-updated': {\n    entityType: string;\n    operation?: 'create' | 'update' | 'delete';\n    clientId?: string;\n    [key: string]: unknown;\n  };\n  'grid-filter-and-select': GridFilterAndSelectMessage;\n  'system-health-update': {\n    data: SystemHealthData;\n    timestamp: string;\n  };\n  'websocket-status-change': {\n    connected: boolean;\n    reason?: string;\n  };\n  'health-service-alert': {\n    serviceName: string;\n    severity: 'warning' | 'error' | 'critical';\n    message: string;\n  };\n  'dashboard-refresh-requested': {\n    source: string;\n  };\n  'real-time-metrics-update': {\n    service: string;\n    metrics: Record<string, number>;\n  };\n  // Add other message types as needed\n  [key: string]: unknown;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class BroadcastEventMessageService {\n  private readonly messageSubject = new Subject<{\n    type: keyof BroadcastMessageType;\n    data: unknown;\n  }>();\n\n  /**\n   * Broadcast a message to all subscribers\n   * @param type The message type identifier\n   * @param data The data payload\n   */\n  broadcast<K extends keyof BroadcastMessageType>(\n    type: K,\n    data: BroadcastMessageType[K],\n  ): void {\n    this.messageSubject.next({ type, data });\n  }\n\n  /**\n   * Listen for messages of a specific type\n   * @param type The message type to listen for\n   * @returns An observable that emits when messages of the specified type are broadcast\n   */\n  on<K extends keyof BroadcastMessageType>(\n    type: K,\n  ): Observable<BroadcastMessageType[K]> {\n    return this.messageSubject.pipe(\n      filter((message) => message.type === type),\n      map((message) => message.data),\n    );\n  }\n}\n"],
  "mappings": ";;;;;;;;;;AAoEM,IAAO,+BAAP,MAAO,8BAA4B;EACtB,iBAAiB,IAAI,QAAO;;;;;;EAU7C,UACE,MACA,MAA6B;AAE7B,SAAK,eAAe,KAAK,EAAE,MAAM,KAAI,CAAE;EACzC;;;;;;EAOA,GACE,MAAO;AAEP,WAAO,KAAK,eAAe,KACzB,OAAO,CAAC,YAAY,QAAQ,SAAS,IAAI,GACzC,IAAI,CAAC,YAAY,QAAQ,IAAI,CAAC;EAElC;;qCA9BW,+BAA4B;EAAA;4EAA5B,+BAA4B,SAA5B,8BAA4B,WAAA,YAF3B,OAAM,CAAA;;;sEAEP,8BAA4B,CAAA;UAHxC;WAAW;MACV,YAAY;KACb;;;",
  "names": []
}

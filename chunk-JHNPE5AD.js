import {
  Dialog,
  DialogModule,
  DialogStyle
} from "./chunk-BUQLELQY.js";
import {
  UtilityService
} from "./chunk-IDQPRALM.js";
import {
  AutoComplete,
  AutoCompleteModule,
  Message,
  MessageModule,
  Popover,
  PopoverModule,
  ProgressBar
} from "./chunk-T5WYQJMH.js";
import {
  Textarea,
  TextareaModule
} from "./chunk-W5XLQNKH.js";
import {
  Tab,
  TabList,
  TabPanel,
  TabPanels,
  Tabs,
  TabsModule
} from "./chunk-B2VOHKSQ.js";
import {
  AngleRightIcon,
  InputNumber,
  InputNumberModule,
  PlusIcon,
  RadioButton,
  RadioButtonModule,
  ToggleButton,
  ToggleButtonModule
} from "./chunk-RAMUTPV2.js";
import {
  Chip,
  ChipModule,
  DatePicker,
  DatePickerModule,
  MultiSelect,
  MultiSelectModule
} from "./chunk-3ELTUYPI.js";
import {
  Checkbox,
  CheckboxModule
} from "./chunk-IM6TEFQQ.js";
import {
  ChevronRightIcon
} from "./chunk-PAFIW2EK.js";
import {
  BaseEditableHolder,
  BaseInput,
  BlankIcon,
  CheckIcon,
  ChevronDownIcon,
  DefaultValueAccessor,
  FormBuilder,
  FormControl,
  FormControlDirective,
  FormGroup,
  FormGroupDirective,
  FormGroupName,
  FormsModule,
  IconField,
  InputIcon,
  InputText,
  InputTextModule,
  MotionDirective,
  MotionModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControlStatus,
  NgControlStatusGroup,
  NgModel,
  Overlay,
  OverlayModule,
  ReactiveFormsModule,
  Scroller,
  SearchIcon,
  Select,
  SelectModule,
  TimesIcon,
  ɵNgNoValidate
} from "./chunk-4CAIP3KE.js";
import {
  ProgressSpinner,
  ProgressSpinnerModule
} from "./chunk-BJMVTXFZ.js";
import {
  Tooltip,
  TooltipModule,
  zindexutils
} from "./chunk-2UAXSVOA.js";
import {
  AutoFocus,
  AutoFocusModule,
  Badge,
  Button,
  ButtonDirective,
  ButtonModule,
  ConnectedOverlayScrollHandler,
  DomHandler,
  Fluid,
  SpinnerIcon
} from "./chunk-PBS4GE25.js";
import {
  $,
  $t,
  BaseComponent,
  BaseIcon,
  BaseStyle,
  Bind,
  BindModule,
  C,
  D,
  FilterService,
  Footer,
  Header,
  I,
  J2 as J,
  Lt,
  M,
  MessageService,
  Nt,
  OverlayService,
  P,
  PARENT_INSTANCE,
  PrimeTemplate,
  R,
  Ripple,
  S,
  SharedModule,
  TranslationKeys,
  TreeDragDropService,
  Tt,
  V,
  W,
  X,
  Y,
  Yt,
  b,
  bt,
  c,
  k,
  k2,
  l,
  m,
  p,
  rr,
  s,
  s2,
  tt,
  ut,
  v,
  vt,
  xt,
  z,
  zt
} from "./chunk-YL4UBWIM.js";
import {
  ApiUrlService,
  AuthDataService,
  ClientDataService,
  CommonModule,
  DEFAULT_SYSTEM_ID,
  DomSanitizer,
  EntitiesService,
  HttpClient,
  HttpEventType,
  LocalStorageService,
  NgClass,
  NgComponentOutlet,
  NgForOf,
  NgIf,
  NgStyle,
  NgTemplateOutlet,
  RequestCacheService,
  Router,
  RouterLink,
  RouterLinkActive,
  RouterModule,
  environment,
  hasProperty,
  isArray,
  isDefined,
  isEmpty,
  isFunction,
  isNullOrUndefined,
  isNumber,
  isObject,
  isPlatformBrowser,
  isPlatformServer,
  isSelectOption,
  isString,
  require_lodash,
  takeUntilDestroyed
} from "./chunk-UNWLID6Q.js";
import {
  APP_ID,
  ApplicationRef,
  BehaviorSubject,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ConnectableObservable,
  ContentChild,
  ContentChildren,
  DOCUMENT,
  DestroyRef,
  Directive,
  ElementRef,
  EnvironmentInjector,
  EventEmitter,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  NgModule,
  NgZone,
  Observable,
  Optional,
  Output,
  PLATFORM_ID,
  Pipe,
  Renderer2,
  RendererFactory2,
  SecurityContext,
  Subject,
  Subscription,
  TemplateRef,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation,
  afterNextRender,
  animationFrameScheduler,
  asapScheduler,
  auditTime,
  booleanAttribute,
  computed,
  createComponent,
  debounceTime,
  distinctUntilChanged,
  effect,
  filter,
  firstValueFrom,
  forwardRef,
  inject,
  input,
  interval,
  isObservable,
  map,
  merge,
  model,
  numberAttribute,
  of,
  output,
  pairwise,
  setClassMetadata,
  shareReplay,
  signal,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap,
  untracked,
  ɵsetClassDebugInfo,
  ɵɵHostDirectivesFeature,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵanimateEnter,
  ɵɵanimateLeave,
  ɵɵariaProperty,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵcomponentInstance,
  ɵɵconditional,
  ɵɵconditionalCreate,
  ɵɵcontentQuery,
  ɵɵcontrol,
  ɵɵcontrolCreate,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵdomElement,
  ɵɵdomElementEnd,
  ɵɵdomElementStart,
  ɵɵdomProperty,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵinterpolate1,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction8,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵresolveDocument,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-4KHPVNTA.js";
import {
  __commonJS,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-7WUTQBRG.js";

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    "use strict";
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    "use strict";
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    "use strict";
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    "use strict";
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    "use strict";
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    "use strict";
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    "use strict";
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    "use strict";
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    "use strict";
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    "use strict";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    "use strict";
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    "use strict";
    var root = require_root();
    var Symbol = root.Symbol;
    module.exports = Symbol;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    "use strict";
    var Symbol = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    "use strict";
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    "use strict";
    var Symbol = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    "use strict";
    function isObject2(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject2;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObject2 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction2;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    "use strict";
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    "use strict";
    var coreJsData = require_coreJsData();
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    "use strict";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    "use strict";
    var isFunction2 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject2 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    "use strict";
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    "use strict";
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    "use strict";
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    "use strict";
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    "use strict";
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    "use strict";
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    "use strict";
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    "use strict";
    var isKeyable = require_isKeyable();
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    "use strict";
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    "use strict";
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    "use strict";
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    "use strict";
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    "use strict";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    "use strict";
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    "use strict";
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module) {
    "use strict";
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    "use strict";
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module) {
    "use strict";
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module.exports = equalArrays;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    "use strict";
    var root = require_root();
    var Uint8Array = root.Uint8Array;
    module.exports = Uint8Array;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module) {
    "use strict";
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    "use strict";
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module) {
    "use strict";
    var Symbol = require_Symbol();
    var Uint8Array = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module.exports = equalByTag;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    "use strict";
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module.exports = arrayPush;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    "use strict";
    var isArray2 = Array.isArray;
    module.exports = isArray2;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    "use strict";
    var arrayPush = require_arrayPush();
    var isArray2 = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    "use strict";
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    "use strict";
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    "use strict";
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    "use strict";
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    "use strict";
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    "use strict";
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
      return arguments;
    })()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    "use strict";
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    "use strict";
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    "use strict";
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    "use strict";
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    "use strict";
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    })();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    "use strict";
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    "use strict";
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray2 = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    "use strict";
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    "use strict";
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    "use strict";
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    "use strict";
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    "use strict";
    var isFunction2 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    "use strict";
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    "use strict";
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module) {
    "use strict";
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module.exports = equalObjects;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module.exports = DataView;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    "use strict";
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    "use strict";
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    "use strict";
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray2 = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module) {
    "use strict";
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// node_modules/lodash/isEqualWith.js
var require_isEqualWith = __commonJS({
  "node_modules/lodash/isEqualWith.js"(exports, module) {
    "use strict";
    var baseIsEqual = require_baseIsEqual();
    function isEqualWith2(value, other, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      var result = customizer ? customizer(value, other) : void 0;
      return result === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result;
    }
    module.exports = isEqualWith2;
  }
});

// node_modules/primeng/fesm2022/primeng-icons-eye.mjs
var _c0 = ["data-p-icon", "eye"];
var EyeIcon = class _EyeIcon extends BaseIcon {
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275EyeIcon_BaseFactory;
    return function EyeIcon_Factory(__ngFactoryType__) {
      return (\u0275EyeIcon_BaseFactory || (\u0275EyeIcon_BaseFactory = \u0275\u0275getInheritedFactory(_EyeIcon)))(__ngFactoryType__ || _EyeIcon);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _EyeIcon,
    selectors: [["", "data-p-icon", "eye"]],
    features: [\u0275\u0275InheritDefinitionFeature],
    attrs: _c0,
    decls: 1,
    vars: 0,
    consts: [["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M0.0535499 7.25213C0.208567 7.59162 2.40413 12.4 7 12.4C11.5959 12.4 13.7914 7.59162 13.9465 7.25213C13.9487 7.2471 13.9506 7.24304 13.952 7.24001C13.9837 7.16396 14 7.08239 14 7.00001C14 6.91762 13.9837 6.83605 13.952 6.76001C13.9506 6.75697 13.9487 6.75292 13.9465 6.74788C13.7914 6.4084 11.5959 1.60001 7 1.60001C2.40413 1.60001 0.208567 6.40839 0.0535499 6.74788C0.0512519 6.75292 0.0494023 6.75697 0.048 6.76001C0.0163137 6.83605 0 6.91762 0 7.00001C0 7.08239 0.0163137 7.16396 0.048 7.24001C0.0494023 7.24304 0.0512519 7.2471 0.0535499 7.25213ZM7 11.2C3.664 11.2 1.736 7.92001 1.264 7.00001C1.736 6.08001 3.664 2.80001 7 2.80001C10.336 2.80001 12.264 6.08001 12.736 7.00001C12.264 7.92001 10.336 11.2 7 11.2ZM5.55551 9.16182C5.98308 9.44751 6.48576 9.6 7 9.6C7.68891 9.59789 8.349 9.32328 8.83614 8.83614C9.32328 8.349 9.59789 7.68891 9.59999 7C9.59999 6.48576 9.44751 5.98308 9.16182 5.55551C8.87612 5.12794 8.47006 4.7947 7.99497 4.59791C7.51988 4.40112 6.99711 4.34963 6.49276 4.44995C5.98841 4.55027 5.52513 4.7979 5.16152 5.16152C4.7979 5.52513 4.55027 5.98841 4.44995 6.49276C4.34963 6.99711 4.40112 7.51988 4.59791 7.99497C4.7947 8.47006 5.12794 8.87612 5.55551 9.16182ZM6.2222 5.83594C6.45243 5.6821 6.7231 5.6 7 5.6C7.37065 5.6021 7.72553 5.75027 7.98762 6.01237C8.24972 6.27446 8.39789 6.62934 8.4 7C8.4 7.27689 8.31789 7.54756 8.16405 7.77779C8.01022 8.00802 7.79157 8.18746 7.53575 8.29343C7.27994 8.39939 6.99844 8.42711 6.72687 8.37309C6.4553 8.31908 6.20584 8.18574 6.01005 7.98994C5.81425 7.79415 5.68091 7.54469 5.6269 7.27312C5.57288 7.00155 5.6006 6.72006 5.70656 6.46424C5.81253 6.20842 5.99197 5.98977 6.2222 5.83594Z", "fill", "currentColor"]],
    template: function EyeIcon_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275namespaceSVG();
        \u0275\u0275domElement(0, "path", 0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EyeIcon, [{
    type: Component,
    args: [{
      selector: '[data-p-icon="eye"]',
      standalone: true,
      template: `
        <svg:path
            fill-rule="evenodd"
            clip-rule="evenodd"
            d="M0.0535499 7.25213C0.208567 7.59162 2.40413 12.4 7 12.4C11.5959 12.4 13.7914 7.59162 13.9465 7.25213C13.9487 7.2471 13.9506 7.24304 13.952 7.24001C13.9837 7.16396 14 7.08239 14 7.00001C14 6.91762 13.9837 6.83605 13.952 6.76001C13.9506 6.75697 13.9487 6.75292 13.9465 6.74788C13.7914 6.4084 11.5959 1.60001 7 1.60001C2.40413 1.60001 0.208567 6.40839 0.0535499 6.74788C0.0512519 6.75292 0.0494023 6.75697 0.048 6.76001C0.0163137 6.83605 0 6.91762 0 7.00001C0 7.08239 0.0163137 7.16396 0.048 7.24001C0.0494023 7.24304 0.0512519 7.2471 0.0535499 7.25213ZM7 11.2C3.664 11.2 1.736 7.92001 1.264 7.00001C1.736 6.08001 3.664 2.80001 7 2.80001C10.336 2.80001 12.264 6.08001 12.736 7.00001C12.264 7.92001 10.336 11.2 7 11.2ZM5.55551 9.16182C5.98308 9.44751 6.48576 9.6 7 9.6C7.68891 9.59789 8.349 9.32328 8.83614 8.83614C9.32328 8.349 9.59789 7.68891 9.59999 7C9.59999 6.48576 9.44751 5.98308 9.16182 5.55551C8.87612 5.12794 8.47006 4.7947 7.99497 4.59791C7.51988 4.40112 6.99711 4.34963 6.49276 4.44995C5.98841 4.55027 5.52513 4.7979 5.16152 5.16152C4.7979 5.52513 4.55027 5.98841 4.44995 6.49276C4.34963 6.99711 4.40112 7.51988 4.59791 7.99497C4.7947 8.47006 5.12794 8.87612 5.55551 9.16182ZM6.2222 5.83594C6.45243 5.6821 6.7231 5.6 7 5.6C7.37065 5.6021 7.72553 5.75027 7.98762 6.01237C8.24972 6.27446 8.39789 6.62934 8.4 7C8.4 7.27689 8.31789 7.54756 8.16405 7.77779C8.01022 8.00802 7.79157 8.18746 7.53575 8.29343C7.27994 8.39939 6.99844 8.42711 6.72687 8.37309C6.4553 8.31908 6.20584 8.18574 6.01005 7.98994C5.81425 7.79415 5.68091 7.54469 5.6269 7.27312C5.57288 7.00155 5.6006 6.72006 5.70656 6.46424C5.81253 6.20842 5.99197 5.98977 6.2222 5.83594Z"
            fill="currentColor"
        />
    `
    }]
  }], null, null);
})();

// node_modules/primeng/fesm2022/primeng-icons-eyeslash.mjs
var _c02 = ["data-p-icon", "eyeslash"];
var EyeSlashIcon = class _EyeSlashIcon extends BaseIcon {
  pathId;
  onInit() {
    this.pathId = "url(#" + s2() + ")";
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275EyeSlashIcon_BaseFactory;
    return function EyeSlashIcon_Factory(__ngFactoryType__) {
      return (\u0275EyeSlashIcon_BaseFactory || (\u0275EyeSlashIcon_BaseFactory = \u0275\u0275getInheritedFactory(_EyeSlashIcon)))(__ngFactoryType__ || _EyeSlashIcon);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _EyeSlashIcon,
    selectors: [["", "data-p-icon", "eyeslash"]],
    features: [\u0275\u0275InheritDefinitionFeature],
    attrs: _c02,
    decls: 5,
    vars: 2,
    consts: [["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M13.9414 6.74792C13.9437 6.75295 13.9455 6.757 13.9469 6.76003C13.982 6.8394 14.0001 6.9252 14.0001 7.01195C14.0001 7.0987 13.982 7.1845 13.9469 7.26386C13.6004 8.00059 13.1711 8.69549 12.6674 9.33515C12.6115 9.4071 12.54 9.46538 12.4582 9.50556C12.3765 9.54574 12.2866 9.56678 12.1955 9.56707C12.0834 9.56671 11.9737 9.53496 11.8788 9.47541C11.7838 9.41586 11.7074 9.3309 11.6583 9.23015C11.6092 9.12941 11.5893 9.01691 11.6008 8.90543C11.6124 8.79394 11.6549 8.68793 11.7237 8.5994C12.1065 8.09726 12.4437 7.56199 12.7313 6.99995C12.2595 6.08027 10.3402 2.8014 6.99732 2.8014C6.63723 2.80218 6.27816 2.83969 5.92569 2.91336C5.77666 2.93304 5.62568 2.89606 5.50263 2.80972C5.37958 2.72337 5.29344 2.59398 5.26125 2.44714C5.22907 2.30031 5.2532 2.14674 5.32885 2.01685C5.40451 1.88696 5.52618 1.79021 5.66978 1.74576C6.10574 1.64961 6.55089 1.60134 6.99732 1.60181C11.5916 1.60181 13.7864 6.40856 13.9414 6.74792ZM2.20333 1.61685C2.35871 1.61411 2.5091 1.67179 2.6228 1.77774L12.2195 11.3744C12.3318 11.4869 12.3949 11.6393 12.3949 11.7983C12.3949 11.9572 12.3318 12.1097 12.2195 12.2221C12.107 12.3345 11.9546 12.3976 11.7956 12.3976C11.6367 12.3976 11.4842 12.3345 11.3718 12.2221L10.5081 11.3584C9.46549 12.0426 8.24432 12.4042 6.99729 12.3981C2.403 12.3981 0.208197 7.59135 0.0532336 7.25198C0.0509364 7.24694 0.0490875 7.2429 0.0476856 7.23986C0.0162332 7.16518 3.05176e-05 7.08497 3.05176e-05 7.00394C3.05176e-05 6.92291 0.0162332 6.8427 0.0476856 6.76802C0.631261 5.47831 1.46902 4.31959 2.51084 3.36119L1.77509 2.62545C1.66914 2.51175 1.61146 2.36136 1.61421 2.20597C1.61695 2.05059 1.6799 1.90233 1.78979 1.79244C1.89968 1.68254 2.04794 1.6196 2.20333 1.61685ZM7.45314 8.35147L5.68574 6.57609V6.5361C5.5872 6.78938 5.56498 7.06597 5.62183 7.33173C5.67868 7.59749 5.8121 7.84078 6.00563 8.03158C6.19567 8.21043 6.43052 8.33458 6.68533 8.39089C6.94014 8.44721 7.20543 8.43359 7.45314 8.35147ZM1.26327 6.99994C1.7351 7.91163 3.64645 11.1985 6.99729 11.1985C7.9267 11.2048 8.8408 10.9618 9.64438 10.4947L8.35682 9.20718C7.86027 9.51441 7.27449 9.64491 6.69448 9.57752C6.11446 9.51014 5.57421 9.24881 5.16131 8.83592C4.74842 8.42303 4.4871 7.88277 4.41971 7.30276C4.35232 6.72274 4.48282 6.13697 4.79005 5.64041L3.35855 4.2089C2.4954 5.00336 1.78523 5.94935 1.26327 6.99994Z", "fill", "currentColor"], [3, "id"], ["width", "14", "height", "14", "fill", "white"]],
    template: function EyeSlashIcon_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275namespaceSVG();
        \u0275\u0275domElementStart(0, "g");
        \u0275\u0275domElement(1, "path", 0);
        \u0275\u0275domElementEnd();
        \u0275\u0275domElementStart(2, "defs")(3, "clipPath", 1);
        \u0275\u0275domElement(4, "rect", 2);
        \u0275\u0275domElementEnd()();
      }
      if (rf & 2) {
        \u0275\u0275attribute("clip-path", ctx.pathId);
        \u0275\u0275advance(3);
        \u0275\u0275domProperty("id", ctx.pathId);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EyeSlashIcon, [{
    type: Component,
    args: [{
      selector: '[data-p-icon="eyeslash"]',
      standalone: true,
      template: `
        <svg:g [attr.clip-path]="pathId">
            <svg:path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M13.9414 6.74792C13.9437 6.75295 13.9455 6.757 13.9469 6.76003C13.982 6.8394 14.0001 6.9252 14.0001 7.01195C14.0001 7.0987 13.982 7.1845 13.9469 7.26386C13.6004 8.00059 13.1711 8.69549 12.6674 9.33515C12.6115 9.4071 12.54 9.46538 12.4582 9.50556C12.3765 9.54574 12.2866 9.56678 12.1955 9.56707C12.0834 9.56671 11.9737 9.53496 11.8788 9.47541C11.7838 9.41586 11.7074 9.3309 11.6583 9.23015C11.6092 9.12941 11.5893 9.01691 11.6008 8.90543C11.6124 8.79394 11.6549 8.68793 11.7237 8.5994C12.1065 8.09726 12.4437 7.56199 12.7313 6.99995C12.2595 6.08027 10.3402 2.8014 6.99732 2.8014C6.63723 2.80218 6.27816 2.83969 5.92569 2.91336C5.77666 2.93304 5.62568 2.89606 5.50263 2.80972C5.37958 2.72337 5.29344 2.59398 5.26125 2.44714C5.22907 2.30031 5.2532 2.14674 5.32885 2.01685C5.40451 1.88696 5.52618 1.79021 5.66978 1.74576C6.10574 1.64961 6.55089 1.60134 6.99732 1.60181C11.5916 1.60181 13.7864 6.40856 13.9414 6.74792ZM2.20333 1.61685C2.35871 1.61411 2.5091 1.67179 2.6228 1.77774L12.2195 11.3744C12.3318 11.4869 12.3949 11.6393 12.3949 11.7983C12.3949 11.9572 12.3318 12.1097 12.2195 12.2221C12.107 12.3345 11.9546 12.3976 11.7956 12.3976C11.6367 12.3976 11.4842 12.3345 11.3718 12.2221L10.5081 11.3584C9.46549 12.0426 8.24432 12.4042 6.99729 12.3981C2.403 12.3981 0.208197 7.59135 0.0532336 7.25198C0.0509364 7.24694 0.0490875 7.2429 0.0476856 7.23986C0.0162332 7.16518 3.05176e-05 7.08497 3.05176e-05 7.00394C3.05176e-05 6.92291 0.0162332 6.8427 0.0476856 6.76802C0.631261 5.47831 1.46902 4.31959 2.51084 3.36119L1.77509 2.62545C1.66914 2.51175 1.61146 2.36136 1.61421 2.20597C1.61695 2.05059 1.6799 1.90233 1.78979 1.79244C1.89968 1.68254 2.04794 1.6196 2.20333 1.61685ZM7.45314 8.35147L5.68574 6.57609V6.5361C5.5872 6.78938 5.56498 7.06597 5.62183 7.33173C5.67868 7.59749 5.8121 7.84078 6.00563 8.03158C6.19567 8.21043 6.43052 8.33458 6.68533 8.39089C6.94014 8.44721 7.20543 8.43359 7.45314 8.35147ZM1.26327 6.99994C1.7351 7.91163 3.64645 11.1985 6.99729 11.1985C7.9267 11.2048 8.8408 10.9618 9.64438 10.4947L8.35682 9.20718C7.86027 9.51441 7.27449 9.64491 6.69448 9.57752C6.11446 9.51014 5.57421 9.24881 5.16131 8.83592C4.74842 8.42303 4.4871 7.88277 4.41971 7.30276C4.35232 6.72274 4.48282 6.13697 4.79005 5.64041L3.35855 4.2089C2.4954 5.00336 1.78523 5.94935 1.26327 6.99994Z"
                fill="currentColor"
            />
        </svg:g>
        <svg:defs>
            <svg:clipPath [id]="pathId">
                <svg:rect width="14" height="14" fill="white" />
            </svg:clipPath>
        </svg:defs>
    `
    }]
  }], null, null);
})();

// node_modules/primeng/fesm2022/primeng-icons-star.mjs
var _c03 = ["data-p-icon", "star"];
var StarIcon = class _StarIcon extends BaseIcon {
  pathId;
  onInit() {
    this.pathId = "url(#" + s2() + ")";
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275StarIcon_BaseFactory;
    return function StarIcon_Factory(__ngFactoryType__) {
      return (\u0275StarIcon_BaseFactory || (\u0275StarIcon_BaseFactory = \u0275\u0275getInheritedFactory(_StarIcon)))(__ngFactoryType__ || _StarIcon);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _StarIcon,
    selectors: [["", "data-p-icon", "star"]],
    features: [\u0275\u0275InheritDefinitionFeature],
    attrs: _c03,
    decls: 5,
    vars: 2,
    consts: [["d", "M10.9741 13.6721C10.8806 13.6719 10.7886 13.6483 10.7066 13.6033L7.00002 11.6545L3.29345 13.6033C3.19926 13.6539 3.09281 13.6771 2.98612 13.6703C2.87943 13.6636 2.77676 13.6271 2.6897 13.5651C2.60277 13.5014 2.53529 13.4147 2.4948 13.3148C2.45431 13.215 2.44241 13.1058 2.46042 12.9995L3.17881 8.87264L0.167699 5.95324C0.0922333 5.8777 0.039368 5.78258 0.0150625 5.67861C-0.00924303 5.57463 -0.00402231 5.46594 0.030136 5.36477C0.0621323 5.26323 0.122141 5.17278 0.203259 5.10383C0.284377 5.03488 0.383311 4.99023 0.488681 4.97501L4.63087 4.37126L6.48797 0.618832C6.54083 0.530159 6.61581 0.456732 6.70556 0.405741C6.79532 0.35475 6.89678 0.327942 7.00002 0.327942C7.10325 0.327942 7.20471 0.35475 7.29447 0.405741C7.38422 0.456732 7.4592 0.530159 7.51206 0.618832L9.36916 4.37126L13.5114 4.97501C13.6167 4.99023 13.7157 5.03488 13.7968 5.10383C13.8779 5.17278 13.9379 5.26323 13.9699 5.36477C14.0041 5.46594 14.0093 5.57463 13.985 5.67861C13.9607 5.78258 13.9078 5.8777 13.8323 5.95324L10.8212 8.87264L11.532 12.9995C11.55 13.1058 11.5381 13.215 11.4976 13.3148C11.4571 13.4147 11.3896 13.5014 11.3027 13.5651C11.2059 13.632 11.0917 13.6692 10.9741 13.6721ZM7.00002 10.4393C7.09251 10.4404 7.18371 10.4613 7.2675 10.5005L10.2098 12.029L9.65193 8.75036C9.6368 8.6584 9.64343 8.56418 9.6713 8.47526C9.69918 8.38633 9.74751 8.30518 9.81242 8.23832L12.1969 5.94559L8.90298 5.45648C8.81188 5.44198 8.72555 5.406 8.65113 5.35152C8.57671 5.29703 8.51633 5.2256 8.475 5.14314L7.00002 2.1626L5.52503 5.15078C5.4837 5.23324 5.42332 5.30467 5.3489 5.35916C5.27448 5.41365 5.18815 5.44963 5.09705 5.46412L1.80318 5.94559L4.18761 8.23832C4.25252 8.30518 4.30085 8.38633 4.32873 8.47526C4.3566 8.56418 4.36323 8.6584 4.3481 8.75036L3.7902 12.0519L6.73253 10.5234C6.81451 10.4762 6.9058 10.4475 7.00002 10.4393Z", "fill", "currentColor"], [3, "id"], ["width", "14", "height", "14", "fill", "white"]],
    template: function StarIcon_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275namespaceSVG();
        \u0275\u0275domElementStart(0, "g");
        \u0275\u0275domElement(1, "path", 0);
        \u0275\u0275domElementEnd();
        \u0275\u0275domElementStart(2, "defs")(3, "clipPath", 1);
        \u0275\u0275domElement(4, "rect", 2);
        \u0275\u0275domElementEnd()();
      }
      if (rf & 2) {
        \u0275\u0275attribute("clip-path", ctx.pathId);
        \u0275\u0275advance(3);
        \u0275\u0275domProperty("id", ctx.pathId);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StarIcon, [{
    type: Component,
    args: [{
      selector: '[data-p-icon="star"]',
      standalone: true,
      template: `
        <svg:g [attr.clip-path]="pathId">
            <svg:path
                d="M10.9741 13.6721C10.8806 13.6719 10.7886 13.6483 10.7066 13.6033L7.00002 11.6545L3.29345 13.6033C3.19926 13.6539 3.09281 13.6771 2.98612 13.6703C2.87943 13.6636 2.77676 13.6271 2.6897 13.5651C2.60277 13.5014 2.53529 13.4147 2.4948 13.3148C2.45431 13.215 2.44241 13.1058 2.46042 12.9995L3.17881 8.87264L0.167699 5.95324C0.0922333 5.8777 0.039368 5.78258 0.0150625 5.67861C-0.00924303 5.57463 -0.00402231 5.46594 0.030136 5.36477C0.0621323 5.26323 0.122141 5.17278 0.203259 5.10383C0.284377 5.03488 0.383311 4.99023 0.488681 4.97501L4.63087 4.37126L6.48797 0.618832C6.54083 0.530159 6.61581 0.456732 6.70556 0.405741C6.79532 0.35475 6.89678 0.327942 7.00002 0.327942C7.10325 0.327942 7.20471 0.35475 7.29447 0.405741C7.38422 0.456732 7.4592 0.530159 7.51206 0.618832L9.36916 4.37126L13.5114 4.97501C13.6167 4.99023 13.7157 5.03488 13.7968 5.10383C13.8779 5.17278 13.9379 5.26323 13.9699 5.36477C14.0041 5.46594 14.0093 5.57463 13.985 5.67861C13.9607 5.78258 13.9078 5.8777 13.8323 5.95324L10.8212 8.87264L11.532 12.9995C11.55 13.1058 11.5381 13.215 11.4976 13.3148C11.4571 13.4147 11.3896 13.5014 11.3027 13.5651C11.2059 13.632 11.0917 13.6692 10.9741 13.6721ZM7.00002 10.4393C7.09251 10.4404 7.18371 10.4613 7.2675 10.5005L10.2098 12.029L9.65193 8.75036C9.6368 8.6584 9.64343 8.56418 9.6713 8.47526C9.69918 8.38633 9.74751 8.30518 9.81242 8.23832L12.1969 5.94559L8.90298 5.45648C8.81188 5.44198 8.72555 5.406 8.65113 5.35152C8.57671 5.29703 8.51633 5.2256 8.475 5.14314L7.00002 2.1626L5.52503 5.15078C5.4837 5.23324 5.42332 5.30467 5.3489 5.35916C5.27448 5.41365 5.18815 5.44963 5.09705 5.46412L1.80318 5.94559L4.18761 8.23832C4.25252 8.30518 4.30085 8.38633 4.32873 8.47526C4.3566 8.56418 4.36323 8.6584 4.3481 8.75036L3.7902 12.0519L6.73253 10.5234C6.81451 10.4762 6.9058 10.4475 7.00002 10.4393Z"
                fill="currentColor"
            />
        </svg:g>
        <svg:defs>
            <svg:clipPath [id]="pathId">
                <svg:rect width="14" height="14" fill="white" />
            </svg:clipPath>
        </svg:defs>
    `
    }]
  }], null, null);
})();

// node_modules/primeng/fesm2022/primeng-icons-starfill.mjs
var _c04 = ["data-p-icon", "star-fill"];
var StarFillIcon = class _StarFillIcon extends BaseIcon {
  pathId;
  onInit() {
    this.pathId = "url(#" + s2() + ")";
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275StarFillIcon_BaseFactory;
    return function StarFillIcon_Factory(__ngFactoryType__) {
      return (\u0275StarFillIcon_BaseFactory || (\u0275StarFillIcon_BaseFactory = \u0275\u0275getInheritedFactory(_StarFillIcon)))(__ngFactoryType__ || _StarFillIcon);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _StarFillIcon,
    selectors: [["", "data-p-icon", "star-fill"]],
    features: [\u0275\u0275InheritDefinitionFeature],
    attrs: _c04,
    decls: 5,
    vars: 2,
    consts: [["d", "M13.9718 5.36453C13.9398 5.26298 13.8798 5.17252 13.7986 5.10356C13.7175 5.0346 13.6186 4.98994 13.5132 4.97472L9.37043 4.37088L7.51307 0.617955C7.46021 0.529271 7.38522 0.455834 7.29545 0.404836C7.20568 0.353838 7.1042 0.327026 7.00096 0.327026C6.89771 0.327026 6.79624 0.353838 6.70647 0.404836C6.6167 0.455834 6.54171 0.529271 6.48885 0.617955L4.63149 4.37088L0.488746 4.97472C0.383363 4.98994 0.284416 5.0346 0.203286 5.10356C0.122157 5.17252 0.0621407 5.26298 0.03014 5.36453C-0.00402286 5.46571 -0.00924428 5.57442 0.0150645 5.67841C0.0393733 5.7824 0.0922457 5.87753 0.167722 5.95308L3.17924 8.87287L2.4684 13.0003C2.45038 13.1066 2.46229 13.2158 2.50278 13.3157C2.54328 13.4156 2.61077 13.5022 2.6977 13.5659C2.78477 13.628 2.88746 13.6644 2.99416 13.6712C3.10087 13.678 3.20733 13.6547 3.30153 13.6042L7.00096 11.6551L10.708 13.6042C10.79 13.6491 10.882 13.6728 10.9755 13.673C11.0958 13.6716 11.2129 13.6343 11.3119 13.5659C11.3988 13.5022 11.4663 13.4156 11.5068 13.3157C11.5473 13.2158 11.5592 13.1066 11.5412 13.0003L10.8227 8.87287L13.8266 5.95308C13.9033 5.87835 13.9577 5.7836 13.9833 5.67957C14.009 5.57554 14.005 5.4664 13.9718 5.36453Z", "fill", "currentColor"], [3, "id"], ["width", "14", "height", "14", "fill", "white"]],
    template: function StarFillIcon_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275namespaceSVG();
        \u0275\u0275domElementStart(0, "g");
        \u0275\u0275domElement(1, "path", 0);
        \u0275\u0275domElementEnd();
        \u0275\u0275domElementStart(2, "defs")(3, "clipPath", 1);
        \u0275\u0275domElement(4, "rect", 2);
        \u0275\u0275domElementEnd()();
      }
      if (rf & 2) {
        \u0275\u0275attribute("clip-path", ctx.pathId);
        \u0275\u0275advance(3);
        \u0275\u0275domProperty("id", ctx.pathId);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StarFillIcon, [{
    type: Component,
    args: [{
      selector: '[data-p-icon="star-fill"]',
      standalone: true,
      template: `
        <svg:g [attr.clip-path]="pathId">
            <svg:path
                d="M13.9718 5.36453C13.9398 5.26298 13.8798 5.17252 13.7986 5.10356C13.7175 5.0346 13.6186 4.98994 13.5132 4.97472L9.37043 4.37088L7.51307 0.617955C7.46021 0.529271 7.38522 0.455834 7.29545 0.404836C7.20568 0.353838 7.1042 0.327026 7.00096 0.327026C6.89771 0.327026 6.79624 0.353838 6.70647 0.404836C6.6167 0.455834 6.54171 0.529271 6.48885 0.617955L4.63149 4.37088L0.488746 4.97472C0.383363 4.98994 0.284416 5.0346 0.203286 5.10356C0.122157 5.17252 0.0621407 5.26298 0.03014 5.36453C-0.00402286 5.46571 -0.00924428 5.57442 0.0150645 5.67841C0.0393733 5.7824 0.0922457 5.87753 0.167722 5.95308L3.17924 8.87287L2.4684 13.0003C2.45038 13.1066 2.46229 13.2158 2.50278 13.3157C2.54328 13.4156 2.61077 13.5022 2.6977 13.5659C2.78477 13.628 2.88746 13.6644 2.99416 13.6712C3.10087 13.678 3.20733 13.6547 3.30153 13.6042L7.00096 11.6551L10.708 13.6042C10.79 13.6491 10.882 13.6728 10.9755 13.673C11.0958 13.6716 11.2129 13.6343 11.3119 13.5659C11.3988 13.5022 11.4663 13.4156 11.5068 13.3157C11.5473 13.2158 11.5592 13.1066 11.5412 13.0003L10.8227 8.87287L13.8266 5.95308C13.9033 5.87835 13.9577 5.7836 13.9833 5.67957C14.009 5.57554 14.005 5.4664 13.9718 5.36453Z"
                fill="currentColor"
            />
        </svg:g>
        <svg:defs>
            <svg:clipPath [id]="pathId">
                <svg:rect width="14" height="14" fill="white" />
            </svg:clipPath>
        </svg:defs>
    `
    }]
  }], null, null);
})();

// node_modules/primeng/fesm2022/primeng-icons-upload.mjs
var _c05 = ["data-p-icon", "upload"];
var UploadIcon = class _UploadIcon extends BaseIcon {
  pathId;
  onInit() {
    this.pathId = "url(#" + s2() + ")";
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275UploadIcon_BaseFactory;
    return function UploadIcon_Factory(__ngFactoryType__) {
      return (\u0275UploadIcon_BaseFactory || (\u0275UploadIcon_BaseFactory = \u0275\u0275getInheritedFactory(_UploadIcon)))(__ngFactoryType__ || _UploadIcon);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _UploadIcon,
    selectors: [["", "data-p-icon", "upload"]],
    features: [\u0275\u0275InheritDefinitionFeature],
    attrs: _c05,
    decls: 5,
    vars: 2,
    consts: [["fill-rule", "evenodd", "clip-rule", "evenodd", "d", "M6.58942 9.82197C6.70165 9.93405 6.85328 9.99793 7.012 10C7.17071 9.99793 7.32234 9.93405 7.43458 9.82197C7.54681 9.7099 7.61079 9.55849 7.61286 9.4V2.04798L9.79204 4.22402C9.84752 4.28011 9.91365 4.32457 9.98657 4.35479C10.0595 4.38502 10.1377 4.40039 10.2167 4.40002C10.2956 4.40039 10.3738 4.38502 10.4467 4.35479C10.5197 4.32457 10.5858 4.28011 10.6413 4.22402C10.7538 4.11152 10.817 3.95902 10.817 3.80002C10.817 3.64102 10.7538 3.48852 10.6413 3.37602L7.45127 0.190618C7.44656 0.185584 7.44176 0.180622 7.43687 0.175736C7.32419 0.063214 7.17136 0 7.012 0C6.85264 0 6.69981 0.063214 6.58712 0.175736C6.58181 0.181045 6.5766 0.186443 6.5715 0.191927L3.38282 3.37602C3.27669 3.48976 3.2189 3.6402 3.22165 3.79564C3.2244 3.95108 3.28746 4.09939 3.39755 4.20932C3.50764 4.31925 3.65616 4.38222 3.81182 4.38496C3.96749 4.3877 4.11814 4.33001 4.23204 4.22402L6.41113 2.04807V9.4C6.41321 9.55849 6.47718 9.7099 6.58942 9.82197ZM11.9952 14H2.02883C1.751 13.9887 1.47813 13.9228 1.22584 13.8061C0.973545 13.6894 0.746779 13.5241 0.558517 13.3197C0.370254 13.1154 0.22419 12.876 0.128681 12.6152C0.0331723 12.3545 -0.00990605 12.0775 0.0019109 11.8V9.40005C0.0019109 9.24092 0.065216 9.08831 0.1779 8.97579C0.290584 8.86326 0.443416 8.80005 0.602775 8.80005C0.762134 8.80005 0.914966 8.86326 1.02765 8.97579C1.14033 9.08831 1.20364 9.24092 1.20364 9.40005V11.8C1.18295 12.0376 1.25463 12.274 1.40379 12.4602C1.55296 12.6463 1.76817 12.7681 2.00479 12.8H11.9952C12.2318 12.7681 12.447 12.6463 12.5962 12.4602C12.7453 12.274 12.817 12.0376 12.7963 11.8V9.40005C12.7963 9.24092 12.8596 9.08831 12.9723 8.97579C13.085 8.86326 13.2378 8.80005 13.3972 8.80005C13.5565 8.80005 13.7094 8.86326 13.8221 8.97579C13.9347 9.08831 13.998 9.24092 13.998 9.40005V11.8C14.022 12.3563 13.8251 12.8996 13.45 13.3116C13.0749 13.7236 12.552 13.971 11.9952 14Z", "fill", "currentColor"], [3, "id"], ["width", "14", "height", "14", "fill", "white"]],
    template: function UploadIcon_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275namespaceSVG();
        \u0275\u0275domElementStart(0, "g");
        \u0275\u0275domElement(1, "path", 0);
        \u0275\u0275domElementEnd();
        \u0275\u0275domElementStart(2, "defs")(3, "clipPath", 1);
        \u0275\u0275domElement(4, "rect", 2);
        \u0275\u0275domElementEnd()();
      }
      if (rf & 2) {
        \u0275\u0275attribute("clip-path", ctx.pathId);
        \u0275\u0275advance(3);
        \u0275\u0275domProperty("id", ctx.pathId);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UploadIcon, [{
    type: Component,
    args: [{
      selector: '[data-p-icon="upload"]',
      standalone: true,
      template: `
        <svg:g [attr.clip-path]="pathId">
            <svg:path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M6.58942 9.82197C6.70165 9.93405 6.85328 9.99793 7.012 10C7.17071 9.99793 7.32234 9.93405 7.43458 9.82197C7.54681 9.7099 7.61079 9.55849 7.61286 9.4V2.04798L9.79204 4.22402C9.84752 4.28011 9.91365 4.32457 9.98657 4.35479C10.0595 4.38502 10.1377 4.40039 10.2167 4.40002C10.2956 4.40039 10.3738 4.38502 10.4467 4.35479C10.5197 4.32457 10.5858 4.28011 10.6413 4.22402C10.7538 4.11152 10.817 3.95902 10.817 3.80002C10.817 3.64102 10.7538 3.48852 10.6413 3.37602L7.45127 0.190618C7.44656 0.185584 7.44176 0.180622 7.43687 0.175736C7.32419 0.063214 7.17136 0 7.012 0C6.85264 0 6.69981 0.063214 6.58712 0.175736C6.58181 0.181045 6.5766 0.186443 6.5715 0.191927L3.38282 3.37602C3.27669 3.48976 3.2189 3.6402 3.22165 3.79564C3.2244 3.95108 3.28746 4.09939 3.39755 4.20932C3.50764 4.31925 3.65616 4.38222 3.81182 4.38496C3.96749 4.3877 4.11814 4.33001 4.23204 4.22402L6.41113 2.04807V9.4C6.41321 9.55849 6.47718 9.7099 6.58942 9.82197ZM11.9952 14H2.02883C1.751 13.9887 1.47813 13.9228 1.22584 13.8061C0.973545 13.6894 0.746779 13.5241 0.558517 13.3197C0.370254 13.1154 0.22419 12.876 0.128681 12.6152C0.0331723 12.3545 -0.00990605 12.0775 0.0019109 11.8V9.40005C0.0019109 9.24092 0.065216 9.08831 0.1779 8.97579C0.290584 8.86326 0.443416 8.80005 0.602775 8.80005C0.762134 8.80005 0.914966 8.86326 1.02765 8.97579C1.14033 9.08831 1.20364 9.24092 1.20364 9.40005V11.8C1.18295 12.0376 1.25463 12.274 1.40379 12.4602C1.55296 12.6463 1.76817 12.7681 2.00479 12.8H11.9952C12.2318 12.7681 12.447 12.6463 12.5962 12.4602C12.7453 12.274 12.817 12.0376 12.7963 11.8V9.40005C12.7963 9.24092 12.8596 9.08831 12.9723 8.97579C13.085 8.86326 13.2378 8.80005 13.3972 8.80005C13.5565 8.80005 13.7094 8.86326 13.8221 8.97579C13.9347 9.08831 13.998 9.24092 13.998 9.40005V11.8C14.022 12.3563 13.8251 12.8996 13.45 13.3116C13.0749 13.7236 12.552 13.971 11.9952 14Z"
                fill="currentColor"
            />
        </svg:g>
        <svg:defs>
            <svg:clipPath [id]="pathId">
                <svg:rect width="14" height="14" fill="white" />
            </svg:clipPath>
        </svg:defs>
    `
    }]
  }], null, null);
})();

// node_modules/primeng/fesm2022/primeng-dynamicdialog.mjs
var _c06 = () => ({
  severity: "secondary",
  variant: "text",
  rounded: true
});
function DynamicDialog_1_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DynamicDialog_1_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_1_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngComponentOutlet", ctx_r0.headerTemplate);
  }
}
function DynamicDialog_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_1_ng_template_0_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
  }
}
function DynamicDialog_2_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DynamicDialog_2_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_2_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngComponentOutlet", ctx_r0.contentTemplate);
  }
}
function DynamicDialog_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_2_ng_template_0_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
  }
}
function DynamicDialog_3_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DynamicDialog_3_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_3_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngComponentOutlet", ctx_r0.footerTemplate);
  }
}
function DynamicDialog_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_3_ng_template_0_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
  }
}
function DynamicDialog_4_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DynamicDialog_4_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_4_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngComponentOutlet", ctx_r0.closeIconTemplate);
  }
}
function DynamicDialog_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_4_ng_template_0_Template, 1, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
  }
}
function DynamicDialog_5_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DynamicDialog_5_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_5_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngComponentOutlet", ctx_r0.maximizeIconTemplate);
  }
}
function DynamicDialog_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_5_ng_template_0_Template, 1, 1, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
  }
}
function DynamicDialog_6_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DynamicDialog_6_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_6_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngComponentOutlet", ctx_r0.minimizeIconTemplate);
  }
}
function DynamicDialog_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_6_ng_template_0_Template, 1, 1, "ng-template", null, 5, \u0275\u0275templateRefExtractor);
  }
}
function DynamicDialog_7_ng_template_0_Template(rf, ctx) {
}
function DynamicDialog_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicDialog_7_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
}
function DynamicDialog_div_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.ddconfig.footer);
  }
}
var DynamicDialogContent = class _DynamicDialogContent {
  viewContainerRef;
  constructor(viewContainerRef) {
    this.viewContainerRef = viewContainerRef;
  }
  static \u0275fac = function DynamicDialogContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DynamicDialogContent)(\u0275\u0275directiveInject(ViewContainerRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _DynamicDialogContent,
    selectors: [["", "pDynamicDialogContent", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamicDialogContent, [{
    type: Directive,
    args: [{
      selector: "[pDynamicDialogContent]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], null);
})();
var DynamicDialogStyle = class _DynamicDialogStyle extends DialogStyle {
  name = "dialog";
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275DynamicDialogStyle_BaseFactory;
    return function DynamicDialogStyle_Factory(__ngFactoryType__) {
      return (\u0275DynamicDialogStyle_BaseFactory || (\u0275DynamicDialogStyle_BaseFactory = \u0275\u0275getInheritedFactory(_DynamicDialogStyle)))(__ngFactoryType__ || _DynamicDialogStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DynamicDialogStyle,
    factory: _DynamicDialogStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamicDialogStyle, [{
    type: Injectable
  }], null, null);
})();
var DynamicDialogClasses;
(function(DynamicDialogClasses2) {
  DynamicDialogClasses2["mask"] = "p-dialog-mask";
  DynamicDialogClasses2["root"] = "p-dialog";
  DynamicDialogClasses2["header"] = "p-dialog-header";
  DynamicDialogClasses2["title"] = "p-dialog-title";
  DynamicDialogClasses2["headerActions"] = "p-dialog-header-actions";
  DynamicDialogClasses2["pcMaximizeButton"] = "p-dialog-maximize-button";
  DynamicDialogClasses2["pcCloseButton"] = "p-dialog-close-button";
  DynamicDialogClasses2["content"] = "p-dialog-content";
  DynamicDialogClasses2["footer"] = "p-dialog-footer";
})(DynamicDialogClasses || (DynamicDialogClasses = {}));
var DynamicDialogConfig = class {
  /**
   * An object to pass to the component loaded inside the Dialog.
   * @group Props
   */
  data;
  /**
   * An object to pass to the component loaded inside the Dialog.
   * @group Props
   */
  inputValues;
  /**
   * Header text of the dialog.
   * @group Props
   */
  header;
  /**
   * Identifies the element (or elements) that labels the element it is applied to.
   * @group Props
   */
  ariaLabelledBy;
  /**
   * Footer text of the dialog.
   * @group Props
   */
  footer;
  /**
   * Width of the dialog.
   * @group Props
   */
  width;
  /**
   * Height of the dialog.
   * @group Props
   */
  height;
  /**
   * Specifies if pressing escape key should hide the dialog.
   * @group Props
   */
  closeOnEscape = false;
  /**
   * Specifies if autofocus should happen on show.
   * @group Props
   */
  focusOnShow = true;
  /**
   * When enabled, can only focus on elements inside the dialog.
   * @group Props
   */
  focusTrap = true;
  /**
   * Base zIndex value to use in layering.
   * @group Props
   */
  baseZIndex;
  /**
   * Whether to re-enforce layering through applying zIndex.
   * @group Props
   */
  autoZIndex = false;
  /**
   * Specifies if clicking the modal background should hide the dialog.
   * @group Props
   */
  dismissableMask = false;
  /**
   * Inline style of the component.
   * @group Props
   */
  rtl = false;
  /**
   * Inline style of the component.
   * @group Props
   */
  style;
  /**
   * Inline style of the content.
   * @group Props
   */
  contentStyle;
  /**
   * Style class of the component.
   * @group Props
   */
  styleClass;
  /**
   * Transition options of the animation.
   * @group Props
   */
  transitionOptions;
  /**
   * Adds a close icon to the header to hide the dialog.
   * @group Props
   */
  closable = false;
  /**
   * Whether to show the header or not.
   * @group Props
   */
  showHeader = false;
  /**
   * Defines if background should be blocked when dialog is displayed.
   * @group Props
   */
  modal = false;
  /**
   * Style class of the mask.
   * @group Props
   */
  maskStyleClass;
  /**
   * Enables resizing of the content.
   * @group Props
   */
  resizable = false;
  /**
   * Enables dragging to change the position using header.
   * @group Props
   */
  draggable = false;
  /**
   * Keeps dialog in the viewport.
   * @group Props
   */
  keepInViewport = false;
  /**
   * Minimum value for the left coordinate of dialog in dragging.
   * @group Props
   */
  minX;
  /**
   * Minimum value for the top coordinate of dialog in dragging.
   * @group Props
   */
  minY;
  /**
   * Whether the dialog can be displayed full screen.
   * @group Props
   */
  maximizable = false;
  /**
   * Name of the maximize icon.
   * @group Props
   */
  maximizeIcon;
  /**
   * Name of the minimize icon.
   * @group Props
   */
  minimizeIcon;
  /**
   * Position of the dialog, options are "center", "top", "bottom", "left", "right", "topleft", "topright", "bottomleft" or "bottomright".
   * @group Props
   */
  position;
  /**
   * Defines a string that labels the close button for accessibility.
   * @group Props
   */
  closeAriaLabel;
  /**
   * Target element to attach the overlay, valid values are "body" or a local ng-template variable of another element (note: use binding with brackets for template variables, e.g. [appendTo]="mydiv" for a div element having #mydiv as variable name).
   * @group Props
   */
  appendTo;
  /**
   * A boolean to determine if it can be duplicate.
   * @group Props
   */
  duplicate = false;
  /**
   * Object literal to define widths per screen size.
   * @group Props
   */
  breakpoints;
  /**
   * Dialog templates.
   * @group Props
   */
  templates;
  /**
   * Used to pass attributes to DOM elements inside the Dialog component.
   * @group Props
   */
  pt;
  /**
   * Indicates whether the component should be rendered without styles.
   * @group Props
   */
  unstyled;
};
var DynamicDialogRef = class {
  constructor() {
  }
  /**
   * Closes dialog.
   * @group Method
   */
  close(result) {
    this._onClose.next(result);
    setTimeout(() => {
      this._onClose.complete();
    }, 1e3);
  }
  /**
   * Destroys the dialog instance.
   * @group Method
   */
  destroy() {
    this._onDestroy.next(null);
  }
  /**
   * Callback to invoke on drag start.
   * @param {MouseEvent} event - Mouse event.
   * @group Method
   */
  dragStart(event) {
    this._onDragStart.next(event);
  }
  /**
   * Callback to invoke on drag end.
   * @param {MouseEvent} event - Mouse event.
   * @group Method
   */
  dragEnd(event) {
    this._onDragEnd.next(event);
  }
  /**
   * Callback to invoke on resize start.
   * @param {MouseEvent} event - Mouse event.
   * @group Method
   */
  resizeInit(event) {
    this._onResizeInit.next(event);
  }
  /**
   * Callback to invoke on resize start.
   * @param {MouseEvent} event - Mouse event.
   * @group Method
   */
  resizeEnd(event) {
    this._onResizeEnd.next(event);
  }
  /**
   * Callback to invoke on dialog is maximized.
   * @param {*} value - Size value.
   * @group Method
   */
  maximize(value) {
    this._onMaximize.next(value);
  }
  _onClose = new Subject();
  /**
   * Event triggered on dialog is closed.
   * @group Events
   */
  onClose = this._onClose.asObservable();
  _onDestroy = new Subject();
  /**
   * Event triggered on dialog instance is destroyed.
   * @group Events
   */
  onDestroy = this._onDestroy.asObservable();
  _onDragStart = new Subject();
  /**
   * Event triggered on drag start.
   * @param {MouseEvent} event - Mouse event.
   * @group Events
   */
  onDragStart = this._onDragStart.asObservable();
  _onDragEnd = new Subject();
  /**
   * Event triggered on drag end.
   * @param {MouseEvent} event - Mouse event.
   * @group Events
   */
  onDragEnd = this._onDragEnd.asObservable();
  _onResizeInit = new Subject();
  /**
   * Event triggered on resize start.
   * @param {MouseEvent} event - Mouse event.
   * @group Events
   */
  onResizeInit = this._onResizeInit.asObservable();
  _onResizeEnd = new Subject();
  /**
   * Event triggered on resize end.
   * @param {MouseEvent} event - Mouse event.
   * @group Events
   */
  onResizeEnd = this._onResizeEnd.asObservable();
  _onMaximize = new Subject();
  /**
   * Event triggered on dialog is maximized.
   * @param {*} value - Size value.
   * @group Events
   */
  onMaximize = this._onMaximize.asObservable();
  /**
   * Event triggered on child component load.
   * @param {*} value - Chi.
   * @group Events
   */
  onChildComponentLoaded = new Subject();
};
var DYNAMIC_DIALOG_INSTANCE = new InjectionToken("DYNAMIC_DIALOG_INSTANCE");
var DynamicDialog = class _DynamicDialog extends BaseComponent {
  ddconfig;
  dialogRef;
  _componentStyle = inject(DynamicDialogStyle);
  $pcDynamicDialog = inject(DYNAMIC_DIALOG_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  visible = true;
  componentRef;
  id = s2("pn_id_");
  insertionPoint;
  dialog;
  childComponentType;
  inputValues;
  get minX() {
    return this.ddconfig.minX ? this.ddconfig.minX : 0;
  }
  get minY() {
    return this.ddconfig.minY ? this.ddconfig.minY : 0;
  }
  get keepInViewport() {
    return this.ddconfig.keepInViewport;
  }
  get maximizable() {
    return this.ddconfig.maximizable;
  }
  get maximizeIcon() {
    return this.ddconfig.maximizeIcon;
  }
  get minimizeIcon() {
    return this.ddconfig.minimizeIcon;
  }
  get closable() {
    return this.ddconfig.closable;
  }
  get position() {
    return this.ddconfig.position;
  }
  get defaultCloseAriaLabel() {
    return this.config.getTranslation(TranslationKeys.ARIA)["close"];
  }
  get breakpoints() {
    return this.ddconfig.breakpoints;
  }
  get footerTemplate() {
    return this.ddconfig?.templates?.footer;
  }
  get headerTemplate() {
    return this.ddconfig?.templates?.header;
  }
  get contentTemplate() {
    return this.ddconfig?.templates?.content;
  }
  get minimizeIconTemplate() {
    return this.ddconfig?.templates?.minimizeicon;
  }
  get maximizeIconTemplate() {
    return this.ddconfig?.templates?.maximizeicon;
  }
  get closeIconTemplate() {
    return this.ddconfig?.templates?.closeicon;
  }
  get dialogStyle() {
    return __spreadValues(__spreadValues(__spreadValues({}, this.ddconfig?.style || {}), this.ddconfig?.width && {
      width: this.ddconfig.width
    }), this.ddconfig?.height && {
      height: this.ddconfig.height
    });
  }
  get header() {
    return this.ddconfig.header;
  }
  get data() {
    return this.ddconfig.data;
  }
  get dialogId() {
    return this.$attrSelector;
  }
  get isUnstyled() {
    return this.ddconfig.unstyled || this.$unstyled();
  }
  maximized;
  dragging;
  resizing;
  ariaLabelledBy;
  _style = {};
  styleElement;
  lastPageX;
  lastPageY;
  contentViewChild;
  footerViewChild;
  headerViewChild;
  maskViewChild;
  maskClickListener;
  documentDragListener;
  documentDragEndListener;
  documentResizeListener;
  documentResizeEndListener;
  documentEscapeListener;
  constructor(ddconfig, dialogRef) {
    super();
    this.ddconfig = ddconfig;
    this.dialogRef = dialogRef;
  }
  onAfterViewInit() {
    this.loadChildComponent(this.childComponentType);
    this.ariaLabelledBy = this.getAriaLabelledBy();
    this.cd.detectChanges();
  }
  getAriaLabelledBy() {
    const {
      header,
      showHeader
    } = this.ddconfig;
    if (header === null || showHeader === false) {
      return null;
    }
    return s2("pn_id_") + "_header";
  }
  loadChildComponent(componentType) {
    let viewContainerRef = this.insertionPoint?.viewContainerRef;
    viewContainerRef?.clear();
    this.componentRef = viewContainerRef?.createComponent(componentType);
    if (this.inputValues && this.componentRef) {
      Object.entries(this.inputValues).forEach(([key, value]) => {
        this.componentRef.setInput(key, value);
      });
    }
    this.dialogRef.onChildComponentLoaded.next(this.componentRef.instance);
  }
  onDialogHide(event) {
    this.dialogRef.destroy();
  }
  onDialogMaximize(event) {
    this.maximized = event.maximized;
    this.dialogRef.maximize(event);
  }
  onDialogResizeInit(event) {
    this.resizing = true;
    this.dialogRef.resizeInit(event);
  }
  onDialogResizeEnd(event) {
    this.resizing = false;
    this.dialogRef.resizeEnd(event);
  }
  onDialogDragEnd(event) {
    this.dragging = false;
    this.dialogRef.dragEnd(event);
  }
  close() {
    this.visible = false;
    this.cd.markForCheck();
  }
  hide() {
    if (this.dialogRef) {
      this.dialogRef.close();
    }
  }
  get _parent() {
    const domElements = Array.from(this.document.getElementsByClassName("p-dialog"));
    if (domElements.length > 1) {
      return domElements.pop();
    }
  }
  get parentContent() {
    const domElements = Array.from(this.document.getElementsByClassName("p-dialog"));
    if (domElements.length > 0) {
      const contentElements = domElements[domElements.length - 1].querySelector(".p-dialog-content");
      if (contentElements) return Array.isArray(contentElements) ? contentElements[0] : contentElements;
    }
  }
  container;
  wrapper;
  unbindGlobalListeners() {
    this.unbindDocumentEscapeListener();
    this.unbindDocumentResizeListeners();
    this.unbindDocumentDragListener();
    this.unbindDocumentDragEndListener();
  }
  onAnimationStart(event) {
    if (event.toState === "visible") {
      if (this._parent) {
        this.unbindGlobalListeners();
      }
      if (this.ddconfig.modal) {
        this.enableModality();
      }
    }
  }
  onAnimationEnd(event) {
    if (event.toState === "void") {
      this.onContainerDestroy();
      this.dialogRef.destroy();
    }
  }
  onContainerDestroy() {
    this.unbindGlobalListeners();
    if (this.ddconfig.modal) {
      this.disableModality();
    }
    this.container = null;
  }
  bindDocumentDragListener() {
    if (!this.documentDragListener) {
      this.documentDragListener = this.renderer.listen(this.document.defaultView, "mousemove", (event) => {
        this.onDrag(event);
      });
    }
  }
  bindDocumentDragEndListener() {
    if (!this.documentDragEndListener) {
      this.documentDragEndListener = this.renderer.listen(this.document.defaultView, "mouseup", (event) => {
        this.endDrag(event);
      });
    }
  }
  unbindDocumentDragEndListener() {
    if (this.documentDragEndListener) {
      this.documentDragEndListener();
      this.documentDragEndListener = null;
    }
  }
  unbindDocumentDragListener() {
    if (this.documentDragListener) {
      this.documentDragListener();
      this.documentDragListener = null;
    }
  }
  initDrag(event) {
    if (event.target instanceof HTMLElement) {
      const target = event.target;
      if (target.closest(".p-dialog-header-icon") || target.closest(".p-dialog-header-icons")) {
        return;
      }
    }
    this.dragging = true;
    this.lastPageX = event.pageX;
    this.lastPageY = event.pageY;
    this.dialogRef.dragStart(event);
    this.bindDocumentDragListener();
    this.bindDocumentDragEndListener();
  }
  onDrag(event) {
    if (this.dragging) {
      this.lastPageX = event.pageX;
      this.lastPageY = event.pageY;
      if (this.ddconfig.keepInViewport && this.container) {
        this.container.style.position = "fixed";
      }
    }
  }
  endDrag(event) {
    if (this.dragging) {
      this.dragging = false;
      this.dialogRef.dragEnd(event);
      this.cd.detectChanges();
    }
  }
  resetPosition() {
    if (this.container) {
      this.container.style.position = "";
      this.container.style.left = "";
      this.container.style.top = "";
      this.container.style.margin = "";
    }
  }
  bindDocumentResizeListeners() {
    if (!this.documentResizeListener) {
      this.documentResizeListener = this.renderer.listen(this.document.defaultView, "mousemove", (event) => {
        this.onResize(event);
      });
    }
    if (!this.documentResizeEndListener) {
      this.documentResizeEndListener = this.renderer.listen(this.document.defaultView, "mouseup", (event) => {
        this.resizeEnd(event);
      });
    }
  }
  unbindDocumentResizeListeners() {
    if (this.documentResizeListener) {
      this.documentResizeListener();
      this.documentResizeListener = null;
    }
    if (this.documentResizeEndListener) {
      this.documentResizeEndListener();
      this.documentResizeEndListener = null;
    }
  }
  initResize(event) {
    this.resizing = true;
    this.lastPageX = event.pageX;
    this.lastPageY = event.pageY;
    this.dialogRef.resizeInit(event);
  }
  onResize(event) {
    if (this.resizing) {
      this.lastPageX = event.pageX;
      this.lastPageY = event.pageY;
    }
  }
  resizeEnd(event) {
    if (this.resizing) {
      this.resizing = false;
      this.dialogRef.resizeEnd(event);
    }
  }
  maximize() {
    this.maximized = !this.maximized;
    this.dialogRef.maximize({
      maximized: this.maximized
    });
  }
  enableModality() {
    if (this.ddconfig.dismissableMask && this.wrapper) {
      this.maskClickListener = this.renderer.listen(this.wrapper, "mousedown", (event) => {
        if (this.wrapper && this.wrapper.isSameNode(event.target)) {
          this.hide();
        }
      });
    }
  }
  disableModality() {
    this.unbindMaskClickListener();
    this.cd.detectChanges();
  }
  unbindMaskClickListener() {
    if (this.maskClickListener) {
      this.maskClickListener();
      this.maskClickListener = null;
    }
  }
  bindDocumentEscapeListener() {
    if (this.ddconfig.closeOnEscape) {
      this.documentEscapeListener = this.renderer.listen(this.document, "keydown", (event) => {
        if (event.key === "Escape" && this.container) {
          this.hide();
        }
      });
    }
  }
  unbindDocumentEscapeListener() {
    if (this.documentEscapeListener) {
      this.documentEscapeListener();
      this.documentEscapeListener = null;
    }
  }
  createStyle() {
    if (!this.styleElement && this.breakpoints) {
      this.styleElement = this.renderer.createElement("style");
      this.styleElement.type = "text/css";
      this.renderer.appendChild(this.document.head, this.styleElement);
      let innerHTML = "";
      for (let breakpoint in this.breakpoints) {
        innerHTML += `
                    @media screen and (max-width: ${breakpoint}) {
                        .p-dialog[${this.dialogId}] {
                            width: ${this.breakpoints[breakpoint]} !important;
                        }
                    }
                `;
      }
      this.renderer.setProperty(this.styleElement, "innerHTML", innerHTML);
    }
  }
  destroyStyle() {
    if (this.styleElement) {
      this.renderer.removeChild(this.document.head, this.styleElement);
      this.styleElement = null;
    }
  }
  onDestroy() {
    if (this.componentRef && typeof this.componentRef.destroy === "function") {
      this.componentRef.destroy();
    }
  }
  ngOnDestroy() {
    this.onContainerDestroy();
    if (this.componentRef && typeof this.componentRef.destroy === "function") {
      this.componentRef.destroy();
    }
    this.destroyStyle();
  }
  static \u0275fac = function DynamicDialog_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DynamicDialog)(\u0275\u0275directiveInject(DynamicDialogConfig), \u0275\u0275directiveInject(DynamicDialogRef));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _DynamicDialog,
    selectors: [["p-dynamicDialog"], ["p-dynamicdialog"], ["p-dynamic-dialog"]],
    viewQuery: function DynamicDialog_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(DynamicDialogContent, 5);
        \u0275\u0275viewQuery(Dialog, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.insertionPoint = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.dialog = _t.first);
      }
    },
    features: [\u0275\u0275ProvidersFeature([DynamicDialogStyle, {
      provide: DYNAMIC_DIALOG_INSTANCE,
      useExisting: _DynamicDialog
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _DynamicDialog
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 9,
    vars: 43,
    consts: [["header", ""], ["content", ""], ["footer", ""], ["closeicon", ""], ["maximizeicon", ""], ["minimizeicon", ""], ["hostName", "DynamicDialog", 3, "visibleChange", "onHide", "onMaximize", "onResizeInit", "onResizeEnd", "onDragEnd", "visible", "header", "draggable", "resizable", "contentStyle", "modal", "closeOnEscape", "dismissableMask", "rtl", "closable", "breakpoints", "styleClass", "maskStyleClass", "showHeader", "autoZIndex", "baseZIndex", "minX", "minY", "focusOnShow", "maximizable", "keepInViewport", "focusTrap", "transitionOptions", "closeAriaLabel", "minimizeIcon", "maximizeIcon", "closeButtonProps", "maximizeButtonProps", "position", "pt", "unstyled"], [4, "ngIf"], [4, "ngComponentOutlet"], ["pDynamicDialogContent", ""]],
    template: function DynamicDialog_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "p-dialog", 6);
        \u0275\u0275twoWayListener("visibleChange", function DynamicDialog_Template_p_dialog_visibleChange_0_listener($event) {
          \u0275\u0275twoWayBindingSet(ctx.visible, $event) || (ctx.visible = $event);
          return $event;
        });
        \u0275\u0275listener("onHide", function DynamicDialog_Template_p_dialog_onHide_0_listener($event) {
          return ctx.onDialogHide($event);
        })("onMaximize", function DynamicDialog_Template_p_dialog_onMaximize_0_listener($event) {
          return ctx.onDialogMaximize($event);
        })("onResizeInit", function DynamicDialog_Template_p_dialog_onResizeInit_0_listener($event) {
          return ctx.onDialogResizeInit($event);
        })("onResizeEnd", function DynamicDialog_Template_p_dialog_onResizeEnd_0_listener($event) {
          return ctx.onDialogResizeEnd($event);
        })("onDragEnd", function DynamicDialog_Template_p_dialog_onDragEnd_0_listener($event) {
          return ctx.onDialogDragEnd($event);
        });
        \u0275\u0275template(1, DynamicDialog_1_Template, 2, 0, null, 7)(2, DynamicDialog_2_Template, 2, 0, null, 7)(3, DynamicDialog_3_Template, 2, 0, null, 7)(4, DynamicDialog_4_Template, 2, 0, null, 7)(5, DynamicDialog_5_Template, 2, 0, null, 7)(6, DynamicDialog_6_Template, 2, 0, null, 7)(7, DynamicDialog_7_Template, 1, 0, null, 7)(8, DynamicDialog_div_8_Template, 2, 1, "div", 7);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275styleMap(ctx.dialogStyle);
        \u0275\u0275twoWayProperty("visible", ctx.visible);
        \u0275\u0275property("header", ctx.ddconfig == null ? null : ctx.ddconfig.header)("draggable", (ctx.ddconfig == null ? null : ctx.ddconfig.draggable) !== false)("resizable", (ctx.ddconfig == null ? null : ctx.ddconfig.resizable) !== false)("contentStyle", ctx.ddconfig == null ? null : ctx.ddconfig.contentStyle)("modal", (ctx.ddconfig == null ? null : ctx.ddconfig.modal) !== false)("closeOnEscape", (ctx.ddconfig == null ? null : ctx.ddconfig.closeOnEscape) !== false)("dismissableMask", ctx.ddconfig == null ? null : ctx.ddconfig.dismissableMask)("rtl", ctx.ddconfig == null ? null : ctx.ddconfig.rtl)("closable", ctx.closable)("breakpoints", ctx.breakpoints)("styleClass", ctx.ddconfig == null ? null : ctx.ddconfig.styleClass)("maskStyleClass", ctx.ddconfig == null ? null : ctx.ddconfig.maskStyleClass)("showHeader", (ctx.ddconfig == null ? null : ctx.ddconfig.showHeader) !== false)("autoZIndex", (ctx.ddconfig == null ? null : ctx.ddconfig.autoZIndex) !== false)("baseZIndex", (ctx.ddconfig == null ? null : ctx.ddconfig.baseZIndex) || 0)("minX", ctx.minX)("minY", ctx.minY)("focusOnShow", (ctx.ddconfig == null ? null : ctx.ddconfig.focusOnShow) !== false)("maximizable", ctx.maximizable)("keepInViewport", ctx.keepInViewport)("focusTrap", (ctx.ddconfig == null ? null : ctx.ddconfig.focusTrap) !== false)("transitionOptions", (ctx.ddconfig == null ? null : ctx.ddconfig.transitionOptions) || "150ms cubic-bezier(0, 0, 0.2, 1)")("closeAriaLabel", (ctx.ddconfig == null ? null : ctx.ddconfig.closeAriaLabel) || ctx.defaultCloseAriaLabel)("minimizeIcon", ctx.minimizeIcon)("maximizeIcon", ctx.maximizeIcon)("closeButtonProps", \u0275\u0275pureFunction0(41, _c06))("maximizeButtonProps", \u0275\u0275pureFunction0(42, _c06))("position", ctx.position)("pt", ctx.ddconfig.pt)("unstyled", ctx.isUnstyled);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.headerTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.contentTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.footerTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.closeIconTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.maximizeIconTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.minimizeIconTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", !ctx.contentTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.ddconfig.footer && !ctx.footerTemplate);
      }
    },
    dependencies: [CommonModule, NgComponentOutlet, NgIf, SharedModule, DynamicDialogContent, Dialog, BindModule],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamicDialog, [{
    type: Component,
    args: [{
      selector: "p-dynamicDialog, p-dynamicdialog, p-dynamic-dialog",
      standalone: true,
      imports: [CommonModule, SharedModule, DynamicDialogContent, Dialog, BindModule],
      template: `
        <p-dialog
            [(visible)]="visible"
            [header]="ddconfig?.header"
            [draggable]="ddconfig?.draggable !== false"
            [resizable]="ddconfig?.resizable !== false"
            [contentStyle]="ddconfig?.contentStyle"
            [modal]="ddconfig?.modal !== false"
            [closeOnEscape]="ddconfig?.closeOnEscape !== false"
            [dismissableMask]="ddconfig?.dismissableMask"
            [rtl]="ddconfig?.rtl"
            [closable]="closable"
            [breakpoints]="breakpoints"
            [styleClass]="ddconfig?.styleClass"
            [maskStyleClass]="ddconfig?.maskStyleClass"
            [showHeader]="ddconfig?.showHeader !== false"
            [autoZIndex]="ddconfig?.autoZIndex !== false"
            [baseZIndex]="ddconfig?.baseZIndex || 0"
            [minX]="minX"
            [minY]="minY"
            [focusOnShow]="ddconfig?.focusOnShow !== false"
            [maximizable]="maximizable"
            [keepInViewport]="keepInViewport"
            [focusTrap]="ddconfig?.focusTrap !== false"
            [transitionOptions]="ddconfig?.transitionOptions || '150ms cubic-bezier(0, 0, 0.2, 1)'"
            [closeAriaLabel]="ddconfig?.closeAriaLabel || defaultCloseAriaLabel"
            [minimizeIcon]="minimizeIcon"
            [maximizeIcon]="maximizeIcon"
            [closeButtonProps]="{ severity: 'secondary', variant: 'text', rounded: true }"
            [maximizeButtonProps]="{ severity: 'secondary', variant: 'text', rounded: true }"
            [style]="dialogStyle"
            [position]="position"
            (onHide)="onDialogHide($event)"
            (onMaximize)="onDialogMaximize($event)"
            (onResizeInit)="onDialogResizeInit($event)"
            (onResizeEnd)="onDialogResizeEnd($event)"
            (onDragEnd)="onDialogDragEnd($event)"
            [pt]="ddconfig.pt"
            hostName="DynamicDialog"
            [unstyled]="isUnstyled"
        >
            <ng-template #header *ngIf="headerTemplate">
                <ng-container *ngComponentOutlet="headerTemplate"></ng-container>
            </ng-template>
            <ng-template #content *ngIf="contentTemplate">
                <ng-container *ngComponentOutlet="contentTemplate"></ng-container>
            </ng-template>
            <ng-template #footer *ngIf="footerTemplate">
                <ng-container *ngComponentOutlet="footerTemplate"></ng-container>
            </ng-template>
            <ng-template #closeicon *ngIf="closeIconTemplate">
                <ng-container *ngComponentOutlet="closeIconTemplate"></ng-container>
            </ng-template>
            <ng-template #maximizeicon *ngIf="maximizeIconTemplate">
                <ng-container *ngComponentOutlet="maximizeIconTemplate"></ng-container>
            </ng-template>
            <ng-template #minimizeicon *ngIf="minimizeIconTemplate">
                <ng-container *ngComponentOutlet="minimizeIconTemplate"></ng-container>
            </ng-template>

            <ng-template pDynamicDialogContent *ngIf="!contentTemplate"></ng-template>
            <div *ngIf="ddconfig.footer && !footerTemplate">{{ ddconfig.footer }}</div>
        </p-dialog>
    `,
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation.None,
      providers: [DynamicDialogStyle, {
        provide: DYNAMIC_DIALOG_INSTANCE,
        useExisting: DynamicDialog
      }, {
        provide: PARENT_INSTANCE,
        useExisting: DynamicDialog
      }],
      hostDirectives: [Bind]
    }]
  }], () => [{
    type: DynamicDialogConfig
  }, {
    type: DynamicDialogRef
  }], {
    insertionPoint: [{
      type: ViewChild,
      args: [DynamicDialogContent]
    }],
    dialog: [{
      type: ViewChild,
      args: [Dialog]
    }]
  });
})();
var DynamicDialogModule = class _DynamicDialogModule {
  static \u0275fac = function DynamicDialogModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DynamicDialogModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _DynamicDialogModule,
    imports: [DynamicDialog, SharedModule],
    exports: [DynamicDialog, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [DynamicDialog, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamicDialogModule, [{
    type: NgModule,
    args: [{
      imports: [DynamicDialog, SharedModule],
      exports: [DynamicDialog, SharedModule]
    }]
  }], null, null);
})();
var DynamicDialogInjector = class {
  _parentInjector;
  _additionalTokens;
  constructor(_parentInjector, _additionalTokens) {
    this._parentInjector = _parentInjector;
    this._additionalTokens = _additionalTokens;
  }
  get(token, notFoundValue, options) {
    const value = this._additionalTokens.get(token);
    if (value) return value;
    return this._parentInjector.get(token, notFoundValue);
  }
};
var DialogService = class _DialogService {
  appRef;
  injector;
  document;
  dialogComponentRefMap = /* @__PURE__ */ new Map();
  constructor(appRef, injector, document2) {
    this.appRef = appRef;
    this.injector = injector;
    this.document = document2;
  }
  /**
   * Displays the dialog using the dynamic dialog object options.
   * @param {*} componentType - Dynamic component for content template.
   * @param {DynamicDialogConfig} config - DynamicDialog object.
   * @returns {DynamicDialogRef} DynamicDialog instance.
   * @group Method
   */
  open(componentType, config) {
    if (!this.duplicationPermission(componentType, config)) {
      return null;
    }
    const dialogRef = this.appendDialogComponentToBody(config, componentType);
    const componentRefInstance = this.dialogComponentRefMap.get(dialogRef);
    if (componentRefInstance) {
      componentRefInstance.instance.childComponentType = componentType;
      componentRefInstance.instance.inputValues = config.inputValues || {};
    }
    return dialogRef;
  }
  /**
   * Returns the dynamic dialog component instance.
   * @param {DynamicDialogRef} ref - DynamicDialog instance.
   * @group Method
   */
  getInstance(ref) {
    return this.dialogComponentRefMap.get(ref)?.instance;
  }
  appendDialogComponentToBody(config, componentType) {
    const map2 = /* @__PURE__ */ new WeakMap();
    map2.set(DynamicDialogConfig, config);
    const dialogRef = new DynamicDialogRef();
    map2.set(DynamicDialogRef, dialogRef);
    const sub = dialogRef.onClose.subscribe(() => {
      this.dialogComponentRefMap.get(dialogRef)?.instance.close();
    });
    const destroySub = dialogRef.onDestroy.subscribe(() => {
      this.removeDialogComponentFromBody(dialogRef);
      destroySub.unsubscribe();
      sub.unsubscribe();
    });
    const componentRef = createComponent(DynamicDialog, {
      environmentInjector: this.appRef.injector,
      elementInjector: new DynamicDialogInjector(this.injector, map2)
    });
    this.appRef.attachView(componentRef.hostView);
    const domElem = componentRef.hostView.rootNodes[0];
    if (!config.appendTo || config.appendTo === "body") {
      this.document.body.appendChild(domElem);
    } else {
      ut(config.appendTo, domElem);
    }
    this.dialogComponentRefMap.set(dialogRef, componentRef);
    return dialogRef;
  }
  removeDialogComponentFromBody(dialogRef) {
    if (!dialogRef || !this.dialogComponentRefMap.has(dialogRef)) {
      return;
    }
    const dialogComponentRef = this.dialogComponentRefMap.get(dialogRef);
    if (dialogComponentRef) {
      this.appRef.detachView(dialogComponentRef.hostView);
      dialogComponentRef.destroy();
      dialogComponentRef.changeDetectorRef.detectChanges();
    }
    this.dialogComponentRefMap.delete(dialogRef);
  }
  duplicationPermission(componentType, config) {
    if (config.duplicate) {
      return true;
    }
    let permission = true;
    for (const [key, value] of this.dialogComponentRefMap) {
      if (value.instance.childComponentType === componentType) {
        permission = false;
        break;
      }
    }
    return permission;
  }
  static \u0275fac = function DialogService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DialogService)(\u0275\u0275inject(ApplicationRef), \u0275\u0275inject(Injector), \u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DialogService,
    factory: _DialogService.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DialogService, [{
    type: Injectable
  }], () => [{
    type: ApplicationRef
  }, {
    type: Injector
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();

// node_modules/@primeuix/styles/dist/rating/index.mjs
var style = "\n    .p-rating {\n        position: relative;\n        display: inline-flex;\n        align-items: center;\n        gap: dt('rating.gap');\n    }\n\n    .p-rating-option {\n        display: inline-flex;\n        align-items: center;\n        cursor: pointer;\n        outline-color: transparent;\n        border-radius: 50%;\n        transition:\n            background dt('rating.transition.duration'),\n            color dt('rating.transition.duration'),\n            border-color dt('rating.transition.duration'),\n            outline-color dt('rating.transition.duration'),\n            box-shadow dt('rating.transition.duration');\n    }\n\n    .p-rating-option.p-focus-visible {\n        box-shadow: dt('rating.focus.ring.shadow');\n        outline: dt('rating.focus.ring.width') dt('rating.focus.ring.style') dt('rating.focus.ring.color');\n        outline-offset: dt('rating.focus.ring.offset');\n    }\n\n    .p-rating-icon {\n        color: dt('rating.icon.color');\n        transition:\n            background dt('rating.transition.duration'),\n            color dt('rating.transition.duration'),\n            border-color dt('rating.transition.duration'),\n            outline-color dt('rating.transition.duration'),\n            box-shadow dt('rating.transition.duration');\n        font-size: dt('rating.icon.size');\n        width: dt('rating.icon.size');\n        height: dt('rating.icon.size');\n    }\n\n    .p-rating:not(.p-disabled):not(.p-readonly) .p-rating-option:hover .p-rating-icon {\n        color: dt('rating.icon.hover.color');\n    }\n\n    .p-rating-option-active .p-rating-icon {\n        color: dt('rating.icon.active.color');\n    }\n\n    .p-rating-icon.p-invalid {\n        /* @todo */\n        stroke: dt('rating.invalid.icon.color');\n    }\n\n    .p-rating.p-readonly .p-rating-option {\n        cursor: not-allowed;\n    }\n";

// node_modules/primeng/fesm2022/primeng-rating.mjs
var _c07 = ["onicon"];
var _c1 = ["officon"];
var _c2 = (a0, a1) => ({
  star: a0,
  value: a1
});
var _c3 = (a0, a1) => ({
  $implicit: a0,
  class: a1
});
function Rating_ng_template_0_Conditional_3_Conditional_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Rating_ng_template_0_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Rating_ng_template_0_Conditional_3_Conditional_0_ng_container_0_Template, 1, 0, "ng-container", 4);
  }
  if (rf & 2) {
    const star_r2 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.onIconTemplate || ctx_r2._onIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c3, star_r2 + 1, ctx_r2.cx("onIcon")));
  }
}
function Rating_ng_template_0_Conditional_3_Conditional_1_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(4);
    \u0275\u0275classMap(ctx_r2.cx("onIcon"));
    \u0275\u0275property("ngStyle", ctx_r2.iconOnStyle)("ngClass", ctx_r2.iconOnClass)("pBind", ctx_r2.ptm("onIcon"));
  }
}
function Rating_ng_template_0_Conditional_3_Conditional_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 8);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(4);
    \u0275\u0275classMap(ctx_r2.cx("onIcon"));
    \u0275\u0275property("ngStyle", ctx_r2.iconOnStyle)("pBind", ctx_r2.ptm("onIcon"));
  }
}
function Rating_ng_template_0_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Rating_ng_template_0_Conditional_3_Conditional_1_span_0_Template, 1, 5, "span", 5)(1, Rating_ng_template_0_Conditional_3_Conditional_1__svg_svg_1_Template, 1, 4, "svg", 6);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngIf", ctx_r2.iconOnClass);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r2.iconOnClass);
  }
}
function Rating_ng_template_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, Rating_ng_template_0_Conditional_3_Conditional_0_Template, 1, 5, "ng-container")(1, Rating_ng_template_0_Conditional_3_Conditional_1_Template, 2, 2);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(ctx_r2.onIconTemplate || ctx_r2._onIconTemplate ? 0 : 1);
  }
}
function Rating_ng_template_0_Conditional_4_Conditional_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Rating_ng_template_0_Conditional_4_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Rating_ng_template_0_Conditional_4_Conditional_0_ng_container_0_Template, 1, 0, "ng-container", 4);
  }
  if (rf & 2) {
    const star_r2 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.offIconTemplate || ctx_r2._offIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c3, star_r2 + 1, ctx_r2.cx("offIcon")));
  }
}
function Rating_ng_template_0_Conditional_4_Conditional_1_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 7);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(4);
    \u0275\u0275classMap(ctx_r2.cx("offIcon"));
    \u0275\u0275property("ngStyle", ctx_r2.iconOffStyle)("ngClass", ctx_r2.iconOffClass)("pBind", ctx_r2.ptm("offIcon"));
  }
}
function Rating_ng_template_0_Conditional_4_Conditional_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 10);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(4);
    \u0275\u0275classMap(ctx_r2.cx("offIcon"));
    \u0275\u0275property("ngStyle", ctx_r2.iconOffStyle)("pBind", ctx_r2.ptm("offIcon"));
  }
}
function Rating_ng_template_0_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Rating_ng_template_0_Conditional_4_Conditional_1_span_0_Template, 1, 5, "span", 5)(1, Rating_ng_template_0_Conditional_4_Conditional_1__svg_svg_1_Template, 1, 4, "svg", 9);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngIf", ctx_r2.iconOffClass);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r2.iconOffClass);
  }
}
function Rating_ng_template_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, Rating_ng_template_0_Conditional_4_Conditional_0_Template, 1, 5, "ng-container")(1, Rating_ng_template_0_Conditional_4_Conditional_1_Template, 2, 2);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(ctx_r2.offIconTemplate || ctx_r2._offIconTemplate ? 0 : 1);
  }
}
function Rating_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", function Rating_ng_template_0_Template_div_click_0_listener($event) {
      const star_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onOptionClick($event, star_r2 + 1));
    });
    \u0275\u0275elementStart(1, "span", 2)(2, "input", 3);
    \u0275\u0275listener("focus", function Rating_ng_template_0_Template_input_focus_2_listener($event) {
      const star_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onInputFocus($event, star_r2 + 1));
    })("blur", function Rating_ng_template_0_Template_input_blur_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onInputBlur($event));
    })("change", function Rating_ng_template_0_Template_input_change_2_listener($event) {
      const star_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onChange($event, star_r2 + 1));
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275conditionalCreate(3, Rating_ng_template_0_Conditional_3_Template, 2, 1)(4, Rating_ng_template_0_Conditional_4_Template, 2, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const star_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r2.cx("option", \u0275\u0275pureFunction2(16, _c2, star_r2, ctx_r2.value)));
    \u0275\u0275property("pBind", ctx_r2.ptm("option"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r2.ptm("hiddenOptionInputContainer"));
    \u0275\u0275attribute("data-p-hidden-accessible", true);
    \u0275\u0275advance();
    \u0275\u0275property("value", star_r2 + 1)("checked", ctx_r2.value === star_r2 + 1)("pAutoFocus", ctx_r2.autofocus)("pBind", ctx_r2.ptm("hiddenOptionInput"));
    \u0275\u0275attribute("name", ctx_r2.name() || ctx_r2.nameattr + "_name")("value", ctx_r2.modelValue())("required", ctx_r2.required() ? "" : void 0)("readonly", ctx_r2.readonly ? "" : void 0)("disabled", ctx_r2.$disabled() ? "" : void 0)("aria-label", ctx_r2.starAriaLabel(star_r2 + 1));
    \u0275\u0275advance();
    \u0275\u0275conditional(star_r2 + 1 <= ctx_r2.value ? 3 : 4);
  }
}
var style2 = (
  /*css*/
  `
    ${style}

    /* For PrimeNG */
    p-rating.ng-invalid.ng-dirty > .p-rating > .p-rating-icon {
        stroke: dt('rating.invalid.icon.color');
    }
`
);
var classes = {
  root: ({
    instance
  }) => ["p-rating", {
    "p-readonly": instance.readonly,
    "p-disabled": instance.$disabled()
  }],
  option: ({
    instance,
    star,
    value
  }) => ["p-rating-option", {
    "p-rating-option-active": star + 1 <= value,
    "p-focus-visible": star + 1 === instance.focusedOptionIndex() && instance.isFocusVisibleItem
  }],
  onIcon: ({
    instance
  }) => ["p-rating-icon p-rating-on-icon", {
    "p-invalid": instance.invalid()
  }],
  offIcon: ({
    instance
  }) => ["p-rating-icon p-rating-off-icon", {
    "p-invalid": instance.invalid()
  }]
};
var RatingStyle = class _RatingStyle extends BaseStyle {
  name = "rating";
  style = style2;
  classes = classes;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275RatingStyle_BaseFactory;
    return function RatingStyle_Factory(__ngFactoryType__) {
      return (\u0275RatingStyle_BaseFactory || (\u0275RatingStyle_BaseFactory = \u0275\u0275getInheritedFactory(_RatingStyle)))(__ngFactoryType__ || _RatingStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RatingStyle,
    factory: _RatingStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingStyle, [{
    type: Injectable
  }], null, null);
})();
var RatingClasses;
(function(RatingClasses2) {
  RatingClasses2["root"] = "p-rating";
  RatingClasses2["option"] = "p-rating-option";
  RatingClasses2["onIcon"] = "p-rating-on-icon";
  RatingClasses2["offIcon"] = "p-rating-off-icon";
})(RatingClasses || (RatingClasses = {}));
var RATING_INSTANCE = new InjectionToken("RATING_INSTANCE");
var RATING_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => Rating),
  multi: true
};
var Rating = class _Rating extends BaseEditableHolder {
  $pcRating = inject(RATING_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * When present, changing the value is not possible.
   * @group Props
   */
  readonly;
  /**
   * Number of stars.
   * @group Props
   */
  stars = 5;
  /**
   * Style class of the on icon.
   * @group Props
   */
  iconOnClass;
  /**
   * Inline style of the on icon.
   * @group Props
   */
  iconOnStyle;
  /**
   * Style class of the off icon.
   * @group Props
   */
  iconOffClass;
  /**
   * Inline style of the off icon.
   * @group Props
   */
  iconOffStyle;
  /**
   * When present, it specifies that the component should automatically get focus on load.
   * @group Props
   */
  autofocus;
  /**
   * Emitted on value change.
   * @param {RatingRateEvent} value - Custom rate event.
   * @group Emits
   */
  onRate = new EventEmitter();
  /**
   * Emitted when the rating receives focus.
   * @param {Event} value - Browser event.
   * @group Emits
   */
  onFocus = new EventEmitter();
  /**
   * Emitted when the rating loses focus.
   * @param {Event} value - Browser event.
   * @group Emits
   */
  onBlur = new EventEmitter();
  /**
   * Custom on icon template.
   * @param {RatingIconTemplateContext} context - icon context.
   * @see {@link RatingIconTemplateContext}
   * @group Templates
   */
  onIconTemplate;
  /**
   * Custom off icon template.
   * @param {RatingIconTemplateContext} context - icon context.
   * @see {@link RatingIconTemplateContext}
   * @group Templates
   */
  offIconTemplate;
  templates;
  value;
  starsArray;
  isFocusVisibleItem = true;
  focusedOptionIndex = signal(-1, ...ngDevMode ? [{
    debugName: "focusedOptionIndex"
  }] : []);
  nameattr;
  _componentStyle = inject(RatingStyle);
  _onIconTemplate;
  _offIconTemplate;
  onInit() {
    this.nameattr = this.nameattr || s2("pn_id_");
    this.starsArray = [];
    for (let i = 0; i < this.stars; i++) {
      this.starsArray[i] = i;
    }
  }
  onAfterContentInit() {
    this.templates.forEach((item) => {
      switch (item.getType()) {
        case "onicon":
          this._onIconTemplate = item.template;
          break;
        case "officon":
          this._offIconTemplate = item.template;
          break;
      }
    });
  }
  onOptionClick(event, value) {
    if (!this.readonly && !this.$disabled()) {
      this.onOptionSelect(event, value);
      this.isFocusVisibleItem = false;
      const firstFocusableEl = vt(event.currentTarget, "");
      firstFocusableEl && bt(firstFocusableEl);
    }
  }
  onOptionSelect(event, value) {
    if (!this.readonly && !this.$disabled()) {
      if (this.focusedOptionIndex() === value || value === this.value) {
        this.focusedOptionIndex.set(-1);
        this.updateModel(event, null);
      } else {
        this.focusedOptionIndex.set(value);
        this.updateModel(event, value || null);
      }
    }
  }
  onChange(event, value) {
    this.onOptionSelect(event, value);
    this.isFocusVisibleItem = true;
  }
  onInputBlur(event) {
    this.focusedOptionIndex.set(-1);
    this.onBlur.emit(event);
  }
  onInputFocus(event, value) {
    if (!this.readonly && !this.$disabled()) {
      this.focusedOptionIndex.set(value);
      this.isFocusVisibleItem = event.sourceCapabilities?.firesTouchEvents === false;
      this.onFocus.emit(event);
    }
  }
  updateModel(event, value) {
    this.writeValue(value);
    this.onModelChange(this.value);
    this.onModelTouched();
    this.onRate.emit({
      originalEvent: event,
      value
    });
  }
  starAriaLabel(value) {
    return value === 1 ? this.config.translation.aria?.star : this.config.translation.aria?.stars?.replace(/{star}/g, value);
  }
  getIconTemplate(i) {
    return !this.value || i >= this.value ? this.offIconTemplate || this._offIconTemplate : this.onIconTemplate || this.offIconTemplate;
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value, setModelValue) {
    this.value = value;
    setModelValue(value);
  }
  get isCustomIcon() {
    return !!(this.onIconTemplate || this._onIconTemplate || this.offIconTemplate || this._offIconTemplate);
  }
  get dataP() {
    return this.cn({
      readonly: this.readonly,
      disabled: this.$disabled()
    });
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275Rating_BaseFactory;
    return function Rating_Factory(__ngFactoryType__) {
      return (\u0275Rating_BaseFactory || (\u0275Rating_BaseFactory = \u0275\u0275getInheritedFactory(_Rating)))(__ngFactoryType__ || _Rating);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _Rating,
    selectors: [["p-rating"]],
    contentQueries: function Rating_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c07, 4);
        \u0275\u0275contentQuery(dirIndex, _c1, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.onIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.offIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    hostVars: 3,
    hostBindings: function Rating_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("data-p", ctx.dataP);
        \u0275\u0275classMap(ctx.cx("root"));
      }
    },
    inputs: {
      readonly: [2, "readonly", "readonly", booleanAttribute],
      stars: [2, "stars", "stars", numberAttribute],
      iconOnClass: "iconOnClass",
      iconOnStyle: "iconOnStyle",
      iconOffClass: "iconOffClass",
      iconOffStyle: "iconOffStyle",
      autofocus: [2, "autofocus", "autofocus", booleanAttribute]
    },
    outputs: {
      onRate: "onRate",
      onFocus: "onFocus",
      onBlur: "onBlur"
    },
    features: [\u0275\u0275ProvidersFeature([RATING_VALUE_ACCESSOR, RatingStyle, {
      provide: RATING_INSTANCE,
      useExisting: _Rating
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _Rating
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["ngFor", "", 3, "ngForOf"], [3, "click", "pBind"], [1, "p-hidden-accessible", 3, "pBind"], ["type", "radio", 3, "focus", "blur", "change", "value", "checked", "pAutoFocus", "pBind"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "class", "ngStyle", "ngClass", "pBind", 4, "ngIf"], ["data-p-icon", "star-fill", 3, "ngStyle", "class", "pBind", 4, "ngIf"], [3, "ngStyle", "ngClass", "pBind"], ["data-p-icon", "star-fill", 3, "ngStyle", "pBind"], ["data-p-icon", "star", 3, "ngStyle", "class", "pBind", 4, "ngIf"], ["data-p-icon", "star", 3, "ngStyle", "pBind"]],
    template: function Rating_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275template(0, Rating_ng_template_0_Template, 5, 19, "ng-template", 0);
      }
      if (rf & 2) {
        \u0275\u0275property("ngForOf", ctx.starsArray);
      }
    },
    dependencies: [CommonModule, NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, AutoFocus, StarFillIcon, StarIcon, SharedModule, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Rating, [{
    type: Component,
    args: [{
      selector: "p-rating",
      imports: [CommonModule, AutoFocus, StarFillIcon, StarIcon, SharedModule, BindModule],
      standalone: true,
      template: `
        <ng-template ngFor [ngForOf]="starsArray" let-star let-i="index">
            <div [class]="cx('option', { star, value })" (click)="onOptionClick($event, star + 1)" [pBind]="ptm('option')">
                <span class="p-hidden-accessible" [attr.data-p-hidden-accessible]="true" [pBind]="ptm('hiddenOptionInputContainer')">
                    <input
                        type="radio"
                        [value]="star + 1"
                        [attr.name]="name() || nameattr + '_name'"
                        [attr.value]="modelValue()"
                        [attr.required]="required() ? '' : undefined"
                        [attr.readonly]="readonly ? '' : undefined"
                        [attr.disabled]="$disabled() ? '' : undefined"
                        [checked]="value === star + 1"
                        [attr.aria-label]="starAriaLabel(star + 1)"
                        (focus)="onInputFocus($event, star + 1)"
                        (blur)="onInputBlur($event)"
                        (change)="onChange($event, star + 1)"
                        [pAutoFocus]="autofocus"
                        [pBind]="ptm('hiddenOptionInput')"
                    />
                </span>
                @if (star + 1 <= value) {
                    @if (onIconTemplate || _onIconTemplate) {
                        <ng-container *ngTemplateOutlet="onIconTemplate || _onIconTemplate; context: { $implicit: star + 1, class: cx('onIcon') }"></ng-container>
                    } @else {
                        <span [class]="cx('onIcon')" *ngIf="iconOnClass" [ngStyle]="iconOnStyle" [ngClass]="iconOnClass" [pBind]="ptm('onIcon')"></span>
                        <svg data-p-icon="star-fill" *ngIf="!iconOnClass" [ngStyle]="iconOnStyle" [class]="cx('onIcon')" [pBind]="ptm('onIcon')" />
                    }
                } @else {
                    @if (offIconTemplate || _offIconTemplate) {
                        <ng-container *ngTemplateOutlet="offIconTemplate || _offIconTemplate; context: { $implicit: star + 1, class: cx('offIcon') }"></ng-container>
                    } @else {
                        <span [class]="cx('offIcon')" *ngIf="iconOffClass" [ngStyle]="iconOffStyle" [ngClass]="iconOffClass" [pBind]="ptm('offIcon')"></span>
                        <svg data-p-icon="star" *ngIf="!iconOffClass" [ngStyle]="iconOffStyle" [class]="cx('offIcon')" [pBind]="ptm('offIcon')" />
                    }
                }
            </div>
        </ng-template>
    `,
      providers: [RATING_VALUE_ACCESSOR, RatingStyle, {
        provide: RATING_INSTANCE,
        useExisting: Rating
      }, {
        provide: PARENT_INSTANCE,
        useExisting: Rating
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cx('root')",
        "[attr.data-p]": "dataP"
      },
      hostDirectives: [Bind]
    }]
  }], null, {
    readonly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    stars: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    iconOnClass: [{
      type: Input
    }],
    iconOnStyle: [{
      type: Input
    }],
    iconOffClass: [{
      type: Input
    }],
    iconOffStyle: [{
      type: Input
    }],
    autofocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    onRate: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    onBlur: [{
      type: Output
    }],
    onIconTemplate: [{
      type: ContentChild,
      args: ["onicon", {
        descendants: false
      }]
    }],
    offIconTemplate: [{
      type: ContentChild,
      args: ["officon", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }]
  });
})();
var RatingModule = class _RatingModule {
  static \u0275fac = function RatingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _RatingModule,
    imports: [Rating, SharedModule],
    exports: [Rating, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [Rating, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingModule, [{
    type: NgModule,
    args: [{
      imports: [Rating, SharedModule],
      exports: [Rating, SharedModule]
    }]
  }], null, null);
})();

// src/app/shared/services/forms/modal-form.service.ts
var ModalFormService = class _ModalFormService {
  dialogService = inject(DialogService);
  messageService = inject(MessageService);
  activeDialogRef = null;
  /**
   * Opens a modal for adding or editing a list item
   * Returns an Observable that emits the submitted data
   */
  openListItemModal(config) {
    const { modalConfig, itemData, editIndex, destroyRef } = config;
    return new Observable((observer) => {
      this.activeDialogRef?.close();
      const modalHeader = this.generateModalHeader(modalConfig.modalTitle, itemData, isDefined(editIndex));
      const modalFields = this.resolveModalFields(modalConfig.modalFields, itemData);
      let modalFieldsFn;
      if (isFunction(modalConfig.modalFields)) {
        modalFieldsFn = () => this.resolveModalFields(modalConfig.modalFields, itemData);
      }
      this.activeDialogRef = this.dialogService.open(modalConfig.modalComponent, {
        header: modalHeader,
        contentStyle: {
          "max-height": "80vh",
          overflow: "auto",
          "min-width": "40rem"
        },
        style: { width: "auto" },
        baseZIndex: 1e4,
        focusOnShow: false,
        modal: true,
        duplicate: true,
        data: {
          fields: modalFields,
          fieldsFn: modalFieldsFn,
          initialData: itemData,
          subHeader: modalConfig.subHeader,
          actions: this.buildModalActions(modalConfig, isDefined(editIndex))
        }
      });
      if (this.activeDialogRef) {
        this.activeDialogRef.onClose.pipe(takeUntilDestroyed(destroyRef)).subscribe((submittedData) => {
          this.activeDialogRef = null;
          if (isDefined(submittedData)) {
            const result = {
              data: submittedData,
              isEdit: isDefined(editIndex),
              index: editIndex
            };
            observer.next(result);
            observer.complete();
          } else {
            observer.complete();
          }
        });
      }
    });
  }
  /**
   * Generates the modal header based on config and operation type
   */
  generateModalHeader(titleConfig, itemData, isEdit) {
    if (isFunction(titleConfig)) {
      return titleConfig(itemData);
    }
    if (isEdit) {
      return titleConfig.replace(/^Add\s+/, "Edit ") === titleConfig ? `Edit ${titleConfig}` : titleConfig.replace(/^Add\s+/, "Edit ");
    }
    return titleConfig;
  }
  /**
   * Resolves modal fields - handles both array and function formats
   */
  resolveModalFields(fieldsConfig, itemData) {
    if (isFunction(fieldsConfig)) {
      return fieldsConfig(itemData);
    }
    return fieldsConfig;
  }
  /**
   * Builds the modal action buttons
   */
  buildModalActions(modalConfig, isEdit) {
    return [
      {
        label: "Cancel",
        severity: "secondary",
        type: "cancel",
        action: () => this.activeDialogRef?.close()
      },
      {
        label: isEdit ? "Update" : "Add",
        severity: "primary",
        type: "submit",
        action: async (submittedData) => {
          if (!this.activeDialogRef)
            return;
          if (isFunction(modalConfig.onSubmit)) {
            try {
              const result = await modalConfig.onSubmit(submittedData.value, this.activeDialogRef);
              if (result !== false && isDefined(this.activeDialogRef)) {
                this.activeDialogRef.close(submittedData.getRawValue());
              }
            } catch (error) {
              console.error("Error in modalConfig.onSubmit:", error);
            }
          } else {
            this.activeDialogRef.close(submittedData.getRawValue());
          }
        }
      }
    ];
  }
  /**
   * Formats a list item for display using the configured formatter or defaults
   */
  formatListItem(item, formatter) {
    if (formatter) {
      try {
        return formatter(item);
      } catch (error) {
        console.error("Error in listItemFormatter:", error);
        return this.defaultItemFormatter(item);
      }
    }
    return this.defaultItemFormatter(item);
  }
  /**
   * Default formatter that intelligently picks common field names
   * Falls back to stringifying the first property if no common names found
   */
  defaultItemFormatter(item) {
    if (isNullOrUndefined(item))
      return { id: "", display: "" };
    const primitiveResult = this.formatPrimitive(item);
    if (primitiveResult)
      return primitiveResult;
    if (typeof item !== "object") {
      const fallback = JSON.stringify(item);
      return { id: fallback, display: fallback };
    }
    const obj = item;
    const displayFields = ["name", "label", "title", "displayName", "display"];
    for (const field of displayFields) {
      const value = obj[field];
      if (typeof value === "string" && value.length > 0) {
        const idField = "id" in obj ? String(obj["id"]) : String(value);
        return {
          id: idField,
          display: value
        };
      }
    }
    const firstKey = Object.keys(obj)[0];
    if (firstKey) {
      const firstValue = obj[firstKey];
      const displayValue = typeof firstValue === "string" ? firstValue : JSON.stringify(firstValue ?? "[Item]");
      return {
        id: "id" in obj ? String(obj["id"]) : firstKey,
        display: displayValue
      };
    }
    return { id: "", display: "[Item]" };
  }
  /**
   * Formats primitive values into a FieldConfiguration if possible
   * Returns null for non-primitive values so caller can continue processing
   */
  formatPrimitive(item) {
    switch (typeof item) {
      case "string":
        return { id: item, display: item };
      case "number": {
        const numeric = String(item);
        return { id: numeric, display: numeric };
      }
      case "boolean": {
        const boolString = item ? "true" : "false";
        return { id: boolString, display: boolString };
      }
      case "bigint": {
        const bigIntString = item.toString();
        return { id: bigIntString, display: bigIntString };
      }
      case "symbol": {
        const symbolString = item.toString();
        return { id: symbolString, display: symbolString };
      }
      case "undefined":
        return { id: "", display: "" };
      default:
        return null;
    }
  }
  /**
   * Shows a notification message after modal submission
   */
  showSubmissionNotification(isEdit, hideSaveNotification) {
    if (hideSaveNotification === true)
      return;
    const summary = isEdit ? "Item Updated" : "Item Added";
    this.messageService.add({
      severity: "info",
      summary,
      detail: 'Click "Save" to save your changes.',
      life: 5e3
    });
  }
  /**
   * Shows a notification for item deletion
   */
  showDeletionNotification() {
    this.messageService.add({
      severity: "info",
      summary: "Item Deleted",
      detail: 'Click "Save" to save your changes.'
    });
  }
  /**
   * Closes any active dialog
   */
  closeActiveDialog() {
    this.activeDialogRef?.close();
    this.activeDialogRef = null;
  }
  static \u0275fac = function ModalFormService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ModalFormService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ModalFormService, factory: _ModalFormService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalFormService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/colorpicker/index.mjs
var style3 = "\n    .p-colorpicker {\n        display: inline-block;\n        position: relative;\n    }\n\n    .p-colorpicker-dragging {\n        cursor: pointer;\n    }\n\n    .p-colorpicker-preview {\n        width: dt('colorpicker.preview.width');\n        height: dt('colorpicker.preview.height');\n        padding: 0;\n        border: 0 none;\n        border-radius: dt('colorpicker.preview.border.radius');\n        transition:\n            background dt('colorpicker.transition.duration'),\n            color dt('colorpicker.transition.duration'),\n            border-color dt('colorpicker.transition.duration'),\n            outline-color dt('colorpicker.transition.duration'),\n            box-shadow dt('colorpicker.transition.duration');\n        outline-color: transparent;\n        cursor: pointer;\n    }\n\n    .p-colorpicker-preview:enabled:focus-visible {\n        border-color: dt('colorpicker.preview.focus.border.color');\n        box-shadow: dt('colorpicker.preview.focus.ring.shadow');\n        outline: dt('colorpicker.preview.focus.ring.width') dt('colorpicker.preview.focus.ring.style') dt('colorpicker.preview.focus.ring.color');\n        outline-offset: dt('colorpicker.preview.focus.ring.offset');\n    }\n\n    .p-colorpicker-panel {\n        background: dt('colorpicker.panel.background');\n        border: 1px solid dt('colorpicker.panel.border.color');\n        border-radius: dt('colorpicker.panel.border.radius');\n        box-shadow: dt('colorpicker.panel.shadow');\n        width: 193px;\n        height: 166px;\n        position: absolute;\n        top: 0;\n        left: 0;\n    }\n\n    .p-colorpicker-panel-inline {\n        box-shadow: none;\n        position: static;\n    }\n\n    .p-colorpicker-content {\n        position: relative;\n    }\n\n    .p-colorpicker-color-selector {\n        width: 150px;\n        height: 150px;\n        inset-block-start: 8px;\n        inset-inline-start: 8px;\n        position: absolute;\n    }\n\n    .p-colorpicker-color-background {\n        width: 100%;\n        height: 100%;\n        background: linear-gradient(to top, #000 0%, rgba(0, 0, 0, 0) 100%), linear-gradient(to right, #fff 0%, rgba(255, 255, 255, 0) 100%);\n    }\n\n    .p-colorpicker-color-handle {\n        position: absolute;\n        inset-block-start: 0px;\n        inset-inline-start: 150px;\n        border-radius: 100%;\n        width: 10px;\n        height: 10px;\n        border-width: 1px;\n        border-style: solid;\n        margin: -5px 0 0 -5px;\n        cursor: pointer;\n        opacity: 0.85;\n        border-color: dt('colorpicker.handle.color');\n    }\n\n    .p-colorpicker-hue {\n        width: 17px;\n        height: 150px;\n        inset-block-start: 8px;\n        inset-inline-start: 167px;\n        position: absolute;\n        opacity: 0.85;\n        background: linear-gradient(0deg, red 0, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, red);\n    }\n\n    .p-colorpicker-hue-handle {\n        position: absolute;\n        inset-block-start: 150px;\n        inset-inline-start: 0px;\n        width: 21px;\n        margin-inline-start: -2px;\n        margin-block-start: -5px;\n        height: 10px;\n        border-width: 2px;\n        border-style: solid;\n        opacity: 0.85;\n        cursor: pointer;\n        border-color: dt('colorpicker.handle.color');\n    }\n";

// node_modules/primeng/fesm2022/primeng-colorpicker.mjs
var _c08 = ["input"];
var _c12 = ["overlay"];
var _c22 = ["colorSelector"];
var _c32 = ["colorHandle"];
var _c4 = ["hue"];
var _c5 = ["hueHandle"];
function ColorPicker_input_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 9, 2);
    \u0275\u0275listener("click", function ColorPicker_input_0_Template_input_click_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onInputClick());
    })("keydown", function ColorPicker_input_0_Template_input_keydown_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onInputKeydown($event));
    })("focus", function ColorPicker_input_0_Template_input_focus_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onInputFocus());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r2.cx("preview"));
    \u0275\u0275styleProp("background-color", ctx_r2.inputBgColor);
    \u0275\u0275property("pAutoFocus", ctx_r2.autofocus)("pBind", ctx_r2.ptm("preview"));
    \u0275\u0275attribute("tabindex", ctx_r2.tabindex)("disabled", ctx_r2.$disabled() ? "" : void 0)("id", ctx_r2.inputId)("aria-label", ctx_r2.ariaLabel);
  }
}
function ColorPicker_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 10)(1, "div", 10)(2, "div", 11, 3);
    \u0275\u0275listener("touchstart", function ColorPicker_ng_template_3_Template_div_touchstart_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onColorDragStart($event));
    })("touchmove", function ColorPicker_ng_template_3_Template_div_touchmove_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDrag($event));
    })("touchend", function ColorPicker_ng_template_3_Template_div_touchend_2_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDragEnd());
    })("mousedown", function ColorPicker_ng_template_3_Template_div_mousedown_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onColorMousedown($event));
    });
    \u0275\u0275elementStart(4, "div", 10);
    \u0275\u0275element(5, "div", 10, 4);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "div", 12, 5);
    \u0275\u0275listener("mousedown", function ColorPicker_ng_template_3_Template_div_mousedown_7_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onHueMousedown($event));
    })("touchstart", function ColorPicker_ng_template_3_Template_div_touchstart_7_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onHueDragStart($event));
    })("touchmove", function ColorPicker_ng_template_3_Template_div_touchmove_7_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDrag($event));
    })("touchend", function ColorPicker_ng_template_3_Template_div_touchend_7_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDragEnd());
    });
    \u0275\u0275element(9, "div", 10, 6);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r2.cx("panel"));
    \u0275\u0275property("pBind", ctx_r2.ptm("panel"));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("content"));
    \u0275\u0275property("pBind", ctx_r2.ptm("content"));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("colorSelector"));
    \u0275\u0275property("pBind", ctx_r2.ptm("colorSelector"));
    \u0275\u0275advance(2);
    \u0275\u0275classMap(ctx_r2.cx("colorBackground"));
    \u0275\u0275property("pBind", ctx_r2.ptm("colorBackground"));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("colorHandle"));
    \u0275\u0275property("pBind", ctx_r2.ptm("colorHandle"));
    \u0275\u0275advance(2);
    \u0275\u0275classMap(ctx_r2.cx("hue"));
    \u0275\u0275property("pBind", ctx_r2.ptm("hue"));
    \u0275\u0275advance(2);
    \u0275\u0275classMap(ctx_r2.cx("hueHandle"));
    \u0275\u0275property("pBind", ctx_r2.ptm("hueHandle"));
  }
}
var classes2 = {
  root: ({
    instance
  }) => ["p-colorpicker p-component", {
    "p-colorpicker-overlay": !instance.inline,
    "p-colorpicker-dragging": instance.colorDragging || instance.hueDragging
  }],
  preview: ({
    instance
  }) => ["p-colorpicker-preview", {
    "p-disabled": instance.$disabled()
  }],
  panel: ({
    instance
  }) => ["p-colorpicker-panel", {
    "p-colorpicker-panel-inline": instance.inline,
    "p-disabled": instance.$disabled()
  }],
  content: "p-colorpicker-content",
  colorSelector: "p-colorpicker-color-selector",
  colorBackground: "p-colorpicker-color-background",
  colorHandle: "p-colorpicker-color-handle",
  hue: "p-colorpicker-hue",
  hueHandle: "p-colorpicker-hue-handle"
};
var ColorPickerStyle = class _ColorPickerStyle extends BaseStyle {
  name = "colorpicker";
  style = style3;
  classes = classes2;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275ColorPickerStyle_BaseFactory;
    return function ColorPickerStyle_Factory(__ngFactoryType__) {
      return (\u0275ColorPickerStyle_BaseFactory || (\u0275ColorPickerStyle_BaseFactory = \u0275\u0275getInheritedFactory(_ColorPickerStyle)))(__ngFactoryType__ || _ColorPickerStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ColorPickerStyle,
    factory: _ColorPickerStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerStyle, [{
    type: Injectable
  }], null, null);
})();
var ColorPickerClasses;
(function(ColorPickerClasses2) {
  ColorPickerClasses2["root"] = "p-colorpicker";
  ColorPickerClasses2["preview"] = "p-colorpicker-preview";
  ColorPickerClasses2["panel"] = "p-colorpicker-panel";
  ColorPickerClasses2["colorSelector"] = "p-colorpicker-color-selector";
  ColorPickerClasses2["colorBackground"] = "p-colorpicker-color-background";
  ColorPickerClasses2["colorHandle"] = "p-colorpicker-color-handle";
  ColorPickerClasses2["hue"] = "p-colorpicker-hue";
  ColorPickerClasses2["hueHandle"] = "p-colorpicker-hue-handle";
})(ColorPickerClasses || (ColorPickerClasses = {}));
var COLORPICKER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => ColorPicker),
  multi: true
};
var COLORPICKER_INSTANCE = new InjectionToken("COLORPICKER_INSTANCE");
var ColorPicker = class _ColorPicker extends BaseEditableHolder {
  overlayService;
  $pcColorPicker = inject(COLORPICKER_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * Style class of the component.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Transition options of the show animation.
   * @group Props
   * @deprecated since v21.0.0, use `motionOptions` instead.
   */
  showTransitionOptions = ".12s cubic-bezier(0, 0, 0.2, 1)";
  /**
   * Transition options of the hide animation.
   * @group Props
   * @deprecated since v21.0.0, use `motionOptions` instead.
   */
  hideTransitionOptions = ".1s linear";
  /**
   * Whether to display as an overlay or not.
   * @group Props
   */
  inline;
  /**
   * Format to use in value binding.
   * @group Props
   */
  format = "hex";
  /**
   * Index of the element in tabbing order.
   * @group Props
   */
  tabindex;
  /**
   * Identifier of the focus input to match a label defined for the dropdown.
   * @group Props
   */
  inputId;
  /**
   * Whether to automatically manage layering.
   * @group Props
   */
  autoZIndex = true;
  /**
   * When present, it specifies that the component should automatically get focus on load.
   * @group Props
   */
  autofocus;
  /**
   * Default color to display initially when model value is not present.
   * @group Props
   */
  defaultColor = "ff0000";
  /**
   * Target element to attach the overlay, valid values are "body" or a local ng-template variable of another element (note: use binding with brackets for template variables, e.g. [appendTo]="mydiv" for a div element having #mydiv as variable name).
   * @defaultValue 'self'
   * @group Props
   */
  appendTo = input(void 0, ...ngDevMode ? [{
    debugName: "appendTo"
  }] : []);
  /**
   * Whether to use overlay API feature. The properties of overlay API can be used like an object in it.
   * @group Props
   */
  overlayOptions = input(void 0, ...ngDevMode ? [{
    debugName: "overlayOptions"
  }] : []);
  /**
   * The motion options.
   * @group Props
   */
  motionOptions = input(void 0, ...ngDevMode ? [{
    debugName: "motionOptions"
  }] : []);
  /**
   * Callback to invoke on value change.
   * @param {ColorPickerChangeEvent} event - Custom value change event.
   * @group Emits
   */
  onChange = new EventEmitter();
  /**
   * Callback to invoke on panel is shown.
   * @group Emits
   */
  onShow = new EventEmitter();
  /**
   * Callback to invoke on panel is hidden.
   * @group Emits
   */
  onHide = new EventEmitter();
  inputViewChild;
  overlayViewChild;
  $appendTo = computed(() => this.appendTo() || this.config.overlayAppendTo(), ...ngDevMode ? [{
    debugName: "$appendTo"
  }] : []);
  value = {
    h: 0,
    s: 100,
    b: 100
  };
  inputBgColor;
  shown;
  overlayVisible;
  documentMousemoveListener;
  documentMouseupListener;
  documentHueMoveListener;
  scrollHandler;
  colorDragging;
  hueDragging;
  overlay;
  colorSelectorViewChild;
  colorHandleViewChild;
  hueViewChild;
  hueHandleViewChild;
  _componentStyle = inject(ColorPickerStyle);
  constructor(overlayService) {
    super();
    this.overlayService = overlayService;
  }
  set colorSelector(element) {
    this.colorSelectorViewChild = element;
  }
  set colorHandle(element) {
    this.colorHandleViewChild = element;
  }
  set hue(element) {
    this.hueViewChild = element;
  }
  set hueHandle(element) {
    this.hueHandleViewChild = element;
  }
  get ariaLabel() {
    return this.config?.getTranslation(TranslationKeys.ARIA)[TranslationKeys.SELECT_COLOR];
  }
  onHueMousedown(event) {
    if (this.$disabled()) {
      return;
    }
    this.bindDocumentMousemoveListener();
    this.bindDocumentMouseupListener();
    this.hueDragging = true;
    this.pickHue(event);
  }
  onHueDragStart(event) {
    if (this.$disabled()) {
      return;
    }
    this.hueDragging = true;
    this.pickHue(event, event.changedTouches[0]);
  }
  onColorDragStart(event) {
    if (this.$disabled()) {
      return;
    }
    this.colorDragging = true;
    this.pickColor(event, event.changedTouches[0]);
    this.el.nativeElement.setAttribute("p-colorpicker-dragging", "true");
  }
  pickHue(event, position) {
    let pageY = position ? position.pageY : event.pageY;
    let top = this.hueViewChild?.nativeElement.getBoundingClientRect().top + (this.document.defaultView.pageYOffset || this.document.documentElement.scrollTop || this.document.body.scrollTop || 0);
    this.value = this.validateHSB({
      h: Math.floor(360 * (150 - Math.max(0, Math.min(150, pageY - top))) / 150),
      s: this.value.s,
      b: this.value.b
    });
    this.updateColorSelector();
    this.updateUI();
    this.updateModel();
    this.onChange.emit({
      originalEvent: event,
      value: this.getValueToUpdate()
    });
  }
  onColorMousedown(event) {
    if (this.$disabled()) {
      return;
    }
    this.bindDocumentMousemoveListener();
    this.bindDocumentMouseupListener();
    this.colorDragging = true;
    this.pickColor(event);
  }
  onDrag(event) {
    if (this.colorDragging) {
      this.pickColor(event, event.changedTouches[0]);
      event.preventDefault();
    }
    if (this.hueDragging) {
      this.pickHue(event, event.changedTouches[0]);
      event.preventDefault();
    }
  }
  onDragEnd() {
    this.colorDragging = false;
    this.hueDragging = false;
    this.el.nativeElement.setAttribute("p-colorpicker-dragging", "false");
    this.unbindDocumentMousemoveListener();
    this.unbindDocumentMouseupListener();
  }
  pickColor(event, position) {
    let pageX = position ? position.pageX : event.pageX;
    let pageY = position ? position.pageY : event.pageY;
    let rect = this.colorSelectorViewChild?.nativeElement.getBoundingClientRect();
    let top = rect.top + (this.document.defaultView.pageYOffset || this.document.documentElement.scrollTop || this.document.body.scrollTop || 0);
    let left = rect.left + this.document.body.scrollLeft;
    let saturation = Math.floor(100 * Math.max(0, Math.min(150, pageX - left)) / 150);
    let brightness = Math.floor(100 * (150 - Math.max(0, Math.min(150, pageY - top))) / 150);
    this.value = this.validateHSB({
      h: this.value.h,
      s: saturation,
      b: brightness
    });
    this.updateUI();
    this.updateModel();
    this.onChange.emit({
      originalEvent: event,
      value: this.getValueToUpdate()
    });
  }
  getValueToUpdate() {
    let val;
    switch (this.format) {
      case "hex":
        val = "#" + this.HSBtoHEX(this.value);
        break;
      case "rgb":
        val = this.HSBtoRGB(this.value);
        break;
      case "hsb":
        val = this.value;
        break;
    }
    return val;
  }
  updateModel() {
    this.onModelChange(this.getValueToUpdate());
    this.cd.markForCheck();
  }
  updateColorSelector() {
    if (this.colorSelectorViewChild) {
      const hsb = {};
      hsb.s = 100;
      hsb.b = 100;
      hsb.h = this.value.h;
      this.colorSelectorViewChild.nativeElement.style.backgroundColor = "#" + this.HSBtoHEX(hsb);
    }
  }
  updateUI() {
    if (this.colorHandleViewChild && this.hueHandleViewChild?.nativeElement) {
      this.colorHandleViewChild.nativeElement.style.left = Math.floor(150 * this.value.s / 100) + "px";
      this.colorHandleViewChild.nativeElement.style.top = Math.floor(150 * (100 - this.value.b) / 100) + "px";
      this.hueHandleViewChild.nativeElement.style.top = Math.floor(150 - 150 * this.value.h / 360) + "px";
    }
    this.inputBgColor = "#" + this.HSBtoHEX(this.value);
  }
  onInputFocus() {
    this.onModelTouched();
  }
  show() {
    this.overlayVisible = true;
    this.cd.markForCheck();
  }
  onOverlayBeforeEnter() {
    if (!this.inline) {
      this.updateColorSelector();
      this.updateUI();
      this.onShow.emit({});
    }
  }
  onOverlayAfterLeave() {
    if (!this.inline) {
      this.onHide.emit({});
    }
  }
  hide() {
    this.overlayVisible = false;
    this.cd.markForCheck();
  }
  onInputClick() {
    this.togglePanel();
  }
  togglePanel() {
    if (!this.overlayVisible) this.show();
    else this.hide();
  }
  onInputKeydown(event) {
    switch (event.code) {
      case "Space":
        this.togglePanel();
        event.preventDefault();
        break;
      case "Escape":
      case "Tab":
        this.hide();
        break;
      default:
        break;
    }
  }
  onOverlayClick(event) {
    this.overlayService.add({
      originalEvent: event,
      target: this.el.nativeElement
    });
  }
  bindDocumentMousemoveListener() {
    if (!this.documentMousemoveListener) {
      const documentTarget = this.el ? this.el.nativeElement.ownerDocument : "document";
      this.documentMousemoveListener = this.renderer.listen(documentTarget, "mousemove", (event) => {
        if (this.colorDragging) {
          this.pickColor(event);
        }
        if (this.hueDragging) {
          this.pickHue(event);
        }
      });
    }
  }
  unbindDocumentMousemoveListener() {
    if (this.documentMousemoveListener) {
      this.documentMousemoveListener();
      this.documentMousemoveListener = null;
    }
  }
  bindDocumentMouseupListener() {
    if (!this.documentMouseupListener) {
      const documentTarget = this.el ? this.el.nativeElement.ownerDocument : "document";
      this.documentMouseupListener = this.renderer.listen(documentTarget, "mouseup", () => {
        this.colorDragging = false;
        this.hueDragging = false;
        this.unbindDocumentMousemoveListener();
        this.unbindDocumentMouseupListener();
      });
    }
  }
  unbindDocumentMouseupListener() {
    if (this.documentMouseupListener) {
      this.documentMouseupListener();
      this.documentMouseupListener = null;
    }
  }
  validateHSB(hsb) {
    return {
      h: Math.min(360, Math.max(0, hsb.h)),
      s: Math.min(100, Math.max(0, hsb.s)),
      b: Math.min(100, Math.max(0, hsb.b))
    };
  }
  validateRGB(rgb) {
    return {
      r: Math.min(255, Math.max(0, rgb.r)),
      g: Math.min(255, Math.max(0, rgb.g)),
      b: Math.min(255, Math.max(0, rgb.b))
    };
  }
  validateHEX(hex) {
    var len = 6 - hex.length;
    if (len > 0) {
      var o = [];
      for (var i = 0; i < len; i++) {
        o.push("0");
      }
      o.push(hex);
      hex = o.join("");
    }
    return hex;
  }
  HEXtoRGB(hex) {
    if (!hex || typeof hex !== "string") {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }
    let hexValue = parseInt(hex.indexOf("#") > -1 ? hex.substring(1) : hex, 16);
    return {
      r: hexValue >> 16,
      g: (hexValue & 65280) >> 8,
      b: hexValue & 255
    };
  }
  HEXtoHSB(hex) {
    return this.RGBtoHSB(this.HEXtoRGB(hex));
  }
  RGBtoHSB(rgb) {
    var hsb = {
      h: 0,
      s: 0,
      b: 0
    };
    var min = Math.min(rgb.r, rgb.g, rgb.b);
    var max = Math.max(rgb.r, rgb.g, rgb.b);
    var delta = max - min;
    hsb.b = max;
    hsb.s = max != 0 ? 255 * delta / max : 0;
    if (hsb.s != 0) {
      if (rgb.r == max) {
        hsb.h = (rgb.g - rgb.b) / delta;
      } else if (rgb.g == max) {
        hsb.h = 2 + (rgb.b - rgb.r) / delta;
      } else {
        hsb.h = 4 + (rgb.r - rgb.g) / delta;
      }
    } else {
      hsb.h = -1;
    }
    hsb.h *= 60;
    if (hsb.h < 0) {
      hsb.h += 360;
    }
    hsb.s *= 100 / 255;
    hsb.b *= 100 / 255;
    return hsb;
  }
  HSBtoRGB(hsb) {
    var rgb = {
      r: 0,
      g: 0,
      b: 0
    };
    let h = hsb.h;
    let s3 = hsb.s * 255 / 100;
    let v2 = hsb.b * 255 / 100;
    if (s3 == 0) {
      rgb = {
        r: v2,
        g: v2,
        b: v2
      };
    } else {
      let t1 = v2;
      let t2 = (255 - s3) * v2 / 255;
      let t3 = (t1 - t2) * (h % 60) / 60;
      if (h == 360) h = 0;
      if (h < 60) {
        rgb.r = t1;
        rgb.b = t2;
        rgb.g = t2 + t3;
      } else if (h < 120) {
        rgb.g = t1;
        rgb.b = t2;
        rgb.r = t1 - t3;
      } else if (h < 180) {
        rgb.g = t1;
        rgb.r = t2;
        rgb.b = t2 + t3;
      } else if (h < 240) {
        rgb.b = t1;
        rgb.r = t2;
        rgb.g = t1 - t3;
      } else if (h < 300) {
        rgb.b = t1;
        rgb.g = t2;
        rgb.r = t2 + t3;
      } else if (h < 360) {
        rgb.r = t1;
        rgb.g = t2;
        rgb.b = t1 - t3;
      } else {
        rgb.r = 0;
        rgb.g = 0;
        rgb.b = 0;
      }
    }
    return {
      r: Math.round(rgb.r),
      g: Math.round(rgb.g),
      b: Math.round(rgb.b)
    };
  }
  RGBtoHEX(rgb) {
    var hex = [rgb.r.toString(16), rgb.g.toString(16), rgb.b.toString(16)];
    for (var key in hex) {
      if (hex[key].length == 1) {
        hex[key] = "0" + hex[key];
      }
    }
    return hex.join("");
  }
  HSBtoHEX(hsb) {
    return this.RGBtoHEX(this.HSBtoRGB(hsb));
  }
  onAfterViewInit() {
    if (this.inline) {
      this.updateColorSelector();
      this.updateUI();
    }
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value) {
    if (value) {
      switch (this.format) {
        case "hex":
          this.value = this.HEXtoHSB(value);
          break;
        case "rgb":
          this.value = this.RGBtoHSB(value);
          break;
        case "hsb":
          this.value = value;
          break;
      }
    } else {
      this.value = this.HEXtoHSB(this.defaultColor);
    }
    this.updateColorSelector();
    this.updateUI();
    this.cd.markForCheck();
  }
  onDestroy() {
    if (this.scrollHandler) {
      this.scrollHandler.destroy();
      this.scrollHandler = null;
    }
    if (this.overlayViewChild?.nativeElement && this.autoZIndex) {
      zindexutils.clear(this.overlayViewChild?.nativeElement);
    }
  }
  static \u0275fac = function ColorPicker_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPicker)(\u0275\u0275directiveInject(OverlayService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _ColorPicker,
    selectors: [["p-colorPicker"], ["p-colorpicker"], ["p-color-picker"]],
    viewQuery: function ColorPicker_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c08, 5);
        \u0275\u0275viewQuery(_c12, 5);
        \u0275\u0275viewQuery(_c22, 5);
        \u0275\u0275viewQuery(_c32, 5);
        \u0275\u0275viewQuery(_c4, 5);
        \u0275\u0275viewQuery(_c5, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.inputViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.overlayViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.colorSelector = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.colorHandle = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.hue = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.hueHandle = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function ColorPicker_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      styleClass: "styleClass",
      showTransitionOptions: "showTransitionOptions",
      hideTransitionOptions: "hideTransitionOptions",
      inline: [2, "inline", "inline", booleanAttribute],
      format: "format",
      tabindex: "tabindex",
      inputId: "inputId",
      autoZIndex: [2, "autoZIndex", "autoZIndex", booleanAttribute],
      autofocus: [2, "autofocus", "autofocus", booleanAttribute],
      defaultColor: "defaultColor",
      appendTo: [1, "appendTo"],
      overlayOptions: [1, "overlayOptions"],
      motionOptions: [1, "motionOptions"]
    },
    outputs: {
      onChange: "onChange",
      onShow: "onShow",
      onHide: "onHide"
    },
    features: [\u0275\u0275ProvidersFeature([COLORPICKER_VALUE_ACCESSOR, ColorPickerStyle, {
      provide: COLORPICKER_INSTANCE,
      useExisting: _ColorPicker
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _ColorPicker
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 5,
    vars: 10,
    consts: [["overlay", ""], ["content", ""], ["input", ""], ["colorSelector", ""], ["colorHandle", ""], ["hue", ""], ["hueHandle", ""], ["type", "text", "readonly", "", 3, "class", "backgroundColor", "pAutoFocus", "pBind", "click", "keydown", "focus", 4, "ngIf"], [3, "visibleChange", "onBeforeEnter", "onAfterLeave", "onHide", "hostAttrSelector", "visible", "options", "target", "inline", "appendTo", "unstyled", "pt", "motionOptions"], ["type", "text", "readonly", "", 3, "click", "keydown", "focus", "pAutoFocus", "pBind"], [3, "pBind"], [3, "touchstart", "touchmove", "touchend", "mousedown", "pBind"], [3, "mousedown", "touchstart", "touchmove", "touchend", "pBind"]],
    template: function ColorPicker_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275template(0, ColorPicker_input_0_Template, 2, 10, "input", 7);
        \u0275\u0275elementStart(1, "p-overlay", 8, 0);
        \u0275\u0275twoWayListener("visibleChange", function ColorPicker_Template_p_overlay_visibleChange_1_listener($event) {
          \u0275\u0275restoreView(_r1);
          \u0275\u0275twoWayBindingSet(ctx.overlayVisible, $event) || (ctx.overlayVisible = $event);
          return \u0275\u0275resetView($event);
        });
        \u0275\u0275listener("onBeforeEnter", function ColorPicker_Template_p_overlay_onBeforeEnter_1_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onOverlayBeforeEnter());
        })("onAfterLeave", function ColorPicker_Template_p_overlay_onAfterLeave_1_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onOverlayAfterLeave());
        })("onHide", function ColorPicker_Template_p_overlay_onHide_1_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.hide());
        });
        \u0275\u0275template(3, ColorPicker_ng_template_3_Template, 11, 21, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275property("ngIf", !ctx.inline);
        \u0275\u0275advance();
        \u0275\u0275property("hostAttrSelector", ctx.$attrSelector);
        \u0275\u0275twoWayProperty("visible", ctx.overlayVisible);
        \u0275\u0275property("options", ctx.overlayOptions())("target", "@parent")("inline", ctx.inline)("appendTo", ctx.$appendTo())("unstyled", ctx.unstyled())("pt", ctx.ptm("pcOverlay"))("motionOptions", ctx.motionOptions());
      }
    },
    dependencies: [CommonModule, NgIf, AutoFocusModule, AutoFocus, SharedModule, Bind, MotionModule, OverlayModule, Overlay],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPicker, [{
    type: Component,
    args: [{
      selector: "p-colorPicker, p-colorpicker, p-color-picker",
      standalone: true,
      imports: [CommonModule, AutoFocusModule, SharedModule, Bind, MotionModule, OverlayModule],
      hostDirectives: [Bind],
      template: `
        <input
            *ngIf="!inline"
            #input
            type="text"
            [class]="cx('preview')"
            readonly
            [attr.tabindex]="tabindex"
            [attr.disabled]="$disabled() ? '' : undefined"
            (click)="onInputClick()"
            (keydown)="onInputKeydown($event)"
            (focus)="onInputFocus()"
            [attr.id]="inputId"
            [style.backgroundColor]="inputBgColor"
            [attr.aria-label]="ariaLabel"
            [pAutoFocus]="autofocus"
            [pBind]="ptm('preview')"
        />

        <p-overlay
            #overlay
            [hostAttrSelector]="$attrSelector"
            [(visible)]="overlayVisible"
            [options]="overlayOptions()"
            [target]="'@parent'"
            [inline]="inline"
            [appendTo]="$appendTo()"
            [unstyled]="unstyled()"
            [pt]="ptm('pcOverlay')"
            [motionOptions]="motionOptions()"
            (onBeforeEnter)="onOverlayBeforeEnter()"
            (onAfterLeave)="onOverlayAfterLeave()"
            (onHide)="hide()"
        >
            <ng-template #content>
                <div [class]="cx('panel')" [pBind]="ptm('panel')">
                    <div [class]="cx('content')" [pBind]="ptm('content')">
                        <div #colorSelector [class]="cx('colorSelector')" (touchstart)="onColorDragStart($event)" (touchmove)="onDrag($event)" (touchend)="onDragEnd()" (mousedown)="onColorMousedown($event)" [pBind]="ptm('colorSelector')">
                            <div [class]="cx('colorBackground')" [pBind]="ptm('colorBackground')">
                                <div #colorHandle [class]="cx('colorHandle')" [pBind]="ptm('colorHandle')"></div>
                            </div>
                        </div>
                        <div #hue [class]="cx('hue')" (mousedown)="onHueMousedown($event)" (touchstart)="onHueDragStart($event)" (touchmove)="onDrag($event)" (touchend)="onDragEnd()" [pBind]="ptm('hue')">
                            <div #hueHandle [class]="cx('hueHandle')" [pBind]="ptm('hueHandle')"></div>
                        </div>
                    </div>
                </div>
            </ng-template>
        </p-overlay>
    `,
      providers: [COLORPICKER_VALUE_ACCESSOR, ColorPickerStyle, {
        provide: COLORPICKER_INSTANCE,
        useExisting: ColorPicker
      }, {
        provide: PARENT_INSTANCE,
        useExisting: ColorPicker
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cn(cx('root'), styleClass)"
      }
    }]
  }], () => [{
    type: OverlayService
  }], {
    styleClass: [{
      type: Input
    }],
    showTransitionOptions: [{
      type: Input
    }],
    hideTransitionOptions: [{
      type: Input
    }],
    inline: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    format: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    inputId: [{
      type: Input
    }],
    autoZIndex: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    autofocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    defaultColor: [{
      type: Input
    }],
    appendTo: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "appendTo",
        required: false
      }]
    }],
    overlayOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "overlayOptions",
        required: false
      }]
    }],
    motionOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "motionOptions",
        required: false
      }]
    }],
    onChange: [{
      type: Output
    }],
    onShow: [{
      type: Output
    }],
    onHide: [{
      type: Output
    }],
    inputViewChild: [{
      type: ViewChild,
      args: ["input"]
    }],
    overlayViewChild: [{
      type: ViewChild,
      args: ["overlay"]
    }],
    colorSelector: [{
      type: ViewChild,
      args: ["colorSelector"]
    }],
    colorHandle: [{
      type: ViewChild,
      args: ["colorHandle"]
    }],
    hue: [{
      type: ViewChild,
      args: ["hue"]
    }],
    hueHandle: [{
      type: ViewChild,
      args: ["hueHandle"]
    }]
  });
})();
var ColorPickerModule = class _ColorPickerModule {
  static \u0275fac = function ColorPickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPickerModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ColorPickerModule,
    imports: [ColorPicker, SharedModule],
    exports: [ColorPicker, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [ColorPicker, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerModule, [{
    type: NgModule,
    args: [{
      imports: [ColorPicker, SharedModule],
      exports: [ColorPicker, SharedModule]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/editor/index.mjs
var style4 = "\n    /*!\n* Quill Editor v1.3.3\n* https://quilljs.com/\n* Copyright (c) 2014, Jason Chen\n* Copyright (c) 2013, salesforce.com\n*/\n    .ql-container {\n        box-sizing: border-box;\n        font-family: Helvetica, Arial, sans-serif;\n        font-size: 13px;\n        height: 100%;\n        margin: 0;\n        position: relative;\n    }\n    .ql-container.ql-disabled .ql-tooltip {\n        visibility: hidden;\n    }\n    .ql-container.ql-disabled .ql-editor ul[data-checked] > li::before {\n        pointer-events: none;\n    }\n    .ql-clipboard {\n        inset-inline-start: -100000px;\n        height: 1px;\n        overflow-y: hidden;\n        position: absolute;\n        top: 50%;\n    }\n    .ql-clipboard p {\n        margin: 0;\n        padding: 0;\n    }\n    .ql-editor {\n        box-sizing: border-box;\n        line-height: 1.42;\n        height: 100%;\n        outline: none;\n        overflow-y: auto;\n        padding: 12px 15px;\n        tab-size: 4;\n        -moz-tab-size: 4;\n        text-align: left;\n        white-space: pre-wrap;\n        word-wrap: break-word;\n    }\n    .ql-editor > * {\n        cursor: text;\n    }\n    .ql-editor p,\n    .ql-editor ol,\n    .ql-editor ul,\n    .ql-editor pre,\n    .ql-editor blockquote,\n    .ql-editor h1,\n    .ql-editor h2,\n    .ql-editor h3,\n    .ql-editor h4,\n    .ql-editor h5,\n    .ql-editor h6 {\n        margin: 0;\n        padding: 0;\n        counter-reset: list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n    }\n    .ql-editor ol,\n    .ql-editor ul {\n        padding-inline-start: 1.5rem;\n    }\n    .ql-editor ol > li,\n    .ql-editor ul > li {\n        list-style-type: none;\n    }\n    .ql-editor ul > li::before {\n        content: '\\2022';\n    }\n    .ql-editor ul[data-checked='true'],\n    .ql-editor ul[data-checked='false'] {\n        pointer-events: none;\n    }\n    .ql-editor ul[data-checked='true'] > li *,\n    .ql-editor ul[data-checked='false'] > li * {\n        pointer-events: all;\n    }\n    .ql-editor ul[data-checked='true'] > li::before,\n    .ql-editor ul[data-checked='false'] > li::before {\n        color: #777;\n        cursor: pointer;\n        pointer-events: all;\n    }\n    .ql-editor ul[data-checked='true'] > li::before {\n        content: '\\2611';\n    }\n    .ql-editor ul[data-checked='false'] > li::before {\n        content: '\\2610';\n    }\n    .ql-editor li::before {\n        display: inline-block;\n        white-space: nowrap;\n        width: 1.2rem;\n    }\n    .ql-editor li:not(.ql-direction-rtl)::before {\n        margin-inline-start: -1.5rem;\n        margin-inline-end: 0.3rem;\n        text-align: right;\n    }\n    .ql-editor li.ql-direction-rtl::before {\n        margin-inline-start: 0.3rem;\n        margin-inline-end: -1.5rem;\n    }\n    .ql-editor ol li:not(.ql-direction-rtl),\n    .ql-editor ul li:not(.ql-direction-rtl) {\n        padding-inline-start: 1.5rem;\n    }\n    .ql-editor ol li.ql-direction-rtl,\n    .ql-editor ul li.ql-direction-rtl {\n        padding-inline-end: 1.5rem;\n    }\n    .ql-editor ol li {\n        counter-reset: list-1 list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n        counter-increment: list-0;\n    }\n    .ql-editor ol li:before {\n        content: counter(list-0, decimal) '. ';\n    }\n    .ql-editor ol li.ql-indent-1 {\n        counter-increment: list-1;\n    }\n    .ql-editor ol li.ql-indent-1:before {\n        content: counter(list-1, lower-alpha) '. ';\n    }\n    .ql-editor ol li.ql-indent-1 {\n        counter-reset: list-2 list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n    }\n    .ql-editor ol li.ql-indent-2 {\n        counter-increment: list-2;\n    }\n    .ql-editor ol li.ql-indent-2:before {\n        content: counter(list-2, lower-roman) '. ';\n    }\n    .ql-editor ol li.ql-indent-2 {\n        counter-reset: list-3 list-4 list-5 list-6 list-7 list-8 list-9;\n    }\n    .ql-editor ol li.ql-indent-3 {\n        counter-increment: list-3;\n    }\n    .ql-editor ol li.ql-indent-3:before {\n        content: counter(list-3, decimal) '. ';\n    }\n    .ql-editor ol li.ql-indent-3 {\n        counter-reset: list-4 list-5 list-6 list-7 list-8 list-9;\n    }\n    .ql-editor ol li.ql-indent-4 {\n        counter-increment: list-4;\n    }\n    .ql-editor ol li.ql-indent-4:before {\n        content: counter(list-4, lower-alpha) '. ';\n    }\n    .ql-editor ol li.ql-indent-4 {\n        counter-reset: list-5 list-6 list-7 list-8 list-9;\n    }\n    .ql-editor ol li.ql-indent-5 {\n        counter-increment: list-5;\n    }\n    .ql-editor ol li.ql-indent-5:before {\n        content: counter(list-5, lower-roman) '. ';\n    }\n    .ql-editor ol li.ql-indent-5 {\n        counter-reset: list-6 list-7 list-8 list-9;\n    }\n    .ql-editor ol li.ql-indent-6 {\n        counter-increment: list-6;\n    }\n    .ql-editor ol li.ql-indent-6:before {\n        content: counter(list-6, decimal) '. ';\n    }\n    .ql-editor ol li.ql-indent-6 {\n        counter-reset: list-7 list-8 list-9;\n    }\n    .ql-editor ol li.ql-indent-7 {\n        counter-increment: list-7;\n    }\n    .ql-editor ol li.ql-indent-7:before {\n        content: counter(list-7, lower-alpha) '. ';\n    }\n    .ql-editor ol li.ql-indent-7 {\n        counter-reset: list-8 list-9;\n    }\n    .ql-editor ol li.ql-indent-8 {\n        counter-increment: list-8;\n    }\n    .ql-editor ol li.ql-indent-8:before {\n        content: counter(list-8, lower-roman) '. ';\n    }\n    .ql-editor ol li.ql-indent-8 {\n        counter-reset: list-9;\n    }\n    .ql-editor ol li.ql-indent-9 {\n        counter-increment: list-9;\n    }\n    .ql-editor ol li.ql-indent-9:before {\n        content: counter(list-9, decimal) '. ';\n    }\n    .ql-editor .ql-video {\n        display: block;\n        max-width: 100%;\n    }\n    .ql-editor .ql-video.ql-align-center {\n        margin: 0 auto;\n    }\n    .ql-editor .ql-video.ql-align-right {\n        margin: 0 0 0 auto;\n    }\n    .ql-editor .ql-bg-black {\n        background: #000;\n    }\n    .ql-editor .ql-bg-red {\n        background: #e60000;\n    }\n    .ql-editor .ql-bg-orange {\n        background: #f90;\n    }\n    .ql-editor .ql-bg-yellow {\n        background: #ff0;\n    }\n    .ql-editor .ql-bg-green {\n        background: #008a00;\n    }\n    .ql-editor .ql-bg-blue {\n        background: #06c;\n    }\n    .ql-editor .ql-bg-purple {\n        background: #93f;\n    }\n    .ql-editor .ql-color-white {\n        color: #fff;\n    }\n    .ql-editor .ql-color-red {\n        color: #e60000;\n    }\n    .ql-editor .ql-color-orange {\n        color: #f90;\n    }\n    .ql-editor .ql-color-yellow {\n        color: #ff0;\n    }\n    .ql-editor .ql-color-green {\n        color: #008a00;\n    }\n    .ql-editor .ql-color-blue {\n        color: #06c;\n    }\n    .ql-editor .ql-color-purple {\n        color: #93f;\n    }\n    .ql-editor .ql-font-serif {\n        font-family:\n            Georgia,\n            Times New Roman,\n            serif;\n    }\n    .ql-editor .ql-font-monospace {\n        font-family:\n            Monaco,\n            Courier New,\n            monospace;\n    }\n    .ql-editor .ql-size-small {\n        font-size: 0.75rem;\n    }\n    .ql-editor .ql-size-large {\n        font-size: 1.5rem;\n    }\n    .ql-editor .ql-size-huge {\n        font-size: 2.5rem;\n    }\n    .ql-editor .ql-direction-rtl {\n        direction: rtl;\n        text-align: inherit;\n    }\n    .ql-editor .ql-align-center {\n        text-align: center;\n    }\n    .ql-editor .ql-align-justify {\n        text-align: justify;\n    }\n    .ql-editor .ql-align-right {\n        text-align: right;\n    }\n    .ql-editor.ql-blank::before {\n        color: dt('form.field.placeholder.color');\n        content: attr(data-placeholder);\n        font-style: italic;\n        inset-inline-start: 15px;\n        pointer-events: none;\n        position: absolute;\n        inset-inline-end: 15px;\n    }\n    .ql-snow.ql-toolbar:after,\n    .ql-snow .ql-toolbar:after {\n        clear: both;\n        content: '';\n        display: table;\n    }\n    .ql-snow.ql-toolbar button,\n    .ql-snow .ql-toolbar button {\n        background: none;\n        border: none;\n        cursor: pointer;\n        display: inline-block;\n        float: left;\n        height: 24px;\n        padding-block: 3px;\n        padding-inline: 5px;\n        width: 28px;\n    }\n    .ql-snow.ql-toolbar button svg,\n    .ql-snow .ql-toolbar button svg {\n        float: left;\n        height: 100%;\n    }\n    .ql-snow.ql-toolbar button:active:hover,\n    .ql-snow .ql-toolbar button:active:hover {\n        outline: none;\n    }\n    .ql-snow.ql-toolbar input.ql-image[type='file'],\n    .ql-snow .ql-toolbar input.ql-image[type='file'] {\n        display: none;\n    }\n    .ql-snow.ql-toolbar button:hover,\n    .ql-snow .ql-toolbar button:hover,\n    .ql-snow.ql-toolbar button:focus,\n    .ql-snow .ql-toolbar button:focus,\n    .ql-snow.ql-toolbar button.ql-active,\n    .ql-snow .ql-toolbar button.ql-active,\n    .ql-snow.ql-toolbar .ql-picker-label:hover,\n    .ql-snow .ql-toolbar .ql-picker-label:hover,\n    .ql-snow.ql-toolbar .ql-picker-label.ql-active,\n    .ql-snow .ql-toolbar .ql-picker-label.ql-active,\n    .ql-snow.ql-toolbar .ql-picker-item:hover,\n    .ql-snow .ql-toolbar .ql-picker-item:hover,\n    .ql-snow.ql-toolbar .ql-picker-item.ql-selected,\n    .ql-snow .ql-toolbar .ql-picker-item.ql-selected {\n        color: #06c;\n    }\n    .ql-snow.ql-toolbar button:hover .ql-fill,\n    .ql-snow .ql-toolbar button:hover .ql-fill,\n    .ql-snow.ql-toolbar button:focus .ql-fill,\n    .ql-snow .ql-toolbar button:focus .ql-fill,\n    .ql-snow.ql-toolbar button.ql-active .ql-fill,\n    .ql-snow .ql-toolbar button.ql-active .ql-fill,\n    .ql-snow.ql-toolbar .ql-picker-label:hover .ql-fill,\n    .ql-snow .ql-toolbar .ql-picker-label:hover .ql-fill,\n    .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-fill,\n    .ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-fill,\n    .ql-snow.ql-toolbar .ql-picker-item:hover .ql-fill,\n    .ql-snow .ql-toolbar .ql-picker-item:hover .ql-fill,\n    .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-fill,\n    .ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-fill,\n    .ql-snow.ql-toolbar button:hover .ql-stroke.ql-fill,\n    .ql-snow .ql-toolbar button:hover .ql-stroke.ql-fill,\n    .ql-snow.ql-toolbar button:focus .ql-stroke.ql-fill,\n    .ql-snow .ql-toolbar button:focus .ql-stroke.ql-fill,\n    .ql-snow.ql-toolbar button.ql-active .ql-stroke.ql-fill,\n    .ql-snow .ql-toolbar button.ql-active .ql-stroke.ql-fill,\n    .ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke.ql-fill,\n    .ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke.ql-fill,\n    .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke.ql-fill,\n    .ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke.ql-fill,\n    .ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke.ql-fill,\n    .ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke.ql-fill,\n    .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke.ql-fill,\n    .ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke.ql-fill {\n        fill: #06c;\n    }\n    .ql-snow.ql-toolbar button:hover .ql-stroke,\n    .ql-snow .ql-toolbar button:hover .ql-stroke,\n    .ql-snow.ql-toolbar button:focus .ql-stroke,\n    .ql-snow .ql-toolbar button:focus .ql-stroke,\n    .ql-snow.ql-toolbar button.ql-active .ql-stroke,\n    .ql-snow .ql-toolbar button.ql-active .ql-stroke,\n    .ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke,\n    .ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke,\n    .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke,\n    .ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke,\n    .ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke,\n    .ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke,\n    .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke,\n    .ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke,\n    .ql-snow.ql-toolbar button:hover .ql-stroke-miter,\n    .ql-snow .ql-toolbar button:hover .ql-stroke-miter,\n    .ql-snow.ql-toolbar button:focus .ql-stroke-miter,\n    .ql-snow .ql-toolbar button:focus .ql-stroke-miter,\n    .ql-snow.ql-toolbar button.ql-active .ql-stroke-miter,\n    .ql-snow.ql-toolbar button.ql-active .ql-stroke-miter,\n    .ql-snow.ql-toolbar .ql-picker-label:hover .ql-stroke-miter,\n    .ql-snow .ql-toolbar .ql-picker-label:hover .ql-stroke-miter,\n    .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke-miter,\n    .ql-snow .ql-toolbar .ql-picker-label.ql-active .ql-stroke-miter,\n    .ql-snow.ql-toolbar .ql-picker-item:hover .ql-stroke-miter,\n    .ql-snow .ql-toolbar .ql-picker-item:hover .ql-stroke-miter,\n    .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke-miter,\n    .ql-snow .ql-toolbar .ql-picker-item.ql-selected .ql-stroke-miter {\n        stroke: #06c;\n    }\n    @media (pointer: coarse) {\n        .ql-snow.ql-toolbar button:hover:not(.ql-active),\n        .ql-snow .ql-toolbar button:hover:not(.ql-active) {\n            color: #444;\n        }\n        .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-fill,\n        .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-fill,\n        .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke.ql-fill,\n        .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke.ql-fill {\n            fill: #444;\n        }\n        .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke,\n        .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke,\n        .ql-snow.ql-toolbar button:hover:not(.ql-active) .ql-stroke-miter,\n        .ql-snow .ql-toolbar button:hover:not(.ql-active) .ql-stroke-miter {\n            stroke: #444;\n        }\n    }\n    .ql-snow {\n        box-sizing: border-box;\n    }\n    .ql-snow * {\n        box-sizing: border-box;\n    }\n    .ql-snow .ql-hidden {\n        display: none;\n    }\n    .ql-snow .ql-out-bottom,\n    .ql-snow .ql-out-top {\n        visibility: hidden;\n    }\n    .ql-snow .ql-tooltip {\n        position: absolute;\n        transform: translateY(10px);\n    }\n    .ql-snow .ql-tooltip a {\n        cursor: pointer;\n        text-decoration: none;\n    }\n    .ql-snow .ql-tooltip.ql-flip {\n        transform: translateY(-10px);\n    }\n    .ql-snow .ql-formats {\n        display: inline-block;\n        vertical-align: middle;\n    }\n    .ql-snow .ql-formats:after {\n        clear: both;\n        content: '';\n        display: table;\n    }\n    .ql-snow .ql-stroke {\n        fill: none;\n        stroke: #444;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 2;\n    }\n    .ql-snow .ql-stroke-miter {\n        fill: none;\n        stroke: #444;\n        stroke-miterlimit: 10;\n        stroke-width: 2;\n    }\n    .ql-snow .ql-fill,\n    .ql-snow .ql-stroke.ql-fill {\n        fill: #444;\n    }\n    .ql-snow .ql-empty {\n        fill: none;\n    }\n    .ql-snow .ql-even {\n        fill-rule: evenodd;\n    }\n    .ql-snow .ql-thin,\n    .ql-snow .ql-stroke.ql-thin {\n        stroke-width: 1;\n    }\n    .ql-snow .ql-transparent {\n        opacity: 0.4;\n    }\n    .ql-snow .ql-direction svg:last-child {\n        display: none;\n    }\n    .ql-snow .ql-direction.ql-active svg:last-child {\n        display: inline;\n    }\n    .ql-snow .ql-direction.ql-active svg:first-child {\n        display: none;\n    }\n    .ql-snow .ql-editor h1 {\n        font-size: 2rem;\n    }\n    .ql-snow .ql-editor h2 {\n        font-size: 1.5rem;\n    }\n    .ql-snow .ql-editor h3 {\n        font-size: 1.17rem;\n    }\n    .ql-snow .ql-editor h4 {\n        font-size: 1rem;\n    }\n    .ql-snow .ql-editor h5 {\n        font-size: 0.83rem;\n    }\n    .ql-snow .ql-editor h6 {\n        font-size: 0.67rem;\n    }\n    .ql-snow .ql-editor a {\n        text-decoration: underline;\n    }\n    .ql-snow .ql-editor blockquote {\n        border-inline-start: 4px solid #ccc;\n        margin-block-end: 5px;\n        margin-block-start: 5px;\n        padding-inline-start: 16px;\n    }\n    .ql-snow .ql-editor code,\n    .ql-snow .ql-editor pre {\n        background: #f0f0f0;\n        border-radius: 3px;\n    }\n    .ql-snow .ql-editor pre {\n        white-space: pre-wrap;\n        margin-block-end: 5px;\n        margin-block-start: 5px;\n        padding: 5px 10px;\n    }\n    .ql-snow .ql-editor code {\n        font-size: 85%;\n        padding: 2px 4px;\n    }\n    .ql-snow .ql-editor pre.ql-syntax {\n        background: #23241f;\n        color: #f8f8f2;\n        overflow: visible;\n    }\n    .ql-snow .ql-editor img {\n        max-width: 100%;\n    }\n    .ql-snow .ql-picker {\n        color: #444;\n        display: inline-block;\n        float: left;\n        inset-inline-start: 0;\n        font-size: 14px;\n        font-weight: 500;\n        height: 24px;\n        position: relative;\n        vertical-align: middle;\n    }\n    .ql-snow .ql-picker-label {\n        cursor: pointer;\n        display: inline-block;\n        height: 100%;\n        padding-inline-start: 8px;\n        padding-inline-end: 2px;\n        position: relative;\n        width: 100%;\n    }\n    .ql-snow .ql-picker-label::before {\n        display: inline-block;\n        line-height: 22px;\n    }\n    .ql-snow .ql-picker-options {\n        background: #fff;\n        display: none;\n        min-width: 100%;\n        padding: 4px 8px;\n        position: absolute;\n        white-space: nowrap;\n    }\n    .ql-snow .ql-picker-options .ql-picker-item {\n        cursor: pointer;\n        display: block;\n        padding-block-end: 5px;\n        padding-block-start: 5px;\n    }\n    .ql-snow .ql-picker.ql-expanded .ql-picker-label {\n        color: #ccc;\n        z-index: 2;\n    }\n    .ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-fill {\n        fill: #ccc;\n    }\n    .ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-stroke {\n        stroke: #ccc;\n    }\n    .ql-snow .ql-picker.ql-expanded .ql-picker-options {\n        display: block;\n        margin-block-start: -1px;\n        top: 100%;\n        z-index: 1;\n    }\n    .ql-snow .ql-color-picker,\n    .ql-snow .ql-icon-picker {\n        width: 28px;\n    }\n    .ql-snow .ql-color-picker .ql-picker-label,\n    .ql-snow .ql-icon-picker .ql-picker-label {\n        padding: 2px 4px;\n    }\n    .ql-snow .ql-color-picker .ql-picker-label svg,\n    .ql-snow .ql-icon-picker .ql-picker-label svg {\n        inset-inline-end: 4px;\n    }\n    .ql-snow .ql-icon-picker .ql-picker-options {\n        padding: 4px 0;\n    }\n    .ql-snow .ql-icon-picker .ql-picker-item {\n        height: 24px;\n        width: 24px;\n        padding: 2px 4px;\n    }\n    .ql-snow .ql-color-picker .ql-picker-options {\n        padding: 3px 5px;\n        width: 152px;\n    }\n    .ql-snow .ql-color-picker .ql-picker-item {\n        border: 1px solid transparent;\n        float: left;\n        height: 16px;\n        margin: 2px;\n        padding: 0;\n        width: 16px;\n    }\n    .ql-snow .ql-picker:not(.ql-color-picker):not(.ql-icon-picker) svg {\n        position: absolute;\n        margin-block-start: -9px;\n        inset-inline-end: 0;\n        top: 50%;\n        width: 18px;\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-label[data-label]:not([data-label=''])::before,\n    .ql-snow .ql-picker.ql-font .ql-picker-label[data-label]:not([data-label=''])::before,\n    .ql-snow .ql-picker.ql-size .ql-picker-label[data-label]:not([data-label=''])::before,\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-label]:not([data-label=''])::before,\n    .ql-snow .ql-picker.ql-font .ql-picker-item[data-label]:not([data-label=''])::before,\n    .ql-snow .ql-picker.ql-size .ql-picker-item[data-label]:not([data-label=''])::before {\n        content: attr(data-label);\n    }\n    .ql-snow .ql-picker.ql-header {\n        width: 98px;\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-label::before,\n    .ql-snow .ql-picker.ql-header .ql-picker-item::before {\n        content: 'Normal';\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='1']::before,\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='1']::before {\n        content: 'Heading 1';\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='2']::before,\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='2']::before {\n        content: 'Heading 2';\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='3']::before,\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='3']::before {\n        content: 'Heading 3';\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='4']::before,\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='4']::before {\n        content: 'Heading 4';\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='5']::before,\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='5']::before {\n        content: 'Heading 5';\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-label[data-value='6']::before,\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='6']::before {\n        content: 'Heading 6';\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='1']::before {\n        font-size: 2rem;\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='2']::before {\n        font-size: 1.5rem;\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='3']::before {\n        font-size: 1.17rem;\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='4']::before {\n        font-size: 1rem;\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='5']::before {\n        font-size: 0.83rem;\n    }\n    .ql-snow .ql-picker.ql-header .ql-picker-item[data-value='6']::before {\n        font-size: 0.67rem;\n    }\n    .ql-snow .ql-picker.ql-font {\n        width: 108px;\n    }\n    .ql-snow .ql-picker.ql-font .ql-picker-label::before,\n    .ql-snow .ql-picker.ql-font .ql-picker-item::before {\n        content: 'Sans Serif';\n    }\n    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value='serif']::before,\n    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value='serif']::before {\n        content: 'Serif';\n    }\n    .ql-snow .ql-picker.ql-font .ql-picker-label[data-value='monospace']::before,\n    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value='monospace']::before {\n        content: 'Monospace';\n    }\n    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value='serif']::before {\n        font-family:\n            Georgia,\n            Times New Roman,\n            serif;\n    }\n    .ql-snow .ql-picker.ql-font .ql-picker-item[data-value='monospace']::before {\n        font-family:\n            Monaco,\n            Courier New,\n            monospace;\n    }\n    .ql-snow .ql-picker.ql-size {\n        width: 98px;\n    }\n    .ql-snow .ql-picker.ql-size .ql-picker-label::before,\n    .ql-snow .ql-picker.ql-size .ql-picker-item::before {\n        content: 'Normal';\n    }\n    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value='small']::before,\n    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='small']::before {\n        content: 'Small';\n    }\n    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value='large']::before,\n    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='large']::before {\n        content: 'Large';\n    }\n    .ql-snow .ql-picker.ql-size .ql-picker-label[data-value='huge']::before,\n    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='huge']::before {\n        content: 'Huge';\n    }\n    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='small']::before {\n        font-size: 10px;\n    }\n    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='large']::before {\n        font-size: 18px;\n    }\n    .ql-snow .ql-picker.ql-size .ql-picker-item[data-value='huge']::before {\n        font-size: 32px;\n    }\n    .ql-snow .ql-color-picker.ql-background .ql-picker-item {\n        background: #fff;\n    }\n    .ql-snow .ql-color-picker.ql-color .ql-picker-item {\n        background: #000;\n    }\n    .ql-toolbar.ql-snow {\n        border: 1px solid #ccc;\n        box-sizing: border-box;\n        font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;\n        padding: 8px;\n    }\n    .ql-toolbar.ql-snow .ql-formats {\n        margin-inline-end: 15px;\n    }\n    .ql-toolbar.ql-snow .ql-picker-label {\n        border: 1px solid transparent;\n    }\n    .ql-toolbar.ql-snow .ql-picker-options {\n        border: 1px solid transparent;\n        box-shadow: rgba(0, 0, 0, 0.2) 0 2px 8px;\n    }\n    .ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label {\n        border-color: #ccc;\n    }\n    .ql-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options {\n        border-color: #ccc;\n    }\n    .ql-toolbar.ql-snow .ql-color-picker .ql-picker-item.ql-selected,\n    .ql-toolbar.ql-snow .ql-color-picker .ql-picker-item:hover {\n        border-color: #000;\n    }\n    .ql-toolbar.ql-snow + .ql-container.ql-snow {\n        border-block-start: 0;\n    }\n    .ql-snow .ql-tooltip {\n        background: #fff;\n        border: 1px solid #ccc;\n        box-shadow: 0 0 5px #ddd;\n        color: #444;\n        padding: 5px 12px;\n        white-space: nowrap;\n    }\n    .ql-snow .ql-tooltip::before {\n        content: 'Visit URL:';\n        line-height: 26px;\n        margin-inline-end: 8px;\n    }\n    .ql-snow .ql-tooltip input[type='text'] {\n        display: none;\n        border: 1px solid #ccc;\n        font-size: 13px;\n        height: 26px;\n        margin: 0;\n        padding: 3px 5px;\n        width: 170px;\n    }\n    .ql-snow .ql-tooltip a.ql-preview {\n        display: inline-block;\n        max-width: 200px;\n        overflow-x: hidden;\n        text-overflow: ellipsis;\n        vertical-align: top;\n    }\n    .ql-snow .ql-tooltip a.ql-action::after {\n        border-inline-end: 1px solid #ccc;\n        content: 'Edit';\n        margin-inline-start: 16px;\n        padding-inline-end: 8px;\n    }\n    .ql-snow .ql-tooltip a.ql-remove::before {\n        content: 'Remove';\n        margin-inline-start: 8px;\n    }\n    .ql-snow .ql-tooltip a {\n        line-height: 26px;\n    }\n    .ql-snow .ql-tooltip.ql-editing a.ql-preview,\n    .ql-snow .ql-tooltip.ql-editing a.ql-remove {\n        display: none;\n    }\n    .ql-snow .ql-tooltip.ql-editing input[type='text'] {\n        display: inline-block;\n    }\n    .ql-snow .ql-tooltip.ql-editing a.ql-action::after {\n        border-inline-end: 0;\n        content: 'Save';\n        padding-inline-end: 0;\n    }\n    .ql-snow .ql-tooltip[data-mode='link']::before {\n        content: 'Enter link:';\n    }\n    .ql-snow .ql-tooltip[data-mode='formula']::before {\n        content: 'Enter formula:';\n    }\n    .ql-snow .ql-tooltip[data-mode='video']::before {\n        content: 'Enter video:';\n    }\n    .ql-snow a {\n        color: #06c;\n    }\n    .ql-container.ql-snow {\n        border: 1px solid #ccc;\n    }\n\n    .p-editor {\n        display: block;\n    }\n\n    .p-editor .p-editor-toolbar {\n        background: dt('editor.toolbar.background');\n        border-start-end-radius: dt('editor.toolbar.border.radius');\n        border-start-start-radius: dt('editor.toolbar.border.radius');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow {\n        border: 1px solid dt('editor.toolbar.border.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-stroke {\n        stroke: dt('editor.toolbar.item.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-fill {\n        fill: dt('editor.toolbar.item.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker .ql-picker-label {\n        border: 0 none;\n        color: dt('editor.toolbar.item.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker .ql-picker-label:hover {\n        color: dt('editor.toolbar.item.hover.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker .ql-picker-label:hover .ql-stroke {\n        stroke: dt('editor.toolbar.item.hover.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker .ql-picker-label:hover .ql-fill {\n        fill: dt('editor.toolbar.item.hover.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label {\n        color: dt('editor.toolbar.item.active.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-stroke {\n        stroke: dt('editor.toolbar.item.active.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-label .ql-fill {\n        fill: dt('editor.toolbar.item.active.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options {\n        background: dt('editor.overlay.background');\n        border: 1px solid dt('editor.overlay.border.color');\n        box-shadow: dt('editor.overlay.shadow');\n        border-radius: dt('editor.overlay.border.radius');\n        padding: dt('editor.overlay.padding');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options .ql-picker-item {\n        color: dt('editor.overlay.option.color');\n        border-radius: dt('editor.overlay.option.border.radius');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker.ql-expanded .ql-picker-options .ql-picker-item:hover {\n        background: dt('editor.overlay.option.focus.background');\n        color: dt('editor.overlay.option.focus.color');\n    }\n\n    .p-editor .p-editor-toolbar.ql-snow .ql-picker.ql-expanded:not(.ql-color-picker, .ql-icon-picker) .ql-picker-item {\n        padding: dt('editor.overlay.option.padding');\n    }\n\n    .p-editor .p-editor-content {\n        border-end-end-radius: dt('editor.content.border.radius');\n        border-end-start-radius: dt('editor.content.border.radius');\n    }\n\n    .p-editor .p-editor-content.ql-snow {\n        border: 1px solid dt('editor.content.border.color');\n    }\n\n    .p-editor .p-editor-content .ql-editor {\n        background: dt('editor.content.background');\n        color: dt('editor.content.color');\n        border-end-end-radius: dt('editor.content.border.radius');\n        border-end-start-radius: dt('editor.content.border.radius');\n    }\n\n    .p-editor .ql-snow.ql-toolbar button:hover,\n    .p-editor .ql-snow.ql-toolbar button:focus {\n        color: dt('editor.toolbar.item.hover.color');\n    }\n\n    .p-editor .ql-snow.ql-toolbar button:hover .ql-stroke,\n    .p-editor .ql-snow.ql-toolbar button:focus .ql-stroke {\n        stroke: dt('editor.toolbar.item.hover.color');\n    }\n\n    .p-editor .ql-snow.ql-toolbar button:hover .ql-fill,\n    .p-editor .ql-snow.ql-toolbar button:focus .ql-fill {\n        fill: dt('editor.toolbar.item.hover.color');\n    }\n\n    .p-editor .ql-snow.ql-toolbar button.ql-active,\n    .p-editor .ql-snow.ql-toolbar .ql-picker-label.ql-active,\n    .p-editor .ql-snow.ql-toolbar .ql-picker-item.ql-selected {\n        color: dt('editor.toolbar.item.active.color');\n    }\n\n    .p-editor .ql-snow.ql-toolbar button.ql-active .ql-stroke,\n    .p-editor .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-stroke,\n    .p-editor .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-stroke {\n        stroke: dt('editor.toolbar.item.active.color');\n    }\n\n    .p-editor .ql-snow.ql-toolbar button.ql-active .ql-fill,\n    .p-editor .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-fill,\n    .p-editor .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-fill {\n        fill: dt('editor.toolbar.item.active.color');\n    }\n\n    .p-editor .ql-snow.ql-toolbar button.ql-active .ql-picker-label,\n    .p-editor .ql-snow.ql-toolbar .ql-picker-label.ql-active .ql-picker-label,\n    .p-editor .ql-snow.ql-toolbar .ql-picker-item.ql-selected .ql-picker-label {\n        color: dt('editor.toolbar.item.active.color');\n    }\n";

// node_modules/primeng/fesm2022/primeng-editor.mjs
var _c09 = ["header"];
var _c13 = [[["p-header"]]];
var _c23 = ["p-header"];
function Editor_div_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Editor_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275projection(1);
    \u0275\u0275template(2, Editor_div_0_ng_container_2_Template, 1, 0, "ng-container", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r0.cx("toolbar"));
    \u0275\u0275property("pBind", ctx_r0.ptm("toolbar"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.headerTemplate || ctx_r0._headerTemplate);
  }
}
function Editor_div_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2)(1, "span", 4)(2, "select", 5)(3, "option", 6);
    \u0275\u0275text(4, "Heading");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "option", 7);
    \u0275\u0275text(6, "Subheading");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "option", 8);
    \u0275\u0275text(8, "Normal");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "select", 9)(10, "option", 8);
    \u0275\u0275text(11, "Sans Serif");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "option", 10);
    \u0275\u0275text(13, "Serif");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "option", 11);
    \u0275\u0275text(15, "Monospace");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(16, "span", 4);
    \u0275\u0275element(17, "button", 12)(18, "button", 13)(19, "button", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(20, "span", 4);
    \u0275\u0275element(21, "select", 15)(22, "select", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(23, "span", 4);
    \u0275\u0275element(24, "button", 17)(25, "button", 18);
    \u0275\u0275elementStart(26, "select", 19);
    \u0275\u0275element(27, "option", 8);
    \u0275\u0275elementStart(28, "option", 20);
    \u0275\u0275text(29, "center");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(30, "option", 21);
    \u0275\u0275text(31, "right");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(32, "option", 22);
    \u0275\u0275text(33, "justify");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(34, "span", 4);
    \u0275\u0275element(35, "button", 23)(36, "button", 24)(37, "button", 25);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(38, "span", 4);
    \u0275\u0275element(39, "button", 26);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r0.cx("toolbar"));
    \u0275\u0275property("pBind", ctx_r0.ptm("toolbar"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("formats"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("header"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r0.ptm("select"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r0.ptm("formats"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("bold"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("italic"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("underline"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("formats"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("color"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("background"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("formats"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("list"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("list"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("select"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r0.ptm("option"));
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r0.ptm("formats"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("link"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("image"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("codeBlock"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("formats"));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r0.ptm("clean"));
  }
}
var classes3 = {
  root: ({
    instance
  }) => ["p-editor", {
    "p-invalid": instance.invalid()
  }],
  toolbar: "p-editor-toolbar",
  content: "p-editor-content"
};
var EditorStyle = class _EditorStyle extends BaseStyle {
  name = "editor";
  style = style4;
  classes = classes3;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275EditorStyle_BaseFactory;
    return function EditorStyle_Factory(__ngFactoryType__) {
      return (\u0275EditorStyle_BaseFactory || (\u0275EditorStyle_BaseFactory = \u0275\u0275getInheritedFactory(_EditorStyle)))(__ngFactoryType__ || _EditorStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _EditorStyle,
    factory: _EditorStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditorStyle, [{
    type: Injectable
  }], null, null);
})();
var EditorClasses;
(function(EditorClasses2) {
  EditorClasses2["root"] = "p-editor";
  EditorClasses2["toolbar"] = "p-editor-toolbar";
  EditorClasses2["content"] = "p-editor-content";
})(EditorClasses || (EditorClasses = {}));
var EDITOR_INSTANCE = new InjectionToken("EDITOR_INSTANCE");
var EDITOR_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => Editor),
  multi: true
};
var Editor = class _Editor extends BaseEditableHolder {
  $pcEditor = inject(EDITOR_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * Inline style of the container.
   * @group Props
   */
  style;
  /**
   * Style class of the container.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Placeholder text to show when editor is empty.
   * @group Props
   */
  placeholder;
  /**
   * Whitelist of formats to display, see [here](https://quilljs.com/docs/formats/) for available options.
   * @group Props
   */
  formats;
  /**
   * Modules configuration of Editor, see [here](https://quilljs.com/docs/modules/) for available options.
   * @group Props
   */
  modules;
  /**
   * DOM Element or a CSS selector for a DOM Element, within which the editor’s p elements (i.e. tooltips, etc.) should be confined. Currently, it only considers left and right boundaries.
   * @group Props
   */
  bounds;
  /**
   * DOM Element or a CSS selector for a DOM Element, specifying which container has the scrollbars (i.e. overflow-y: auto), if is has been changed from the default ql-editor with custom CSS. Necessary to fix scroll jumping bugs when Quill is set to auto grow its height, and another ancestor container is responsible from the scrolling..
   * @group Props
   */
  scrollingContainer;
  /**
   * Shortcut for debug. Note debug is a static method and will affect other instances of Quill editors on the page. Only warning and error messages are enabled by default.
   * @group Props
   */
  debug;
  /**
   * Whether to instantiate the editor to read-only mode.
   * @group Props
   */
  get readonly() {
    return this._readonly;
  }
  set readonly(val) {
    this._readonly = val;
    if (this.quill) {
      if (this._readonly) this.quill.disable();
      else this.quill.enable();
    }
  }
  /**
   * Callback to invoke when the quill modules are loaded.
   * @param {EditorInitEvent} event - custom event.
   * @group Emits
   */
  onEditorInit = new EventEmitter();
  /**
   * Callback to invoke when text of editor changes.
   * @param {EditorTextChangeEvent} event - custom event.
   * @group Emits
   */
  onTextChange = new EventEmitter();
  /**
   * Callback to invoke when selection of the text changes.
   * @param {EditorSelectionChangeEvent} event - custom event.
   * @group Emits
   */
  onSelectionChange = new EventEmitter();
  /**
   * Callback to invoke when editor content changes (combines both text and selection changes).
   * @param {EditorChangeEvent} event - custom event.
   * @group Emits
   */
  onEditorChange = new EventEmitter();
  /**
   * Callback to invoke when editor receives focus.
   * @param {EditorFocusEvent} event - custom event.
   * @group Emits
   */
  onFocus = new EventEmitter();
  /**
   * Callback to invoke when editor loses focus.
   * @param {EditorBlurEvent} event - custom event.
   * @group Emits
   */
  onBlur = new EventEmitter();
  toolbar;
  value;
  delayedCommand = null;
  _readonly = false;
  quill;
  dynamicQuill;
  /**
   * Custom item template.
   * @group Templates
   */
  headerTemplate;
  templates;
  _headerTemplate;
  get isAttachedQuillEditorToDOM() {
    return this.quillElements?.editorElement?.isConnected;
  }
  quillElements;
  focusListener = null;
  blurListener = null;
  _componentStyle = inject(EditorStyle);
  constructor() {
    super();
    afterNextRender(() => {
      this.initQuillElements();
      this.initQuillEditor();
    });
  }
  onAfterContentInit() {
    this.templates.forEach((item) => {
      switch (item.getType()) {
        case "header":
          this.headerTemplate = item.template;
          break;
      }
    });
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value) {
    this.value = value;
    if (this.quill) {
      if (value) {
        const command = () => {
          this.quill.setContents(this.quill.clipboard.convert(this.dynamicQuill.version.startsWith("2") ? {
            html: this.value
          } : this.value));
        };
        if (this.isAttachedQuillEditorToDOM) {
          command();
        } else {
          this.delayedCommand = command;
        }
      } else {
        const command = () => {
          this.quill.setText("");
        };
        if (this.isAttachedQuillEditorToDOM) {
          command();
        } else {
          this.delayedCommand = command;
        }
      }
    }
  }
  getQuill() {
    return this.quill;
  }
  initQuillEditor() {
    if (isPlatformServer(this.platformId)) {
      return;
    }
    if (!this.dynamicQuill) {
      import("./chunk-AGF4UJHH.js").then((quillModule) => {
        this.dynamicQuill = quillModule.default;
        this.createQuillEditor();
      }).catch((e) => console.error(e.message));
    } else {
      this.createQuillEditor();
    }
  }
  createQuillEditor() {
    this.initQuillElements();
    const {
      toolbarElement,
      editorElement
    } = this.quillElements;
    let defaultModule = {
      toolbar: toolbarElement
    };
    let modules = this.modules ? __spreadValues(__spreadValues({}, defaultModule), this.modules) : defaultModule;
    this.quill = new this.dynamicQuill(editorElement, {
      modules,
      placeholder: this.placeholder,
      readOnly: this.readonly,
      theme: "snow",
      formats: this.formats,
      bounds: this.bounds,
      debug: this.debug,
      scrollingContainer: this.scrollingContainer
    });
    const isQuill2 = this.dynamicQuill.version.startsWith("2");
    if (this.value) {
      this.quill.setContents(this.quill.clipboard.convert(isQuill2 ? {
        html: this.value
      } : this.value));
    }
    this.quill.on("text-change", (delta, oldContents, source) => {
      if (source === "user") {
        let html = isQuill2 ? this.quill.getSemanticHTML() : z(editorElement, ".ql-editor")?.innerHTML;
        let text = this.quill.getText().trim();
        if (html === "<p><br></p>") {
          html = null;
        }
        this.onTextChange.emit({
          htmlValue: html,
          textValue: text,
          delta,
          source
        });
        this.onModelChange(html);
        this.onModelTouched();
      }
    });
    this.quill.on("selection-change", (range, oldRange, source) => {
      this.onSelectionChange.emit({
        range,
        oldRange,
        source
      });
    });
    this.quill.on("editor-change", (eventName, ...args) => {
      this.onEditorChange.emit({
        eventName,
        args
      });
    });
    const editorEl = this.quill.root;
    this.focusListener = () => {
      this.onFocus.emit({
        source: "user"
      });
    };
    this.blurListener = () => {
      this.onBlur.emit({
        source: "user"
      });
    };
    editorEl.addEventListener("focus", this.focusListener);
    editorEl.addEventListener("blur", this.blurListener);
    this.onEditorInit.emit({
      editor: this.quill
    });
  }
  onDestroy() {
    if (this.quill && this.quill.root) {
      const editorEl = this.quill.root;
      if (this.focusListener) {
        editorEl.removeEventListener("focus", this.focusListener);
        this.focusListener = null;
      }
      if (this.blurListener) {
        editorEl.removeEventListener("blur", this.blurListener);
        this.blurListener = null;
      }
    }
  }
  initQuillElements() {
    if (!this.quillElements) {
      this.quillElements = {
        editorElement: z(this.el.nativeElement, 'div[data-pc-section="content"]'),
        toolbarElement: z(this.el.nativeElement, 'div[data-pc-section="toolbar"]')
      };
    }
  }
  static \u0275fac = function Editor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Editor)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _Editor,
    selectors: [["p-editor"]],
    contentQueries: function Editor_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, Header, 5);
        \u0275\u0275contentQuery(dirIndex, _c09, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.toolbar = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    hostVars: 2,
    hostBindings: function Editor_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      style: "style",
      styleClass: "styleClass",
      placeholder: "placeholder",
      formats: "formats",
      modules: "modules",
      bounds: "bounds",
      scrollingContainer: "scrollingContainer",
      debug: "debug",
      readonly: "readonly"
    },
    outputs: {
      onEditorInit: "onInit",
      onTextChange: "onTextChange",
      onSelectionChange: "onSelectionChange",
      onEditorChange: "onEditorChange",
      onFocus: "onFocus",
      onBlur: "onBlur"
    },
    features: [\u0275\u0275ProvidersFeature([EDITOR_VALUE_ACCESSOR, EditorStyle, {
      provide: EDITOR_INSTANCE,
      useExisting: _Editor
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _Editor
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    ngContentSelectors: _c23,
    decls: 3,
    vars: 6,
    consts: [[3, "class", "pBind", 4, "ngIf"], [3, "ngStyle", "pBind"], [3, "pBind"], [4, "ngTemplateOutlet"], [1, "ql-formats", 3, "pBind"], [1, "ql-header", 3, "pBind"], ["value", "1", 3, "pBind"], ["value", "2", 3, "pBind"], ["selected", "", 3, "pBind"], [1, "ql-font", 3, "pBind"], ["value", "serif", 3, "pBind"], ["value", "monospace", 3, "pBind"], ["aria-label", "Bold", "type", "button", 1, "ql-bold", 3, "pBind"], ["aria-label", "Italic", "type", "button", 1, "ql-italic", 3, "pBind"], ["aria-label", "Underline", "type", "button", 1, "ql-underline", 3, "pBind"], [1, "ql-color", 3, "pBind"], [1, "ql-background", 3, "pBind"], ["value", "ordered", "aria-label", "Ordered List", "type", "button", 1, "ql-list", 3, "pBind"], ["value", "bullet", "aria-label", "Unordered List", "type", "button", 1, "ql-list", 3, "pBind"], [1, "ql-align", 3, "pBind"], ["value", "center", 3, "pBind"], ["value", "right", 3, "pBind"], ["value", "justify", 3, "pBind"], ["aria-label", "Insert Link", "type", "button", 1, "ql-link", 3, "pBind"], ["aria-label", "Insert Image", "type", "button", 1, "ql-image", 3, "pBind"], ["aria-label", "Insert Code Block", "type", "button", 1, "ql-code-block", 3, "pBind"], ["aria-label", "Remove Styles", "type", "button", 1, "ql-clean", 3, "pBind"]],
    template: function Editor_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef(_c13);
        \u0275\u0275template(0, Editor_div_0_Template, 3, 4, "div", 0)(1, Editor_div_1_Template, 40, 33, "div", 0);
        \u0275\u0275element(2, "div", 1);
      }
      if (rf & 2) {
        \u0275\u0275property("ngIf", ctx.toolbar || ctx.headerTemplate || ctx._headerTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", !ctx.toolbar && !ctx.headerTemplate && !ctx._headerTemplate);
        \u0275\u0275advance();
        \u0275\u0275classMap(ctx.cx("content"));
        \u0275\u0275property("ngStyle", ctx.style)("pBind", ctx.ptm("content"));
      }
    },
    dependencies: [CommonModule, NgIf, NgTemplateOutlet, NgStyle, SharedModule, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Editor, [{
    type: Component,
    args: [{
      selector: "p-editor",
      standalone: true,
      imports: [CommonModule, SharedModule, BindModule],
      template: `
        <div [class]="cx('toolbar')" *ngIf="toolbar || headerTemplate || _headerTemplate" [pBind]="ptm('toolbar')">
            <ng-content select="p-header"></ng-content>
            <ng-container *ngTemplateOutlet="headerTemplate || _headerTemplate"></ng-container>
        </div>
        <div [class]="cx('toolbar')" *ngIf="!toolbar && !headerTemplate && !_headerTemplate" [pBind]="ptm('toolbar')">
            <span class="ql-formats" [pBind]="ptm('formats')">
                <select class="ql-header" [pBind]="ptm('header')">
                    <option value="1" [pBind]="ptm('option')">Heading</option>
                    <option value="2" [pBind]="ptm('option')">Subheading</option>
                    <option selected [pBind]="ptm('option')">Normal</option>
                </select>
                <select class="ql-font" [pBind]="ptm('select')">
                    <option selected [pBind]="ptm('option')">Sans Serif</option>
                    <option value="serif" [pBind]="ptm('option')">Serif</option>
                    <option value="monospace" [pBind]="ptm('option')">Monospace</option>
                </select>
            </span>
            <span class="ql-formats" [pBind]="ptm('formats')">
                <button class="ql-bold" aria-label="Bold" type="button" [pBind]="ptm('bold')"></button>
                <button class="ql-italic" aria-label="Italic" type="button" [pBind]="ptm('italic')"></button>
                <button class="ql-underline" aria-label="Underline" type="button" [pBind]="ptm('underline')"></button>
            </span>
            <span class="ql-formats" [pBind]="ptm('formats')">
                <select class="ql-color" [pBind]="ptm('color')"></select>
                <select class="ql-background" [pBind]="ptm('background')"></select>
            </span>
            <span class="ql-formats" [pBind]="ptm('formats')">
                <button class="ql-list" value="ordered" aria-label="Ordered List" type="button" [pBind]="ptm('list')"></button>
                <button class="ql-list" value="bullet" aria-label="Unordered List" type="button" [pBind]="ptm('list')"></button>
                <select class="ql-align" [pBind]="ptm('select')">
                    <option selected [pBind]="ptm('option')"></option>
                    <option value="center" [pBind]="ptm('option')">center</option>
                    <option value="right" [pBind]="ptm('option')">right</option>
                    <option value="justify" [pBind]="ptm('option')">justify</option>
                </select>
            </span>
            <span class="ql-formats" [pBind]="ptm('formats')">
                <button class="ql-link" aria-label="Insert Link" type="button" [pBind]="ptm('link')"></button>
                <button class="ql-image" aria-label="Insert Image" type="button" [pBind]="ptm('image')"></button>
                <button class="ql-code-block" aria-label="Insert Code Block" type="button" [pBind]="ptm('codeBlock')"></button>
            </span>
            <span class="ql-formats" [pBind]="ptm('formats')">
                <button class="ql-clean" aria-label="Remove Styles" type="button" [pBind]="ptm('clean')"></button>
            </span>
        </div>
        <div [class]="cx('content')" [ngStyle]="style" [pBind]="ptm('content')"></div>
    `,
      providers: [EDITOR_VALUE_ACCESSOR, EditorStyle, {
        provide: EDITOR_INSTANCE,
        useExisting: Editor
      }, {
        provide: PARENT_INSTANCE,
        useExisting: Editor
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cn(cx('root'), styleClass)"
      },
      hostDirectives: [Bind]
    }]
  }], () => [], {
    style: [{
      type: Input
    }],
    styleClass: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    formats: [{
      type: Input
    }],
    modules: [{
      type: Input
    }],
    bounds: [{
      type: Input
    }],
    scrollingContainer: [{
      type: Input
    }],
    debug: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    onEditorInit: [{
      type: Output,
      args: ["onInit"]
    }],
    onTextChange: [{
      type: Output
    }],
    onSelectionChange: [{
      type: Output
    }],
    onEditorChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    onBlur: [{
      type: Output
    }],
    toolbar: [{
      type: ContentChild,
      args: [Header]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: ["header", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }]
  });
})();
var EditorModule = class _EditorModule {
  static \u0275fac = function EditorModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EditorModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _EditorModule,
    imports: [Editor, SharedModule],
    exports: [Editor, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [Editor, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EditorModule, [{
    type: NgModule,
    args: [{
      imports: [Editor, SharedModule],
      exports: [Editor, SharedModule]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/password/index.mjs
var style5 = "\n    .p-password {\n        display: inline-flex;\n        position: relative;\n    }\n\n    .p-password .p-password-overlay {\n        min-width: 100%;\n    }\n\n    .p-password-meter {\n        height: dt('password.meter.height');\n        background: dt('password.meter.background');\n        border-radius: dt('password.meter.border.radius');\n    }\n\n    .p-password-meter-label {\n        height: 100%;\n        width: 0;\n        transition: width 1s ease-in-out;\n        border-radius: dt('password.meter.border.radius');\n    }\n\n    .p-password-meter-weak {\n        background: dt('password.strength.weak.background');\n    }\n\n    .p-password-meter-medium {\n        background: dt('password.strength.medium.background');\n    }\n\n    .p-password-meter-strong {\n        background: dt('password.strength.strong.background');\n    }\n\n    .p-password-fluid {\n        display: flex;\n    }\n\n    .p-password-fluid .p-password-input {\n        width: 100%;\n    }\n\n    .p-password-input::-ms-reveal,\n    .p-password-input::-ms-clear {\n        display: none;\n    }\n\n    .p-password-overlay {\n        padding: dt('password.overlay.padding');\n        background: dt('password.overlay.background');\n        color: dt('password.overlay.color');\n        border: 1px solid dt('password.overlay.border.color');\n        box-shadow: dt('password.overlay.shadow');\n        border-radius: dt('password.overlay.border.radius');\n    }\n\n    .p-password-content {\n        display: flex;\n        flex-direction: column;\n        gap: dt('password.content.gap');\n    }\n\n    .p-password-toggle-mask-icon {\n        inset-inline-end: dt('form.field.padding.x');\n        color: dt('password.icon.color');\n        position: absolute;\n        top: 50%;\n        margin-top: calc(-1 * calc(dt('icon.size') / 2));\n        width: dt('icon.size');\n        height: dt('icon.size');\n    }\n\n    .p-password-clear-icon {\n        position: absolute;\n        top: 50%;\n        margin-top: -0.5rem;\n        cursor: pointer;\n        inset-inline-end: dt('form.field.padding.x');\n        color: dt('form.field.icon.color');\n    }\n\n    .p-password:has(.p-password-toggle-mask-icon) .p-password-input {\n        padding-inline-end: calc((dt('form.field.padding.x') * 2) + dt('icon.size'));\n    }\n\n    .p-password:has(.p-password-toggle-mask-icon) .p-password-clear-icon {\n        inset-inline-end: calc((dt('form.field.padding.x') * 2) + dt('icon.size'));\n    }\n\n    .p-password:has(.p-password-clear-icon) .p-password-input {\n        padding-inline-end: calc((dt('form.field.padding.x') * 2) + dt('icon.size'));\n    }\n\n    .p-password:has(.p-password-clear-icon):has(.p-password-toggle-mask-icon)  .p-password-input {\n        padding-inline-end: calc((dt('form.field.padding.x') * 3) + calc(dt('icon.size') * 2));\n    }\n\n";

// node_modules/primeng/fesm2022/primeng-password.mjs
var _c010 = ["content"];
var _c14 = ["footer"];
var _c24 = ["header"];
var _c33 = ["clearicon"];
var _c42 = ["hideicon"];
var _c52 = ["showicon"];
var _c6 = ["overlay"];
var _c7 = ["input"];
var _c8 = (a0) => ({
  class: a0
});
var _c9 = (a0) => ({
  width: a0
});
function Password_ng_container_2__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg", 10);
    \u0275\u0275listener("click", function Password_ng_container_2__svg_svg_1_Template_svg_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.clear());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r3.cx("clearIcon"));
    \u0275\u0275property("pBind", ctx_r3.ptm("clearIcon"));
  }
}
function Password_ng_container_2_3_ng_template_0_Template(rf, ctx) {
}
function Password_ng_container_2_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Password_ng_container_2_3_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function Password_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Password_ng_container_2__svg_svg_1_Template, 1, 3, "svg", 7);
    \u0275\u0275elementStart(2, "span", 8);
    \u0275\u0275listener("click", function Password_ng_container_2_Template_span_click_2_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.clear());
    });
    \u0275\u0275template(3, Password_ng_container_2_3_Template, 1, 0, null, 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r3.clearIconTemplate && !ctx_r3._clearIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r3.cx("clearIcon"));
    \u0275\u0275property("pBind", ctx_r3.ptm("clearIcon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.clearIconTemplate || ctx_r3._clearIconTemplate);
  }
}
function Password_ng_container_3_ng_container_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg", 13);
    \u0275\u0275listener("click", function Password_ng_container_3_ng_container_1__svg_svg_1_Template_svg_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.onMaskToggle());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r3.cx("maskIcon"));
    \u0275\u0275property("pBind", ctx_r3.ptm("maskIcon"));
  }
}
function Password_ng_container_3_ng_container_1_span_2_1_ng_template_0_Template(rf, ctx) {
}
function Password_ng_container_3_ng_container_1_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Password_ng_container_3_ng_container_1_span_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function Password_ng_container_3_ng_container_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 8);
    \u0275\u0275listener("click", function Password_ng_container_3_ng_container_1_span_2_Template_span_click_0_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.onMaskToggle());
    });
    \u0275\u0275template(1, Password_ng_container_3_ng_container_1_span_2_1_Template, 1, 0, null, 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(3);
    \u0275\u0275property("pBind", ctx_r3.ptm("maskIcon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.hideIconTemplate || ctx_r3._hideIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(3, _c8, ctx_r3.cx("maskIcon")));
  }
}
function Password_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Password_ng_container_3_ng_container_1__svg_svg_1_Template, 1, 3, "svg", 11)(2, Password_ng_container_3_ng_container_1_span_2_Template, 2, 5, "span", 12);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r3.hideIconTemplate && !ctx_r3._hideIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r3.hideIconTemplate || ctx_r3._hideIconTemplate);
  }
}
function Password_ng_container_3_ng_container_2__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg", 16);
    \u0275\u0275listener("click", function Password_ng_container_3_ng_container_2__svg_svg_1_Template_svg_click_0_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.onMaskToggle());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r3.cx("unmaskIcon"));
    \u0275\u0275property("pBind", ctx_r3.ptm("unmaskIcon"));
  }
}
function Password_ng_container_3_ng_container_2_span_2_1_ng_template_0_Template(rf, ctx) {
}
function Password_ng_container_3_ng_container_2_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Password_ng_container_3_ng_container_2_span_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function Password_ng_container_3_ng_container_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 8);
    \u0275\u0275listener("click", function Password_ng_container_3_ng_container_2_span_2_Template_span_click_0_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r3 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r3.onMaskToggle());
    });
    \u0275\u0275template(1, Password_ng_container_3_ng_container_2_span_2_1_Template, 1, 0, null, 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(3);
    \u0275\u0275property("pBind", ctx_r3.ptm("unmaskIcon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.showIconTemplate || ctx_r3._showIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(3, _c8, ctx_r3.cx("unmaskIcon")));
  }
}
function Password_ng_container_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Password_ng_container_3_ng_container_2__svg_svg_1_Template, 1, 3, "svg", 15)(2, Password_ng_container_3_ng_container_2_span_2_Template, 2, 5, "span", 12);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r3.showIconTemplate && !ctx_r3._showIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r3.showIconTemplate || ctx_r3._showIconTemplate);
  }
}
function Password_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Password_ng_container_3_ng_container_1_Template, 3, 2, "ng-container", 5)(2, Password_ng_container_3_ng_container_2_Template, 3, 2, "ng-container", 5);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r3.unmasked);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r3.unmasked);
  }
}
function Password_ng_template_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Password_ng_template_6_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Password_ng_template_6_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Password_ng_template_6_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.contentTemplate || ctx_r3._contentTemplate);
  }
}
function Password_ng_template_6_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 18)(1, "div", 18);
    \u0275\u0275element(2, "div", 19);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 18);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r3.cx("content"));
    \u0275\u0275property("pBind", ctx_r3.ptm("content"));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r3.cx("meter"));
    \u0275\u0275property("pBind", ctx_r3.ptm("meter"));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r3.cx("meterLabel"));
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(15, _c9, ctx_r3.meter ? ctx_r3.meter.width : ""))("pBind", ctx_r3.ptm("meterLabel"));
    \u0275\u0275attribute("data-p", ctx_r3.meterDataP);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r3.cx("meterText"));
    \u0275\u0275property("pBind", ctx_r3.ptm("meterText"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r3.infoText);
  }
}
function Password_ng_template_6_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Password_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275listener("click", function Password_ng_template_6_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onOverlayClick($event));
    });
    \u0275\u0275template(1, Password_ng_template_6_ng_container_1_Template, 1, 0, "ng-container", 9)(2, Password_ng_template_6_ng_container_2_Template, 2, 1, "ng-container", 17)(3, Password_ng_template_6_ng_template_3_Template, 5, 17, "ng-template", null, 3, \u0275\u0275templateRefExtractor)(5, Password_ng_template_6_ng_container_5_Template, 1, 0, "ng-container", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const defaultContent_r10 = \u0275\u0275reference(4);
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r3.sx("overlay"));
    \u0275\u0275classMap(ctx_r3.cx("overlay"));
    \u0275\u0275property("pBind", ctx_r3.ptm("overlay"));
    \u0275\u0275attribute("data-p", ctx_r3.overlayDataP);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.headerTemplate || ctx_r3._headerTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r3.contentTemplate || ctx_r3._contentTemplate)("ngIfElse", defaultContent_r10);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.footerTemplate || ctx_r3._footerTemplate);
  }
}
var style6 = (
  /*css*/
  `
${style5}

/* For PrimeNG */
.p-password-overlay {
    min-width: 100%;
}

p-password.ng-invalid.ng-dirty .p-inputtext {
    border-color: dt('inputtext.invalid.border.color');
}

p-password.ng-invalid.ng-dirty .p-inputtext:enabled:focus {
    border-color: dt('inputtext.focus.border.color');
}

p-password.ng-invalid.ng-dirty .p-inputtext::placeholder {
    color: dt('inputtext.invalid.placeholder.color');
}

.p-password-fluid-directive {
    width: 100%;
}

/* Animations */
.p-password-enter {
    animation: p-animate-password-enter 300ms cubic-bezier(.19,1,.22,1);
}

.p-password-leave {
    animation: p-animate-password-leave 300ms cubic-bezier(.19,1,.22,1);
}

@keyframes p-animate-password-enter {
    from {
        opacity: 0;
        transform: scale(0.93);
    }
}

@keyframes p-animate-password-leave {
    to {
        opacity: 0;
        transform: scale(0.93);
    }
}
`
);
var inlineStyles = {
  root: ({
    instance
  }) => ({
    position: instance.$appendTo() === "self" ? "relative" : void 0
  }),
  overlay: {
    position: "absolute"
  }
};
var classes4 = {
  root: ({
    instance
  }) => ["p-password p-component p-inputwrapper", {
    "p-inputwrapper-filled": instance.$filled(),
    "p-variant-filled": instance.$variant() === "filled",
    "p-inputwrapper-focus": instance.focused,
    "p-password-fluid": instance.hasFluid
  }],
  rootDirective: ({
    instance
  }) => ["p-password p-inputtext p-component p-inputwrapper", {
    "p-inputwrapper-filled": instance.$filled(),
    "p-variant-filled": instance.$variant() === "filled",
    "p-password-fluid-directive": instance.hasFluid
  }],
  pcInputText: "p-password-input",
  maskIcon: "p-password-toggle-mask-icon p-password-mask-icon",
  unmaskIcon: "p-password-toggle-mask-icon p-password-unmask-icon",
  overlay: "p-password-overlay p-component",
  content: "p-password-content",
  meter: "p-password-meter",
  meterLabel: ({
    instance
  }) => `p-password-meter-label ${instance.meter ? "p-password-meter-" + instance.meter.strength : ""}`,
  meterText: "p-password-meter-text",
  clearIcon: "p-password-clear-icon"
};
var PasswordStyle = class _PasswordStyle extends BaseStyle {
  name = "password";
  style = style6;
  classes = classes4;
  inlineStyles = inlineStyles;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275PasswordStyle_BaseFactory;
    return function PasswordStyle_Factory(__ngFactoryType__) {
      return (\u0275PasswordStyle_BaseFactory || (\u0275PasswordStyle_BaseFactory = \u0275\u0275getInheritedFactory(_PasswordStyle)))(__ngFactoryType__ || _PasswordStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PasswordStyle,
    factory: _PasswordStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PasswordStyle, [{
    type: Injectable
  }], null, null);
})();
var PasswordClasses;
(function(PasswordClasses2) {
  PasswordClasses2["root"] = "p-password";
  PasswordClasses2["pcInputText"] = "p-password-input";
  PasswordClasses2["maskIcon"] = "p-password-mask-icon";
  PasswordClasses2["unmaskIcon"] = "p-password-unmask-icon";
  PasswordClasses2["overlay"] = "p-password-overlay";
  PasswordClasses2["meter"] = "p-password-meter";
  PasswordClasses2["meterLabel"] = "p-password-meter-label";
  PasswordClasses2["meterText"] = "p-password-meter-text";
  PasswordClasses2["clearIcon"] = "p-password-clear-icon";
})(PasswordClasses || (PasswordClasses = {}));
var PASSWORD_DIRECTIVE_INSTANCE = new InjectionToken("PASSWORD_DIRECTIVE_INSTANCE");
var PASSWORD_INSTANCE = new InjectionToken("PASSWORD_INSTANCE");
var PasswordDirective = class _PasswordDirective extends BaseEditableHolder {
  zone;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  $pcPasswordDirective = inject(PASSWORD_DIRECTIVE_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  /**
   * Used to pass attributes to DOM elements inside the Password component.
   * @defaultValue undefined
   * @group Props
   */
  pPasswordPT = input(...ngDevMode ? [void 0, {
    debugName: "pPasswordPT"
  }] : []);
  /**
   * Indicates whether the component should be rendered without styles.
   * @defaultValue undefined
   * @group Props
   */
  pPasswordUnstyled = input(...ngDevMode ? [void 0, {
    debugName: "pPasswordUnstyled"
  }] : []);
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * Text to prompt password entry. Defaults to PrimeNG I18N API configuration.
   * @group Props
   */
  promptLabel = "Enter a password";
  /**
   * Text for a weak password. Defaults to PrimeNG I18N API configuration.
   * @group Props
   */
  weakLabel = "Weak";
  /**
   * Text for a medium password. Defaults to PrimeNG I18N API configuration.
   * @group Props
   */
  mediumLabel = "Medium";
  /**
   * Text for a strong password. Defaults to PrimeNG I18N API configuration.
   * @group Props
   */
  strongLabel = "Strong";
  /**
   * Whether to show the strength indicator or not.
   * @group Props
   */
  feedback = true;
  /**
   * Sets the visibility of the password field.
   * @defaultValue false
   * @type boolean
   * @group Props
   */
  set showPassword(show) {
    this.el.nativeElement.type = show ? "text" : "password";
  }
  /**
   * Specifies the input variant of the component.
   * @defaultValue 'outlined'
   * @group Props
   */
  variant = input(...ngDevMode ? [void 0, {
    debugName: "variant"
  }] : []);
  /**
   * Spans 100% width of the container when enabled.
   * @defaultValue false
   * @group Props
   */
  fluid = input(void 0, __spreadProps(__spreadValues({}, ngDevMode ? {
    debugName: "fluid"
  } : {}), {
    transform: booleanAttribute
  }));
  /**
   * Specifies the size of the component.
   * @defaultValue undefined
   * @group Props
   */
  size = input(void 0, __spreadProps(__spreadValues({}, ngDevMode ? {
    debugName: "size"
  } : {}), {
    alias: "pSize"
  }));
  pcFluid = inject(Fluid, {
    optional: true,
    host: true,
    skipSelf: true
  });
  $variant = computed(() => this.variant() || this.config.inputStyle() || this.config.inputVariant(), ...ngDevMode ? [{
    debugName: "$variant"
  }] : []);
  get hasFluid() {
    return this.fluid() ?? !!this.pcFluid;
  }
  panel;
  meter;
  info;
  filled;
  content;
  label;
  scrollHandler;
  documentResizeListener;
  _componentStyle = inject(PasswordStyle);
  constructor(zone) {
    super();
    this.zone = zone;
    effect(() => {
      const pt = this.pPasswordPT();
      pt && this.directivePT.set(pt);
    });
    effect(() => {
      this.pPasswordUnstyled() && this.directiveUnstyled.set(this.pPasswordUnstyled());
    });
  }
  onInput(e) {
    this.writeModelValue(this.el.nativeElement.value);
  }
  createPanel() {
    if (isPlatformBrowser(this.platformId)) {
      this.panel = this.renderer.createElement("div");
      this.renderer.addClass(this.panel, "p-password-overlay");
      this.renderer.addClass(this.panel, "p-component");
      this.content = this.renderer.createElement("div");
      this.renderer.addClass(this.content, "p-password-content");
      this.renderer.appendChild(this.panel, this.content);
      this.meter = this.renderer.createElement("div");
      this.renderer.addClass(this.meter, "p-password-meter");
      this.renderer.appendChild(this.content, this.meter);
      this.label = this.renderer.createElement("div");
      this.renderer.addClass(this.label, "p-password-meter-label");
      this.renderer.appendChild(this.meter, this.label);
      this.info = this.renderer.createElement("div");
      this.renderer.addClass(this.info, "p-password-meter-text");
      this.renderer.setProperty(this.info, "textContent", this.promptLabel);
      this.renderer.appendChild(this.content, this.info);
      this.renderer.setStyle(this.panel, "minWidth", `${this.el.nativeElement.offsetWidth}px`);
      this.renderer.appendChild(document.body, this.panel);
      this.updateMeter();
    }
  }
  showOverlay() {
    if (this.feedback) {
      if (!this.panel) {
        this.createPanel();
      }
      this.renderer.setStyle(this.panel, "zIndex", String(++DomHandler.zindex));
      this.renderer.setStyle(this.panel, "display", "block");
      this.zone.runOutsideAngular(() => {
        setTimeout(() => {
          W(this.panel, "p-connected-overlay-visible");
          this.bindScrollListener();
          this.bindDocumentResizeListener();
        }, 1);
      });
      D(this.panel, this.el.nativeElement);
    }
  }
  hideOverlay() {
    if (this.feedback && this.panel) {
      W(this.panel, "p-connected-overlay-hidden");
      P(this.panel, "p-connected-overlay-visible");
      this.unbindScrollListener();
      this.unbindDocumentResizeListener();
      this.zone.runOutsideAngular(() => {
        setTimeout(() => {
          this.onDestroy();
        }, 150);
      });
    }
  }
  onFocus() {
    this.showOverlay();
  }
  onBlur() {
    this.hideOverlay();
  }
  labelSignal = signal("", ...ngDevMode ? [{
    debugName: "labelSignal"
  }] : []);
  onKeyup(e) {
    if (this.feedback) {
      let value = e.target.value, label = null, meterPos = null;
      if (value.length === 0) {
        label = this.promptLabel;
        meterPos = "0px 0px";
      } else {
        var score = this.testStrength(value);
        if (score < 30) {
          label = this.weakLabel;
          meterPos = "0px -10px";
        } else if (score >= 30 && score < 80) {
          label = this.mediumLabel;
          meterPos = "0px -20px";
        } else if (score >= 80) {
          label = this.strongLabel;
          meterPos = "0px -30px";
        }
        this.labelSignal.set(label);
        this.updateMeter();
      }
      if (!this.panel || !R(this.panel, "p-connected-overlay-visible")) {
        this.showOverlay();
      }
      if (this.meter) {
        this.renderer.setStyle(this.meter, "backgroundPosition", meterPos);
      }
      if (this.info) {
        this.info.textContent = label;
      }
    }
  }
  updateMeter() {
    if (this.labelSignal() && this.meter && this.info) {
      const label = this.labelSignal();
      const strengthClass = this.strengthClass(label.toLowerCase());
      const width = this.getWidth(label.toLowerCase());
      this.renderer.addClass(this.meter, strengthClass);
      this.renderer.setStyle(this.meter, "width", width);
      this.info.textContent = label;
    }
  }
  getWidth(label) {
    return label === "weak" ? "33.33%" : label === "medium" ? "66.66%" : label === "strong" ? "100%" : "";
  }
  strengthClass(label) {
    return `p-password-meter${label ? `-${label}` : ""}`;
  }
  testStrength(str) {
    let grade = 0;
    let val;
    val = str.match("[0-9]");
    grade += this.normalize(val ? val.length : 1 / 4, 1) * 25;
    val = str.match("[a-zA-Z]");
    grade += this.normalize(val ? val.length : 1 / 2, 3) * 10;
    val = str.match("[!@#$%^&*?_~.,;=]");
    grade += this.normalize(val ? val.length : 1 / 6, 1) * 35;
    val = str.match("[A-Z]");
    grade += this.normalize(val ? val.length : 1 / 6, 1) * 30;
    grade *= str.length / 8;
    return grade > 100 ? 100 : grade;
  }
  normalize(x, y) {
    let diff = x - y;
    if (diff <= 0) return x / y;
    else return 1 + 0.5 * (x / (x + y / 4));
  }
  bindScrollListener() {
    if (!this.scrollHandler) {
      this.scrollHandler = new ConnectedOverlayScrollHandler(this.el.nativeElement, () => {
        if (R(this.panel, "p-connected-overlay-visible")) {
          this.hideOverlay();
        }
      });
    }
    this.scrollHandler.bindScrollListener();
  }
  unbindScrollListener() {
    if (this.scrollHandler) {
      this.scrollHandler.unbindScrollListener();
    }
  }
  bindDocumentResizeListener() {
    if (isPlatformBrowser(this.platformId)) {
      if (!this.documentResizeListener) {
        const window2 = this.document.defaultView;
        this.documentResizeListener = this.renderer.listen(window2, "resize", this.onWindowResize.bind(this));
      }
    }
  }
  unbindDocumentResizeListener() {
    if (this.documentResizeListener) {
      this.documentResizeListener();
      this.documentResizeListener = null;
    }
  }
  onWindowResize() {
    if (!Yt()) {
      this.hideOverlay();
    }
  }
  onDestroy() {
    if (this.panel) {
      if (this.scrollHandler) {
        this.scrollHandler.destroy();
        this.scrollHandler = null;
      }
      this.unbindDocumentResizeListener();
      this.renderer.removeChild(this.document.body, this.panel);
      this.panel = null;
      this.meter = null;
      this.info = null;
    }
  }
  static \u0275fac = function PasswordDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PasswordDirective)(\u0275\u0275directiveInject(NgZone));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _PasswordDirective,
    selectors: [["", "pPassword", ""]],
    hostVars: 2,
    hostBindings: function PasswordDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("input", function PasswordDirective_input_HostBindingHandler($event) {
          return ctx.onInput($event);
        })("focus", function PasswordDirective_focus_HostBindingHandler() {
          return ctx.onFocus();
        })("blur", function PasswordDirective_blur_HostBindingHandler() {
          return ctx.onBlur();
        })("keyup", function PasswordDirective_keyup_HostBindingHandler($event) {
          return ctx.onKeyup($event);
        });
      }
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cx("rootDirective"));
      }
    },
    inputs: {
      pPasswordPT: [1, "pPasswordPT"],
      pPasswordUnstyled: [1, "pPasswordUnstyled"],
      promptLabel: "promptLabel",
      weakLabel: "weakLabel",
      mediumLabel: "mediumLabel",
      strongLabel: "strongLabel",
      feedback: [2, "feedback", "feedback", booleanAttribute],
      showPassword: "showPassword",
      variant: [1, "variant"],
      fluid: [1, "fluid"],
      size: [1, "pSize", "size"]
    },
    features: [\u0275\u0275ProvidersFeature([PasswordStyle, {
      provide: PASSWORD_DIRECTIVE_INSTANCE,
      useExisting: _PasswordDirective
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _PasswordDirective
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PasswordDirective, [{
    type: Directive,
    args: [{
      selector: "[pPassword]",
      standalone: true,
      host: {
        "[class]": "cx('rootDirective')"
      },
      providers: [PasswordStyle, {
        provide: PASSWORD_DIRECTIVE_INSTANCE,
        useExisting: PasswordDirective
      }, {
        provide: PARENT_INSTANCE,
        useExisting: PasswordDirective
      }],
      hostDirectives: [Bind]
    }]
  }], () => [{
    type: NgZone
  }], {
    pPasswordPT: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "pPasswordPT",
        required: false
      }]
    }],
    pPasswordUnstyled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "pPasswordUnstyled",
        required: false
      }]
    }],
    promptLabel: [{
      type: Input
    }],
    weakLabel: [{
      type: Input
    }],
    mediumLabel: [{
      type: Input
    }],
    strongLabel: [{
      type: Input
    }],
    feedback: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showPassword: [{
      type: Input
    }],
    variant: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "variant",
        required: false
      }]
    }],
    fluid: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "fluid",
        required: false
      }]
    }],
    size: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "pSize",
        required: false
      }]
    }],
    onInput: [{
      type: HostListener,
      args: ["input", ["$event"]]
    }],
    onFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    onBlur: [{
      type: HostListener,
      args: ["blur"]
    }],
    onKeyup: [{
      type: HostListener,
      args: ["keyup", ["$event"]]
    }]
  });
})();
var MapperPipe = class _MapperPipe {
  transform(value, mapper, ...args) {
    return mapper(value, ...args);
  }
  static \u0275fac = function MapperPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MapperPipe)();
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
    name: "mapper",
    type: _MapperPipe,
    pure: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MapperPipe, [{
    type: Pipe,
    args: [{
      name: "mapper",
      pure: true,
      standalone: true
    }]
  }], null, null);
})();
var Password_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => Password),
  multi: true
};
var Password = class _Password extends BaseInput {
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  $pcPassword = inject(PASSWORD_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * Defines a string that labels the input for accessibility.
   * @group Props
   */
  ariaLabel;
  /**
   * Specifies one or more IDs in the DOM that labels the input field.
   * @group Props
   */
  ariaLabelledBy;
  /**
   * Label of the input for accessibility.
   * @group Props
   */
  label;
  /**
   * Text to prompt password entry. Defaults to PrimeNG I18N API configuration.
   * @group Props
   */
  promptLabel;
  /**
   * Regex value for medium regex.
   * @group Props
   */
  mediumRegex = "^(((?=.*[a-z])(?=.*[A-Z]))|((?=.*[a-z])(?=.*[0-9]))|((?=.*[A-Z])(?=.*[0-9])))(?=.{6,})";
  /**
   * Regex value for strong regex.
   * @group Props
   */
  strongRegex = "^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.{8,})";
  /**
   * Text for a weak password. Defaults to PrimeNG I18N API configuration.
   * @group Props
   */
  weakLabel;
  /**
   * Text for a medium password. Defaults to PrimeNG I18N API configuration.
   * @group Props
   */
  mediumLabel;
  /**
   * specifies the maximum number of characters allowed in the input element.
   * @deprecated since v20.0.0, use maxlength instead.
   * @group Props
   */
  maxLength;
  /**
   * Text for a strong password. Defaults to PrimeNG I18N API configuration.
   * @group Props
   */
  strongLabel;
  /**
   * Identifier of the accessible input element.
   * @group Props
   */
  inputId;
  /**
   * Whether to show the strength indicator or not.
   * @group Props
   */
  feedback = true;
  /**
   * Whether to show an icon to display the password as plain text.
   * @group Props
   */
  toggleMask;
  /**
   * Style class of the input field.
   * @group Props
   */
  inputStyleClass;
  /**
   * Style class of the element.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Inline style of the input field.
   * @group Props
   */
  inputStyle;
  /**
   * Transition options of the show animation.
   * @group Props
   * @deprecated since v21.0.0, use `motionOptions` instead.
   */
  showTransitionOptions = ".12s cubic-bezier(0, 0, 0.2, 1)";
  /**
   * Transition options of the hide animation.
   * @group Props
   * @deprecated since v21.0.0, use `motionOptions` instead.
   */
  hideTransitionOptions = ".1s linear";
  /**
   * Specify automated assistance in filling out password by browser.
   * @group Props
   */
  autocomplete;
  /**
   * Advisory information to display on input.
   * @group Props
   */
  placeholder;
  /**
   * When enabled, a clear icon is displayed to clear the value.
   * @group Props
   */
  showClear = false;
  /**
   * When present, it specifies that the component should automatically get focus on load.
   * @group Props
   */
  autofocus;
  /**
   * Index of the element in tabbing order.
   * @group Props
   */
  tabindex;
  /**
   * Target element to attach the overlay, valid values are "body" or a local ng-template variable of another element (note: use binding with brackets for template variables, e.g. [appendTo]="mydiv" for a div element having #mydiv as variable name).
   * @defaultValue 'self'
   * @group Props
   */
  appendTo = input("self", ...ngDevMode ? [{
    debugName: "appendTo"
  }] : []);
  /**
   * The motion options.
   * @group Props
   */
  motionOptions = input(void 0, ...ngDevMode ? [{
    debugName: "motionOptions"
  }] : []);
  /**
   * Whether to use overlay API feature. The properties of overlay API can be used like an object in it.
   * @group Props
   */
  overlayOptions;
  /**
   * Callback to invoke when the component receives focus.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onFocus = new EventEmitter();
  /**
   * Callback to invoke when the component loses focus.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onBlur = new EventEmitter();
  /**
   * Callback to invoke when clear button is clicked.
   * @group Emits
   */
  onClear = new EventEmitter();
  overlayViewChild;
  input;
  /**
   * Custom template of content.
   * @group Templates
   */
  contentTemplate;
  /**
   * Custom template of footer.
   * @group Templates
   */
  footerTemplate;
  /**
   * Custom template of header.
   * @group Templates
   */
  headerTemplate;
  /**
   * Custom template of clear icon.
   * @group Templates
   */
  clearIconTemplate;
  /**
   * Custom template of hide icon.
   * @param {PasswordIconTemplateContext} context - icon context.
   * @see {@link PasswordIconTemplateContext}
   * @group Templates
   */
  hideIconTemplate;
  /**
   * Custom template of show icon.
   * @param {PasswordIconTemplateContext} context - icon context.
   * @see {@link PasswordIconTemplateContext}
   * @group Templates
   */
  showIconTemplate;
  templates;
  $appendTo = computed(() => this.appendTo() || this.config.overlayAppendTo(), ...ngDevMode ? [{
    debugName: "$appendTo"
  }] : []);
  _contentTemplate;
  _footerTemplate;
  _headerTemplate;
  _clearIconTemplate;
  _hideIconTemplate;
  _showIconTemplate;
  overlayVisible = false;
  meter;
  infoText;
  focused = false;
  unmasked = false;
  mediumCheckRegExp;
  strongCheckRegExp;
  resizeListener;
  scrollHandler;
  value = null;
  translationSubscription;
  _componentStyle = inject(PasswordStyle);
  overlayService = inject(OverlayService);
  onInit() {
    this.infoText = this.promptText();
    this.mediumCheckRegExp = new RegExp(this.mediumRegex);
    this.strongCheckRegExp = new RegExp(this.strongRegex);
    this.translationSubscription = this.config.translationObserver.subscribe(() => {
      this.updateUI(this.value || "");
    });
  }
  onAfterContentInit() {
    this.templates.forEach((item) => {
      switch (item.getType()) {
        case "content":
          this._contentTemplate = item.template;
          break;
        case "header":
          this._headerTemplate = item.template;
          break;
        case "footer":
          this._footerTemplate = item.template;
          break;
        case "clearicon":
          this._clearIconTemplate = item.template;
          break;
        case "hideicon":
          this._hideIconTemplate = item.template;
          break;
        case "showicon":
          this._showIconTemplate = item.template;
          break;
        default:
          this._contentTemplate = item.template;
          break;
      }
    });
  }
  onInput(event) {
    this.value = event.target.value;
    this.onModelChange(this.value);
  }
  onInputFocus(event) {
    this.focused = true;
    if (this.feedback) {
      this.overlayVisible = true;
    }
    this.onFocus.emit(event);
  }
  onInputBlur(event) {
    this.focused = false;
    if (this.feedback) {
      this.overlayVisible = false;
    }
    this.onModelTouched();
    this.onBlur.emit(event);
  }
  onKeyUp(event) {
    if (this.feedback) {
      let value = event.target.value;
      this.updateUI(value);
      if (event.code === "Escape") {
        this.overlayVisible && (this.overlayVisible = false);
        return;
      }
      if (!this.overlayVisible) {
        this.overlayVisible = true;
      }
    }
  }
  updateUI(value) {
    let label = null;
    let meter = null;
    switch (this.testStrength(value)) {
      case 1:
        label = this.weakText();
        meter = {
          strength: "weak",
          width: "33.33%"
        };
        break;
      case 2:
        label = this.mediumText();
        meter = {
          strength: "medium",
          width: "66.66%"
        };
        break;
      case 3:
        label = this.strongText();
        meter = {
          strength: "strong",
          width: "100%"
        };
        break;
      default:
        label = this.promptText();
        meter = null;
        break;
    }
    this.meter = meter;
    this.infoText = label;
  }
  onMaskToggle() {
    this.unmasked = !this.unmasked;
  }
  onOverlayClick(event) {
    this.overlayService.add({
      originalEvent: event,
      target: this.el.nativeElement
    });
  }
  testStrength(str) {
    let level = 0;
    if (this.strongCheckRegExp?.test(str)) level = 3;
    else if (this.mediumCheckRegExp?.test(str)) level = 2;
    else if (str.length) level = 1;
    return level;
  }
  promptText() {
    return this.promptLabel || this.getTranslation(TranslationKeys.PASSWORD_PROMPT);
  }
  weakText() {
    return this.weakLabel || this.getTranslation(TranslationKeys.WEAK);
  }
  mediumText() {
    return this.mediumLabel || this.getTranslation(TranslationKeys.MEDIUM);
  }
  strongText() {
    return this.strongLabel || this.getTranslation(TranslationKeys.STRONG);
  }
  inputType(unmasked) {
    return unmasked ? "text" : "password";
  }
  getTranslation(option) {
    return this.config.getTranslation(option);
  }
  clear() {
    this.value = null;
    this.onModelChange(this.value);
    this.writeValue(this.value);
    this.onClear.emit();
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value, setModelValue) {
    if (value === void 0) this.value = null;
    else this.value = value;
    if (this.feedback) this.updateUI(this.value || "");
    setModelValue(this.value);
    this.cd.markForCheck();
  }
  onDestroy() {
    if (this.translationSubscription) {
      this.translationSubscription.unsubscribe();
    }
  }
  get containerDataP() {
    return this.cn({
      fluid: this.hasFluid
    });
  }
  get meterDataP() {
    return this.cn({
      [this.meter?.strength]: this.meter?.strength
    });
  }
  get overlayDataP() {
    return this.cn({
      ["overlay-" + this.$appendTo()]: "overlay-" + this.$appendTo()
    });
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275Password_BaseFactory;
    return function Password_Factory(__ngFactoryType__) {
      return (\u0275Password_BaseFactory || (\u0275Password_BaseFactory = \u0275\u0275getInheritedFactory(_Password)))(__ngFactoryType__ || _Password);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _Password,
    selectors: [["p-password"]],
    contentQueries: function Password_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c010, 4);
        \u0275\u0275contentQuery(dirIndex, _c14, 4);
        \u0275\u0275contentQuery(dirIndex, _c24, 4);
        \u0275\u0275contentQuery(dirIndex, _c33, 4);
        \u0275\u0275contentQuery(dirIndex, _c42, 4);
        \u0275\u0275contentQuery(dirIndex, _c52, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contentTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.footerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.clearIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.hideIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.showIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function Password_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c6, 5);
        \u0275\u0275viewQuery(_c7, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.overlayViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.input = _t.first);
      }
    },
    hostVars: 5,
    hostBindings: function Password_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("data-p", ctx.containerDataP);
        \u0275\u0275styleMap(ctx.sx("root"));
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      ariaLabel: "ariaLabel",
      ariaLabelledBy: "ariaLabelledBy",
      label: "label",
      promptLabel: "promptLabel",
      mediumRegex: "mediumRegex",
      strongRegex: "strongRegex",
      weakLabel: "weakLabel",
      mediumLabel: "mediumLabel",
      maxLength: [2, "maxLength", "maxLength", numberAttribute],
      strongLabel: "strongLabel",
      inputId: "inputId",
      feedback: [2, "feedback", "feedback", booleanAttribute],
      toggleMask: [2, "toggleMask", "toggleMask", booleanAttribute],
      inputStyleClass: "inputStyleClass",
      styleClass: "styleClass",
      inputStyle: "inputStyle",
      showTransitionOptions: "showTransitionOptions",
      hideTransitionOptions: "hideTransitionOptions",
      autocomplete: "autocomplete",
      placeholder: "placeholder",
      showClear: [2, "showClear", "showClear", booleanAttribute],
      autofocus: [2, "autofocus", "autofocus", booleanAttribute],
      tabindex: [2, "tabindex", "tabindex", numberAttribute],
      appendTo: [1, "appendTo"],
      motionOptions: [1, "motionOptions"],
      overlayOptions: "overlayOptions"
    },
    outputs: {
      onFocus: "onFocus",
      onBlur: "onBlur",
      onClear: "onClear"
    },
    features: [\u0275\u0275ProvidersFeature([Password_VALUE_ACCESSOR, PasswordStyle, {
      provide: PASSWORD_INSTANCE,
      useExisting: _Password
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _Password
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 8,
    vars: 33,
    consts: [["input", ""], ["overlay", ""], ["content", ""], ["defaultContent", ""], ["pInputText", "", 3, "input", "focus", "blur", "keyup", "pSize", "ngStyle", "value", "variant", "invalid", "pAutoFocus", "pt", "unstyled"], [4, "ngIf"], [3, "visibleChange", "hostAttrSelector", "visible", "options", "target", "appendTo", "unstyled", "pt", "motionOptions"], ["data-p-icon", "times", 3, "class", "pBind", "click", 4, "ngIf"], [3, "click", "pBind"], [4, "ngTemplateOutlet"], ["data-p-icon", "times", 3, "click", "pBind"], ["data-p-icon", "eyeslash", 3, "class", "pBind", "click", 4, "ngIf"], [3, "pBind", "click", 4, "ngIf"], ["data-p-icon", "eyeslash", 3, "click", "pBind"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["data-p-icon", "eye", 3, "class", "pBind", "click", 4, "ngIf"], ["data-p-icon", "eye", 3, "click", "pBind"], [4, "ngIf", "ngIfElse"], [3, "pBind"], [3, "ngStyle", "pBind"]],
    template: function Password_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "input", 4, 0);
        \u0275\u0275listener("input", function Password_Template_input_input_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onInput($event));
        })("focus", function Password_Template_input_focus_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onInputFocus($event));
        })("blur", function Password_Template_input_blur_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onInputBlur($event));
        })("keyup", function Password_Template_input_keyup_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onKeyUp($event));
        });
        \u0275\u0275elementEnd();
        \u0275\u0275template(2, Password_ng_container_2_Template, 4, 5, "ng-container", 5)(3, Password_ng_container_3_Template, 3, 2, "ng-container", 5);
        \u0275\u0275elementStart(4, "p-overlay", 6, 1);
        \u0275\u0275twoWayListener("visibleChange", function Password_Template_p_overlay_visibleChange_4_listener($event) {
          \u0275\u0275restoreView(_r1);
          \u0275\u0275twoWayBindingSet(ctx.overlayVisible, $event) || (ctx.overlayVisible = $event);
          return \u0275\u0275resetView($event);
        });
        \u0275\u0275template(6, Password_ng_template_6_Template, 6, 10, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cn(ctx.cx("pcInputText"), ctx.inputStyleClass));
        \u0275\u0275property("pSize", ctx.size())("ngStyle", ctx.inputStyle)("value", ctx.value)("variant", ctx.$variant())("invalid", ctx.invalid())("pAutoFocus", ctx.autofocus)("pt", ctx.ptm("pcInputText"))("unstyled", ctx.unstyled());
        \u0275\u0275attribute("label", ctx.label)("aria-label", ctx.ariaLabel)("aria-labelledBy", ctx.ariaLabelledBy)("id", ctx.inputId)("tabindex", ctx.tabindex)("type", ctx.unmasked ? "text" : "password")("placeholder", ctx.placeholder)("autocomplete", ctx.autocomplete)("name", ctx.name())("maxlength", ctx.maxlength() || ctx.maxLength)("minlength", ctx.minlength())("required", ctx.required() ? "" : void 0)("disabled", ctx.$disabled() ? "" : void 0);
        \u0275\u0275advance(2);
        \u0275\u0275property("ngIf", ctx.showClear && ctx.value != null);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.toggleMask);
        \u0275\u0275advance();
        \u0275\u0275property("hostAttrSelector", ctx.$attrSelector);
        \u0275\u0275twoWayProperty("visible", ctx.overlayVisible);
        \u0275\u0275property("options", ctx.overlayOptions)("target", "@parent")("appendTo", ctx.$appendTo())("unstyled", ctx.unstyled())("pt", ctx.ptm("pcOverlay"))("motionOptions", ctx.motionOptions());
      }
    },
    dependencies: [CommonModule, NgIf, NgTemplateOutlet, NgStyle, InputText, AutoFocus, TimesIcon, EyeSlashIcon, EyeIcon, Overlay, SharedModule, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Password, [{
    type: Component,
    args: [{
      selector: "p-password",
      standalone: true,
      imports: [CommonModule, InputText, AutoFocus, TimesIcon, EyeSlashIcon, EyeIcon, Overlay, SharedModule, BindModule],
      template: `
        <input
            #input
            [attr.label]="label"
            [attr.aria-label]="ariaLabel"
            [attr.aria-labelledBy]="ariaLabelledBy"
            [attr.id]="inputId"
            [attr.tabindex]="tabindex"
            pInputText
            [pSize]="size()"
            [ngStyle]="inputStyle"
            [class]="cn(cx('pcInputText'), inputStyleClass)"
            [attr.type]="unmasked ? 'text' : 'password'"
            [attr.placeholder]="placeholder"
            [attr.autocomplete]="autocomplete"
            [value]="value"
            [variant]="$variant()"
            [attr.name]="name()"
            [attr.maxlength]="maxlength() || maxLength"
            [attr.minlength]="minlength()"
            [attr.required]="required() ? '' : undefined"
            [attr.disabled]="$disabled() ? '' : undefined"
            [invalid]="invalid()"
            (input)="onInput($event)"
            (focus)="onInputFocus($event)"
            (blur)="onInputBlur($event)"
            (keyup)="onKeyUp($event)"
            [pAutoFocus]="autofocus"
            [pt]="ptm('pcInputText')"
            [unstyled]="unstyled()"
        />
        <ng-container *ngIf="showClear && value != null">
            <svg data-p-icon="times" *ngIf="!clearIconTemplate && !_clearIconTemplate" [class]="cx('clearIcon')" (click)="clear()" [pBind]="ptm('clearIcon')" />
            <span (click)="clear()" [class]="cx('clearIcon')" [pBind]="ptm('clearIcon')">
                <ng-template *ngTemplateOutlet="clearIconTemplate || _clearIconTemplate"></ng-template>
            </span>
        </ng-container>

        <ng-container *ngIf="toggleMask">
            <ng-container *ngIf="unmasked">
                <svg data-p-icon="eyeslash" [class]="cx('maskIcon')" [pBind]="ptm('maskIcon')" *ngIf="!hideIconTemplate && !_hideIconTemplate" (click)="onMaskToggle()" />
                <span *ngIf="hideIconTemplate || _hideIconTemplate" (click)="onMaskToggle()" [pBind]="ptm('maskIcon')">
                    <ng-template *ngTemplateOutlet="hideIconTemplate || _hideIconTemplate; context: { class: cx('maskIcon') }"></ng-template>
                </span>
            </ng-container>
            <ng-container *ngIf="!unmasked">
                <svg data-p-icon="eye" *ngIf="!showIconTemplate && !_showIconTemplate" [class]="cx('unmaskIcon')" [pBind]="ptm('unmaskIcon')" (click)="onMaskToggle()" />
                <span *ngIf="showIconTemplate || _showIconTemplate" (click)="onMaskToggle()" [pBind]="ptm('unmaskIcon')">
                    <ng-template *ngTemplateOutlet="showIconTemplate || _showIconTemplate; context: { class: cx('unmaskIcon') }"></ng-template>
                </span>
            </ng-container>
        </ng-container>

        <p-overlay #overlay [hostAttrSelector]="$attrSelector" [(visible)]="overlayVisible" [options]="overlayOptions" [target]="'@parent'" [appendTo]="$appendTo()" [unstyled]="unstyled()" [pt]="ptm('pcOverlay')" [motionOptions]="motionOptions()">
            <ng-template #content>
                <div [class]="cx('overlay')" [style]="sx('overlay')" (click)="onOverlayClick($event)" [pBind]="ptm('overlay')" [attr.data-p]="overlayDataP">
                    <ng-container *ngTemplateOutlet="headerTemplate || _headerTemplate"></ng-container>
                    <ng-container *ngIf="contentTemplate || _contentTemplate; else defaultContent">
                        <ng-container *ngTemplateOutlet="contentTemplate || _contentTemplate"></ng-container>
                    </ng-container>
                    <ng-template #defaultContent>
                        <div [class]="cx('content')" [pBind]="ptm('content')">
                            <div [class]="cx('meter')" [pBind]="ptm('meter')">
                                <div [class]="cx('meterLabel')" [ngStyle]="{ width: meter ? meter.width : '' }" [pBind]="ptm('meterLabel')" [attr.data-p]="meterDataP"></div>
                            </div>
                            <div [class]="cx('meterText')" [pBind]="ptm('meterText')">{{ infoText }}</div>
                        </div>
                    </ng-template>
                    <ng-container *ngTemplateOutlet="footerTemplate || _footerTemplate"></ng-container>
                </div>
            </ng-template>
        </p-overlay>
    `,
      providers: [Password_VALUE_ACCESSOR, PasswordStyle, {
        provide: PASSWORD_INSTANCE,
        useExisting: Password
      }, {
        provide: PARENT_INSTANCE,
        useExisting: Password
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cn(cx('root'), styleClass)",
        "[style]": "sx('root')",
        "[attr.data-p]": "containerDataP"
      },
      hostDirectives: [Bind]
    }]
  }], null, {
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    promptLabel: [{
      type: Input
    }],
    mediumRegex: [{
      type: Input
    }],
    strongRegex: [{
      type: Input
    }],
    weakLabel: [{
      type: Input
    }],
    mediumLabel: [{
      type: Input
    }],
    maxLength: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    strongLabel: [{
      type: Input
    }],
    inputId: [{
      type: Input
    }],
    feedback: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    toggleMask: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    inputStyleClass: [{
      type: Input
    }],
    styleClass: [{
      type: Input
    }],
    inputStyle: [{
      type: Input
    }],
    showTransitionOptions: [{
      type: Input
    }],
    hideTransitionOptions: [{
      type: Input
    }],
    autocomplete: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    showClear: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    autofocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    tabindex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    appendTo: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "appendTo",
        required: false
      }]
    }],
    motionOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "motionOptions",
        required: false
      }]
    }],
    overlayOptions: [{
      type: Input
    }],
    onFocus: [{
      type: Output
    }],
    onBlur: [{
      type: Output
    }],
    onClear: [{
      type: Output
    }],
    overlayViewChild: [{
      type: ViewChild,
      args: ["overlay"]
    }],
    input: [{
      type: ViewChild,
      args: ["input"]
    }],
    contentTemplate: [{
      type: ContentChild,
      args: ["content", {
        descendants: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: ["footer", {
        descendants: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: ["header", {
        descendants: false
      }]
    }],
    clearIconTemplate: [{
      type: ContentChild,
      args: ["clearicon", {
        descendants: false
      }]
    }],
    hideIconTemplate: [{
      type: ContentChild,
      args: ["hideicon", {
        descendants: false
      }]
    }],
    showIconTemplate: [{
      type: ContentChild,
      args: ["showicon", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }]
  });
})();
var PasswordModule = class _PasswordModule {
  static \u0275fac = function PasswordModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PasswordModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _PasswordModule,
    imports: [Password, PasswordDirective, SharedModule, BindModule],
    exports: [PasswordDirective, Password, SharedModule, BindModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [Password, SharedModule, BindModule, SharedModule, BindModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PasswordModule, [{
    type: NgModule,
    args: [{
      imports: [Password, PasswordDirective, SharedModule, BindModule],
      exports: [PasswordDirective, Password, SharedModule, BindModule]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/slider/index.mjs
var style7 = "\n    .p-slider {\n        display: block;\n        position: relative;\n        background: dt('slider.track.background');\n        border-radius: dt('slider.track.border.radius');\n    }\n\n    .p-slider-handle {\n        cursor: grab;\n        touch-action: none;\n        user-select: none;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        height: dt('slider.handle.height');\n        width: dt('slider.handle.width');\n        background: dt('slider.handle.background');\n        border-radius: dt('slider.handle.border.radius');\n        transition:\n            background dt('slider.transition.duration'),\n            color dt('slider.transition.duration'),\n            border-color dt('slider.transition.duration'),\n            box-shadow dt('slider.transition.duration'),\n            outline-color dt('slider.transition.duration');\n        outline-color: transparent;\n    }\n\n    .p-slider-handle::before {\n        content: '';\n        width: dt('slider.handle.content.width');\n        height: dt('slider.handle.content.height');\n        display: block;\n        background: dt('slider.handle.content.background');\n        border-radius: dt('slider.handle.content.border.radius');\n        box-shadow: dt('slider.handle.content.shadow');\n        transition: background dt('slider.transition.duration');\n    }\n\n    .p-slider:not(.p-disabled) .p-slider-handle:hover {\n        background: dt('slider.handle.hover.background');\n    }\n\n    .p-slider:not(.p-disabled) .p-slider-handle:hover::before {\n        background: dt('slider.handle.content.hover.background');\n    }\n\n    .p-slider-handle:focus-visible {\n        box-shadow: dt('slider.handle.focus.ring.shadow');\n        outline: dt('slider.handle.focus.ring.width') dt('slider.handle.focus.ring.style') dt('slider.handle.focus.ring.color');\n        outline-offset: dt('slider.handle.focus.ring.offset');\n    }\n\n    .p-slider-range {\n        display: block;\n        background: dt('slider.range.background');\n        border-radius: dt('slider.track.border.radius');\n    }\n\n    .p-slider.p-slider-horizontal {\n        height: dt('slider.track.size');\n    }\n\n    .p-slider-horizontal .p-slider-range {\n        inset-block-start: 0;\n        inset-inline-start: 0;\n        height: 100%;\n    }\n\n    .p-slider-horizontal .p-slider-handle {\n        inset-block-start: 50%;\n        margin-block-start: calc(-1 * calc(dt('slider.handle.height') / 2));\n        margin-inline-start: calc(-1 * calc(dt('slider.handle.width') / 2));\n    }\n\n    .p-slider-vertical {\n        min-height: 100px;\n        width: dt('slider.track.size');\n    }\n\n    .p-slider-vertical .p-slider-handle {\n        inset-inline-start: 50%;\n        margin-inline-start: calc(-1 * calc(dt('slider.handle.width') / 2));\n        margin-block-end: calc(-1 * calc(dt('slider.handle.height') / 2));\n    }\n\n    .p-slider-vertical .p-slider-range {\n        inset-block-end: 0;\n        inset-inline-start: 0;\n        width: 100%;\n    }\n";

// node_modules/primeng/fesm2022/primeng-slider.mjs
var _c011 = ["sliderHandle"];
var _c15 = ["sliderHandleStart"];
var _c25 = ["sliderHandleEnd"];
var _c34 = (a0, a1) => ({
  "inset-inline-start": a0,
  width: a1
});
var _c43 = (a0, a1) => ({
  bottom: a0,
  height: a1
});
var _c53 = (a0) => ({
  height: a0
});
var _c62 = (a0) => ({
  width: a0
});
var _c72 = (a0, a1) => ({
  "inset-inline-start": a0,
  bottom: a1
});
function Slider_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r0.sx("range"));
    \u0275\u0275classMap(ctx_r0.cx("range"));
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction2(8, _c34, ctx_r0.offset !== null && ctx_r0.offset !== void 0 ? ctx_r0.offset + "%" : ctx_r0.handleValues[0] + "%", ctx_r0.diff ? ctx_r0.diff + "%" : ctx_r0.handleValues[1] - ctx_r0.handleValues[0] + "%"))("pBind", ctx_r0.ptm("range"));
    \u0275\u0275attribute("data-pc-section", "range")("data-p", ctx_r0.dataP);
  }
}
function Slider_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r0.sx("range"));
    \u0275\u0275classMap(ctx_r0.cx("range"));
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction2(8, _c43, ctx_r0.offset !== null && ctx_r0.offset !== void 0 ? ctx_r0.offset + "%" : ctx_r0.handleValues[0] + "%", ctx_r0.diff ? ctx_r0.diff + "%" : ctx_r0.handleValues[1] - ctx_r0.handleValues[0] + "%"))("pBind", ctx_r0.ptm("range"));
    \u0275\u0275attribute("data-pc-section", "range")("data-p", ctx_r0.dataP);
  }
}
function Slider_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r0.sx("range"));
    \u0275\u0275classMap(ctx_r0.cx("range"));
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(7, _c53, ctx_r0.handleValue + "%"))("pBind", ctx_r0.ptm("range"));
    \u0275\u0275attribute("data-pc-section", "range");
  }
}
function Slider_span_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r0.sx("range"));
    \u0275\u0275classMap(ctx_r0.cx("range"));
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(7, _c62, ctx_r0.handleValue + "%"))("pBind", ctx_r0.ptm("range"));
    \u0275\u0275attribute("data-pc-section", "range");
  }
}
function Slider_span_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 9, 0);
    \u0275\u0275listener("touchstart", function Slider_span_4_Template_span_touchstart_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onDragStart($event));
    })("touchmove", function Slider_span_4_Template_span_touchmove_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onDrag($event));
    })("touchend", function Slider_span_4_Template_span_touchend_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onDragEnd($event));
    })("mousedown", function Slider_span_4_Template_span_mousedown_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onMouseDown($event));
    })("keydown", function Slider_span_4_Template_span_keydown_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onKeyDown($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r0.sx("handle"));
    \u0275\u0275classMap(ctx_r0.cx("handle"));
    \u0275\u0275styleProp("transition", ctx_r0.dragging ? "none" : null);
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction2(18, _c72, ctx_r0.orientation == "horizontal" ? ctx_r0.handleValue + "%" : null, ctx_r0.orientation == "vertical" ? ctx_r0.handleValue + "%" : null))("pAutoFocus", ctx_r0.autofocus)("pBind", ctx_r0.ptm("handle"));
    \u0275\u0275attribute("tabindex", ctx_r0.$disabled() ? null : ctx_r0.tabindex)("aria-valuemin", ctx_r0.min)("aria-valuenow", ctx_r0.value)("aria-valuemax", ctx_r0.max)("aria-labelledby", ctx_r0.ariaLabelledBy)("aria-label", ctx_r0.ariaLabel)("aria-orientation", ctx_r0.orientation)("data-pc-section", "handle")("data-p", ctx_r0.dataP);
  }
}
function Slider_span_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 10, 1);
    \u0275\u0275listener("keydown", function Slider_span_5_Template_span_keydown_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onKeyDown($event, 0));
    })("mousedown", function Slider_span_5_Template_span_mousedown_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onMouseDown($event, 0));
    })("touchstart", function Slider_span_5_Template_span_touchstart_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onDragStart($event, 0));
    })("touchmove", function Slider_span_5_Template_span_touchmove_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onDrag($event));
    })("touchend", function Slider_span_5_Template_span_touchend_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onDragEnd($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r0.sx("handle"));
    \u0275\u0275classMap(ctx_r0.cn(ctx_r0.cx("handle"), ctx_r0.handleIndex == 0 && "p-slider-handle-active"));
    \u0275\u0275styleProp("transition", ctx_r0.dragging ? "none" : null);
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction2(18, _c72, ctx_r0.rangeStartLeft, ctx_r0.rangeStartBottom))("pAutoFocus", ctx_r0.autofocus)("pBind", ctx_r0.ptm("startHandler"));
    \u0275\u0275attribute("tabindex", ctx_r0.$disabled() ? null : ctx_r0.tabindex)("aria-valuemin", ctx_r0.min)("aria-valuenow", ctx_r0.value ? ctx_r0.value[0] : null)("aria-valuemax", ctx_r0.max)("aria-labelledby", ctx_r0.ariaLabelledBy)("aria-label", ctx_r0.ariaLabel)("aria-orientation", ctx_r0.orientation)("data-pc-section", "startHandler")("data-p", ctx_r0.dataP);
  }
}
function Slider_span_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 11, 2);
    \u0275\u0275listener("keydown", function Slider_span_6_Template_span_keydown_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onKeyDown($event, 1));
    })("mousedown", function Slider_span_6_Template_span_mousedown_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onMouseDown($event, 1));
    })("touchstart", function Slider_span_6_Template_span_touchstart_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onDragStart($event, 1));
    })("touchmove", function Slider_span_6_Template_span_touchmove_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onDrag($event));
    })("touchend", function Slider_span_6_Template_span_touchend_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onDragEnd($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r0.sx("handle"));
    \u0275\u0275classMap(ctx_r0.cn(ctx_r0.cx("handle"), ctx_r0.handleIndex == 1 && "p-slider-handle-active"));
    \u0275\u0275styleProp("transition", ctx_r0.dragging ? "none" : null);
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction2(17, _c72, ctx_r0.rangeEndLeft, ctx_r0.rangeEndBottom))("pBind", ctx_r0.ptm("endHandler"));
    \u0275\u0275attribute("tabindex", ctx_r0.$disabled() ? null : ctx_r0.tabindex)("aria-valuemin", ctx_r0.min)("aria-valuenow", ctx_r0.value ? ctx_r0.value[1] : null)("aria-valuemax", ctx_r0.max)("aria-labelledby", ctx_r0.ariaLabelledBy)("aria-label", ctx_r0.ariaLabel)("aria-orientation", ctx_r0.orientation)("data-pc-section", "endHandler")("data-p", ctx_r0.dataP);
  }
}
var inlineStyles2 = {
  handle: {
    position: "absolute"
  },
  range: {
    position: "absolute"
  }
};
var classes5 = {
  root: ({
    instance
  }) => ["p-slider p-component", {
    "p-disabled": instance.$disabled(),
    "p-invalid": instance.invalid(),
    "p-slider-horizontal": instance.orientation === "horizontal",
    "p-slider-vertical": instance.orientation === "vertical",
    "p-slider-animate": instance.animate
  }],
  range: "p-slider-range",
  handle: "p-slider-handle"
};
var SliderStyle = class _SliderStyle extends BaseStyle {
  name = "slider";
  style = style7;
  classes = classes5;
  inlineStyles = inlineStyles2;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275SliderStyle_BaseFactory;
    return function SliderStyle_Factory(__ngFactoryType__) {
      return (\u0275SliderStyle_BaseFactory || (\u0275SliderStyle_BaseFactory = \u0275\u0275getInheritedFactory(_SliderStyle)))(__ngFactoryType__ || _SliderStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _SliderStyle,
    factory: _SliderStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderStyle, [{
    type: Injectable
  }], null, null);
})();
var SliderClasses;
(function(SliderClasses2) {
  SliderClasses2["root"] = "p-slider";
  SliderClasses2["range"] = "p-slider-range";
  SliderClasses2["handle"] = "p-slider-handle";
})(SliderClasses || (SliderClasses = {}));
var SLIDER_INSTANCE = new InjectionToken("SLIDER_INSTANCE");
var SLIDER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => Slider),
  multi: true
};
var Slider = class _Slider extends BaseEditableHolder {
  $pcSlider = inject(SLIDER_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * When enabled, displays an animation on click of the slider bar.
   * @group Props
   */
  animate;
  /**
   * Mininum boundary value.
   * @group Props
   */
  min = 0;
  /**
   * Maximum boundary value.
   * @group Props
   */
  max = 100;
  /**
   * Orientation of the slider.
   * @group Props
   */
  orientation = "horizontal";
  /**
   * Step factor to increment/decrement the value.
   * @group Props
   */
  step;
  /**
   * When specified, allows two boundary values to be picked.
   * @group Props
   */
  range;
  /**
   * Style class of the component.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Defines a string that labels the input for accessibility.
   * @group Props
   */
  ariaLabel;
  /**
   * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
   * @group Props
   */
  ariaLabelledBy;
  /**
   * Index of the element in tabbing order.
   * @group Props
   */
  tabindex = 0;
  /**
   * When present, it specifies that the component should automatically get focus on load.
   * @group Props
   */
  autofocus;
  /**
   * Callback to invoke on value change.
   * @param {SliderChangeEvent} event - Custom value change event.
   * @group Emits
   */
  onChange = new EventEmitter();
  /**
   * Callback to invoke when slide ended.
   * @param {SliderSlideEndEvent} event - Custom slide end event.
   * @group Emits
   */
  onSlideEnd = new EventEmitter();
  sliderHandle;
  sliderHandleStart;
  sliderHandleEnd;
  _componentStyle = inject(SliderStyle);
  value;
  values;
  handleValue;
  handleValues = [];
  diff;
  offset;
  bottom;
  dragging;
  dragListener;
  mouseupListener;
  initX;
  initY;
  barWidth;
  barHeight;
  sliderHandleClick;
  handleIndex = 0;
  startHandleValue;
  startx;
  starty;
  ngZone = inject(NgZone);
  onHostClick(event) {
    this.onBarClick(event);
  }
  onMouseDown(event, index) {
    if (this.$disabled()) {
      return;
    }
    this.dragging = true;
    this.updateDomData();
    this.sliderHandleClick = true;
    if (this.range && this.handleValues && this.handleValues[0] === this.max) {
      this.handleIndex = 0;
    } else {
      this.handleIndex = index;
    }
    this.bindDragListeners();
    event.target.focus();
    event.preventDefault();
    if (this.animate) {
      P(this.el.nativeElement, "p-slider-animate");
    }
  }
  onDragStart(event, index) {
    if (this.$disabled()) {
      return;
    }
    this.el.nativeElement.setAttribute("data-p-sliding", true);
    var touchobj = event.changedTouches[0];
    this.startHandleValue = this.range ? this.handleValues[index] : this.handleValue;
    this.dragging = true;
    if (this.range && this.handleValues && this.handleValues[0] === this.max) {
      this.handleIndex = 0;
    } else {
      this.handleIndex = index;
    }
    if (this.orientation === "horizontal") {
      this.startx = parseInt(touchobj.clientX, 10);
      this.barWidth = this.el.nativeElement.offsetWidth;
    } else {
      this.starty = parseInt(touchobj.clientY, 10);
      this.barHeight = this.el.nativeElement.offsetHeight;
    }
    if (this.animate) {
      P(this.el.nativeElement, "p-slider-animate");
    }
    event.preventDefault();
  }
  onDrag(event) {
    if (this.$disabled()) {
      return;
    }
    var touchobj = event.changedTouches[0], handleValue = 0;
    if (this.orientation === "horizontal") {
      handleValue = Math.floor((parseInt(touchobj.clientX, 10) - this.startx) * 100 / this.barWidth) + this.startHandleValue;
    } else {
      handleValue = Math.floor((this.starty - parseInt(touchobj.clientY, 10)) * 100 / this.barHeight) + this.startHandleValue;
    }
    this.setValueFromHandle(event, handleValue);
    event.preventDefault();
  }
  onDragEnd(event) {
    if (this.$disabled()) {
      return;
    }
    this.dragging = false;
    this.el.nativeElement.setAttribute("data-p-sliding", false);
    if (this.range) this.onSlideEnd.emit({
      originalEvent: event,
      values: this.values
    });
    else this.onSlideEnd.emit({
      originalEvent: event,
      value: this.value
    });
    if (this.animate) {
      W(this.el.nativeElement, "p-slider-animate");
    }
    event.preventDefault();
  }
  onBarClick(event) {
    if (this.$disabled()) {
      return;
    }
    if (!this.sliderHandleClick) {
      this.updateDomData();
      this.handleChange(event);
      if (this.range) this.onSlideEnd.emit({
        originalEvent: event,
        values: this.values
      });
      else this.onSlideEnd.emit({
        originalEvent: event,
        value: this.value
      });
    }
    this.sliderHandleClick = false;
  }
  onKeyDown(event, index) {
    this.handleIndex = index;
    switch (event.code) {
      case "ArrowDown":
      case "ArrowLeft":
        this.decrementValue(event, index);
        event.preventDefault();
        break;
      case "ArrowUp":
      case "ArrowRight":
        this.incrementValue(event, index);
        event.preventDefault();
        break;
      case "PageDown":
        this.decrementValue(event, index, true);
        event.preventDefault();
        break;
      case "PageUp":
        this.incrementValue(event, index, true);
        event.preventDefault();
        break;
      case "Home":
        this.updateValue(this.min, event);
        event.preventDefault();
        break;
      case "End":
        this.updateValue(this.max, event);
        event.preventDefault();
        break;
      default:
        break;
    }
  }
  decrementValue(event, index, pageKey = false) {
    let newValue;
    if (this.range) {
      if (this.step) newValue = (this.values?.[index] ?? 0) - this.step;
      else newValue = (this.values?.[index] ?? 0) - 1;
    } else {
      if (this.step) newValue = this.value - this.step;
      else if (!this.step && pageKey) newValue = this.value - 10;
      else newValue = this.value - 1;
    }
    this.updateValue(newValue, event);
    event.preventDefault();
  }
  incrementValue(event, index, pageKey = false) {
    let newValue;
    if (this.range) {
      if (this.step) newValue = (this.values?.[index] ?? 0) + this.step;
      else newValue = (this.values?.[index] ?? 0) + 1;
    } else {
      if (this.step) newValue = this.value + this.step;
      else if (!this.step && pageKey) newValue = this.value + 10;
      else newValue = this.value + 1;
    }
    this.updateValue(newValue, event);
    event.preventDefault();
  }
  handleChange(event) {
    let handleValue = this.calculateHandleValue(event);
    this.setValueFromHandle(event, handleValue);
  }
  bindDragListeners() {
    if (isPlatformBrowser(this.platformId)) {
      this.ngZone.runOutsideAngular(() => {
        const documentTarget = this.el ? this.el.nativeElement.ownerDocument : this.document;
        if (!this.dragListener) {
          this.dragListener = this.renderer.listen(documentTarget, "mousemove", (event) => {
            if (this.dragging) {
              this.el.nativeElement.setAttribute("data-p-sliding", true);
              this.ngZone.run(() => {
                this.handleChange(event);
              });
            }
          });
        }
        if (!this.mouseupListener) {
          this.mouseupListener = this.renderer.listen(documentTarget, "mouseup", (event) => {
            if (this.dragging) {
              this.dragging = false;
              this.el.nativeElement.setAttribute("data-p-sliding", false);
              this.ngZone.run(() => {
                if (this.range) this.onSlideEnd.emit({
                  originalEvent: event,
                  values: this.values
                });
                else this.onSlideEnd.emit({
                  originalEvent: event,
                  value: this.value
                });
                if (this.animate) {
                  W(this.el.nativeElement, "p-slider-animate");
                }
              });
            }
          });
        }
      });
    }
  }
  unbindDragListeners() {
    if (this.dragListener) {
      this.dragListener();
      this.dragListener = null;
    }
    if (this.mouseupListener) {
      this.mouseupListener();
      this.mouseupListener = null;
    }
  }
  setValueFromHandle(event, handleValue) {
    let newValue = this.getValueFromHandle(handleValue);
    if (this.range) {
      if (this.step) {
        this.handleStepChange(newValue, this.values[this.handleIndex]);
      } else {
        this.handleValues[this.handleIndex] = handleValue;
        this.updateValue(newValue, event);
      }
    } else {
      if (this.step) {
        this.handleStepChange(newValue, this.value);
      } else {
        this.handleValue = handleValue;
        this.updateValue(newValue, event);
      }
    }
    this.cd.markForCheck();
  }
  handleStepChange(newValue, oldValue) {
    let diff = newValue - oldValue;
    let val = oldValue;
    let _step = this.step;
    if (diff < 0) {
      val = oldValue + Math.ceil(newValue / _step - oldValue / _step) * _step;
    } else if (diff > 0) {
      val = oldValue + Math.floor(newValue / _step - oldValue / _step) * _step;
    }
    this.updateValue(val);
    this.updateHandleValue();
  }
  get rangeStartLeft() {
    if (!this.isVertical()) return this.handleValues[0] > 100 ? "100%" : this.handleValues[0] + "%";
    return null;
  }
  get rangeStartBottom() {
    return this.isVertical() ? this.handleValues[0] + "%" : "auto";
  }
  get rangeEndLeft() {
    return this.isVertical() ? null : this.handleValues[1] + "%";
  }
  get rangeEndBottom() {
    return this.isVertical() ? this.handleValues[1] + "%" : "auto";
  }
  isVertical() {
    return this.orientation === "vertical";
  }
  updateDomData() {
    let rect = this.el.nativeElement.getBoundingClientRect();
    this.initX = rect.left + k();
    this.initY = rect.top + $();
    this.barWidth = this.el.nativeElement.offsetWidth;
    this.barHeight = this.el.nativeElement.offsetHeight;
  }
  calculateHandleValue(event) {
    if (this.orientation === "horizontal") {
      if (V(this.el.nativeElement)) {
        return (this.initX + this.barWidth - event.pageX) * 100 / this.barWidth;
      } else {
        return (event.pageX - this.initX) * 100 / this.barWidth;
      }
    } else {
      return (this.initY + this.barHeight - event.pageY) * 100 / this.barHeight;
    }
  }
  updateHandleValue() {
    if (this.range) {
      this.handleValues[0] = (this.values[0] < this.min ? 0 : this.values[0] - this.min) * 100 / (this.max - this.min);
      this.handleValues[1] = (this.values[1] > this.max ? 100 : this.values[1] - this.min) * 100 / (this.max - this.min);
    } else {
      if (this.value < this.min) this.handleValue = 0;
      else if (this.value > this.max) this.handleValue = 100;
      else this.handleValue = (this.value - this.min) * 100 / (this.max - this.min);
    }
    if (this.step) {
      this.updateDiffAndOffset();
    }
  }
  updateDiffAndOffset() {
    this.diff = this.getDiff();
    this.offset = this.getOffset();
  }
  getDiff() {
    return Math.abs(this.handleValues[0] - this.handleValues[1]);
  }
  getOffset() {
    return Math.min(this.handleValues[0], this.handleValues[1]);
  }
  updateValue(val, event) {
    if (this.range) {
      let value = val;
      if (this.handleIndex == 0) {
        if (value < this.min) {
          value = this.min;
          this.handleValues[0] = 0;
        } else if (value > this.values[1]) {
          if (value > this.max) {
            value = this.max;
            this.handleValues[0] = 100;
          }
        }
        this.sliderHandleStart?.nativeElement.focus();
      } else {
        if (value > this.max) {
          value = this.max;
          this.handleValues[1] = 100;
          this.offset = this.handleValues[1];
        } else if (value < this.min) {
          value = this.min;
          this.handleValues[1] = 0;
        } else if (value < this.values[0]) {
          this.offset = this.handleValues[1];
        }
        this.sliderHandleEnd?.nativeElement.focus();
      }
      if (this.step) {
        this.updateHandleValue();
      } else {
        this.updateDiffAndOffset();
      }
      this.values[this.handleIndex] = this.getNormalizedValue(value);
      let newValues = [this.minVal, this.maxVal];
      this.onModelChange(newValues);
      this.onChange.emit({
        event,
        values: this.values
      });
    } else {
      if (val < this.min) {
        val = this.min;
        this.handleValue = 0;
      } else if (val > this.max) {
        val = this.max;
        this.handleValue = 100;
      }
      this.value = this.getNormalizedValue(val);
      this.onModelChange(this.value);
      this.onChange.emit({
        event,
        value: this.value
      });
      this.sliderHandle?.nativeElement.focus();
    }
    this.updateHandleValue();
  }
  getValueFromHandle(handleValue) {
    return (this.max - this.min) * (handleValue / 100) + this.min;
  }
  getDecimalsCount(value) {
    if (value && Math.floor(value) !== value) return value.toString().split(".")[1].length || 0;
    return 0;
  }
  getNormalizedValue(val) {
    let decimalsCount = this.getDecimalsCount(this.step);
    if (decimalsCount > 0) {
      return +parseFloat(val.toString()).toFixed(decimalsCount);
    } else {
      return Math.floor(val);
    }
  }
  onDestroy() {
    this.unbindDragListeners();
  }
  get minVal() {
    return Math.min(this.values[1], this.values[0]);
  }
  get maxVal() {
    return Math.max(this.values[1], this.values[0]);
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value) {
    if (this.range) this.values = value || [0, 0];
    else this.value = value || 0;
    this.updateHandleValue();
    this.updateDiffAndOffset();
    this.cd.markForCheck();
  }
  get dataP() {
    return this.cn({
      [this.orientation]: this.orientation
    });
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275Slider_BaseFactory;
    return function Slider_Factory(__ngFactoryType__) {
      return (\u0275Slider_BaseFactory || (\u0275Slider_BaseFactory = \u0275\u0275getInheritedFactory(_Slider)))(__ngFactoryType__ || _Slider);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _Slider,
    selectors: [["p-slider"]],
    viewQuery: function Slider_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c011, 5);
        \u0275\u0275viewQuery(_c15, 5);
        \u0275\u0275viewQuery(_c25, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.sliderHandle = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.sliderHandleStart = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.sliderHandleEnd = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function Slider_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("click", function Slider_click_HostBindingHandler($event) {
          return ctx.onHostClick($event);
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("data-pc-name", "slider")("data-pc-section", "root")("data-p", ctx.dataP)("data-p-sliding", false);
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      animate: [2, "animate", "animate", booleanAttribute],
      min: [2, "min", "min", numberAttribute],
      max: [2, "max", "max", numberAttribute],
      orientation: "orientation",
      step: [2, "step", "step", numberAttribute],
      range: [2, "range", "range", booleanAttribute],
      styleClass: "styleClass",
      ariaLabel: "ariaLabel",
      ariaLabelledBy: "ariaLabelledBy",
      tabindex: [2, "tabindex", "tabindex", numberAttribute],
      autofocus: [2, "autofocus", "autofocus", booleanAttribute]
    },
    outputs: {
      onChange: "onChange",
      onSlideEnd: "onSlideEnd"
    },
    features: [\u0275\u0275ProvidersFeature([SLIDER_VALUE_ACCESSOR, SliderStyle, {
      provide: SLIDER_INSTANCE,
      useExisting: _Slider
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _Slider
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 7,
    vars: 7,
    consts: [["sliderHandle", ""], ["sliderHandleStart", ""], ["sliderHandleEnd", ""], [3, "class", "ngStyle", "style", "pBind", 4, "ngIf"], [3, "class", "style", "ngStyle", "pBind", 4, "ngIf"], ["role", "slider", 3, "class", "transition", "ngStyle", "style", "pAutoFocus", "pBind", "touchstart", "touchmove", "touchend", "mousedown", "keydown", 4, "ngIf"], ["role", "slider", 3, "transition", "class", "style", "ngStyle", "pAutoFocus", "pBind", "keydown", "mousedown", "touchstart", "touchmove", "touchend", 4, "ngIf"], ["role", "slider", 3, "transition", "class", "ngStyle", "style", "pBind", "keydown", "mousedown", "touchstart", "touchmove", "touchend", 4, "ngIf"], [3, "ngStyle", "pBind"], ["role", "slider", 3, "touchstart", "touchmove", "touchend", "mousedown", "keydown", "ngStyle", "pAutoFocus", "pBind"], ["role", "slider", 3, "keydown", "mousedown", "touchstart", "touchmove", "touchend", "ngStyle", "pAutoFocus", "pBind"], ["role", "slider", 3, "keydown", "mousedown", "touchstart", "touchmove", "touchend", "ngStyle", "pBind"]],
    template: function Slider_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275template(0, Slider_span_0_Template, 1, 11, "span", 3)(1, Slider_span_1_Template, 1, 11, "span", 3)(2, Slider_span_2_Template, 1, 9, "span", 4)(3, Slider_span_3_Template, 1, 9, "span", 4)(4, Slider_span_4_Template, 2, 21, "span", 5)(5, Slider_span_5_Template, 2, 21, "span", 6)(6, Slider_span_6_Template, 2, 20, "span", 7);
      }
      if (rf & 2) {
        \u0275\u0275property("ngIf", ctx.range && ctx.orientation == "horizontal");
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.range && ctx.orientation == "vertical");
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", !ctx.range && ctx.orientation == "vertical");
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", !ctx.range && ctx.orientation == "horizontal");
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", !ctx.range);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.range);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.range);
      }
    },
    dependencies: [CommonModule, NgIf, NgStyle, AutoFocus, SharedModule, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Slider, [{
    type: Component,
    args: [{
      selector: "p-slider",
      standalone: true,
      imports: [CommonModule, AutoFocus, SharedModule, BindModule],
      template: `
        <span
            *ngIf="range && orientation == 'horizontal'"
            [class]="cx('range')"
            [ngStyle]="{
                'inset-inline-start': offset !== null && offset !== undefined ? offset + '%' : handleValues[0] + '%',
                width: diff ? diff + '%' : handleValues[1] - handleValues[0] + '%'
            }"
            [style]="sx('range')"
            [attr.data-pc-section]="'range'"
            [attr.data-p]="dataP"
            [pBind]="ptm('range')"
        ></span>
        <span
            *ngIf="range && orientation == 'vertical'"
            [class]="cx('range')"
            [ngStyle]="{
                bottom: offset !== null && offset !== undefined ? offset + '%' : handleValues[0] + '%',
                height: diff ? diff + '%' : handleValues[1] - handleValues[0] + '%'
            }"
            [style]="sx('range')"
            [attr.data-pc-section]="'range'"
            [attr.data-p]="dataP"
            [pBind]="ptm('range')"
        ></span>
        <span *ngIf="!range && orientation == 'vertical'" [class]="cx('range')" [attr.data-pc-section]="'range'" [style]="sx('range')" [ngStyle]="{ height: handleValue + '%' }" [pBind]="ptm('range')"></span>
        <span *ngIf="!range && orientation == 'horizontal'" [class]="cx('range')" [attr.data-pc-section]="'range'" [style]="sx('range')" [ngStyle]="{ width: handleValue + '%' }" [pBind]="ptm('range')"></span>
        <span
            *ngIf="!range"
            #sliderHandle
            [class]="cx('handle')"
            [style.transition]="dragging ? 'none' : null"
            [ngStyle]="{
                'inset-inline-start': orientation == 'horizontal' ? handleValue + '%' : null,
                bottom: orientation == 'vertical' ? handleValue + '%' : null
            }"
            [style]="sx('handle')"
            (touchstart)="onDragStart($event)"
            (touchmove)="onDrag($event)"
            (touchend)="onDragEnd($event)"
            (mousedown)="onMouseDown($event)"
            (keydown)="onKeyDown($event)"
            [attr.tabindex]="$disabled() ? null : tabindex"
            role="slider"
            [attr.aria-valuemin]="min"
            [attr.aria-valuenow]="value"
            [attr.aria-valuemax]="max"
            [attr.aria-labelledby]="ariaLabelledBy"
            [attr.aria-label]="ariaLabel"
            [attr.aria-orientation]="orientation"
            [attr.data-pc-section]="'handle'"
            [pAutoFocus]="autofocus"
            [pBind]="ptm('handle')"
            [attr.data-p]="dataP"
        ></span>
        <span
            *ngIf="range"
            #sliderHandleStart
            [style.transition]="dragging ? 'none' : null"
            [class]="cn(cx('handle'), handleIndex == 0 && 'p-slider-handle-active')"
            [style]="sx('handle')"
            [ngStyle]="{ 'inset-inline-start': rangeStartLeft, bottom: rangeStartBottom }"
            (keydown)="onKeyDown($event, 0)"
            (mousedown)="onMouseDown($event, 0)"
            (touchstart)="onDragStart($event, 0)"
            (touchmove)="onDrag($event)"
            (touchend)="onDragEnd($event)"
            [attr.tabindex]="$disabled() ? null : tabindex"
            role="slider"
            [attr.aria-valuemin]="min"
            [attr.aria-valuenow]="value ? value[0] : null"
            [attr.aria-valuemax]="max"
            [attr.aria-labelledby]="ariaLabelledBy"
            [attr.aria-label]="ariaLabel"
            [attr.aria-orientation]="orientation"
            [attr.data-pc-section]="'startHandler'"
            [pAutoFocus]="autofocus"
            [pBind]="ptm('startHandler')"
            [attr.data-p]="dataP"
        ></span>
        <span
            *ngIf="range"
            #sliderHandleEnd
            [style.transition]="dragging ? 'none' : null"
            [class]="cn(cx('handle'), handleIndex == 1 && 'p-slider-handle-active')"
            [ngStyle]="{ 'inset-inline-start': rangeEndLeft, bottom: rangeEndBottom }"
            [style]="sx('handle')"
            (keydown)="onKeyDown($event, 1)"
            (mousedown)="onMouseDown($event, 1)"
            (touchstart)="onDragStart($event, 1)"
            (touchmove)="onDrag($event)"
            (touchend)="onDragEnd($event)"
            [attr.tabindex]="$disabled() ? null : tabindex"
            role="slider"
            [attr.aria-valuemin]="min"
            [attr.aria-valuenow]="value ? value[1] : null"
            [attr.aria-valuemax]="max"
            [attr.aria-labelledby]="ariaLabelledBy"
            [attr.aria-label]="ariaLabel"
            [attr.aria-orientation]="orientation"
            [attr.data-pc-section]="'endHandler'"
            [pBind]="ptm('endHandler')"
            [attr.data-p]="dataP"
        ></span>
    `,
      providers: [SLIDER_VALUE_ACCESSOR, SliderStyle, {
        provide: SLIDER_INSTANCE,
        useExisting: Slider
      }, {
        provide: PARENT_INSTANCE,
        useExisting: Slider
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[attr.data-pc-name]": "'slider'",
        "[attr.data-pc-section]": "'root'",
        "[class]": "cn(cx('root'), styleClass)",
        "[attr.data-p]": "dataP",
        "[attr.data-p-sliding]": "false"
      },
      hostDirectives: [Bind]
    }]
  }], null, {
    animate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    min: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    max: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    orientation: [{
      type: Input
    }],
    step: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    range: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    styleClass: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    tabindex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    autofocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    onChange: [{
      type: Output
    }],
    onSlideEnd: [{
      type: Output
    }],
    sliderHandle: [{
      type: ViewChild,
      args: ["sliderHandle"]
    }],
    sliderHandleStart: [{
      type: ViewChild,
      args: ["sliderHandleStart"]
    }],
    sliderHandleEnd: [{
      type: ViewChild,
      args: ["sliderHandleEnd"]
    }],
    onHostClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var SliderModule = class _SliderModule {
  static \u0275fac = function SliderModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _SliderModule,
    imports: [Slider, SharedModule],
    exports: [Slider, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [Slider, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderModule, [{
    type: NgModule,
    args: [{
      imports: [Slider, SharedModule],
      exports: [Slider, SharedModule]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/knob/index.mjs
var style8 = "\n    .p-knob-range {\n        fill: none;\n        transition: stroke 0.1s ease-in;\n    }\n\n    .p-knob-value {\n        animation-name: p-knob-dash-frame;\n        animation-fill-mode: forwards;\n        fill: none;\n    }\n\n    .p-knob-text {\n        font-size: 1.3rem;\n        text-align: center;\n    }\n\n    .p-knob svg {\n        border-radius: 50%;\n        outline-color: transparent;\n        transition:\n            background dt('knob.transition.duration'),\n            color dt('knob.transition.duration'),\n            outline-color dt('knob.transition.duration'),\n            box-shadow dt('knob.transition.duration');\n    }\n\n    .p-knob svg:focus-visible {\n        box-shadow: dt('knob.focus.ring.shadow');\n        outline: dt('knob.focus.ring.width') dt('knob.focus.ring.style') dt('knob.focus.ring.color');\n        outline-offset: dt('knob.focus.ring.offset');\n    }\n\n    @keyframes p-knob-dash-frame {\n        100% {\n            stroke-dashoffset: 0;\n        }\n    }\n";

// node_modules/primeng/fesm2022/primeng-knob.mjs
function Knob__svg_text_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 3);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r0.cx("text"));
    \u0275\u0275property("pBind", ctx_r0.ptm("text"));
    \u0275\u0275attribute("x", 50)("y", 57)("fill", ctx_r0.textColor)("name", ctx_r0.name());
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.valueToDisplay(), " ");
  }
}
var classes6 = {
  root: ({
    instance
  }) => ["p-knob p-component", {
    "p-disabled": instance.$disabled()
  }],
  range: "p-knob-range",
  value: "p-knob-value",
  text: "p-knob-text"
};
var KnobStyle = class _KnobStyle extends BaseStyle {
  name = "knob";
  style = style8;
  classes = classes6;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275KnobStyle_BaseFactory;
    return function KnobStyle_Factory(__ngFactoryType__) {
      return (\u0275KnobStyle_BaseFactory || (\u0275KnobStyle_BaseFactory = \u0275\u0275getInheritedFactory(_KnobStyle)))(__ngFactoryType__ || _KnobStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _KnobStyle,
    factory: _KnobStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KnobStyle, [{
    type: Injectable
  }], null, null);
})();
var KnobClasses;
(function(KnobClasses2) {
  KnobClasses2["root"] = "p-knob";
  KnobClasses2["range"] = "p-knob-range";
  KnobClasses2["value"] = "p-knob-value";
  KnobClasses2["text"] = "p-knob-text";
})(KnobClasses || (KnobClasses = {}));
var KNOB_INSTANCE = new InjectionToken("KNOB_INSTANCE");
var KNOB_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => Knob),
  multi: true
};
var Knob = class _Knob extends BaseEditableHolder {
  $pcKnob = inject(KNOB_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * Style class of the component.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Defines a string that labels the input for accessibility.
   * @group Props
   */
  ariaLabel;
  /**
   * Specifies one or more IDs in the DOM that labels the input field.
   * @group Props
   */
  ariaLabelledBy;
  /**
   * Index of the element in tabbing order.
   * @group Props
   */
  tabindex = 0;
  /**
   * Background of the value.
   * @group Props
   */
  valueColor = rr("knob.value.background").variable;
  /**
   * Background color of the range.
   * @group Props
   */
  rangeColor = rr("knob.range.background").variable;
  /**
   * Color of the value text.
   * @group Props
   */
  textColor = rr("knob.text.color").variable;
  /**
   * Template string of the value.
   * @group Props
   */
  valueTemplate = "{value}";
  /**
   * Size of the component in pixels.
   * @group Props
   */
  size = 100;
  /**
   * Mininum boundary value.
   * @group Props
   */
  min = 0;
  /**
   * Maximum boundary value.
   * @group Props
   */
  max = 100;
  /**
   * Step factor to increment/decrement the value.
   * @group Props
   */
  step = 1;
  /**
   * Width of the knob stroke.
   * @group Props
   */
  strokeWidth = 14;
  /**
   * Whether the show the value inside the knob.
   * @group Props
   */
  showValue = true;
  /**
   * When present, it specifies that the component value cannot be edited.
   * @group Props
   */
  readonly = false;
  /**
   * Callback to invoke on value change.
   * @param {number} value - New value.
   * @group Emits
   */
  onChange = new EventEmitter();
  radius = 40;
  midX = 50;
  midY = 50;
  minRadians = 4 * Math.PI / 3;
  maxRadians = -Math.PI / 3;
  value = signal(0, ...ngDevMode ? [{
    debugName: "value"
  }] : []);
  windowMouseMoveListener;
  windowMouseUpListener;
  windowTouchMoveListener;
  windowTouchEndListener;
  _componentStyle = inject(KnobStyle);
  mapRange(x, inMin, inMax, outMin, outMax) {
    return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
  }
  onClick(event) {
    if (!this.$disabled() && !this.readonly) {
      this.updateValue(event.offsetX, event.offsetY);
    }
  }
  updateValue(offsetX, offsetY) {
    let dx = offsetX - this.size / 2;
    let dy = this.size / 2 - offsetY;
    let angle = Math.atan2(dy, dx);
    let start = -Math.PI / 2 - Math.PI / 6;
    this.updateModel(angle, start);
  }
  updateModel(angle, start) {
    let mappedValue;
    if (angle > this.maxRadians) mappedValue = this.mapRange(angle, this.minRadians, this.maxRadians, this.min, this.max);
    else if (angle < start) mappedValue = this.mapRange(angle + 2 * Math.PI, this.minRadians, this.maxRadians, this.min, this.max);
    else return;
    let newValue = Math.round((mappedValue - this.min) / this.step) * this.step + this.min;
    this.value.set(newValue);
    this.writeModelValue(this.value());
    this.onModelChange(this.value());
    this.onChange.emit(this.value());
  }
  onMouseDown(event) {
    if (!this.$disabled() && !this.readonly) {
      const window2 = this.document.defaultView || "window";
      this.windowMouseMoveListener = this.renderer.listen(window2, "mousemove", this.onMouseMove.bind(this));
      this.windowMouseUpListener = this.renderer.listen(window2, "mouseup", this.onMouseUp.bind(this));
      event.preventDefault();
    }
  }
  onMouseUp(event) {
    if (!this.$disabled() && !this.readonly) {
      if (this.windowMouseMoveListener) {
        this.windowMouseMoveListener();
        this.windowMouseUpListener = null;
      }
      if (this.windowMouseUpListener) {
        this.windowMouseUpListener();
        this.windowMouseMoveListener = null;
      }
      event.preventDefault();
    }
  }
  onTouchStart(event) {
    if (!this.$disabled() && !this.readonly) {
      const window2 = this.document.defaultView || "window";
      this.windowTouchMoveListener = this.renderer.listen(window2, "touchmove", this.onTouchMove.bind(this));
      this.windowTouchEndListener = this.renderer.listen(window2, "touchend", this.onTouchEnd.bind(this));
      event.preventDefault();
    }
  }
  onTouchEnd(event) {
    if (!this.$disabled() && !this.readonly) {
      if (this.windowTouchMoveListener) {
        this.windowTouchMoveListener();
      }
      if (this.windowTouchEndListener) {
        this.windowTouchEndListener();
      }
      this.windowTouchMoveListener = null;
      this.windowTouchEndListener = null;
      event.preventDefault();
    }
  }
  onMouseMove(event) {
    if (!this.$disabled() && !this.readonly) {
      this.updateValue(event.offsetX, event.offsetY);
      event.preventDefault();
    }
  }
  onTouchMove(event) {
    if (!this.$disabled() && !this.readonly && event instanceof TouchEvent && event.touches.length === 1) {
      const rect = this.el.nativeElement.children[0].getBoundingClientRect();
      const touch = event.targetTouches.item(0);
      if (touch) {
        const offsetX = touch.clientX - rect.left;
        const offsetY = touch.clientY - rect.top;
        this.updateValue(offsetX, offsetY);
      }
    }
  }
  updateModelValue(newValue) {
    if (newValue > this.max) this.value.set(this.max);
    else if (newValue < this.min) this.value.set(this.min);
    else this.value.set(newValue);
    this.writeModelValue(this.value());
    this.onModelChange(this.value());
    this.onChange.emit(this.value());
  }
  onKeyDown(event) {
    if (!this.$disabled() && !this.readonly) {
      switch (event.code) {
        case "ArrowRight":
        case "ArrowUp": {
          event.preventDefault();
          this.updateModelValue(this._value + 1);
          break;
        }
        case "ArrowLeft":
        case "ArrowDown": {
          event.preventDefault();
          this.updateModelValue(this._value - 1);
          break;
        }
        case "Home": {
          event.preventDefault();
          this.updateModelValue(this.min);
          break;
        }
        case "End": {
          event.preventDefault();
          this.updateModelValue(this.max);
          break;
        }
        case "PageUp": {
          event.preventDefault();
          this.updateModelValue(this._value + 10);
          break;
        }
        case "PageDown": {
          event.preventDefault();
          this.updateModelValue(this._value - 10);
          break;
        }
      }
    }
  }
  rangePath() {
    return `M ${this.minX()} ${this.minY()} A ${this.radius} ${this.radius} 0 1 1 ${this.maxX()} ${this.maxY()}`;
  }
  valuePath() {
    return `M ${this.zeroX()} ${this.zeroY()} A ${this.radius} ${this.radius} 0 ${this.largeArc()} ${this.sweep()} ${this.valueX()} ${this.valueY()}`;
  }
  zeroRadians() {
    if (this.min > 0 && this.max > 0) return this.mapRange(this.min, this.min, this.max, this.minRadians, this.maxRadians);
    else return this.mapRange(0, this.min, this.max, this.minRadians, this.maxRadians);
  }
  valueRadians() {
    return this.mapRange(this._value, this.min, this.max, this.minRadians, this.maxRadians);
  }
  minX() {
    return this.midX + Math.cos(this.minRadians) * this.radius;
  }
  minY() {
    return this.midY - Math.sin(this.minRadians) * this.radius;
  }
  maxX() {
    return this.midX + Math.cos(this.maxRadians) * this.radius;
  }
  maxY() {
    return this.midY - Math.sin(this.maxRadians) * this.radius;
  }
  zeroX() {
    return this.midX + Math.cos(this.zeroRadians()) * this.radius;
  }
  zeroY() {
    return this.midY - Math.sin(this.zeroRadians()) * this.radius;
  }
  valueX() {
    return this.midX + Math.cos(this.valueRadians()) * this.radius;
  }
  valueY() {
    return this.midY - Math.sin(this.valueRadians()) * this.radius;
  }
  largeArc() {
    return Math.abs(this.zeroRadians() - this.valueRadians()) < Math.PI ? 0 : 1;
  }
  sweep() {
    return this.valueRadians() > this.zeroRadians() ? 0 : 1;
  }
  valueToDisplay() {
    return this.valueTemplate.replace("{value}", this._value.toString());
  }
  get _value() {
    return this.value() != null ? this.value() : this.min;
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value, setModelValue) {
    this.value.set(value);
    setModelValue(this.value());
    this.cd.markForCheck();
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275Knob_BaseFactory;
    return function Knob_Factory(__ngFactoryType__) {
      return (\u0275Knob_BaseFactory || (\u0275Knob_BaseFactory = \u0275\u0275getInheritedFactory(_Knob)))(__ngFactoryType__ || _Knob);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _Knob,
    selectors: [["p-knob"]],
    hostVars: 2,
    hostBindings: function Knob_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      styleClass: "styleClass",
      ariaLabel: "ariaLabel",
      ariaLabelledBy: "ariaLabelledBy",
      tabindex: [2, "tabindex", "tabindex", numberAttribute],
      valueColor: "valueColor",
      rangeColor: "rangeColor",
      textColor: "textColor",
      valueTemplate: "valueTemplate",
      size: [2, "size", "size", numberAttribute],
      min: [2, "min", "min", numberAttribute],
      max: [2, "max", "max", numberAttribute],
      step: [2, "step", "step", numberAttribute],
      strokeWidth: [2, "strokeWidth", "strokeWidth", numberAttribute],
      showValue: [2, "showValue", "showValue", booleanAttribute],
      readonly: [2, "readonly", "readonly", booleanAttribute]
    },
    outputs: {
      onChange: "onChange"
    },
    features: [\u0275\u0275ProvidersFeature([KNOB_VALUE_ACCESSOR, KnobStyle, {
      provide: KNOB_INSTANCE,
      useExisting: _Knob
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _Knob
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 4,
    vars: 25,
    consts: [["viewBox", "0 0 100 100", "role", "slider", 3, "click", "keydown", "mousedown", "mouseup", "touchstart", "touchend", "pBind"], [3, "pBind"], ["text-anchor", "middle", 3, "class", "pBind", 4, "ngIf"], ["text-anchor", "middle", 3, "pBind"]],
    template: function Knob_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275namespaceSVG();
        \u0275\u0275elementStart(0, "svg", 0);
        \u0275\u0275listener("click", function Knob_Template_svg_click_0_listener($event) {
          return ctx.onClick($event);
        })("keydown", function Knob_Template_svg_keydown_0_listener($event) {
          return ctx.onKeyDown($event);
        })("mousedown", function Knob_Template_svg_mousedown_0_listener($event) {
          return ctx.onMouseDown($event);
        })("mouseup", function Knob_Template_svg_mouseup_0_listener($event) {
          return ctx.onMouseUp($event);
        })("touchstart", function Knob_Template_svg_touchstart_0_listener($event) {
          return ctx.onTouchStart($event);
        })("touchend", function Knob_Template_svg_touchend_0_listener($event) {
          return ctx.onTouchEnd($event);
        });
        \u0275\u0275element(1, "path", 1)(2, "path", 1);
        \u0275\u0275template(3, Knob__svg_text_3_Template, 2, 8, "text", 2);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275styleProp("width", ctx.size + "px")("height", ctx.size + "px");
        \u0275\u0275property("pBind", ctx.ptm("svg"));
        \u0275\u0275attribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("required", ctx.required() ? "" : void 0)("aria-valuenow", ctx._value)("aria-labelledby", ctx.ariaLabelledBy)("aria-label", ctx.ariaLabel)("tabindex", ctx.readonly || ctx.$disabled() ? -1 : ctx.tabindex);
        \u0275\u0275advance();
        \u0275\u0275classMap(ctx.cx("range"));
        \u0275\u0275property("pBind", ctx.ptm("range"));
        \u0275\u0275attribute("d", ctx.rangePath())("stroke-width", ctx.strokeWidth)("stroke", ctx.rangeColor);
        \u0275\u0275advance();
        \u0275\u0275classMap(ctx.cx("value"));
        \u0275\u0275property("pBind", ctx.ptm("value"));
        \u0275\u0275attribute("d", ctx.valuePath())("stroke-width", ctx.strokeWidth)("stroke", ctx.valueColor);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.showValue);
      }
    },
    dependencies: [CommonModule, NgIf, SharedModule, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Knob, [{
    type: Component,
    args: [{
      selector: "p-knob",
      standalone: true,
      imports: [CommonModule, SharedModule, BindModule],
      template: `
        <svg
            viewBox="0 0 100 100"
            role="slider"
            [style.width]="size + 'px'"
            [style.height]="size + 'px'"
            (click)="onClick($event)"
            (keydown)="onKeyDown($event)"
            (mousedown)="onMouseDown($event)"
            (mouseup)="onMouseUp($event)"
            (touchstart)="onTouchStart($event)"
            (touchend)="onTouchEnd($event)"
            [attr.aria-valuemin]="min"
            [attr.aria-valuemax]="max"
            [attr.required]="required() ? '' : undefined"
            [attr.aria-valuenow]="_value"
            [attr.aria-labelledby]="ariaLabelledBy"
            [attr.aria-label]="ariaLabel"
            [attr.tabindex]="readonly || $disabled() ? -1 : tabindex"
            [pBind]="ptm('svg')"
        >
            <path [attr.d]="rangePath()" [attr.stroke-width]="strokeWidth" [attr.stroke]="rangeColor" [class]="cx('range')" [pBind]="ptm('range')"></path>
            <path [attr.d]="valuePath()" [attr.stroke-width]="strokeWidth" [attr.stroke]="valueColor" [class]="cx('value')" [pBind]="ptm('value')"></path>
            <text *ngIf="showValue" [attr.x]="50" [attr.y]="57" text-anchor="middle" [attr.fill]="textColor" [class]="cx('text')" [attr.name]="name()" [pBind]="ptm('text')">
                {{ valueToDisplay() }}
            </text>
        </svg>
    `,
      providers: [KNOB_VALUE_ACCESSOR, KnobStyle, {
        provide: KNOB_INSTANCE,
        useExisting: Knob
      }, {
        provide: PARENT_INSTANCE,
        useExisting: Knob
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cn(cx('root'), styleClass)"
      },
      hostDirectives: [Bind]
    }]
  }], null, {
    styleClass: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    tabindex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    valueColor: [{
      type: Input
    }],
    rangeColor: [{
      type: Input
    }],
    textColor: [{
      type: Input
    }],
    valueTemplate: [{
      type: Input
    }],
    size: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    min: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    max: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    step: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    strokeWidth: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    showValue: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    readonly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    onChange: [{
      type: Output
    }]
  });
})();
var KnobModule = class _KnobModule {
  static \u0275fac = function KnobModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _KnobModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _KnobModule,
    imports: [Knob, SharedModule],
    exports: [Knob, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [Knob, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KnobModule, [{
    type: NgModule,
    args: [{
      imports: [Knob, SharedModule],
      exports: [Knob, SharedModule]
    }]
  }], null, null);
})();

// src/app/shared/services/dynamic-form.service.ts
var DynamicFormService = class _DynamicFormService {
  formStateSubject = new BehaviorSubject(null);
  formState$ = this.formStateSubject.asObservable();
  STORAGE_KEY = "dynamicFormState";
  fb = inject(FormBuilder);
  localStorageService = inject(LocalStorageService);
  createFormGroup(fields) {
    const group = {};
    fields.forEach((field) => {
      if (field.type === "array") {
        group[field.name] = this.fb.array([]);
      } else if (field.type === "group") {
        group[field.name] = this.createFormGroup(field.fields ?? []);
      } else {
        const initialValue = this.getInitialValue(field);
        group[field.key] = this.fb.control(initialValue, this.bindValidations(field.validations ?? []));
      }
    });
    return this.fb.group(group);
  }
  bindValidations(validations) {
    if (validations.length > 0) {
      return validations.map((valid) => valid.validator);
    }
    return [];
  }
  getInitialValue(field) {
    if (isDefined(field.persistKey) && isString(field.persistKey)) {
      const savedState = this.localStorageService.getItem(this.STORAGE_KEY);
      if (isDefined(savedState) && isString(savedState)) {
        try {
          const state = JSON.parse(savedState);
          if (hasProperty(state, field.persistKey)) {
            return state[field.persistKey];
          }
        } catch (error) {
          console.warn("Failed to parse saved state:", error);
        }
      }
    }
    return field.value;
  }
  saveState(formValue) {
    this.localStorageService.setItem(this.STORAGE_KEY, JSON.stringify(formValue));
  }
  updateFormState(state) {
    this.formStateSubject.next(state);
    this.saveState(state);
  }
  clearSavedState() {
    this.localStorageService.removeItem(this.STORAGE_KEY);
    this.formStateSubject.next(null);
  }
  static \u0275fac = function DynamicFormService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DynamicFormService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _DynamicFormService, factory: _DynamicFormService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamicFormService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/fileupload/index.mjs
var style9 = "\n    .p-fileupload input[type='file'] {\n        display: none;\n    }\n\n    .p-fileupload-advanced {\n        border: 1px solid dt('fileupload.border.color');\n        border-radius: dt('fileupload.border.radius');\n        background: dt('fileupload.background');\n        color: dt('fileupload.color');\n    }\n\n    .p-fileupload-header {\n        display: flex;\n        align-items: center;\n        padding: dt('fileupload.header.padding');\n        background: dt('fileupload.header.background');\n        color: dt('fileupload.header.color');\n        border-style: solid;\n        border-width: dt('fileupload.header.border.width');\n        border-color: dt('fileupload.header.border.color');\n        border-radius: dt('fileupload.header.border.radius');\n        gap: dt('fileupload.header.gap');\n    }\n\n    .p-fileupload-content {\n        border: 1px solid transparent;\n        display: flex;\n        flex-direction: column;\n        gap: dt('fileupload.content.gap');\n        transition: border-color dt('fileupload.transition.duration');\n        padding: dt('fileupload.content.padding');\n    }\n\n    .p-fileupload-content .p-progressbar {\n        width: 100%;\n        height: dt('fileupload.progressbar.height');\n    }\n\n    .p-fileupload-file-list {\n        display: flex;\n        flex-direction: column;\n        gap: dt('fileupload.filelist.gap');\n    }\n\n    .p-fileupload-file {\n        display: flex;\n        flex-wrap: wrap;\n        align-items: center;\n        padding: dt('fileupload.file.padding');\n        border-block-end: 1px solid dt('fileupload.file.border.color');\n        gap: dt('fileupload.file.gap');\n    }\n\n    .p-fileupload-file:last-child {\n        border-block-end: 0;\n    }\n\n    .p-fileupload-file-info {\n        display: flex;\n        flex-direction: column;\n        gap: dt('fileupload.file.info.gap');\n    }\n\n    .p-fileupload-file-thumbnail {\n        flex-shrink: 0;\n    }\n\n    .p-fileupload-file-actions {\n        margin-inline-start: auto;\n    }\n\n    .p-fileupload-highlight {\n        border: 1px dashed dt('fileupload.content.highlight.border.color');\n    }\n\n    .p-fileupload-basic .p-message {\n        margin-block-end: dt('fileupload.basic.gap');\n    }\n\n    .p-fileupload-basic-content {\n        display: flex;\n        flex-wrap: wrap;\n        align-items: center;\n        gap: dt('fileupload.basic.gap');\n    }\n";

// node_modules/primeng/fesm2022/primeng-fileupload.mjs
var _c012 = ["pFileContent", ""];
var _c16 = (a0, a1, a2) => ({
  class: a0,
  file: a1,
  index: a2
});
var _forTrack0 = ($index, $item) => ($item == null ? null : $item.name) + "-" + $index;
function FileContent_For_1_ng_template_10_Conditional_0_0_ng_template_0_Template(rf, ctx) {
}
function FileContent_For_1_ng_template_10_Conditional_0_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileContent_For_1_ng_template_10_Conditional_0_0_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function FileContent_For_1_ng_template_10_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileContent_For_1_ng_template_10_Conditional_0_0_Template, 1, 0, null, 7);
  }
  if (rf & 2) {
    const iconClass_r4 = \u0275\u0275nextContext().class;
    const ctx_r4 = \u0275\u0275nextContext();
    const file_r6 = ctx_r4.$implicit;
    const \u0275$index_1_r2 = ctx_r4.$index;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.fileRemoveIconTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction3(2, _c16, iconClass_r4, file_r6, \u0275$index_1_r2));
  }
}
function FileContent_For_1_ng_template_10_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 8);
  }
  if (rf & 2) {
    const iconClass_r4 = \u0275\u0275nextContext().class;
    \u0275\u0275classMap(iconClass_r4);
    \u0275\u0275attribute("aria-hidden", true);
  }
}
function FileContent_For_1_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, FileContent_For_1_ng_template_10_Conditional_0_Template, 1, 6)(1, FileContent_For_1_ng_template_10_Conditional_1_Template, 1, 3, ":svg:svg", 6);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(ctx_r2.fileRemoveIconTemplate() ? 0 : 1);
  }
}
function FileContent_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275element(1, "img", 3);
    \u0275\u0275elementStart(2, "div", 2)(3, "div", 2);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "span", 2);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
    \u0275\u0275element(7, "p-badge", 4);
    \u0275\u0275elementStart(8, "div", 2)(9, "p-button", 5);
    \u0275\u0275listener("onClick", function FileContent_For_1_Template_p_button_onClick_9_listener($event) {
      const \u0275$index_1_r2 = \u0275\u0275restoreView(_r1).$index;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onRemoveClick($event, \u0275$index_1_r2));
    });
    \u0275\u0275template(10, FileContent_For_1_ng_template_10_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const file_r6 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r2.cx("file"));
    \u0275\u0275property("pBind", ctx_r2.$pcFileUpload.ptm("file"));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("fileThumbnail"));
    \u0275\u0275property("src", file_r6.objectURL, \u0275\u0275sanitizeUrl)("width", ctx_r2.previewWidth())("pBind", ctx_r2.$pcFileUpload.ptm("fileThumbnail"));
    \u0275\u0275attribute("alt", file_r6.name);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("fileInfo"));
    \u0275\u0275property("pBind", ctx_r2.$pcFileUpload.ptm("fileInfo"));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("fileName"));
    \u0275\u0275property("pBind", ctx_r2.$pcFileUpload.ptm("fileName"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(file_r6.name);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("fileSize"));
    \u0275\u0275property("pBind", ctx_r2.$pcFileUpload.ptm("fileSize"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r2.formatSize(file_r6.size));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("pcFileBadge"));
    \u0275\u0275property("value", ctx_r2.badgeValue())("severity", ctx_r2.badgeSeverity())("pt", ctx_r2.$pcFileUpload.ptm("pcFileBadge"))("unstyled", ctx_r2.unstyled());
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("fileActions"));
    \u0275\u0275property("pBind", ctx_r2.$pcFileUpload.ptm("fileActions"));
    \u0275\u0275advance();
    \u0275\u0275property("styleClass", ctx_r2.cx("pcFileRemoveButton"))("pt", ctx_r2.$pcFileUpload.ptm("pcFileRemoveButton"))("unstyled", ctx_r2.unstyled());
  }
}
var _c26 = ["file"];
var _c35 = ["header"];
var _c44 = ["content"];
var _c54 = ["toolbar"];
var _c63 = ["chooseicon"];
var _c73 = ["filelabel"];
var _c82 = ["uploadicon"];
var _c92 = ["cancelicon"];
var _c10 = ["empty"];
var _c11 = ["advancedfileinput"];
var _c122 = ["basicfileinput"];
var _c132 = (a0, a1, a2, a3, a4) => ({
  $implicit: a0,
  uploadedFiles: a1,
  chooseCallback: a2,
  clearCallback: a3,
  uploadCallback: a4
});
var _c142 = (a0, a1, a2, a3, a4, a5, a6, a7) => ({
  $implicit: a0,
  uploadedFiles: a1,
  chooseCallback: a2,
  clearCallback: a3,
  removeUploadedFileCallback: a4,
  removeFileCallback: a5,
  progress: a6,
  messages: a7
});
var _c152 = (a0) => ({
  $implicit: a0
});
function FileUpload_div_0_ng_container_4_ng_template_4_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 8);
  }
  if (rf & 2) {
    let tmp_9_0;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275classMap(ctx_r1.chooseIcon);
    \u0275\u0275property("pBind", (tmp_9_0 = ctx_r1.ptm("pcChooseButton")) == null ? null : tmp_9_0.icon);
    \u0275\u0275attribute("aria-label", true);
  }
}
function FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 17);
  }
  if (rf & 2) {
    let tmp_9_0;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275property("pBind", (tmp_9_0 = ctx_r1.ptm("pcChooseButton")) == null ? null : tmp_9_0.icon);
    \u0275\u0275attribute("aria-label", true);
  }
}
function FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1_span_2_1_ng_template_0_Template(rf, ctx) {
}
function FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1_span_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 8);
    \u0275\u0275template(1, FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1_span_2_1_Template, 1, 0, null, 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_9_0;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275property("pBind", (tmp_9_0 = ctx_r1.ptm("pcChooseButton")) == null ? null : tmp_9_0.icon);
    \u0275\u0275attribute("aria-label", true);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.chooseIconTemplate || ctx_r1._chooseIconTemplate);
  }
}
function FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1__svg_svg_1_Template, 1, 2, "svg", 15)(2, FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1_span_2_Template, 2, 3, "span", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.chooseIconTemplate && !ctx_r1._chooseIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.chooseIconTemplate || ctx_r1._chooseIconTemplate);
  }
}
function FileUpload_div_0_ng_container_4_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_0_ng_container_4_ng_template_4_span_0_Template, 1, 4, "span", 5)(1, FileUpload_div_0_ng_container_4_ng_template_4_ng_container_1_Template, 3, 2, "ng-container", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngIf", ctx_r1.chooseIcon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.chooseIcon);
  }
}
function FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 20);
  }
  if (rf & 2) {
    let tmp_11_0;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275property("ngClass", ctx_r1.uploadIcon)("pBind", (tmp_11_0 = ctx_r1.ptm("pcUploadButton")) == null ? null : tmp_11_0.icon);
    \u0275\u0275attribute("aria-hidden", true);
  }
}
function FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 22);
  }
  if (rf & 2) {
    let tmp_11_0;
    const ctx_r1 = \u0275\u0275nextContext(6);
    \u0275\u0275property("pBind", (tmp_11_0 = ctx_r1.ptm("pcUploadButton")) == null ? null : tmp_11_0.icon);
  }
}
function FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1_span_2_1_ng_template_0_Template(rf, ctx) {
}
function FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1_span_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 8);
    \u0275\u0275template(1, FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1_span_2_1_Template, 1, 0, null, 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_11_0;
    const ctx_r1 = \u0275\u0275nextContext(6);
    \u0275\u0275property("pBind", (tmp_11_0 = ctx_r1.ptm("pcUploadButton")) == null ? null : tmp_11_0.icon);
    \u0275\u0275attribute("aria-hidden", true);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.uploadIconTemplate || ctx_r1._uploadIconTemplate);
  }
}
function FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1__svg_svg_1_Template, 1, 1, "svg", 21)(2, FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1_span_2_Template, 2, 3, "span", 16);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.uploadIconTemplate && !ctx_r1._uploadIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.uploadIconTemplate || ctx_r1._uploadIconTemplate);
  }
}
function FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_span_0_Template, 1, 3, "span", 19)(1, FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_ng_container_1_Template, 3, 2, "ng-container", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngIf", ctx_r1.uploadIcon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.uploadIcon);
  }
}
function FileUpload_div_0_ng_container_4_p_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-button", 18);
    \u0275\u0275listener("onClick", function FileUpload_div_0_ng_container_4_p_button_6_Template_p_button_onClick_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.upload());
    });
    \u0275\u0275template(1, FileUpload_div_0_ng_container_4_p_button_6_ng_template_1_Template, 2, 2, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("label", ctx_r1.uploadButtonLabel)("disabled", !ctx_r1.hasFiles() || ctx_r1.isFileLimitExceeded())("styleClass", ctx_r1.cn(ctx_r1.cx("pcUploadButton"), ctx_r1.uploadStyleClass))("buttonProps", ctx_r1.uploadButtonProps)("pt", ctx_r1.ptm("pcUploadButton"))("unstyled", ctx_r1.unstyled());
  }
}
function FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 24);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275property("ngClass", ctx_r1.cancelIcon);
  }
}
function FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 26);
  }
  if (rf & 2) {
    \u0275\u0275attribute("aria-hidden", true);
  }
}
function FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1_span_2_1_ng_template_0_Template(rf, ctx) {
}
function FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1_span_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275template(1, FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1_span_2_1_Template, 1, 0, null, 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(6);
    \u0275\u0275attribute("aria-hidden", true);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.cancelIconTemplate || ctx_r1._cancelIconTemplate);
  }
}
function FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1__svg_svg_1_Template, 1, 1, "svg", 25)(2, FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1_span_2_Template, 2, 2, "span", 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.cancelIconTemplate && !ctx_r1._cancelIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.cancelIconTemplate || ctx_r1._cancelIconTemplate);
  }
}
function FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_span_0_Template, 1, 1, "span", 23)(1, FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_ng_container_1_Template, 3, 2, "ng-container", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngIf", ctx_r1.cancelIcon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.cancelIcon);
  }
}
function FileUpload_div_0_ng_container_4_p_button_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-button", 18);
    \u0275\u0275listener("onClick", function FileUpload_div_0_ng_container_4_p_button_7_Template_p_button_onClick_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.clear());
    });
    \u0275\u0275template(1, FileUpload_div_0_ng_container_4_p_button_7_ng_template_1_Template, 2, 2, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("label", ctx_r1.cancelButtonLabel)("disabled", !ctx_r1.hasFiles() || ctx_r1.uploading)("styleClass", ctx_r1.cn(ctx_r1.cx("pcCancelButton"), ctx_r1.cancelStyleClass))("buttonProps", ctx_r1.cancelButtonProps)("pt", ctx_r1.ptm("pcCancelButton"))("unstyled", ctx_r1.unstyled());
  }
}
function FileUpload_div_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "p-button", 13);
    \u0275\u0275listener("focus", function FileUpload_div_0_ng_container_4_Template_p_button_focus_1_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onFocus());
    })("blur", function FileUpload_div_0_ng_container_4_Template_p_button_blur_1_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onBlur());
    })("onClick", function FileUpload_div_0_ng_container_4_Template_p_button_onClick_1_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.choose());
    })("keydown.enter", function FileUpload_div_0_ng_container_4_Template_p_button_keydown_enter_1_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.choose());
    });
    \u0275\u0275elementStart(2, "input", 7, 0);
    \u0275\u0275listener("change", function FileUpload_div_0_ng_container_4_Template_input_change_2_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onFileSelect($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, FileUpload_div_0_ng_container_4_ng_template_4_Template, 2, 2, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, FileUpload_div_0_ng_container_4_p_button_6_Template, 3, 6, "p-button", 14)(7, FileUpload_div_0_ng_container_4_p_button_7_Template, 3, 6, "p-button", 14);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("styleClass", ctx_r1.cn(ctx_r1.cx("pcChooseButton"), ctx_r1.chooseStyleClass))("disabled", ctx_r1.disabled || ctx_r1.isChooseDisabled())("label", ctx_r1.chooseButtonLabel)("buttonProps", ctx_r1.chooseButtonProps)("pt", ctx_r1.ptm("pcChooseButton"))("unstyled", ctx_r1.unstyled());
    \u0275\u0275advance();
    \u0275\u0275property("multiple", ctx_r1.multiple)("accept", ctx_r1.accept)("disabled", ctx_r1.disabled || ctx_r1.isChooseDisabled())("pBind", ctx_r1.ptm("input"));
    \u0275\u0275attribute("aria-label", ctx_r1.browseFilesLabel)("title", "");
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", !ctx_r1.auto && ctx_r1.showUploadButton);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.auto && ctx_r1.showCancelButton);
  }
}
function FileUpload_div_0_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function FileUpload_div_0_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function FileUpload_div_0_Conditional_9_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function FileUpload_div_0_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_0_Conditional_9_ng_container_0_Template, 1, 0, "ng-container", 10);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.contentTemplate || ctx_r1._contentTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction8(2, _c142, ctx_r1.files, ctx_r1.uploadedFiles, ctx_r1.choose.bind(ctx_r1), ctx_r1.clear.bind(ctx_r1), ctx_r1.removeUploadedFile.bind(ctx_r1), ctx_r1.remove.bind(ctx_r1), ctx_r1.progress, ctx_r1.msgs));
  }
}
function FileUpload_div_0_Conditional_10_p_progressbar_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-progressbar", 30);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("value", ctx_r1.progress)("showValue", false)("pt", ctx_r1.ptm("pcProgressBar"));
  }
}
function FileUpload_div_0_Conditional_10_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-message", 28);
  }
  if (rf & 2) {
    const message_r6 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("severity", message_r6.severity)("text", message_r6.text)("pt", ctx_r1.ptm("pcMessage"))("unstyled", ctx_r1.unstyled());
  }
}
function FileUpload_div_0_Conditional_10_Conditional_3_ng_template_1_Template(rf, ctx) {
}
function FileUpload_div_0_Conditional_10_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 33);
    \u0275\u0275listener("onRemove", function FileUpload_div_0_Conditional_10_Conditional_3_Conditional_2_Template_div_onRemove_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.onRemoveClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("unstyled", ctx_r1.unstyled())("files", ctx_r1.files)("badgeValue", ctx_r1.pendingLabel)("previewWidth", ctx_r1.previewWidth)("fileRemoveIconTemplate", ctx_r1.cancelIconTemplate || ctx_r1._cancelIconTemplate);
  }
}
function FileUpload_div_0_Conditional_10_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275template(1, FileUpload_div_0_Conditional_10_Conditional_3_ng_template_1_Template, 0, 0, "ng-template", 31);
    \u0275\u0275conditionalCreate(2, FileUpload_div_0_Conditional_10_Conditional_3_Conditional_2_Template, 1, 5, "div", 32);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r1.cx("fileList"));
    \u0275\u0275property("pBind", ctx_r1.ptm("fileList"));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.files)("ngForTemplate", ctx_r1.fileTemplate || ctx_r1._fileTemplate);
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r1.fileTemplate && !ctx_r1._fileTemplate ? 2 : -1);
  }
}
function FileUpload_div_0_Conditional_10_Conditional_4_ng_template_1_Template(rf, ctx) {
}
function FileUpload_div_0_Conditional_10_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 35);
    \u0275\u0275listener("onRemove", function FileUpload_div_0_Conditional_10_Conditional_4_Conditional_2_Template_div_onRemove_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.onRemoveUploadedFileClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("unstyled", ctx_r1.unstyled())("files", ctx_r1.uploadedFiles)("badgeValue", ctx_r1.completedLabel())("previewWidth", ctx_r1.previewWidth)("fileRemoveIconTemplate", ctx_r1.cancelIconTemplate || ctx_r1._cancelIconTemplate);
  }
}
function FileUpload_div_0_Conditional_10_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275template(1, FileUpload_div_0_Conditional_10_Conditional_4_ng_template_1_Template, 0, 0, "ng-template", 31);
    \u0275\u0275conditionalCreate(2, FileUpload_div_0_Conditional_10_Conditional_4_Conditional_2_Template, 1, 5, "div", 34);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r1.cx("fileList"));
    \u0275\u0275property("pBind", ctx_r1.ptm("fileList"));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.uploadedFiles)("ngForTemplate", ctx_r1.fileTemplate || ctx_r1._fileTemplate);
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r1.fileTemplate && !ctx_r1._fileTemplate ? 2 : -1);
  }
}
function FileUpload_div_0_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_0_Conditional_10_p_progressbar_0_Template, 1, 3, "p-progressbar", 27);
    \u0275\u0275repeaterCreate(1, FileUpload_div_0_Conditional_10_For_2_Template, 1, 4, "p-message", 28, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275conditionalCreate(3, FileUpload_div_0_Conditional_10_Conditional_3_Template, 3, 6, "div", 29);
    \u0275\u0275conditionalCreate(4, FileUpload_div_0_Conditional_10_Conditional_4_Template, 3, 6, "div", 29);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngIf", ctx_r1.hasFiles());
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.msgs);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r1.hasFiles() ? 3 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.hasUploadedFiles() ? 4 : -1);
  }
}
function FileUpload_div_0_Conditional_11_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 8);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("pBind", ctx_r1.ptm("empty"));
  }
}
function FileUpload_div_0_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_0_Conditional_11_ng_container_0_Template, 1, 1, "ng-container", 36);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.emptyTemplate || ctx_r1._emptyTemplate);
  }
}
function FileUpload_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 6)(1, "input", 7, 0);
    \u0275\u0275listener("change", function FileUpload_div_0_Template_input_change_1_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFileSelect($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 8);
    \u0275\u0275template(4, FileUpload_div_0_ng_container_4_Template, 8, 14, "ng-container", 9)(5, FileUpload_div_0_ng_container_5_Template, 1, 0, "ng-container", 10)(6, FileUpload_div_0_ng_container_6_Template, 1, 0, "ng-container", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(7, "div", 12, 1);
    \u0275\u0275listener("dragenter", function FileUpload_div_0_Template_div_dragenter_7_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDragEnter($event));
    })("dragleave", function FileUpload_div_0_Template_div_dragleave_7_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDragLeave($event));
    })("drop", function FileUpload_div_0_Template_div_drop_7_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onDrop($event));
    });
    \u0275\u0275conditionalCreate(9, FileUpload_div_0_Conditional_9_Template, 1, 11, "ng-container")(10, FileUpload_div_0_Conditional_10_Template, 5, 3);
    \u0275\u0275conditionalCreate(11, FileUpload_div_0_Conditional_11_Template, 1, 1, "ng-container", 8);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("root"), ctx_r1.styleClass));
    \u0275\u0275property("ngStyle", ctx_r1.style)("pBind", ctx_r1.ptm("root"));
    \u0275\u0275advance();
    \u0275\u0275property("multiple", ctx_r1.multiple)("accept", ctx_r1.accept)("disabled", ctx_r1.disabled || ctx_r1.isChooseDisabled())("pBind", ctx_r1.ptm("input"));
    \u0275\u0275attribute("aria-label", ctx_r1.browseFilesLabel)("title", "");
    \u0275\u0275advance(2);
    \u0275\u0275classMap(ctx_r1.cx("header"));
    \u0275\u0275property("pBind", ctx_r1.ptm("header"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.headerTemplate && !ctx_r1._headerTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.headerTemplate || ctx_r1._headerTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction5(22, _c132, ctx_r1.files, ctx_r1.uploadedFiles, ctx_r1.choose.bind(ctx_r1), ctx_r1.clear.bind(ctx_r1), ctx_r1.upload.bind(ctx_r1)));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.toolbarTemplate || ctx_r1._toolbarTemplate);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("content"));
    \u0275\u0275property("pBind", ctx_r1.ptm("content"));
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r1.contentTemplate || ctx_r1._contentTemplate ? 9 : 10);
    \u0275\u0275advance(2);
    \u0275\u0275conditional((ctx_r1.emptyTemplate || ctx_r1._emptyTemplate) && !ctx_r1.hasFiles() && !ctx_r1.hasUploadedFiles() ? 11 : -1);
  }
}
function FileUpload_div_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-message", 28);
  }
  if (rf & 2) {
    const message_r10 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("severity", message_r10.severity)("text", message_r10.text)("pt", ctx_r1.ptm("pcMessage"))("unstyled", ctx_r1.unstyled());
  }
}
function FileUpload_div_1_ng_template_5_Conditional_0_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 40);
  }
  if (rf & 2) {
    let tmp_7_0;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngClass", ctx_r1.uploadIcon)("pBind", (tmp_7_0 = ctx_r1.ptm("pcChooseButton")) == null ? null : tmp_7_0.icon);
  }
}
function FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 22);
  }
  if (rf & 2) {
    let tmp_8_0;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275classMap("p-button-icon p-button-icon-left");
    \u0275\u0275property("pBind", (tmp_8_0 = ctx_r1.ptm("pcChooseButton")) == null ? null : tmp_8_0.icon);
  }
}
function FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1_span_2_1_ng_template_0_Template(rf, ctx) {
}
function FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1_span_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 43);
    \u0275\u0275template(1, FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1_span_2_1_Template, 1, 0, null, 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_7_0;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275property("pBind", (tmp_7_0 = ctx_r1.ptm("pcChooseButton")) == null ? null : tmp_7_0.icon);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1._uploadIconTemplate || ctx_r1.uploadIconTemplate);
  }
}
function FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1__svg_svg_1_Template, 1, 3, "svg", 41)(2, FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1_span_2_Template, 2, 2, "span", 42);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.uploadIconTemplate && !ctx_r1._uploadIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1._uploadIconTemplate || ctx_r1.uploadIconTemplate);
  }
}
function FileUpload_div_1_ng_template_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_1_ng_template_5_Conditional_0_span_0_Template, 1, 2, "span", 39)(1, FileUpload_div_1_ng_template_5_Conditional_0_ng_container_1_Template, 3, 2, "ng-container", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngIf", ctx_r1.uploadIcon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.uploadIcon);
  }
}
function FileUpload_div_1_ng_template_5_Conditional_1_span_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 45);
  }
  if (rf & 2) {
    let tmp_7_0;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngClass", ctx_r1.chooseIcon)("pBind", (tmp_7_0 = ctx_r1.ptm("pcChooseButton")) == null ? null : tmp_7_0.icon);
  }
}
function FileUpload_div_1_ng_template_5_Conditional_1_ng_container_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 17);
  }
  if (rf & 2) {
    let tmp_7_0;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275property("pBind", (tmp_7_0 = ctx_r1.ptm("pcChooseButton")) == null ? null : tmp_7_0.icon);
  }
}
function FileUpload_div_1_ng_template_5_Conditional_1_ng_container_1_2_ng_template_0_Template(rf, ctx) {
}
function FileUpload_div_1_ng_template_5_Conditional_1_ng_container_1_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_1_ng_template_5_Conditional_1_ng_container_1_2_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function FileUpload_div_1_ng_template_5_Conditional_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, FileUpload_div_1_ng_template_5_Conditional_1_ng_container_1__svg_svg_1_Template, 1, 1, "svg", 15)(2, FileUpload_div_1_ng_template_5_Conditional_1_ng_container_1_2_Template, 1, 0, null, 11);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.chooseIconTemplate && !ctx_r1._chooseIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.chooseIconTemplate || ctx_r1._chooseIconTemplate);
  }
}
function FileUpload_div_1_ng_template_5_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_1_ng_template_5_Conditional_1_span_0_Template, 1, 2, "span", 44)(1, FileUpload_div_1_ng_template_5_Conditional_1_ng_container_1_Template, 3, 2, "ng-container", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngIf", ctx_r1.chooseIcon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.chooseIcon);
  }
}
function FileUpload_div_1_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, FileUpload_div_1_ng_template_5_Conditional_0_Template, 2, 2)(1, FileUpload_div_1_ng_template_5_Conditional_1_Template, 2, 2);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(ctx_r1.hasFiles() && !ctx_r1.auto ? 0 : 1);
  }
}
function FileUpload_div_1_Conditional_9_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.basicFileChosenLabel(), " ");
  }
}
function FileUpload_div_1_Conditional_9_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function FileUpload_div_1_Conditional_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, FileUpload_div_1_Conditional_9_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 10);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.fileLabelTemplate || ctx_r1._fileLabelTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c152, ctx_r1.files));
  }
}
function FileUpload_div_1_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, FileUpload_div_1_Conditional_9_Conditional_0_Template, 2, 1, "span")(1, FileUpload_div_1_Conditional_9_Conditional_1_Template, 1, 4, "ng-container");
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(!ctx_r1.fileLabelTemplate && !ctx_r1._fileLabelTemplate ? 0 : 1);
  }
}
function FileUpload_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275repeaterCreate(1, FileUpload_div_1_For_2_Template, 1, 4, "p-message", 28, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementStart(3, "div", 8)(4, "p-button", 37);
    \u0275\u0275listener("onClick", function FileUpload_div_1_Template_p_button_onClick_4_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBasicUploaderClick());
    })("keydown", function FileUpload_div_1_Template_p_button_keydown_4_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBasicKeydown($event));
    });
    \u0275\u0275template(5, FileUpload_div_1_ng_template_5_Template, 2, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementStart(7, "input", 38, 3);
    \u0275\u0275listener("change", function FileUpload_div_1_Template_input_change_7_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFileSelect($event));
    })("focus", function FileUpload_div_1_Template_input_focus_7_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFocus());
    })("blur", function FileUpload_div_1_Template_input_blur_7_listener() {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBlur());
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275conditionalCreate(9, FileUpload_div_1_Conditional_9_Template, 2, 1);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("root"), ctx_r1.styleClass));
    \u0275\u0275property("pBind", ctx_r1.ptm("root"));
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.msgs);
    \u0275\u0275advance(2);
    \u0275\u0275classMap(ctx_r1.cx("basicContent"));
    \u0275\u0275property("pBind", ctx_r1.ptm("basicContent"));
    \u0275\u0275advance();
    \u0275\u0275styleMap(ctx_r1.style);
    \u0275\u0275property("styleClass", ctx_r1.cn(ctx_r1.cx("pcChooseButton"), ctx_r1.chooseStyleClass))("disabled", ctx_r1.disabled)("label", ctx_r1.chooseButtonLabel)("buttonProps", ctx_r1.chooseButtonProps)("pt", ctx_r1.ptm("pcChooseButton"))("unstyled", ctx_r1.unstyled());
    \u0275\u0275advance(3);
    \u0275\u0275property("accept", ctx_r1.accept)("multiple", ctx_r1.multiple)("disabled", ctx_r1.disabled)("pBind", ctx_r1.ptm("input"));
    \u0275\u0275attribute("aria-label", ctx_r1.browseFilesLabel);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!ctx_r1.auto ? 9 : -1);
  }
}
var classes7 = {
  root: ({
    instance
  }) => `p-fileupload p-fileupload-${instance.mode} p-component`,
  header: "p-fileupload-header",
  pcChooseButton: "p-fileupload-choose-button",
  pcUploadButton: "p-fileupload-upload-button",
  pcCancelButton: "p-fileupload-cancel-button",
  content: "p-fileupload-content",
  fileList: "p-fileupload-file-list",
  file: "p-fileupload-file",
  fileThumbnail: "p-fileupload-file-thumbnail",
  fileInfo: "p-fileupload-file-info",
  fileName: "p-fileupload-file-name",
  fileSize: "p-fileupload-file-size",
  pcFileBadge: "p-fileupload-file-badge",
  fileActions: "p-fileupload-file-actions",
  pcFileRemoveButton: "p-fileupload-file-remove-button",
  basicContent: "p-fileupload-basic-content"
};
var FileUploadStyle = class _FileUploadStyle extends BaseStyle {
  name = "fileupload";
  style = style9;
  classes = classes7;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275FileUploadStyle_BaseFactory;
    return function FileUploadStyle_Factory(__ngFactoryType__) {
      return (\u0275FileUploadStyle_BaseFactory || (\u0275FileUploadStyle_BaseFactory = \u0275\u0275getInheritedFactory(_FileUploadStyle)))(__ngFactoryType__ || _FileUploadStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FileUploadStyle,
    factory: _FileUploadStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileUploadStyle, [{
    type: Injectable
  }], null, null);
})();
var FileUploadClasses;
(function(FileUploadClasses2) {
  FileUploadClasses2["root"] = "p-fileupload";
  FileUploadClasses2["header"] = "p-fileupload-header";
  FileUploadClasses2["pcChooseButton"] = "p-fileupload-choose-button";
  FileUploadClasses2["pcUploadButton"] = "p-fileupload-upload-button";
  FileUploadClasses2["pcCancelButton"] = "p-fileupload-cancel-button";
  FileUploadClasses2["content"] = "p-fileupload-content";
  FileUploadClasses2["fileList"] = "p-fileupload-file-list";
  FileUploadClasses2["file"] = "p-fileupload-file";
  FileUploadClasses2["fileThumbnail"] = "p-fileupload-file-thumbnail";
  FileUploadClasses2["fileInfo"] = "p-fileupload-file-info";
  FileUploadClasses2["fileName"] = "p-fileupload-file-name";
  FileUploadClasses2["fileSize"] = "p-fileupload-file-size";
  FileUploadClasses2["pcFileBadge"] = "p-fileupload-file-badge";
  FileUploadClasses2["fileActions"] = "p-fileupload-file-actions";
  FileUploadClasses2["pcFileRemoveButton"] = "p-fileupload-file-remove-button";
  FileUploadClasses2["basicContent"] = "p-fileupload-basic-content";
})(FileUploadClasses || (FileUploadClasses = {}));
var FILEUPLOAD_INSTANCE = new InjectionToken("FILEUPLOAD_INSTANCE");
var FileContent = class _FileContent extends BaseComponent {
  _componentStyle = inject(FileUploadStyle);
  $pcFileUpload = inject(FILEUPLOAD_INSTANCE);
  onRemove = output();
  files = input(...ngDevMode ? [void 0, {
    debugName: "files"
  }] : []);
  badgeSeverity = input("warn", ...ngDevMode ? [{
    debugName: "badgeSeverity"
  }] : []);
  badgeValue = input(...ngDevMode ? [void 0, {
    debugName: "badgeValue"
  }] : []);
  previewWidth = input(50, ...ngDevMode ? [{
    debugName: "previewWidth"
  }] : []);
  fileRemoveIconTemplate = input(...ngDevMode ? [void 0, {
    debugName: "fileRemoveIconTemplate"
  }] : []);
  onRemoveClick(event, index) {
    this.onRemove.emit({
      event,
      index
    });
  }
  formatSize(bytes) {
    const k3 = 1024;
    const dm = 3;
    const sizes = this.config.getTranslation(TranslationKeys.FILE_SIZE_TYPES);
    if (bytes === 0) {
      return `0 ${sizes[0]}`;
    }
    const i = Math.floor(Math.log(bytes) / Math.log(k3));
    const formattedSize = (bytes / Math.pow(k3, i)).toFixed(dm);
    return `${formattedSize} ${sizes[i]}`;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275FileContent_BaseFactory;
    return function FileContent_Factory(__ngFactoryType__) {
      return (\u0275FileContent_BaseFactory || (\u0275FileContent_BaseFactory = \u0275\u0275getInheritedFactory(_FileContent)))(__ngFactoryType__ || _FileContent);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _FileContent,
    selectors: [["", "pFileContent", ""]],
    inputs: {
      files: [1, "files"],
      badgeSeverity: [1, "badgeSeverity"],
      badgeValue: [1, "badgeValue"],
      previewWidth: [1, "previewWidth"],
      fileRemoveIconTemplate: [1, "fileRemoveIconTemplate"]
    },
    outputs: {
      onRemove: "onRemove"
    },
    features: [\u0275\u0275ProvidersFeature([FileUploadStyle]), \u0275\u0275InheritDefinitionFeature],
    attrs: _c012,
    decls: 2,
    vars: 0,
    consts: [["icon", ""], [3, "class", "pBind"], [3, "pBind"], ["role", "presentation", 3, "src", "width", "pBind"], [3, "value", "severity", "pt", "unstyled"], ["text", "", "rounded", "", "severity", "danger", 3, "onClick", "styleClass", "pt", "unstyled"], ["data-p-icon", "times", 3, "class"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["data-p-icon", "times"]],
    template: function FileContent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275repeaterCreate(0, FileContent_For_1_Template, 12, 32, "div", 1, _forTrack0);
      }
      if (rf & 2) {
        \u0275\u0275repeater(ctx.files());
      }
    },
    dependencies: [CommonModule, NgTemplateOutlet, Badge, Button, TimesIcon, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileContent, [{
    type: Component,
    args: [{
      selector: "[pFileContent]",
      standalone: true,
      template: `@for (file of files(); track file?.name + '-' + $index; let index = $index) {
        <div [class]="cx('file')" [pBind]="$pcFileUpload.ptm('file')">
            <img role="presentation" [class]="cx('fileThumbnail')" [attr.alt]="file.name" [src]="file.objectURL" [width]="previewWidth()" [pBind]="$pcFileUpload.ptm('fileThumbnail')" />
            <div [class]="cx('fileInfo')" [pBind]="$pcFileUpload.ptm('fileInfo')">
                <div [class]="cx('fileName')" [pBind]="$pcFileUpload.ptm('fileName')">{{ file.name }}</div>
                <span [class]="cx('fileSize')" [pBind]="$pcFileUpload.ptm('fileSize')">{{ formatSize(file.size) }}</span>
            </div>
            <p-badge [value]="badgeValue()" [severity]="badgeSeverity()" [class]="cx('pcFileBadge')" [pt]="$pcFileUpload.ptm('pcFileBadge')" [unstyled]="unstyled()" />
            <div [class]="cx('fileActions')" [pBind]="$pcFileUpload.ptm('fileActions')">
                <p-button (onClick)="onRemoveClick($event, index)" [styleClass]="cx('pcFileRemoveButton')" text rounded severity="danger" [pt]="$pcFileUpload.ptm('pcFileRemoveButton')" [unstyled]="unstyled()">
                    <ng-template #icon let-iconClass="class">
                        @if (fileRemoveIconTemplate()) {
                            <ng-template *ngTemplateOutlet="fileRemoveIconTemplate(); context: { class: iconClass, file: file, index: index }"></ng-template>
                        } @else {
                            <svg data-p-icon="times" [class]="iconClass" [attr.aria-hidden]="true" />
                        }
                    </ng-template>
                </p-button>
            </div>
        </div>
    }`,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [FileUploadStyle],
      imports: [CommonModule, Badge, Button, TimesIcon, Bind]
    }]
  }], null, {
    onRemove: [{
      type: Output,
      args: ["onRemove"]
    }],
    files: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "files",
        required: false
      }]
    }],
    badgeSeverity: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "badgeSeverity",
        required: false
      }]
    }],
    badgeValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "badgeValue",
        required: false
      }]
    }],
    previewWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "previewWidth",
        required: false
      }]
    }],
    fileRemoveIconTemplate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "fileRemoveIconTemplate",
        required: false
      }]
    }]
  });
})();
var FileUpload = class _FileUpload extends BaseComponent {
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptm("host"));
  }
  /**
   * Name of the request parameter to identify the files at backend.
   * @group Props
   */
  name;
  /**
   * Remote url to upload the files.
   * @group Props
   */
  url;
  /**
   * HTTP method to send the files to the url such as "post" and "put".
   * @group Props
   */
  method = "post";
  /**
   * Used to select multiple files at once from file dialog.
   * @group Props
   */
  multiple;
  /**
   * Comma-separated list of pattern to restrict the allowed file types. Can be any combination of either the MIME types (such as "image/*") or the file extensions (such as ".jpg").
   * @group Props
   */
  accept;
  /**
   * Disables the upload functionality.
   * @group Props
   */
  disabled;
  /**
   * When enabled, upload begins automatically after selection is completed.
   * @group Props
   */
  auto;
  /**
   * Cross-site Access-Control requests should be made using credentials such as cookies, authorization headers or TLS client certificates.
   * @group Props
   */
  withCredentials;
  /**
   * Maximum file size allowed in bytes.
   * @group Props
   */
  maxFileSize;
  /**
   * Summary message of the invalid file size.
   * @group Props
   */
  invalidFileSizeMessageSummary = "{0}: Invalid file size, ";
  /**
   * Detail message of the invalid file size.
   * @group Props
   */
  invalidFileSizeMessageDetail = "maximum upload size is {0}.";
  /**
   * Summary message of the invalid file type.
   * @group Props
   */
  invalidFileTypeMessageSummary = "{0}: Invalid file type, ";
  /**
   * Detail message of the invalid file type.
   * @group Props
   */
  invalidFileTypeMessageDetail = "allowed file types: {0}.";
  /**
   * Detail message of the invalid file type.
   * @group Props
   */
  invalidFileLimitMessageDetail = "limit is {0} at most.";
  /**
   * Summary message of the invalid file type.
   * @group Props
   */
  invalidFileLimitMessageSummary = "Maximum number of files exceeded, ";
  /**
   * Inline style of the element.
   * @group Props
   */
  style;
  /**
   * Class of the element.
   * @group Props
   */
  styleClass;
  /**
   * Width of the image thumbnail in pixels.
   * @group Props
   */
  previewWidth = 50;
  /**
   * Label of the choose button. Defaults to PrimeNG Locale configuration.
   * @group Props
   */
  chooseLabel;
  /**
   * Label of the upload button. Defaults to PrimeNG Locale configuration.
   * @group Props
   */
  uploadLabel;
  /**
   * Label of the cancel button. Defaults to PrimeNG Locale configuration.
   * @group Props
   */
  cancelLabel;
  /**
   * Icon of the choose button.
   * @group Props
   */
  chooseIcon;
  /**
   * Icon of the upload button.
   * @group Props
   */
  uploadIcon;
  /**
   * Icon of the cancel button.
   * @group Props
   */
  cancelIcon;
  /**
   * Whether to show the upload button.
   * @group Props
   */
  showUploadButton = true;
  /**
   * Whether to show the cancel button.
   * @group Props
   */
  showCancelButton = true;
  /**
   * Defines the UI of the component.
   * @group Props
   */
  mode = "advanced";
  /**
   * HttpHeaders class represents the header configuration options for an HTTP request.
   * @group Props
   */
  headers;
  /**
   * Whether to use the default upload or a manual implementation defined in uploadHandler callback. Defaults to PrimeNG Locale configuration.
   * @group Props
   */
  customUpload;
  /**
   * Maximum number of files that can be uploaded.
   * @group Props
   */
  fileLimit;
  /**
   * Style class of the upload button.
   * @group Props
   */
  uploadStyleClass;
  /**
   * Style class of the cancel button.
   * @group Props
   */
  cancelStyleClass;
  /**
   * Style class of the remove button.
   * @group Props
   */
  removeStyleClass;
  /**
   * Style class of the choose button.
   * @group Props
   */
  chooseStyleClass;
  /**
   * Used to pass all properties of the ButtonProps to the choose button inside the component.
   * @group Props
   */
  chooseButtonProps;
  /**
   * Used to pass all properties of the ButtonProps to the upload button inside the component.
   * @group Props
   */
  uploadButtonProps = {
    severity: "secondary"
  };
  /**
   * Used to pass all properties of the ButtonProps to the cancel button inside the component.
   * @group Props
   */
  cancelButtonProps = {
    severity: "secondary"
  };
  /**
   * Callback to invoke before file upload is initialized.
   * @param {FileBeforeUploadEvent} event - Custom upload event.
   * @group Emits
   */
  onBeforeUpload = new EventEmitter();
  /**
   * An event indicating that the request was sent to the server. Useful when a request may be retried multiple times, to distinguish between retries on the final event stream.
   * @param {FileSendEvent} event - Custom send event.
   * @group Emits
   */
  onSend = new EventEmitter();
  /**
   * Callback to invoke when file upload is complete.
   * @param {FileUploadEvent} event - Custom upload event.
   * @group Emits
   */
  onUpload = new EventEmitter();
  /**
   * Callback to invoke if file upload fails.
   * @param {FileUploadErrorEvent} event - Custom error event.
   * @group Emits
   */
  onError = new EventEmitter();
  /**
   * Callback to invoke when files in queue are removed without uploading using clear all button.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onClear = new EventEmitter();
  /**
   * Callback to invoke when a file is removed without uploading using clear button of a file.
   * @param {FileRemoveEvent} event - Remove event.
   * @group Emits
   */
  onRemove = new EventEmitter();
  /**
   * Callback to invoke when files are selected.
   * @param {FileSelectEvent} event - Select event.
   * @group Emits
   */
  onSelect = new EventEmitter();
  /**
   * Callback to invoke when files are being uploaded.
   * @param {FileProgressEvent} event - Progress event.
   * @group Emits
   */
  onProgress = new EventEmitter();
  /**
   * Callback to invoke in custom upload mode to upload the files manually.
   * @param {FileUploadHandlerEvent} event - Upload handler event.
   * @group Emits
   */
  uploadHandler = new EventEmitter();
  /**
   * This event is triggered if an error occurs while loading an image file.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onImageError = new EventEmitter();
  /**
   * This event is triggered if an error occurs while loading an image file.
   * @param {RemoveUploadedFileEvent} event - Remove event.
   * @group Emits
   */
  onRemoveUploadedFile = new EventEmitter();
  /**
   * Custom file template.
   * @group Templates
   */
  fileTemplate;
  /**
   * Custom header template.
   * @param {FileUploadHeaderTemplateContext} context - header template context.
   * @group Templates
   */
  headerTemplate;
  /**
   * Custom content template.
   * @param {FileUploadContentTemplateContext} context - content template context.
   * @group Templates
   */
  contentTemplate;
  /**
   * Custom toolbar template.
   * @group Templates
   */
  toolbarTemplate;
  /**
   * Custom choose icon template.
   * @group Templates
   */
  chooseIconTemplate;
  /**
   * Custom file label template.
   * @param {FileUploadFileLabelTemplateContext} context - file label template context.
   * @group Templates
   */
  fileLabelTemplate;
  /**
   * Custom upload icon template.
   * @group Templates
   */
  uploadIconTemplate;
  /**
   * Custom cancel icon template.
   * @group Templates
   */
  cancelIconTemplate;
  /**
   * Custom empty state template.
   * @group Templates
   */
  emptyTemplate;
  advancedFileInput;
  basicFileInput;
  content;
  set files(files) {
    this._files = [];
    for (let i = 0; i < files.length; i++) {
      let file = files[i];
      if (this.validate(file)) {
        if (this.isImage(file)) {
          file.objectURL = this.sanitizer.bypassSecurityTrustUrl(window.URL.createObjectURL(files[i]));
        }
        this._files.push(files[i]);
      }
    }
  }
  get files() {
    return this._files;
  }
  get basicButtonLabel() {
    if (this.auto || !this.hasFiles()) {
      return this.chooseLabel;
    }
    return this.uploadLabel ?? this.files[0].name;
  }
  _files = [];
  progress = 0;
  dragHighlight;
  msgs;
  uploadedFileCount = 0;
  focus;
  uploading;
  duplicateIEEvent;
  // flag to recognize duplicate onchange event for file input
  translationSubscription;
  dragOverListener;
  uploadedFiles = [];
  sanitizer = inject(DomSanitizer);
  zone = inject(NgZone);
  http = inject(HttpClient);
  _componentStyle = inject(FileUploadStyle);
  onInit() {
    this.translationSubscription = this.config.translationObserver.subscribe(() => {
      this.cd.markForCheck();
    });
  }
  onAfterViewInit() {
    if (isPlatformBrowser(this.platformId)) {
      if (this.mode === "advanced") {
        this.zone.runOutsideAngular(() => {
          if (this.content) {
            this.dragOverListener = this.renderer.listen(this.content.nativeElement, "dragover", this.onDragOver.bind(this));
          }
        });
      }
    }
  }
  _headerTemplate;
  _contentTemplate;
  _toolbarTemplate;
  _chooseIconTemplate;
  _uploadIconTemplate;
  _cancelIconTemplate;
  _emptyTemplate;
  _fileTemplate;
  _fileLabelTemplate;
  templates;
  onAfterContentInit() {
    this.templates?.forEach((item) => {
      switch (item.getType()) {
        case "header":
          this._headerTemplate = item.template;
          break;
        case "file":
          this._fileTemplate = item.template;
          break;
        case "content":
          this._contentTemplate = item.template;
          break;
        case "toolbar":
          this._toolbarTemplate = item.template;
          break;
        case "chooseicon":
          this._chooseIconTemplate = item.template;
          break;
        case "uploadicon":
          this._uploadIconTemplate = item.template;
          break;
        case "cancelicon":
          this._cancelIconTemplate = item.template;
          break;
        case "empty":
          this._emptyTemplate = item.template;
          break;
        case "filelabel":
          this._fileLabelTemplate = item.template;
          break;
        default:
          this._fileTemplate = item.template;
          break;
      }
    });
  }
  basicFileChosenLabel() {
    if (this.auto) return this.chooseButtonLabel;
    else if (this.hasFiles()) {
      if (this.files && this.files.length === 1) return this.files[0].name;
      return this.config.getTranslation("fileChosenMessage")?.replace("{0}", this.files.length);
    }
    return this.config.getTranslation("noFileChosenMessage") || "";
  }
  completedLabel() {
    return this.config.getTranslation("completed") || "";
  }
  getTranslation(option) {
    return this.config.getTranslation(option);
  }
  choose() {
    this.advancedFileInput?.nativeElement.click();
  }
  onFileSelect(event) {
    if (event.type !== "drop" && this.isIE11() && this.duplicateIEEvent) {
      this.duplicateIEEvent = false;
      return;
    }
    if (!this.multiple) {
      this.files = [];
    }
    this.msgs = [];
    this.files = this.files || [];
    let files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
    for (let i = 0; i < files.length; i++) {
      let file = files[i];
      if (!this.isFileSelected(file)) {
        if (this.validate(file)) {
          if (this.isImage(file)) {
            file.objectURL = this.sanitizer.bypassSecurityTrustUrl(window.URL.createObjectURL(files[i]));
          }
          this.files.push(files[i]);
        }
      }
    }
    this.onSelect.emit({
      originalEvent: event,
      files,
      currentFiles: this.files
    });
    this.checkFileLimit(files);
    if (this.hasFiles() && this.auto && (this.mode !== "advanced" || !this.isFileLimitExceeded())) {
      this.upload();
    }
    if (event.type !== "drop" && this.isIE11()) {
      this.clearIEInput();
    } else {
      this.clearInputElement();
    }
  }
  isFileSelected(file) {
    for (let sFile of this.files) {
      if (sFile.name + sFile.type + sFile.size === file.name + file.type + file.size) {
        return true;
      }
    }
    return false;
  }
  isIE11() {
    if (isPlatformBrowser(this.platformId)) {
      return !!this.document.defaultView["MSInputMethodContext"] && !!this.document["documentMode"];
    }
  }
  validate(file) {
    this.msgs = this.msgs || [];
    if (this.accept && !this.isFileTypeValid(file)) {
      const text = `${this.invalidFileTypeMessageSummary.replace("{0}", file.name)} ${this.invalidFileTypeMessageDetail.replace("{0}", this.accept)}`;
      this.msgs.push({
        severity: "error",
        text
      });
      return false;
    }
    if (this.maxFileSize && file.size > this.maxFileSize) {
      const text = `${this.invalidFileSizeMessageSummary.replace("{0}", file.name)} ${this.invalidFileSizeMessageDetail.replace("{0}", this.formatSize(this.maxFileSize))}`;
      this.msgs.push({
        severity: "error",
        text
      });
      return false;
    }
    return true;
  }
  isFileTypeValid(file) {
    let acceptableTypes = this.accept?.split(",").map((type) => type.trim());
    for (let type of acceptableTypes) {
      let acceptable = this.isWildcard(type) ? this.getTypeClass(file.type) === this.getTypeClass(type) : file.type == type || this.getFileExtension(file).toLowerCase() === type.toLowerCase();
      if (acceptable) {
        return true;
      }
    }
    return false;
  }
  getTypeClass(fileType) {
    return fileType.substring(0, fileType.indexOf("/"));
  }
  isWildcard(fileType) {
    return fileType.indexOf("*") !== -1;
  }
  getFileExtension(file) {
    return "." + file.name.split(".").pop();
  }
  isImage(file) {
    return /^image\//.test(file.type);
  }
  onImageLoad(img) {
    window.URL.revokeObjectURL(img.src);
  }
  /**
   * Uploads the selected files.
   * @group Method
   */
  uploader() {
    if (this.customUpload) {
      if (this.fileLimit) {
        this.uploadedFileCount += this.files.length;
      }
      this.uploadHandler.emit({
        files: this.files
      });
      this.cd.markForCheck();
    } else {
      this.uploading = true;
      this.msgs = [];
      let formData = new FormData();
      this.onBeforeUpload.emit({
        formData
      });
      for (let i = 0; i < this.files.length; i++) {
        formData.append(this.name, this.files[i], this.files[i].name);
      }
      this.http.request(this.method, this.url, {
        body: formData,
        headers: this.headers,
        reportProgress: true,
        observe: "events",
        withCredentials: this.withCredentials
      }).subscribe((event) => {
        switch (event.type) {
          case HttpEventType.Sent:
            this.onSend.emit({
              originalEvent: event,
              formData
            });
            break;
          case HttpEventType.Response:
            this.uploading = false;
            this.progress = 0;
            if (event["status"] >= 200 && event["status"] < 300) {
              if (this.fileLimit) {
                this.uploadedFileCount += this.files.length;
              }
              this.onUpload.emit({
                originalEvent: event,
                files: this.files
              });
            } else {
              this.onError.emit({
                files: this.files
              });
            }
            this.uploadedFiles = [...this.uploadedFiles, ...this.files];
            this.clear();
            break;
          case HttpEventType.UploadProgress: {
            if (event["loaded"]) {
              this.progress = Math.round(event["loaded"] * 100 / event["total"]);
            }
            this.onProgress.emit({
              originalEvent: event,
              progress: this.progress
            });
            break;
          }
        }
        this.cd.markForCheck();
      }, (error) => {
        this.uploading = false;
        this.onError.emit({
          files: this.files,
          error
        });
      });
    }
  }
  onRemoveClick(e) {
    const {
      event,
      index
    } = e;
    if (this.hasFiles()) {
      this.remove(event, index);
    }
  }
  onRemoveUploadedFileClick(e) {
    const {
      index
    } = e;
    if (this.hasUploadedFiles()) {
      this.removeUploadedFile(index);
    }
  }
  /**
   * Clears the files list.
   * @group Method
   */
  clear() {
    this.files = [];
    this.onClear.emit();
    this.clearInputElement();
    this.msgs = [];
    this.cd.markForCheck();
  }
  /**
   * Removes a single file.
   * @param {Event} event - Browser event.
   * @param {Number} index - Index of the file.
   * @group Method
   */
  remove(event, index) {
    this.clearInputElement();
    this.onRemove.emit({
      originalEvent: event,
      file: this.files[index]
    });
    this.files.splice(index, 1);
    this.checkFileLimit(this.files);
  }
  /**
   * Removes uploaded file.
   * @param {Number} index - Index of the file to be removed.
   * @group Method
   */
  removeUploadedFile(index) {
    let removedFile = this.uploadedFiles.splice(index, 1)[0];
    this.uploadedFiles = [...this.uploadedFiles];
    this.onRemoveUploadedFile.emit({
      file: removedFile,
      files: this.uploadedFiles
    });
  }
  isFileLimitExceeded() {
    const isAutoMode = this.auto;
    const totalFileCount = isAutoMode ? this.files.length : this.files.length + this.uploadedFileCount;
    if (this.fileLimit && this.fileLimit <= totalFileCount && this.focus) {
      this.focus = false;
    }
    return this.fileLimit && this.fileLimit < totalFileCount;
  }
  isChooseDisabled() {
    if (this.auto) {
      return this.fileLimit && this.fileLimit <= this.files.length;
    } else {
      return this.fileLimit && this.fileLimit <= this.files.length + this.uploadedFileCount;
    }
  }
  checkFileLimit(files) {
    this.msgs ??= [];
    const hasExistingValidationMessages = this.msgs.length > 0 && this.fileLimit && this.fileLimit < files.length;
    if (this.isFileLimitExceeded() || hasExistingValidationMessages) {
      const text = `${this.invalidFileLimitMessageSummary.replace("{0}", this.fileLimit.toString())} ${this.invalidFileLimitMessageDetail.replace("{0}", this.fileLimit.toString())}`;
      this.msgs.push({
        severity: "error",
        text
      });
    } else {
      this.msgs = this.msgs.filter((msg) => !msg.text.includes(this.invalidFileLimitMessageSummary));
    }
  }
  clearInputElement() {
    if (this.advancedFileInput && this.advancedFileInput.nativeElement) {
      this.advancedFileInput.nativeElement.value = "";
    }
    if (this.basicFileInput && this.basicFileInput.nativeElement) {
      this.basicFileInput.nativeElement.value = "";
    }
  }
  clearIEInput() {
    if (this.advancedFileInput && this.advancedFileInput.nativeElement) {
      this.duplicateIEEvent = true;
      this.advancedFileInput.nativeElement.value = "";
    }
  }
  hasFiles() {
    return this.files && this.files.length > 0;
  }
  hasUploadedFiles() {
    return this.uploadedFiles && this.uploadedFiles.length > 0;
  }
  onDragEnter(e) {
    if (!this.disabled) {
      e.stopPropagation();
      e.preventDefault();
    }
  }
  onDragOver(e) {
    if (!this.disabled) {
      !this.$unstyled() && W(this.content?.nativeElement, "p-fileupload-highlight");
      this.content?.nativeElement.setAttribute("data-p-highlight", true);
      this.dragHighlight = true;
      e.stopPropagation();
      e.preventDefault();
    }
  }
  onDragLeave(event) {
    if (!this.disabled) {
      !this.$unstyled() && P(this.content?.nativeElement, "p-fileupload-highlight");
      this.content?.nativeElement.setAttribute("data-p-highlight", false);
    }
  }
  onDrop(event) {
    if (!this.disabled) {
      !this.$unstyled() && P(this.content?.nativeElement, "p-fileupload-highlight");
      this.content?.nativeElement.setAttribute("data-p-highlight", false);
      event.stopPropagation();
      event.preventDefault();
      let files = event.dataTransfer ? event.dataTransfer.files : event.target.files;
      let allowDrop = this.multiple || files && files.length === 1;
      if (allowDrop) {
        this.onFileSelect(event);
      }
    }
  }
  onFocus() {
    this.focus = true;
  }
  onBlur() {
    this.focus = false;
  }
  formatSize(bytes) {
    const k3 = 1024;
    const dm = 3;
    const sizes = this.getTranslation(TranslationKeys.FILE_SIZE_TYPES);
    if (bytes === 0) {
      return `0 ${sizes[0]}`;
    }
    const i = Math.floor(Math.log(bytes) / Math.log(k3));
    const formattedSize = (bytes / Math.pow(k3, i)).toFixed(dm);
    return `${formattedSize} ${sizes[i]}`;
  }
  upload() {
    if (this.hasFiles()) this.uploader();
  }
  onBasicUploaderClick() {
    this.basicFileInput?.nativeElement.click();
  }
  onBasicKeydown(event) {
    switch (event.code) {
      case "Space":
      case "Enter":
        this.onBasicUploaderClick();
        event.preventDefault();
        break;
    }
  }
  imageError(event) {
    this.onImageError.emit(event);
  }
  getBlockableElement() {
    return this.el.nativeElement.children[0];
  }
  get chooseButtonLabel() {
    return this.chooseLabel || this.config.getTranslation(TranslationKeys.CHOOSE);
  }
  get uploadButtonLabel() {
    return this.uploadLabel || this.config.getTranslation(TranslationKeys.UPLOAD);
  }
  get cancelButtonLabel() {
    return this.cancelLabel || this.config.getTranslation(TranslationKeys.CANCEL);
  }
  get browseFilesLabel() {
    return this.config.getTranslation(TranslationKeys.ARIA)[TranslationKeys.BROWSE_FILES];
  }
  get pendingLabel() {
    return this.config.getTranslation(TranslationKeys.PENDING);
  }
  onDestroy() {
    if (this.content && this.content.nativeElement) {
      if (this.dragOverListener) {
        this.dragOverListener();
        this.dragOverListener = null;
      }
    }
    if (this.translationSubscription) {
      this.translationSubscription.unsubscribe();
    }
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275FileUpload_BaseFactory;
    return function FileUpload_Factory(__ngFactoryType__) {
      return (\u0275FileUpload_BaseFactory || (\u0275FileUpload_BaseFactory = \u0275\u0275getInheritedFactory(_FileUpload)))(__ngFactoryType__ || _FileUpload);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _FileUpload,
    selectors: [["p-fileupload"], ["p-fileUpload"]],
    contentQueries: function FileUpload_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c26, 4);
        \u0275\u0275contentQuery(dirIndex, _c35, 4);
        \u0275\u0275contentQuery(dirIndex, _c44, 4);
        \u0275\u0275contentQuery(dirIndex, _c54, 4);
        \u0275\u0275contentQuery(dirIndex, _c63, 4);
        \u0275\u0275contentQuery(dirIndex, _c73, 4);
        \u0275\u0275contentQuery(dirIndex, _c82, 4);
        \u0275\u0275contentQuery(dirIndex, _c92, 4);
        \u0275\u0275contentQuery(dirIndex, _c10, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.fileTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contentTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.toolbarTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.chooseIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.fileLabelTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.uploadIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.cancelIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.emptyTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function FileUpload_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c11, 5);
        \u0275\u0275viewQuery(_c122, 5);
        \u0275\u0275viewQuery(_c44, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.advancedFileInput = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.basicFileInput = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.content = _t.first);
      }
    },
    inputs: {
      name: "name",
      url: "url",
      method: "method",
      multiple: [2, "multiple", "multiple", booleanAttribute],
      accept: "accept",
      disabled: [2, "disabled", "disabled", booleanAttribute],
      auto: [2, "auto", "auto", booleanAttribute],
      withCredentials: [2, "withCredentials", "withCredentials", booleanAttribute],
      maxFileSize: [2, "maxFileSize", "maxFileSize", numberAttribute],
      invalidFileSizeMessageSummary: "invalidFileSizeMessageSummary",
      invalidFileSizeMessageDetail: "invalidFileSizeMessageDetail",
      invalidFileTypeMessageSummary: "invalidFileTypeMessageSummary",
      invalidFileTypeMessageDetail: "invalidFileTypeMessageDetail",
      invalidFileLimitMessageDetail: "invalidFileLimitMessageDetail",
      invalidFileLimitMessageSummary: "invalidFileLimitMessageSummary",
      style: "style",
      styleClass: "styleClass",
      previewWidth: [2, "previewWidth", "previewWidth", numberAttribute],
      chooseLabel: "chooseLabel",
      uploadLabel: "uploadLabel",
      cancelLabel: "cancelLabel",
      chooseIcon: "chooseIcon",
      uploadIcon: "uploadIcon",
      cancelIcon: "cancelIcon",
      showUploadButton: [2, "showUploadButton", "showUploadButton", booleanAttribute],
      showCancelButton: [2, "showCancelButton", "showCancelButton", booleanAttribute],
      mode: "mode",
      headers: "headers",
      customUpload: [2, "customUpload", "customUpload", booleanAttribute],
      fileLimit: [2, "fileLimit", "fileLimit", (value) => numberAttribute(value, void 0)],
      uploadStyleClass: "uploadStyleClass",
      cancelStyleClass: "cancelStyleClass",
      removeStyleClass: "removeStyleClass",
      chooseStyleClass: "chooseStyleClass",
      chooseButtonProps: "chooseButtonProps",
      uploadButtonProps: "uploadButtonProps",
      cancelButtonProps: "cancelButtonProps",
      files: "files"
    },
    outputs: {
      onBeforeUpload: "onBeforeUpload",
      onSend: "onSend",
      onUpload: "onUpload",
      onError: "onError",
      onClear: "onClear",
      onRemove: "onRemove",
      onSelect: "onSelect",
      onProgress: "onProgress",
      uploadHandler: "uploadHandler",
      onImageError: "onImageError",
      onRemoveUploadedFile: "onRemoveUploadedFile"
    },
    features: [\u0275\u0275ProvidersFeature([FileUploadStyle, {
      provide: FILEUPLOAD_INSTANCE,
      useExisting: _FileUpload
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _FileUpload
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 2,
    vars: 2,
    consts: [["advancedfileinput", ""], ["content", ""], ["icon", ""], ["basicfileinput", ""], [3, "class", "ngStyle", "pBind", 4, "ngIf"], [3, "class", "pBind", 4, "ngIf"], [3, "ngStyle", "pBind"], ["type", "file", 3, "change", "multiple", "accept", "disabled", "pBind"], [3, "pBind"], [4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngTemplateOutlet"], [3, "dragenter", "dragleave", "drop", "pBind"], [3, "focus", "blur", "onClick", "keydown.enter", "styleClass", "disabled", "label", "buttonProps", "pt", "unstyled"], [3, "label", "disabled", "styleClass", "buttonProps", "pt", "unstyled", "onClick", 4, "ngIf"], ["data-p-icon", "plus", 3, "pBind", 4, "ngIf"], [3, "pBind", 4, "ngIf"], ["data-p-icon", "plus", 3, "pBind"], [3, "onClick", "label", "disabled", "styleClass", "buttonProps", "pt", "unstyled"], [3, "ngClass", "pBind", 4, "ngIf"], [3, "ngClass", "pBind"], ["data-p-icon", "upload", 3, "pBind", 4, "ngIf"], ["data-p-icon", "upload", 3, "pBind"], [3, "ngClass", 4, "ngIf"], [3, "ngClass"], ["data-p-icon", "times", 4, "ngIf"], ["data-p-icon", "times"], [3, "value", "showValue", "pt", 4, "ngIf"], [3, "severity", "text", "pt", "unstyled"], [3, "class", "pBind"], [3, "value", "showValue", "pt"], ["ngFor", "", 3, "ngForOf", "ngForTemplate"], ["pFileContent", "", 3, "unstyled", "files", "badgeValue", "previewWidth", "fileRemoveIconTemplate"], ["pFileContent", "", 3, "onRemove", "unstyled", "files", "badgeValue", "previewWidth", "fileRemoveIconTemplate"], ["pFileContent", "", "badgeSeverity", "success", 3, "unstyled", "files", "badgeValue", "previewWidth", "fileRemoveIconTemplate"], ["pFileContent", "", "badgeSeverity", "success", 3, "onRemove", "unstyled", "files", "badgeValue", "previewWidth", "fileRemoveIconTemplate"], [3, "pBind", 4, "ngTemplateOutlet"], [3, "onClick", "keydown", "styleClass", "disabled", "label", "buttonProps", "pt", "unstyled"], ["type", "file", 3, "change", "focus", "blur", "accept", "multiple", "disabled", "pBind"], ["class", "p-button-icon p-button-icon-left", 3, "ngClass", "pBind", 4, "ngIf"], [1, "p-button-icon", "p-button-icon-left", 3, "ngClass", "pBind"], ["data-p-icon", "upload", 3, "class", "pBind", 4, "ngIf"], ["class", "p-button-icon p-button-icon-left", 3, "pBind", 4, "ngIf"], [1, "p-button-icon", "p-button-icon-left", 3, "pBind"], ["class", "p-button-icon p-button-icon-left pi", 3, "ngClass", "pBind", 4, "ngIf"], [1, "p-button-icon", "p-button-icon-left", "pi", 3, "ngClass", "pBind"]],
    template: function FileUpload_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275template(0, FileUpload_div_0_Template, 12, 28, "div", 4)(1, FileUpload_div_1_Template, 10, 20, "div", 5);
      }
      if (rf & 2) {
        \u0275\u0275property("ngIf", ctx.mode === "advanced");
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.mode === "basic");
      }
    },
    dependencies: [CommonModule, NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, Button, ProgressBar, Message, PlusIcon, UploadIcon, TimesIcon, SharedModule, FileContent, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileUpload, [{
    type: Component,
    args: [{
      selector: "p-fileupload, p-fileUpload",
      standalone: true,
      imports: [CommonModule, Button, ProgressBar, Message, PlusIcon, UploadIcon, TimesIcon, SharedModule, FileContent, Bind],
      template: `
        <div [class]="cn(cx('root'), styleClass)" [ngStyle]="style" *ngIf="mode === 'advanced'" [pBind]="ptm('root')">
            <input [attr.aria-label]="browseFilesLabel" #advancedfileinput type="file" (change)="onFileSelect($event)" [multiple]="multiple" [accept]="accept" [disabled]="disabled || isChooseDisabled()" [attr.title]="''" [pBind]="ptm('input')" />
            <div [class]="cx('header')" [pBind]="ptm('header')">
                <ng-container *ngIf="!headerTemplate && !_headerTemplate">
                    <p-button
                        [styleClass]="cn(cx('pcChooseButton'), chooseStyleClass)"
                        [disabled]="disabled || isChooseDisabled()"
                        (focus)="onFocus()"
                        [label]="chooseButtonLabel"
                        (blur)="onBlur()"
                        (onClick)="choose()"
                        (keydown.enter)="choose()"
                        [buttonProps]="chooseButtonProps"
                        [pt]="ptm('pcChooseButton')"
                        [unstyled]="unstyled()"
                    >
                        <input
                            [attr.aria-label]="browseFilesLabel"
                            #advancedfileinput
                            type="file"
                            (change)="onFileSelect($event)"
                            [multiple]="multiple"
                            [accept]="accept"
                            [disabled]="disabled || isChooseDisabled()"
                            [attr.title]="''"
                            [pBind]="ptm('input')"
                        />
                        <ng-template #icon>
                            <span *ngIf="chooseIcon" [class]="chooseIcon" [attr.aria-label]="true" [pBind]="ptm('pcChooseButton')?.icon"></span>
                            <ng-container *ngIf="!chooseIcon">
                                <svg data-p-icon="plus" *ngIf="!chooseIconTemplate && !_chooseIconTemplate" [attr.aria-label]="true" [pBind]="ptm('pcChooseButton')?.icon" />
                                <span *ngIf="chooseIconTemplate || _chooseIconTemplate" [attr.aria-label]="true" [pBind]="ptm('pcChooseButton')?.icon">
                                    <ng-template *ngTemplateOutlet="chooseIconTemplate || _chooseIconTemplate"></ng-template>
                                </span>
                            </ng-container>
                        </ng-template>
                    </p-button>

                    <p-button
                        *ngIf="!auto && showUploadButton"
                        [label]="uploadButtonLabel"
                        (onClick)="upload()"
                        [disabled]="!hasFiles() || isFileLimitExceeded()"
                        [styleClass]="cn(cx('pcUploadButton'), uploadStyleClass)"
                        [buttonProps]="uploadButtonProps"
                        [pt]="ptm('pcUploadButton')"
                        [unstyled]="unstyled()"
                    >
                        <ng-template #icon>
                            <span *ngIf="uploadIcon" [ngClass]="uploadIcon" [attr.aria-hidden]="true" [pBind]="ptm('pcUploadButton')?.icon"></span>
                            <ng-container *ngIf="!uploadIcon">
                                <svg data-p-icon="upload" *ngIf="!uploadIconTemplate && !_uploadIconTemplate" [pBind]="ptm('pcUploadButton')?.icon" />
                                <span *ngIf="uploadIconTemplate || _uploadIconTemplate" [attr.aria-hidden]="true" [pBind]="ptm('pcUploadButton')?.icon">
                                    <ng-template *ngTemplateOutlet="uploadIconTemplate || _uploadIconTemplate"></ng-template>
                                </span>
                            </ng-container>
                        </ng-template>
                    </p-button>
                    <p-button
                        *ngIf="!auto && showCancelButton"
                        [label]="cancelButtonLabel"
                        (onClick)="clear()"
                        [disabled]="!hasFiles() || uploading"
                        [styleClass]="cn(cx('pcCancelButton'), cancelStyleClass)"
                        [buttonProps]="cancelButtonProps"
                        [pt]="ptm('pcCancelButton')"
                        [unstyled]="unstyled()"
                    >
                        <ng-template #icon>
                            <span *ngIf="cancelIcon" [ngClass]="cancelIcon"></span>
                            <ng-container *ngIf="!cancelIcon">
                                <svg data-p-icon="times" *ngIf="!cancelIconTemplate && !_cancelIconTemplate" [attr.aria-hidden]="true" />
                                <span *ngIf="cancelIconTemplate || _cancelIconTemplate" [attr.aria-hidden]="true">
                                    <ng-template *ngTemplateOutlet="cancelIconTemplate || _cancelIconTemplate"></ng-template>
                                </span>
                            </ng-container>
                        </ng-template>
                    </p-button>
                </ng-container>
                <ng-container
                    *ngTemplateOutlet="
                        headerTemplate || _headerTemplate;
                        context: {
                            $implicit: files,
                            uploadedFiles: uploadedFiles,
                            chooseCallback: choose.bind(this),
                            clearCallback: clear.bind(this),
                            uploadCallback: upload.bind(this)
                        }
                    "
                ></ng-container>
                <ng-container *ngTemplateOutlet="toolbarTemplate || _toolbarTemplate"></ng-container>
            </div>
            <div #content [class]="cx('content')" (dragenter)="onDragEnter($event)" (dragleave)="onDragLeave($event)" (drop)="onDrop($event)" [pBind]="ptm('content')">
                @if (contentTemplate || _contentTemplate) {
                    <ng-container
                        *ngTemplateOutlet="
                            contentTemplate || _contentTemplate;
                            context: {
                                $implicit: files,
                                uploadedFiles: uploadedFiles,
                                chooseCallback: choose.bind(this),
                                clearCallback: clear.bind(this),
                                removeUploadedFileCallback: removeUploadedFile.bind(this),
                                removeFileCallback: remove.bind(this),
                                progress: progress,
                                messages: msgs
                            }
                        "
                    ></ng-container>
                } @else {
                    <p-progressbar [value]="progress" [showValue]="false" *ngIf="hasFiles()" [pt]="ptm('pcProgressBar')"></p-progressbar>
                    @for (message of msgs; track message) {
                        <p-message [severity]="message.severity" [text]="message.text" [pt]="ptm('pcMessage')" [unstyled]="unstyled()"></p-message>
                    }

                    @if (hasFiles()) {
                        <div [class]="cx('fileList')" [pBind]="ptm('fileList')">
                            <ng-template ngFor [ngForOf]="files" [ngForTemplate]="fileTemplate || _fileTemplate"></ng-template>
                            @if (!fileTemplate && !_fileTemplate) {
                                <div
                                    pFileContent
                                    [unstyled]="unstyled()"
                                    [files]="files"
                                    (onRemove)="onRemoveClick($event)"
                                    [badgeValue]="pendingLabel"
                                    [previewWidth]="previewWidth"
                                    [fileRemoveIconTemplate]="cancelIconTemplate || _cancelIconTemplate"
                                ></div>
                            }
                        </div>
                    }
                    @if (hasUploadedFiles()) {
                        <div [class]="cx('fileList')" [pBind]="ptm('fileList')">
                            <ng-template ngFor [ngForOf]="uploadedFiles" [ngForTemplate]="fileTemplate || _fileTemplate"></ng-template>
                            @if (!fileTemplate && !_fileTemplate) {
                                <div
                                    pFileContent
                                    [unstyled]="unstyled()"
                                    [files]="uploadedFiles"
                                    (onRemove)="onRemoveUploadedFileClick($event)"
                                    [badgeValue]="completedLabel()"
                                    badgeSeverity="success"
                                    [previewWidth]="previewWidth"
                                    [fileRemoveIconTemplate]="cancelIconTemplate || _cancelIconTemplate"
                                ></div>
                            }
                        </div>
                    }
                }
                @if ((emptyTemplate || _emptyTemplate) && !hasFiles() && !hasUploadedFiles()) {
                    <ng-container *ngTemplateOutlet="emptyTemplate || _emptyTemplate" [pBind]="ptm('empty')"></ng-container>
                }
            </div>
        </div>
        <div [class]="cn(cx('root'), styleClass)" *ngIf="mode === 'basic'" [pBind]="ptm('root')">
            @for (message of msgs; track message) {
                <p-message [severity]="message.severity" [text]="message.text" [pt]="ptm('pcMessage')" [unstyled]="unstyled()"></p-message>
            }

            <div [class]="cx('basicContent')" [pBind]="ptm('basicContent')">
                <p-button
                    [styleClass]="cn(cx('pcChooseButton'), chooseStyleClass)"
                    [disabled]="disabled"
                    [label]="chooseButtonLabel"
                    [style]="style"
                    (onClick)="onBasicUploaderClick()"
                    (keydown)="onBasicKeydown($event)"
                    [buttonProps]="chooseButtonProps"
                    [pt]="ptm('pcChooseButton')"
                    [unstyled]="unstyled()"
                >
                    <ng-template #icon>
                        @if (hasFiles() && !auto) {
                            <span *ngIf="uploadIcon" class="p-button-icon p-button-icon-left" [ngClass]="uploadIcon" [pBind]="ptm('pcChooseButton')?.icon"></span>
                            <ng-container *ngIf="!uploadIcon">
                                <svg data-p-icon="upload" *ngIf="!uploadIconTemplate && !_uploadIconTemplate" [class]="'p-button-icon p-button-icon-left'" [pBind]="ptm('pcChooseButton')?.icon" />
                                <span *ngIf="_uploadIconTemplate || uploadIconTemplate" class="p-button-icon p-button-icon-left" [pBind]="ptm('pcChooseButton')?.icon">
                                    <ng-template *ngTemplateOutlet="_uploadIconTemplate || uploadIconTemplate"></ng-template>
                                </span>
                            </ng-container>
                        } @else {
                            <span *ngIf="chooseIcon" class="p-button-icon p-button-icon-left pi" [ngClass]="chooseIcon" [pBind]="ptm('pcChooseButton')?.icon"></span>
                            <ng-container *ngIf="!chooseIcon">
                                <svg data-p-icon="plus" *ngIf="!chooseIconTemplate && !_chooseIconTemplate" [pBind]="ptm('pcChooseButton')?.icon" />
                                <ng-template *ngTemplateOutlet="chooseIconTemplate || _chooseIconTemplate"></ng-template>
                            </ng-container>
                        }
                    </ng-template>
                    <input [attr.aria-label]="browseFilesLabel" #basicfileinput type="file" [accept]="accept" [multiple]="multiple" [disabled]="disabled" (change)="onFileSelect($event)" (focus)="onFocus()" (blur)="onBlur()" [pBind]="ptm('input')" />
                </p-button>
                @if (!auto) {
                    @if (!fileLabelTemplate && !_fileLabelTemplate) {
                        <span>
                            {{ basicFileChosenLabel() }}
                        </span>
                    } @else {
                        <ng-container *ngTemplateOutlet="fileLabelTemplate || _fileLabelTemplate; context: { $implicit: files }"></ng-container>
                    }
                }
            </div>
        </div>
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [FileUploadStyle, {
        provide: FILEUPLOAD_INSTANCE,
        useExisting: FileUpload
      }, {
        provide: PARENT_INSTANCE,
        useExisting: FileUpload
      }],
      hostDirectives: [Bind]
    }]
  }], null, {
    name: [{
      type: Input
    }],
    url: [{
      type: Input
    }],
    method: [{
      type: Input
    }],
    multiple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    accept: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    auto: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    withCredentials: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    maxFileSize: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    invalidFileSizeMessageSummary: [{
      type: Input
    }],
    invalidFileSizeMessageDetail: [{
      type: Input
    }],
    invalidFileTypeMessageSummary: [{
      type: Input
    }],
    invalidFileTypeMessageDetail: [{
      type: Input
    }],
    invalidFileLimitMessageDetail: [{
      type: Input
    }],
    invalidFileLimitMessageSummary: [{
      type: Input
    }],
    style: [{
      type: Input
    }],
    styleClass: [{
      type: Input
    }],
    previewWidth: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    chooseLabel: [{
      type: Input
    }],
    uploadLabel: [{
      type: Input
    }],
    cancelLabel: [{
      type: Input
    }],
    chooseIcon: [{
      type: Input
    }],
    uploadIcon: [{
      type: Input
    }],
    cancelIcon: [{
      type: Input
    }],
    showUploadButton: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showCancelButton: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    mode: [{
      type: Input
    }],
    headers: [{
      type: Input
    }],
    customUpload: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    fileLimit: [{
      type: Input,
      args: [{
        transform: (value) => numberAttribute(value, void 0)
      }]
    }],
    uploadStyleClass: [{
      type: Input
    }],
    cancelStyleClass: [{
      type: Input
    }],
    removeStyleClass: [{
      type: Input
    }],
    chooseStyleClass: [{
      type: Input
    }],
    chooseButtonProps: [{
      type: Input
    }],
    uploadButtonProps: [{
      type: Input
    }],
    cancelButtonProps: [{
      type: Input
    }],
    onBeforeUpload: [{
      type: Output
    }],
    onSend: [{
      type: Output
    }],
    onUpload: [{
      type: Output
    }],
    onError: [{
      type: Output
    }],
    onClear: [{
      type: Output
    }],
    onRemove: [{
      type: Output
    }],
    onSelect: [{
      type: Output
    }],
    onProgress: [{
      type: Output
    }],
    uploadHandler: [{
      type: Output
    }],
    onImageError: [{
      type: Output
    }],
    onRemoveUploadedFile: [{
      type: Output
    }],
    fileTemplate: [{
      type: ContentChild,
      args: ["file", {
        descendants: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: ["header", {
        descendants: false
      }]
    }],
    contentTemplate: [{
      type: ContentChild,
      args: ["content", {
        descendants: false
      }]
    }],
    toolbarTemplate: [{
      type: ContentChild,
      args: ["toolbar", {
        descendants: false
      }]
    }],
    chooseIconTemplate: [{
      type: ContentChild,
      args: ["chooseicon", {
        descendants: false
      }]
    }],
    fileLabelTemplate: [{
      type: ContentChild,
      args: ["filelabel", {
        descendants: false
      }]
    }],
    uploadIconTemplate: [{
      type: ContentChild,
      args: ["uploadicon", {
        descendants: false
      }]
    }],
    cancelIconTemplate: [{
      type: ContentChild,
      args: ["cancelicon", {
        descendants: false
      }]
    }],
    emptyTemplate: [{
      type: ContentChild,
      args: ["empty", {
        descendants: false
      }]
    }],
    advancedFileInput: [{
      type: ViewChild,
      args: ["advancedfileinput"]
    }],
    basicFileInput: [{
      type: ViewChild,
      args: ["basicfileinput"]
    }],
    content: [{
      type: ViewChild,
      args: ["content"]
    }],
    files: [{
      type: Input
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }]
  });
})();
var FileUploadModule = class _FileUploadModule {
  static \u0275fac = function FileUploadModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FileUploadModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _FileUploadModule,
    imports: [FileUpload, SharedModule],
    exports: [FileUpload, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [FileUpload, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FileUploadModule, [{
    type: NgModule,
    args: [{
      imports: [FileUpload, SharedModule],
      exports: [FileUpload, SharedModule]
    }]
  }], null, null);
})();

// node_modules/primeng/fesm2022/primeng-inputmask.mjs
var _c013 = ["clearicon"];
var _c17 = ["input"];
function InputMask_ng_container_2__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg", 5);
    \u0275\u0275listener("click", function InputMask_ng_container_2__svg_svg_1_Template_svg_click_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.clear());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r2.cx("clearIcon"));
    \u0275\u0275property("pBind", ctx_r2.ptm("clearIcon"));
  }
}
function InputMask_ng_container_2_span_2_1_ng_template_0_Template(rf, ctx) {
}
function InputMask_ng_container_2_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, InputMask_ng_container_2_span_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function InputMask_ng_container_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 6);
    \u0275\u0275listener("click", function InputMask_ng_container_2_span_2_Template_span_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.clear());
    });
    \u0275\u0275template(1, InputMask_ng_container_2_span_2_1_Template, 1, 0, null, 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r2.cx("clearIcon"));
    \u0275\u0275property("pBind", ctx_r2.ptm("clearIcon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.clearIconTemplate || ctx_r2._clearIconTemplate);
  }
}
function InputMask_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, InputMask_ng_container_2__svg_svg_1_Template, 1, 3, "svg", 3)(2, InputMask_ng_container_2_span_2_Template, 2, 4, "span", 4);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r2.clearIconTemplate && !ctx_r2._clearIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r2.clearIconTemplate || ctx_r2._clearIconTemplate);
  }
}
var style10 = (
  /*css*/
  `
    /* For PrimeNG */
    p-inputmask {
        position: relative;
    }

    .p-inputmask-clear-icon {
        position: absolute;
        top: 50%;
        margin-top: -0.5rem;
        cursor: pointer;
        inset-inline-end: dt('form.field.padding.x');
        color: dt('form.field.icon.color');
    }

    p-inputMask:has(.p-inputtext-fluid),
    p-input-mask:has(.p-inputtext-fluid),
    p-inputmask:has(.p-inputtext-fluid) {
        width: 100%;
    }

    p-inputMask.ng-invalid.ng-dirty > .p-inputtext,
    p-input-mask.ng-invalid.ng-dirty > .p-inputtext,
    p-inputmask.ng-invalid.ng-dirty > .p-inputtext {
        border-color: dt('inputtext.invalid.border.color');
    }

    p-inputMask.ng-invalid.ng-dirty > .p-inputtext:enabled:focus,
    p-input-mask.ng-invalid.ng-dirty > .p-inputtext:enabled:focus,
    p-inputmask.ng-invalid.ng-dirty > .p-inputtext:enabled:focus {
        border-color: dt('inputtext.focus.border.color');
    }

    p-inputMask.ng-invalid.ng-dirty > .p-inputtext::placeholder,
    p-input-mask.ng-invalid.ng-dirty > .p-inputtext::placeholder,
    p-inputmask.ng-invalid.ng-dirty > .p-inputtext::placeholder {
        color: dt('inputtext.invalid.placeholder.color');
    }
`
);
var classes8 = {
  root: ({
    instance
  }) => ["p-inputmask p-component p-inputwrapper", {
    "p-variant-filled": instance.$variant() === "filled"
  }],
  clearIcon: "p-inputmask-clear-icon"
};
var InputMaskStyle = class _InputMaskStyle extends BaseStyle {
  name = "inputmask";
  style = style10;
  classes = classes8;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275InputMaskStyle_BaseFactory;
    return function InputMaskStyle_Factory(__ngFactoryType__) {
      return (\u0275InputMaskStyle_BaseFactory || (\u0275InputMaskStyle_BaseFactory = \u0275\u0275getInheritedFactory(_InputMaskStyle)))(__ngFactoryType__ || _InputMaskStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _InputMaskStyle,
    factory: _InputMaskStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputMaskStyle, [{
    type: Injectable
  }], null, null);
})();
var InputMaskClasses;
(function(InputMaskClasses2) {
  InputMaskClasses2["root"] = "p-inputmask";
  InputMaskClasses2["clearIcon"] = "p-inputmask-clear-icon";
})(InputMaskClasses || (InputMaskClasses = {}));
var INPUTMASK_INSTANCE = new InjectionToken("INPUTMASK_INSTANCE");
var INPUTMASK_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => InputMask),
  multi: true
};
var InputMask = class _InputMask extends BaseInput {
  _componentStyle = inject(InputMaskStyle);
  $pcInputMask = inject(INPUTMASK_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["root", "host"]));
  }
  ptmParams = computed(() => ({
    context: {
      filled: this.$variant() === "filled"
    }
  }), ...ngDevMode ? [{
    debugName: "ptmParams"
  }] : []);
  /**
   * HTML5 input type.
   * @group Props
   */
  type = "text";
  /**
   * Placeholder character in mask, default is underscore.
   * @group Props
   */
  slotChar = "_";
  /**
   * Clears the incomplete value on blur.
   * @group Props
   */
  autoClear = true;
  /**
   * When enabled, a clear icon is displayed to clear the value.
   * @group Props
   */
  showClear = false;
  /**
   * Inline style of the input field.
   * @group Props
   */
  style;
  /**
   * Identifier of the focus input to match a label defined for the component.
   * @group Props
   */
  inputId;
  /**
   * Style class of the input field.
   * @group Props
   */
  styleClass;
  /**
   * Advisory information to display on input.
   * @group Props
   */
  placeholder;
  /**
   * Specifies tab order of the element.
   * @group Props
   */
  tabindex;
  /**
   * Title text of the input text.
   * @group Props
   */
  title;
  /**
   * Used to define a string that labels the input element.
   * @group Props
   */
  ariaLabel;
  /**
   * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
   * @group Props
   */
  ariaLabelledBy;
  /**
   * Used to indicate that user input is required on an element before a form can be submitted.
   * @group Props
   */
  ariaRequired;
  /**
   * When present, it specifies that an input field is read-only.
   * @group Props
   */
  readonly;
  /**
   * Defines if ngModel sets the raw unmasked value to bound value or the formatted mask value.
   * @group Props
   */
  unmask;
  /**
   * Regex pattern for alpha characters
   * @group Props
   */
  characterPattern = "[A-Za-z]";
  /**
   * When present, the input gets a focus automatically on load.
   * @group Props
   */
  autofocus;
  /**
   * Used to define a string that autocomplete attribute the current element.
   * @group Props
   */
  autocomplete;
  /**
   * When present, it specifies that whether to clean buffer value from model.
   * @group Props
   */
  keepBuffer = false;
  /**
   * Mask pattern.
   * @group Props
   */
  get mask() {
    return this._mask;
  }
  set mask(val) {
    this._mask = val;
    this.initMask();
    this.writeValue("");
    this.onModelChange(this.value);
  }
  /**
   * Callback to invoke when the mask is completed.
   * @group Emits
   */
  onComplete = new EventEmitter();
  /**
   * Callback to invoke when the component receives focus.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onFocus = new EventEmitter();
  /**
   * Callback to invoke when the component loses focus.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onBlur = new EventEmitter();
  /**
   * Callback to invoke on input.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onInput = new EventEmitter();
  /**
   * Callback to invoke on input key press.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onKeydown = new EventEmitter();
  /**
   * Callback to invoke when input field is cleared.
   * @group Emits
   */
  onClear = new EventEmitter();
  /**
   * Custom clear icon template.
   * @group Templates
   */
  clearIconTemplate;
  templates;
  inputViewChild;
  value;
  _mask;
  input;
  defs;
  tests;
  partialPosition;
  firstNonMaskPos;
  lastRequiredNonMaskPos;
  len;
  oldVal;
  buffer;
  defaultBuffer;
  focusText;
  caretTimeoutId;
  androidChrome = true;
  focused;
  onInit() {
    if (isPlatformBrowser(this.platformId)) {
      let ua = navigator.userAgent;
      this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);
    }
    this.initMask();
  }
  _clearIconTemplate;
  onAfterContentInit() {
    this.templates.forEach((item) => {
      switch (item.getType()) {
        case "clearicon":
          this._clearIconTemplate = item.template;
          break;
      }
    });
  }
  initMask() {
    if (!this.mask) {
      return;
    }
    this.tests = [];
    this.partialPosition = this.mask.length;
    this.len = this.mask.length;
    this.firstNonMaskPos = null;
    this.defs = {
      "9": "[0-9]",
      a: this.characterPattern,
      "*": `${this.characterPattern}|[0-9]`
    };
    let maskTokens = this.mask.split("");
    for (let i = 0; i < maskTokens.length; i++) {
      let c2 = maskTokens[i];
      if (c2 == "?") {
        this.len--;
        this.partialPosition = i;
      } else if (this.defs[c2]) {
        this.tests.push(new RegExp(this.defs[c2]));
        if (this.firstNonMaskPos === null) {
          this.firstNonMaskPos = this.tests.length - 1;
        }
        if (i < this.partialPosition) {
          this.lastRequiredNonMaskPos = this.tests.length - 1;
        }
      } else {
        this.tests.push(null);
      }
    }
    this.buffer = [];
    for (let i = 0; i < maskTokens.length; i++) {
      let c2 = maskTokens[i];
      if (c2 != "?") {
        if (this.defs[c2]) this.buffer.push(this.getPlaceholder(i));
        else this.buffer.push(c2);
      }
    }
    this.defaultBuffer = this.buffer.join("");
  }
  caret(first, last) {
    let range, begin, end;
    if (!this.inputViewChild?.nativeElement.offsetParent || this.inputViewChild.nativeElement !== this.inputViewChild.nativeElement.ownerDocument.activeElement) {
      return;
    }
    if (typeof first == "number") {
      begin = first;
      end = typeof last === "number" ? last : begin;
      if (this.inputViewChild.nativeElement.setSelectionRange) {
        this.inputViewChild.nativeElement.setSelectionRange(begin, end);
      } else if (this.inputViewChild.nativeElement["createTextRange"]) {
        range = this.inputViewChild.nativeElement["createTextRange"]();
        range.collapse(true);
        range.moveEnd("character", end);
        range.moveStart("character", begin);
        range.select();
      }
    } else {
      if (this.inputViewChild.nativeElement.setSelectionRange) {
        begin = this.inputViewChild.nativeElement.selectionStart;
        end = this.inputViewChild.nativeElement.selectionEnd;
      } else if (this.document && this.document["selection"].createRange) {
        range = this.document.createRange();
        begin = 0 - range.duplicate().moveStart("character", -1e5);
        end = begin + range.text.length;
      }
      return {
        begin,
        end
      };
    }
  }
  isCompleted() {
    let completed;
    for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {
      if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {
        return false;
      }
    }
    return true;
  }
  getPlaceholder(i) {
    if (i < this.slotChar.length) {
      return this.slotChar.charAt(i);
    }
    return this.slotChar.charAt(0);
  }
  seekNext(pos) {
    while (++pos < this.len && !this.tests[pos]) ;
    return pos;
  }
  seekPrev(pos) {
    while (--pos >= 0 && !this.tests[pos]) ;
    return pos;
  }
  shiftL(begin, end) {
    let i, j;
    if (begin < 0) {
      return;
    }
    for (i = begin, j = this.seekNext(end); i < this.len; i++) {
      if (this.tests[i]) {
        if (j < this.len && this.tests[i].test(this.buffer[j])) {
          this.buffer[i] = this.buffer[j];
          this.buffer[j] = this.getPlaceholder(j);
        } else {
          break;
        }
        j = this.seekNext(j);
      }
    }
    this.writeBuffer();
    this.caret(Math.max(this.firstNonMaskPos, begin));
  }
  shiftR(pos) {
    let i, c2, j, t;
    for (i = pos, c2 = this.getPlaceholder(pos); i < this.len; i++) {
      if (this.tests[i]) {
        j = this.seekNext(i);
        t = this.buffer[i];
        this.buffer[i] = c2;
        if (j < this.len && this.tests[j].test(t)) {
          c2 = t;
        } else {
          break;
        }
      }
    }
  }
  handleAndroidInput(e) {
    var curVal = this.inputViewChild?.nativeElement.value;
    var pos = this.caret();
    if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {
      this.checkVal(true);
      while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;
      if (pos.begin === 0) {
        while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;
      }
      setTimeout(() => {
        this.caret(pos.begin, pos.begin);
        this.updateModel(e);
        if (this.isCompleted()) {
          this.onComplete.emit();
        }
      }, 0);
    } else {
      this.checkVal(true);
      while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;
      setTimeout(() => {
        this.caret(pos.begin, pos.begin);
        this.updateModel(e);
        if (this.isCompleted()) {
          this.onComplete.emit();
        }
      }, 0);
    }
  }
  onInputBlur(e) {
    this.focused = false;
    this.onModelTouched();
    if (!this.keepBuffer) {
      this.checkVal();
    }
    this.onBlur.emit(e);
    if (this.modelValue() != this.focusText || this.modelValue() != this.value) {
      this.updateModel(e);
      let event = this.document.createEvent("HTMLEvents");
      event.initEvent("change", true, false);
      this.inputViewChild?.nativeElement.dispatchEvent(event);
    }
  }
  onInputKeydown(e) {
    if (this.readonly) {
      return;
    }
    let k3 = e.which || e.keyCode, pos, begin, end;
    let iPhone;
    if (isPlatformBrowser(this.platformId)) {
      iPhone = /iphone/i.test(Nt());
    }
    this.oldVal = this.inputViewChild?.nativeElement.value;
    this.onKeydown.emit(e);
    if (k3 === 8 || k3 === 46 || iPhone && k3 === 127) {
      pos = this.caret();
      begin = pos.begin;
      end = pos.end;
      if (end - begin === 0) {
        begin = k3 !== 46 ? this.seekPrev(begin) : end = this.seekNext(begin - 1);
        end = k3 === 46 ? this.seekNext(end) : end;
      }
      this.clearBuffer(begin, end);
      if (this.keepBuffer) {
        this.shiftL(begin, end - 2);
      } else {
        this.shiftL(begin, end - 1);
      }
      this.updateModel(e);
      this.onInput.emit(e);
      e.preventDefault();
    } else if (k3 === 13) {
      this.onInputBlur(e);
      this.updateModel(e);
    } else if (k3 === 27) {
      this.inputViewChild.nativeElement.value = this.focusText;
      this.caret(0, this.checkVal());
      this.updateModel(e);
      e.preventDefault();
    }
  }
  onKeyPress(e) {
    if (this.readonly) {
      return;
    }
    var k3 = e.which || e.keyCode, pos = this.caret(), p2, c2, next, completed;
    if (e.ctrlKey || e.altKey || e.metaKey || k3 < 32 || k3 > 34 && k3 < 41) {
      return;
    } else if (k3 && k3 !== 13) {
      if (pos.end - pos.begin !== 0) {
        this.clearBuffer(pos.begin, pos.end);
        this.shiftL(pos.begin, pos.end - 1);
      }
      p2 = this.seekNext(pos.begin - 1);
      if (p2 < this.len) {
        c2 = String.fromCharCode(k3);
        if (this.tests[p2].test(c2)) {
          this.shiftR(p2);
          this.buffer[p2] = c2;
          this.writeBuffer();
          next = this.seekNext(p2);
          if (tt() && /android/i.test(Nt())) {
            let proxy = () => {
              this.caret(next);
            };
            setTimeout(proxy, 0);
          } else {
            this.caret(next);
          }
          if (pos.begin <= this.lastRequiredNonMaskPos) {
            completed = this.isCompleted();
          }
          this.onInput.emit(e);
        }
      }
      e.preventDefault();
    }
    this.updateModel(e);
    if (completed) {
      this.onComplete.emit();
    }
  }
  clearBuffer(start, end) {
    if (!this.keepBuffer) {
      let i;
      for (i = start; i < end && i < this.len; i++) {
        if (this.tests[i]) {
          this.buffer[i] = this.getPlaceholder(i);
        }
      }
    }
  }
  writeBuffer() {
    if (this.buffer && this.inputViewChild?.nativeElement) {
      this.inputViewChild.nativeElement.value = this.buffer.join("");
    }
  }
  checkVal(allow) {
    let test = this.inputViewChild?.nativeElement.value, lastMatch = -1, i, c2, pos;
    for (i = 0, pos = 0; i < this.len; i++) {
      if (this.tests[i]) {
        this.buffer[i] = this.getPlaceholder(i);
        while (pos++ < test.length) {
          c2 = test.charAt(pos - 1);
          if (this.tests[i].test(c2)) {
            if (!this.keepBuffer) {
              this.buffer[i] = c2;
            }
            lastMatch = i;
            break;
          }
        }
        if (pos > test.length) {
          this.clearBuffer(i + 1, this.len);
          break;
        }
      } else {
        if (this.buffer[i] === test.charAt(pos)) {
          pos++;
        }
        if (i < this.partialPosition) {
          lastMatch = i;
        }
      }
    }
    if (allow) {
      this.writeBuffer();
    } else if (lastMatch + 1 < this.partialPosition) {
      if (this.autoClear || this.buffer.join("") === this.defaultBuffer) {
        if (this.inputViewChild?.nativeElement.value) this.inputViewChild.nativeElement.value = "";
        this.clearBuffer(0, this.len);
      } else {
        this.writeBuffer();
      }
    } else {
      this.writeBuffer();
      this.inputViewChild.nativeElement.value = this.inputViewChild?.nativeElement.value.substring(0, lastMatch + 1);
    }
    return this.partialPosition ? i : this.firstNonMaskPos;
  }
  onInputFocus(event) {
    if (this.readonly) {
      return;
    }
    this.focused = true;
    clearTimeout(this.caretTimeoutId);
    let pos;
    this.focusText = this.inputViewChild?.nativeElement.value;
    pos = this.keepBuffer ? this.inputViewChild?.nativeElement.value.length : this.checkVal();
    this.caretTimeoutId = setTimeout(() => {
      if (this.inputViewChild?.nativeElement !== this.inputViewChild?.nativeElement.ownerDocument.activeElement) {
        return;
      }
      this.writeBuffer();
      if (pos == this.mask?.replace("?", "").length) {
        this.caret(0, pos);
      } else {
        this.caret(pos);
      }
    }, 10);
    this.onFocus.emit(event);
  }
  onInputChange(event) {
    if (this.androidChrome) this.handleAndroidInput(event);
    else this.handleInputChange(event);
    this.onInput.emit(event);
  }
  handleInputChange(event) {
    if (this.readonly) {
      return;
    }
    setTimeout(() => {
      var pos = this.checkVal(true);
      this.caret(pos);
      this.updateModel(event);
      if (this.isCompleted()) {
        this.onComplete.emit();
      }
    }, 0);
  }
  getUnmaskedValue() {
    let unmaskedBuffer = [];
    for (let i = 0; i < this.buffer.length; i++) {
      let c2 = this.buffer[i];
      if (this.tests[i] && c2 != this.getPlaceholder(i)) {
        unmaskedBuffer.push(c2);
      }
    }
    return unmaskedBuffer.join("");
  }
  updateModel(e) {
    const target = e.target;
    if (!target) {
      return;
    }
    const updatedValue = this.unmask ? this.getUnmaskedValue() : target.value;
    if (updatedValue !== null && updatedValue !== void 0) {
      this.value = updatedValue;
      this.writeModelValue(this.value);
      this.onModelChange(this.value);
    }
  }
  focus() {
    this.inputViewChild?.nativeElement.focus();
  }
  clear() {
    this.inputViewChild.nativeElement.value = "";
    this.value = null;
    this.onModelChange(this.value);
    this.onClear.emit();
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value, setModelValue) {
    this.value = value;
    setModelValue(this.value);
    if (this.inputViewChild && this.inputViewChild.nativeElement) {
      if (this.value == void 0 || this.value == null) this.inputViewChild.nativeElement.value = "";
      else this.inputViewChild.nativeElement.value = this.value;
      this.checkVal();
      this.focusText = this.inputViewChild.nativeElement.value;
    }
    this.cd.markForCheck();
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275InputMask_BaseFactory;
    return function InputMask_Factory(__ngFactoryType__) {
      return (\u0275InputMask_BaseFactory || (\u0275InputMask_BaseFactory = \u0275\u0275getInheritedFactory(_InputMask)))(__ngFactoryType__ || _InputMask);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _InputMask,
    selectors: [["p-inputmask"], ["p-inputMask"], ["p-input-mask"]],
    contentQueries: function InputMask_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c013, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.clearIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function InputMask_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c17, 7);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.inputViewChild = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function InputMask_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cx("root"));
      }
    },
    inputs: {
      type: "type",
      slotChar: "slotChar",
      autoClear: [2, "autoClear", "autoClear", booleanAttribute],
      showClear: [2, "showClear", "showClear", booleanAttribute],
      style: "style",
      inputId: "inputId",
      styleClass: "styleClass",
      placeholder: "placeholder",
      tabindex: "tabindex",
      title: "title",
      ariaLabel: "ariaLabel",
      ariaLabelledBy: "ariaLabelledBy",
      ariaRequired: [2, "ariaRequired", "ariaRequired", booleanAttribute],
      readonly: [2, "readonly", "readonly", booleanAttribute],
      unmask: [2, "unmask", "unmask", booleanAttribute],
      characterPattern: "characterPattern",
      autofocus: [2, "autofocus", "autofocus", booleanAttribute],
      autocomplete: "autocomplete",
      keepBuffer: [2, "keepBuffer", "keepBuffer", booleanAttribute],
      mask: "mask"
    },
    outputs: {
      onComplete: "onComplete",
      onFocus: "onFocus",
      onBlur: "onBlur",
      onInput: "onInput",
      onKeydown: "onKeydown",
      onClear: "onClear"
    },
    features: [\u0275\u0275ProvidersFeature([INPUTMASK_VALUE_ACCESSOR, InputMaskStyle, {
      provide: INPUTMASK_INSTANCE,
      useExisting: _InputMask
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _InputMask
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 3,
    vars: 27,
    consts: [["input", ""], ["pInputText", "", 3, "focus", "blur", "keydown", "keypress", "input", "paste", "pt", "unstyled", "invalid", "ngStyle", "pSize", "variant", "pAutoFocus", "fluid"], [4, "ngIf"], ["data-p-icon", "times", 3, "class", "pBind", "click", 4, "ngIf"], [3, "class", "pBind", "click", 4, "ngIf"], ["data-p-icon", "times", 3, "click", "pBind"], [3, "click", "pBind"], [4, "ngTemplateOutlet"]],
    template: function InputMask_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "input", 1, 0);
        \u0275\u0275listener("focus", function InputMask_Template_input_focus_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onInputFocus($event));
        })("blur", function InputMask_Template_input_blur_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onInputBlur($event));
        })("keydown", function InputMask_Template_input_keydown_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onInputKeydown($event));
        })("keypress", function InputMask_Template_input_keypress_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onKeyPress($event));
        })("input", function InputMask_Template_input_input_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onInputChange($event));
        })("paste", function InputMask_Template_input_paste_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.handleInputChange($event));
        });
        \u0275\u0275elementEnd();
        \u0275\u0275template(2, InputMask_ng_container_2_Template, 3, 2, "ng-container", 2);
      }
      if (rf & 2) {
        \u0275\u0275classMap(ctx.styleClass);
        \u0275\u0275property("pt", ctx.ptm("pcInputText", ctx.ptmParams()))("unstyled", ctx.unstyled())("invalid", ctx.invalid())("ngStyle", ctx.style)("pSize", ctx.size())("variant", ctx.$variant())("pAutoFocus", ctx.autofocus)("fluid", ctx.hasFluid);
        \u0275\u0275attribute("id", ctx.inputId)("type", ctx.type)("name", ctx.name())("placeholder", ctx.placeholder)("title", ctx.title)("size", ctx.inputSize())("autocomplete", ctx.autocomplete)("maxlength", ctx.maxlength())("minlength", ctx.minlength())("tabindex", ctx.tabindex)("aria-label", ctx.ariaLabel)("aria-labelledBy", ctx.ariaLabelledBy)("aria-required", ctx.ariaRequired)("required", ctx.required() ? "" : void 0)("readonly", ctx.readonly ? "" : void 0)("disabled", ctx.$disabled() ? "" : void 0);
        \u0275\u0275advance(2);
        \u0275\u0275property("ngIf", ctx.value != null && ctx.$filled() && ctx.showClear && !ctx.$disabled());
      }
    },
    dependencies: [CommonModule, NgIf, NgTemplateOutlet, NgStyle, InputText, AutoFocus, TimesIcon, SharedModule, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputMask, [{
    type: Component,
    args: [{
      selector: "p-inputmask, p-inputMask, p-input-mask",
      standalone: true,
      imports: [CommonModule, InputText, AutoFocus, TimesIcon, SharedModule, BindModule],
      template: `
        <input
            #input
            pInputText
            [pt]="ptm('pcInputText', ptmParams())"
            [unstyled]="unstyled()"
            [attr.id]="inputId"
            [attr.type]="type"
            [attr.name]="name()"
            [invalid]="invalid()"
            [class]="styleClass"
            [ngStyle]="style"
            [attr.placeholder]="placeholder"
            [attr.title]="title"
            [pSize]="size()"
            [attr.size]="inputSize()"
            [attr.autocomplete]="autocomplete"
            [attr.maxlength]="maxlength()"
            [attr.minlength]="minlength()"
            [attr.tabindex]="tabindex"
            [attr.aria-label]="ariaLabel"
            [attr.aria-labelledBy]="ariaLabelledBy"
            [attr.aria-required]="ariaRequired"
            [attr.required]="required() ? '' : undefined"
            [attr.readonly]="readonly ? '' : undefined"
            [attr.disabled]="$disabled() ? '' : undefined"
            (focus)="onInputFocus($event)"
            (blur)="onInputBlur($event)"
            (keydown)="onInputKeydown($event)"
            (keypress)="onKeyPress($event)"
            [variant]="$variant()"
            [pAutoFocus]="autofocus"
            (input)="onInputChange($event)"
            (paste)="handleInputChange($event)"
            [fluid]="hasFluid"
        />
        <ng-container *ngIf="value != null && $filled() && showClear && !$disabled()">
            <svg data-p-icon="times" *ngIf="!clearIconTemplate && !_clearIconTemplate" [class]="cx('clearIcon')" [pBind]="ptm('clearIcon')" (click)="clear()" />
            <span *ngIf="clearIconTemplate || _clearIconTemplate" [class]="cx('clearIcon')" [pBind]="ptm('clearIcon')" (click)="clear()">
                <ng-template *ngTemplateOutlet="clearIconTemplate || _clearIconTemplate"></ng-template>
            </span>
        </ng-container>
    `,
      providers: [INPUTMASK_VALUE_ACCESSOR, InputMaskStyle, {
        provide: INPUTMASK_INSTANCE,
        useExisting: InputMask
      }, {
        provide: PARENT_INSTANCE,
        useExisting: InputMask
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      hostDirectives: [Bind],
      host: {
        "[class]": "cx('root')"
      }
    }]
  }], null, {
    type: [{
      type: Input
    }],
    slotChar: [{
      type: Input
    }],
    autoClear: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showClear: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    style: [{
      type: Input
    }],
    inputId: [{
      type: Input
    }],
    styleClass: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    ariaRequired: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    readonly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    unmask: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    characterPattern: [{
      type: Input
    }],
    autofocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    autocomplete: [{
      type: Input
    }],
    keepBuffer: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    mask: [{
      type: Input
    }],
    onComplete: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    onBlur: [{
      type: Output
    }],
    onInput: [{
      type: Output
    }],
    onKeydown: [{
      type: Output
    }],
    onClear: [{
      type: Output
    }],
    clearIconTemplate: [{
      type: ContentChild,
      args: ["clearicon", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }],
    inputViewChild: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }]
  });
})();
var InputMaskModule = class _InputMaskModule {
  static \u0275fac = function InputMaskModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InputMaskModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _InputMaskModule,
    imports: [InputMask, SharedModule],
    exports: [InputMask, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [InputMask, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputMaskModule, [{
    type: NgModule,
    args: [{
      imports: [InputMask, SharedModule],
      exports: [InputMask, SharedModule]
    }]
  }], null, null);
})();

// node_modules/primeng/fesm2022/primeng-keyfilter.mjs
var KEYFILTER_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => KeyFilter),
  multi: true
};
var DEFAULT_MASKS = {
  pint: /^[\d]*$/,
  int: /^[-]?[\d]*$/,
  pnum: /^[\d\.]*$/,
  money: /^[\d\.\s,]*$/,
  num: /^[-]?[\d\.]*$/,
  hex: /^[0-9a-f]*$/i,
  email: /^[a-z0-9_\.\-@]*$/i,
  alpha: /^[a-z_]*$/i,
  alphanum: /^[a-z0-9_]*$/i
};
var KEYS = {
  TAB: 9,
  RETURN: 13,
  ESC: 27,
  BACKSPACE: 8,
  DELETE: 46
};
var SAFARI_KEYS = {
  63234: 37,
  // left
  63235: 39,
  // right
  63232: 38,
  // up
  63233: 40,
  // down
  63276: 33,
  // page up
  63277: 34,
  // page down
  63272: 46,
  // delete
  63273: 36,
  // home
  63275: 35
  // end
};
var KeyFilter = class _KeyFilter {
  document;
  platformId;
  el;
  /**
   * When enabled, instead of blocking keys, input is validated internally to test against the regular expression.
   * @group Props
   */
  pValidateOnly;
  /**
   * Sets the pattern for key filtering.
   * @group Props
   */
  set pattern(_pattern) {
    this._pattern = _pattern;
    if (_pattern instanceof RegExp) {
      this.regex = _pattern;
    } else if (_pattern && _pattern in DEFAULT_MASKS) {
      this.regex = DEFAULT_MASKS[_pattern];
    } else {
      this.regex = /./;
    }
  }
  get pattern() {
    return this._pattern;
  }
  /**
   * Emits a value whenever the ngModel of the component changes.
   * @param {(string | number)} modelValue - Custom model change event.
   * @group Emits
   */
  ngModelChange = new EventEmitter();
  regex = /./;
  _pattern;
  isAndroid;
  lastValue;
  constructor(document2, platformId, el) {
    this.document = document2;
    this.platformId = platformId;
    this.el = el;
    if (isPlatformBrowser(this.platformId)) {
      this.isAndroid = $t();
    } else {
      this.isAndroid = false;
    }
  }
  isNavKeyPress(e) {
    let k3 = e.keyCode;
    k3 = xt().safari ? SAFARI_KEYS[k3] || k3 : k3;
    return k3 >= 33 && k3 <= 40 || k3 == KEYS.RETURN || k3 == KEYS.TAB || k3 == KEYS.ESC;
  }
  isSpecialKey(e) {
    let k3 = e.keyCode || e.charCode;
    return k3 == 9 || k3 == 13 || k3 == 27 || k3 == 16 || k3 == 17 || k3 >= 18 && k3 <= 20 || xt().opera && !e.shiftKey && (k3 == 8 || k3 >= 33 && k3 <= 35 || k3 >= 36 && k3 <= 39 || k3 >= 44 && k3 <= 45);
  }
  getKey(e) {
    let k3 = e.keyCode || e.charCode;
    return xt().safari ? SAFARI_KEYS[k3] || k3 : k3;
  }
  getCharCode(e) {
    return e.charCode || e.keyCode || e.which;
  }
  findDelta(value, prevValue) {
    let delta = "";
    for (let i = 0; i < value.length; i++) {
      let str = value.substr(0, i) + value.substr(i + value.length - prevValue.length);
      if (str === prevValue) delta = value.substr(i, value.length - prevValue.length);
    }
    return delta;
  }
  isValidChar(c2) {
    return this.regex.test(c2);
  }
  isValidString(str) {
    for (let i = 0; i < str.length; i++) {
      if (!this.isValidChar(str.substr(i, 1))) {
        return false;
      }
    }
    return true;
  }
  onInput(e) {
    if (this.isAndroid && !this.pValidateOnly) {
      let val = this.el.nativeElement.value;
      let lastVal = this.lastValue || "";
      let inserted = this.findDelta(val, lastVal);
      let removed = this.findDelta(lastVal, val);
      let pasted = inserted.length > 1 || !inserted && !removed;
      if (pasted) {
        if (!this.isValidString(val)) {
          this.el.nativeElement.value = lastVal;
          this.ngModelChange.emit(lastVal);
        }
      } else if (!removed) {
        if (!this.isValidChar(inserted)) {
          this.el.nativeElement.value = lastVal;
          this.ngModelChange.emit(lastVal);
        }
      }
      val = this.el.nativeElement.value;
      if (this.isValidString(val)) {
        this.lastValue = val;
      }
    }
  }
  onKeyPress(e) {
    if (this.isAndroid || this.pValidateOnly) {
      return;
    }
    let browser = xt();
    let k3 = this.getKey(e);
    if (browser.mozilla && (e.ctrlKey || e.altKey)) {
      return;
    } else if (k3 == 17 || k3 == 18) {
      return;
    }
    if (k3 == 13) {
      return;
    }
    let c2 = this.getCharCode(e);
    let cc = String.fromCharCode(c2);
    let ok = true;
    if (!browser.mozilla && (this.isSpecialKey(e) || !cc)) {
      return;
    }
    let existingValue = this.el.nativeElement.value || "";
    let combinedValue = existingValue + cc;
    ok = this.regex.test(combinedValue);
    if (!ok) {
      e.preventDefault();
    }
  }
  onPaste(e) {
    let clipboardData = e.clipboardData;
    if (!clipboardData && this.document.defaultView) {
      const windowClipboard = this.document.defaultView.clipboardData;
      if (windowClipboard) {
        clipboardData = {
          getData: (_format) => windowClipboard.getData("text")
        };
      }
    }
    if (clipboardData) {
      let pattern = /\{[0-9]+\}/;
      const pastedText = clipboardData.getData("text");
      if (pattern.test(this.regex.toString())) {
        if (!this.regex.test(pastedText)) {
          e.preventDefault();
          return;
        }
      } else {
        for (let char of pastedText.toString()) {
          if (!this.regex.test(char)) {
            e.preventDefault();
            return;
          }
        }
      }
    }
  }
  validate(_c) {
    if (this.pValidateOnly) {
      let value = this.el.nativeElement.value;
      if (value && !this.regex.test(value)) {
        return {
          validatePattern: false
        };
      }
    }
  }
  static \u0275fac = function KeyFilter_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _KeyFilter)(\u0275\u0275directiveInject(DOCUMENT), \u0275\u0275directiveInject(PLATFORM_ID), \u0275\u0275directiveInject(ElementRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _KeyFilter,
    selectors: [["", "pKeyFilter", ""]],
    hostBindings: function KeyFilter_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("input", function KeyFilter_input_HostBindingHandler($event) {
          return ctx.onInput($event);
        })("keypress", function KeyFilter_keypress_HostBindingHandler($event) {
          return ctx.onKeyPress($event);
        })("paste", function KeyFilter_paste_HostBindingHandler($event) {
          return ctx.onPaste($event);
        });
      }
    },
    inputs: {
      pValidateOnly: [2, "pValidateOnly", "pValidateOnly", booleanAttribute],
      pattern: [0, "pKeyFilter", "pattern"]
    },
    outputs: {
      ngModelChange: "ngModelChange"
    },
    features: [\u0275\u0275ProvidersFeature([KEYFILTER_VALIDATOR])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyFilter, [{
    type: Directive,
    args: [{
      selector: "[pKeyFilter]",
      standalone: true,
      providers: [KEYFILTER_VALIDATOR]
    }]
  }], () => [{
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: ElementRef
  }], {
    pValidateOnly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    pattern: [{
      type: Input,
      args: ["pKeyFilter"]
    }],
    ngModelChange: [{
      type: Output
    }],
    onInput: [{
      type: HostListener,
      args: ["input", ["$event"]]
    }],
    onKeyPress: [{
      type: HostListener,
      args: ["keypress", ["$event"]]
    }],
    onPaste: [{
      type: HostListener,
      args: ["paste", ["$event"]]
    }]
  });
})();
var KeyFilterModule = class _KeyFilterModule {
  static \u0275fac = function KeyFilterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _KeyFilterModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _KeyFilterModule,
    imports: [KeyFilter],
    exports: [KeyFilter]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyFilterModule, [{
    type: NgModule,
    args: [{
      imports: [KeyFilter],
      exports: [KeyFilter]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/_shadow-dom-chunk.mjs
var shadowDomIsSupported;
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}

// node_modules/@angular/cdk/fesm2022/_fake-event-detection-chunk.mjs
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}

// node_modules/@angular/cdk/fesm2022/_element-chunk.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  if (_isNumberValue(value)) {
    return Number(value);
  }
  return arguments.length === 2 ? fallbackValue : 0;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}

// node_modules/@angular/cdk/fesm2022/_style-loader-chunk.mjs
var appsWithLoaders = /* @__PURE__ */ new WeakMap();
var _CdkPrivateStyleLoader = class __CdkPrivateStyleLoader {
  _appRef;
  _injector = inject(Injector);
  _environmentInjector = inject(EnvironmentInjector);
  load(loader) {
    const appRef = this._appRef = this._appRef || this._injector.get(ApplicationRef);
    let data = appsWithLoaders.get(appRef);
    if (!data) {
      data = {
        loaders: /* @__PURE__ */ new Set(),
        refs: []
      };
      appsWithLoaders.set(appRef, data);
      appRef.onDestroy(() => {
        appsWithLoaders.get(appRef)?.refs.forEach((ref) => ref.destroy());
        appsWithLoaders.delete(appRef);
      });
    }
    if (!data.loaders.has(loader)) {
      data.loaders.add(loader);
      data.refs.push(createComponent(loader, {
        environmentInjector: this._environmentInjector
      }));
    }
  }
  static \u0275fac = function _CdkPrivateStyleLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __CdkPrivateStyleLoader)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: __CdkPrivateStyleLoader,
    factory: __CdkPrivateStyleLoader.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkPrivateStyleLoader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/_platform-chunk.mjs
var hasV8BreakIterator;
try {
  hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
} catch {
  hasV8BreakIterator = false;
}
var Platform = class _Platform {
  _platformId = inject(PLATFORM_ID);
  isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
  EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
  TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
  BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
  WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
  IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
  FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
  ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
  SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
  constructor() {
  }
  static \u0275fac = function Platform_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Platform)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Platform,
    factory: _Platform.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/_directionality-chunk.mjs
var DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
  providedIn: "root",
  factory: () => inject(DOCUMENT)
});
var RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var Directionality = class _Directionality {
  get value() {
    return this.valueSignal();
  }
  valueSignal = signal("ltr", ...ngDevMode ? [{
    debugName: "valueSignal"
  }] : []);
  change = new EventEmitter();
  constructor() {
    const _document = inject(DIR_DOCUMENT, {
      optional: true
    });
    if (_document) {
      const bodyDir = _document.body ? _document.body.dir : null;
      const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
      this.valueSignal.set(_resolveDirectionality(bodyDir || htmlDir || "ltr"));
    }
  }
  ngOnDestroy() {
    this.change.complete();
  }
  static \u0275fac = function Directionality_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Directionality)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Directionality,
    factory: _Directionality.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/_scrolling-chunk.mjs
var RtlScrollAxisType;
(function(RtlScrollAxisType2) {
  RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
  RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
  RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
})(RtlScrollAxisType || (RtlScrollAxisType = {}));
var rtlScrollAxisType;
var scrollBehaviorSupported;
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if (document.documentElement?.style && "scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var Dir = class _Dir {
  _isInitialized = false;
  _rawDir;
  change = new EventEmitter();
  get dir() {
    return this.valueSignal();
  }
  set dir(value) {
    const previousValue = this.valueSignal();
    this.valueSignal.set(_resolveDirectionality(value));
    this._rawDir = value;
    if (previousValue !== this.valueSignal() && this._isInitialized) {
      this.change.emit(this.valueSignal());
    }
  }
  get value() {
    return this.dir;
  }
  valueSignal = signal("ltr", ...ngDevMode ? [{
    debugName: "valueSignal"
  }] : []);
  ngAfterContentInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    this.change.complete();
  }
  static \u0275fac = function Dir_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Dir)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _Dir,
    selectors: [["", "dir", ""]],
    hostVars: 1,
    hostBindings: function Dir_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("dir", ctx._rawDir);
      }
    },
    inputs: {
      dir: "dir"
    },
    outputs: {
      change: "dirChange"
    },
    exportAs: ["dir"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: Directionality,
      useExisting: _Dir
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
    type: Directive,
    args: [{
      selector: "[dir]",
      providers: [{
        provide: Directionality,
        useExisting: Dir
      }],
      host: {
        "[attr.dir]": "_rawDir"
      },
      exportAs: "dir"
    }]
  }], null, {
    change: [{
      type: Output,
      args: ["dirChange"]
    }],
    dir: [{
      type: Input
    }]
  });
})();
var BidiModule = class _BidiModule {
  static \u0275fac = function BidiModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BidiModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _BidiModule,
    imports: [Dir],
    exports: [Dir]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
    type: NgModule,
    args: [{
      imports: [Dir],
      exports: [Dir]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/_data-source-chunk.mjs
var DataSource = class {
};
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}

// node_modules/@angular/cdk/fesm2022/_recycle-view-repeater-strategy-chunk.mjs
var ArrayDataSource = class extends DataSource {
  _data;
  constructor(_data) {
    super();
    this._data = _data;
  }
  connect() {
    return isObservable(this._data) ? this._data : of(this._data);
  }
  disconnect() {
  }
};
var _ViewRepeaterOperation;
(function(_ViewRepeaterOperation2) {
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
var _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
var _RecycleViewRepeaterStrategy = class {
  viewCacheSize = 20;
  _viewCache = [];
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
      } else if (currentIndex == null) {
        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
        operation = _ViewRepeaterOperation.REMOVED;
      } else {
        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = _ViewRepeaterOperation.MOVED;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
    for (const view of this._viewCache) {
      view.destroy();
    }
    this._viewCache = [];
  }
  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
    if (cachedView) {
      cachedView.context.$implicit = value;
      return void 0;
    }
    const viewArgs = viewArgsFactory();
    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
  }
  _detachAndCacheView(index, viewContainerRef) {
    const detachedView = viewContainerRef.detach(index);
    this._maybeCacheView(detachedView, viewContainerRef);
  }
  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
    const view = viewContainerRef.get(adjustedPreviousIndex);
    viewContainerRef.move(view, currentIndex);
    view.context.$implicit = value;
    return view;
  }
  _maybeCacheView(view, viewContainerRef) {
    if (this._viewCache.length < this.viewCacheSize) {
      this._viewCache.push(view);
    } else {
      const index = viewContainerRef.indexOf(view);
      if (index === -1) {
        view.destroy();
      } else {
        viewContainerRef.remove(index);
      }
    }
  }
  _insertViewFromCache(index, viewContainerRef) {
    const cachedView = this._viewCache.pop();
    if (cachedView) {
      viewContainerRef.insert(cachedView, index);
    }
    return cachedView || null;
  }
};

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
var _c014 = ["contentWrapper"];
var _c18 = ["*"];
var VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
var FixedSizeVirtualScrollStrategy = class {
  _scrolledIndexChange = new Subject();
  scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
  _viewport = null;
  _itemSize;
  _minBufferPx;
  _maxBufferPx;
  constructor(itemSize, minBufferPx, maxBufferPx) {
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
  }
  attach(viewport) {
    this._viewport = viewport;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  detach() {
    this._scrolledIndexChange.complete();
    this._viewport = null;
  }
  updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
    if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
    }
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  onContentScrolled() {
    this._updateRenderedRange();
  }
  onDataLengthChanged() {
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  onContentRendered() {
  }
  onRenderedOffsetChanged() {
  }
  scrollToIndex(index, behavior) {
    if (this._viewport) {
      this._viewport.scrollToOffset(index * this._itemSize, behavior);
    }
  }
  _updateTotalContentSize() {
    if (!this._viewport) {
      return;
    }
    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
  }
  _updateRenderedRange() {
    if (!this._viewport) {
      return;
    }
    const renderedRange = this._viewport.getRenderedRange();
    const newRange = {
      start: renderedRange.start,
      end: renderedRange.end
    };
    const viewportSize = this._viewport.getViewportSize();
    const dataLength = this._viewport.getDataLength();
    let scrollOffset = this._viewport.measureScrollOffset();
    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
    if (newRange.end > dataLength) {
      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
      const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
      if (firstVisibleIndex != newVisibleIndex) {
        firstVisibleIndex = newVisibleIndex;
        scrollOffset = newVisibleIndex * this._itemSize;
        newRange.start = Math.floor(firstVisibleIndex);
      }
      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
    }
    const startBuffer = scrollOffset - newRange.start * this._itemSize;
    if (startBuffer < this._minBufferPx && newRange.start != 0) {
      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
      newRange.start = Math.max(0, newRange.start - expandStart);
      newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
    } else {
      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
        if (expandEnd > 0) {
          newRange.end = Math.min(dataLength, newRange.end + expandEnd);
          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
        }
      }
    }
    this._viewport.setRenderedRange(newRange);
    this._viewport.setRenderedContentOffset(Math.round(this._itemSize * newRange.start));
    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
  }
};
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
var CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value) {
    this._itemSize = coerceNumberProperty(value);
  }
  _itemSize = 20;
  get minBufferPx() {
    return this._minBufferPx;
  }
  set minBufferPx(value) {
    this._minBufferPx = coerceNumberProperty(value);
  }
  _minBufferPx = 100;
  get maxBufferPx() {
    return this._maxBufferPx;
  }
  set maxBufferPx(value) {
    this._maxBufferPx = coerceNumberProperty(value);
  }
  _maxBufferPx = 200;
  _scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
  ngOnChanges() {
    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
  static \u0275fac = function CdkFixedSizeVirtualScroll_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkFixedSizeVirtualScroll)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkFixedSizeVirtualScroll,
    selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
    inputs: {
      itemSize: "itemSize",
      minBufferPx: "minBufferPx",
      maxBufferPx: "maxBufferPx"
    },
    features: [\u0275\u0275ProvidersFeature([{
      provide: VIRTUAL_SCROLL_STRATEGY,
      useFactory: _fixedSizeVirtualScrollStrategyFactory,
      deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
    }]), \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[itemSize]",
      providers: [{
        provide: VIRTUAL_SCROLL_STRATEGY,
        useFactory: _fixedSizeVirtualScrollStrategyFactory,
        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
      }]
    }]
  }], null, {
    itemSize: [{
      type: Input
    }],
    minBufferPx: [{
      type: Input
    }],
    maxBufferPx: [{
      type: Input
    }]
  });
})();
var DEFAULT_SCROLL_TIME = 20;
var ScrollDispatcher = class _ScrollDispatcher {
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupGlobalListener;
  constructor() {
  }
  _scrolled = new Subject();
  _scrolledCount = 0;
  scrollContainers = /* @__PURE__ */ new Map();
  register(scrollable) {
    if (!this.scrollContainers.has(scrollable)) {
      this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
    }
  }
  deregister(scrollable) {
    const scrollableReference = this.scrollContainers.get(scrollable);
    if (scrollableReference) {
      scrollableReference.unsubscribe();
      this.scrollContainers.delete(scrollable);
    }
  }
  scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
    if (!this._platform.isBrowser) {
      return of();
    }
    return new Observable((observer) => {
      if (!this._cleanupGlobalListener) {
        this._cleanupGlobalListener = this._ngZone.runOutsideAngular(() => this._renderer.listen("document", "scroll", () => this._scrolled.next()));
      }
      const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
      this._scrolledCount++;
      return () => {
        subscription.unsubscribe();
        this._scrolledCount--;
        if (!this._scrolledCount) {
          this._cleanupGlobalListener?.();
          this._cleanupGlobalListener = void 0;
        }
      };
    });
  }
  ngOnDestroy() {
    this._cleanupGlobalListener?.();
    this._cleanupGlobalListener = void 0;
    this.scrollContainers.forEach((_, container) => this.deregister(container));
    this._scrolled.complete();
  }
  ancestorScrolled(elementOrElementRef, auditTimeInMs) {
    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
    return this.scrolled(auditTimeInMs).pipe(filter((target) => !target || ancestors.indexOf(target) > -1));
  }
  getAncestorScrollContainers(elementOrElementRef) {
    const scrollingContainers = [];
    this.scrollContainers.forEach((_subscription, scrollable) => {
      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
        scrollingContainers.push(scrollable);
      }
    });
    return scrollingContainers;
  }
  _scrollableContainsElement(scrollable, elementOrElementRef) {
    let element = coerceElement(elementOrElementRef);
    let scrollableElement = scrollable.getElementRef().nativeElement;
    do {
      if (element == scrollableElement) {
        return true;
      }
    } while (element = element.parentElement);
    return false;
  }
  static \u0275fac = function ScrollDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollDispatcher)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ScrollDispatcher,
    factory: _ScrollDispatcher.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkScrollable = class _CdkScrollable {
  elementRef = inject(ElementRef);
  scrollDispatcher = inject(ScrollDispatcher);
  ngZone = inject(NgZone);
  dir = inject(Directionality, {
    optional: true
  });
  _scrollElement = this.elementRef.nativeElement;
  _destroyed = new Subject();
  _renderer = inject(Renderer2);
  _cleanupScroll;
  _elementScrolled = new Subject();
  constructor() {
  }
  ngOnInit() {
    this._cleanupScroll = this.ngZone.runOutsideAngular(() => this._renderer.listen(this._scrollElement, "scroll", (event) => this._elementScrolled.next(event)));
    this.scrollDispatcher.register(this);
  }
  ngOnDestroy() {
    this._cleanupScroll?.();
    this._elementScrolled.complete();
    this.scrollDispatcher.deregister(this);
    this._destroyed.next();
    this._destroyed.complete();
  }
  elementScrolled() {
    return this._elementScrolled;
  }
  getElementRef() {
    return this.elementRef;
  }
  scrollTo(options) {
    const el = this.elementRef.nativeElement;
    const isRtl = this.dir && this.dir.value == "rtl";
    if (options.left == null) {
      options.left = isRtl ? options.end : options.start;
    }
    if (options.right == null) {
      options.right = isRtl ? options.start : options.end;
    }
    if (options.bottom != null) {
      options.top = el.scrollHeight - el.clientHeight - options.bottom;
    }
    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
      if (options.left != null) {
        options.right = el.scrollWidth - el.clientWidth - options.left;
      }
      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
        options.left = options.right;
      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
        options.left = options.right ? -options.right : options.right;
      }
    } else {
      if (options.right != null) {
        options.left = el.scrollWidth - el.clientWidth - options.right;
      }
    }
    this._applyScrollToOptions(options);
  }
  _applyScrollToOptions(options) {
    const el = this.elementRef.nativeElement;
    if (supportsScrollBehavior()) {
      el.scrollTo(options);
    } else {
      if (options.top != null) {
        el.scrollTop = options.top;
      }
      if (options.left != null) {
        el.scrollLeft = options.left;
      }
    }
  }
  measureScrollOffset(from) {
    const LEFT = "left";
    const RIGHT = "right";
    const el = this.elementRef.nativeElement;
    if (from == "top") {
      return el.scrollTop;
    }
    if (from == "bottom") {
      return el.scrollHeight - el.clientHeight - el.scrollTop;
    }
    const isRtl = this.dir && this.dir.value == "rtl";
    if (from == "start") {
      from = isRtl ? RIGHT : LEFT;
    } else if (from == "end") {
      from = isRtl ? LEFT : RIGHT;
    }
    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
      if (from == LEFT) {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      } else {
        return el.scrollLeft;
      }
    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
      if (from == LEFT) {
        return el.scrollLeft + el.scrollWidth - el.clientWidth;
      } else {
        return -el.scrollLeft;
      }
    } else {
      if (from == LEFT) {
        return el.scrollLeft;
      } else {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      }
    }
  }
  static \u0275fac = function CdkScrollable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkScrollable)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkScrollable,
    selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
    type: Directive,
    args: [{
      selector: "[cdk-scrollable], [cdkScrollable]"
    }]
  }], () => [], null);
})();
var DEFAULT_RESIZE_TIME = 20;
var ViewportRuler = class _ViewportRuler {
  _platform = inject(Platform);
  _listeners;
  _viewportSize;
  _change = new Subject();
  _document = inject(DOCUMENT);
  constructor() {
    const ngZone = inject(NgZone);
    const renderer = inject(RendererFactory2).createRenderer(null, null);
    ngZone.runOutsideAngular(() => {
      if (this._platform.isBrowser) {
        const changeListener = (event) => this._change.next(event);
        this._listeners = [renderer.listen("window", "resize", changeListener), renderer.listen("window", "orientationchange", changeListener)];
      }
      this.change().subscribe(() => this._viewportSize = null);
    });
  }
  ngOnDestroy() {
    this._listeners?.forEach((cleanup) => cleanup());
    this._change.complete();
  }
  getViewportSize() {
    if (!this._viewportSize) {
      this._updateViewportSize();
    }
    const output2 = {
      width: this._viewportSize.width,
      height: this._viewportSize.height
    };
    if (!this._platform.isBrowser) {
      this._viewportSize = null;
    }
    return output2;
  }
  getViewportRect() {
    const scrollPosition = this.getViewportScrollPosition();
    const {
      width,
      height
    } = this.getViewportSize();
    return {
      top: scrollPosition.top,
      left: scrollPosition.left,
      bottom: scrollPosition.top + height,
      right: scrollPosition.left + width,
      height,
      width
    };
  }
  getViewportScrollPosition() {
    if (!this._platform.isBrowser) {
      return {
        top: 0,
        left: 0
      };
    }
    const document2 = this._document;
    const window2 = this._getWindow();
    const documentElement = document2.documentElement;
    const documentRect = documentElement.getBoundingClientRect();
    const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
    const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
    return {
      top,
      left
    };
  }
  change(throttleTime = DEFAULT_RESIZE_TIME) {
    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
  }
  _getWindow() {
    return this._document.defaultView || window;
  }
  _updateViewportSize() {
    const window2 = this._getWindow();
    this._viewportSize = this._platform.isBrowser ? {
      width: window2.innerWidth,
      height: window2.innerHeight
    } : {
      width: 0,
      height: 0
    };
  }
  static \u0275fac = function ViewportRuler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ViewportRuler)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ViewportRuler,
    factory: _ViewportRuler.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
var CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
  constructor() {
    super();
  }
  measureViewportSize(orientation) {
    const viewportEl = this.elementRef.nativeElement;
    return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
  }
  static \u0275fac = function CdkVirtualScrollable_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollable)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkVirtualScrollable,
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
    type: Directive
  }], () => [], null);
})();
function rangesEqual(r1, r2) {
  return r1.start == r2.start && r1.end == r2.end;
}
var SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
  elementRef = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollStrategy = inject(VIRTUAL_SCROLL_STRATEGY, {
    optional: true
  });
  scrollable = inject(VIRTUAL_SCROLLABLE, {
    optional: true
  });
  _platform = inject(Platform);
  _detachedSubject = new Subject();
  _renderedRangeSubject = new Subject();
  get orientation() {
    return this._orientation;
  }
  set orientation(orientation) {
    if (this._orientation !== orientation) {
      this._orientation = orientation;
      this._calculateSpacerSize();
    }
  }
  _orientation = "vertical";
  appendOnly = false;
  scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
  _contentWrapper;
  renderedRangeStream = this._renderedRangeSubject;
  _totalContentSize = 0;
  _totalContentWidth = signal("", ...ngDevMode ? [{
    debugName: "_totalContentWidth"
  }] : []);
  _totalContentHeight = signal("", ...ngDevMode ? [{
    debugName: "_totalContentHeight"
  }] : []);
  _renderedContentTransform;
  _renderedRange = {
    start: 0,
    end: 0
  };
  _dataLength = 0;
  _viewportSize = 0;
  _forOf;
  _renderedContentOffset = 0;
  _renderedContentOffsetNeedsRewrite = false;
  _changeDetectionNeeded = signal(false, ...ngDevMode ? [{
    debugName: "_changeDetectionNeeded"
  }] : []);
  _runAfterChangeDetection = [];
  _viewportChanges = Subscription.EMPTY;
  _injector = inject(Injector);
  _isDestroyed = false;
  constructor() {
    super();
    const viewportRuler = inject(ViewportRuler);
    if (!this._scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
    }
    this._viewportChanges = viewportRuler.change().subscribe(() => {
      this.checkViewportSize();
    });
    if (!this.scrollable) {
      this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
      this.scrollable = this;
    }
    const ref = effect(() => {
      if (this._changeDetectionNeeded()) {
        this._doChangeDetection();
      }
    }, ...ngDevMode ? [{
      debugName: "ref",
      injector: inject(ApplicationRef).injector
    }] : [{
      injector: inject(ApplicationRef).injector
    }]);
    inject(DestroyRef).onDestroy(() => void ref.destroy());
  }
  ngOnInit() {
    if (!this._platform.isBrowser) {
      return;
    }
    if (this.scrollable === this) {
      super.ngOnInit();
    }
    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
      this._measureViewportSize();
      this._scrollStrategy.attach(this);
      this.scrollable.elementScrolled().pipe(startWith(null), auditTime(0, SCROLL_SCHEDULER), takeUntil(this._destroyed)).subscribe(() => this._scrollStrategy.onContentScrolled());
      this._markChangeDetectionNeeded();
    }));
  }
  ngOnDestroy() {
    this.detach();
    this._scrollStrategy.detach();
    this._renderedRangeSubject.complete();
    this._detachedSubject.complete();
    this._viewportChanges.unsubscribe();
    this._isDestroyed = true;
    super.ngOnDestroy();
  }
  attach(forOf) {
    if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CdkVirtualScrollViewport is already attached.");
    }
    this.ngZone.runOutsideAngular(() => {
      this._forOf = forOf;
      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
        const newLength = data.length;
        if (newLength !== this._dataLength) {
          this._dataLength = newLength;
          this._scrollStrategy.onDataLengthChanged();
        }
        this._doChangeDetection();
      });
    });
  }
  detach() {
    this._forOf = null;
    this._detachedSubject.next();
  }
  getDataLength() {
    return this._dataLength;
  }
  getViewportSize() {
    return this._viewportSize;
  }
  getRenderedRange() {
    return this._renderedRange;
  }
  measureBoundingClientRectWithScrollOffset(from) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from];
  }
  setTotalContentSize(size) {
    if (this._totalContentSize !== size) {
      this._totalContentSize = size;
      this._calculateSpacerSize();
      this._markChangeDetectionNeeded();
    }
  }
  setRenderedRange(range) {
    if (!rangesEqual(this._renderedRange, range)) {
      if (this.appendOnly) {
        range = {
          start: 0,
          end: Math.max(this._renderedRange.end, range.end)
        };
      }
      this._renderedRangeSubject.next(this._renderedRange = range);
      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
    }
  }
  getOffsetToRenderedContentStart() {
    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
  }
  setRenderedContentOffset(offset, to = "to-start") {
    offset = this.appendOnly && to === "to-start" ? 0 : offset;
    const isRtl = this.dir && this.dir.value == "rtl";
    const isHorizontal = this.orientation == "horizontal";
    const axis = isHorizontal ? "X" : "Y";
    const axisDirection = isHorizontal && isRtl ? -1 : 1;
    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
    this._renderedContentOffset = offset;
    if (to === "to-end") {
      transform += ` translate${axis}(-100%)`;
      this._renderedContentOffsetNeedsRewrite = true;
    }
    if (this._renderedContentTransform != transform) {
      this._renderedContentTransform = transform;
      this._markChangeDetectionNeeded(() => {
        if (this._renderedContentOffsetNeedsRewrite) {
          this._renderedContentOffset -= this.measureRenderedContentSize();
          this._renderedContentOffsetNeedsRewrite = false;
          this.setRenderedContentOffset(this._renderedContentOffset);
        } else {
          this._scrollStrategy.onRenderedOffsetChanged();
        }
      });
    }
  }
  scrollToOffset(offset, behavior = "auto") {
    const options = {
      behavior
    };
    if (this.orientation === "horizontal") {
      options.start = offset;
    } else {
      options.top = offset;
    }
    this.scrollable.scrollTo(options);
  }
  scrollToIndex(index, behavior = "auto") {
    this._scrollStrategy.scrollToIndex(index, behavior);
  }
  measureScrollOffset(from) {
    let measureScrollOffset;
    if (this.scrollable == this) {
      measureScrollOffset = (_from) => super.measureScrollOffset(_from);
    } else {
      measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
    }
    return Math.max(0, measureScrollOffset(from ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
  }
  measureViewportOffset(from) {
    let fromRect;
    const LEFT = "left";
    const RIGHT = "right";
    const isRtl = this.dir?.value == "rtl";
    if (from == "start") {
      fromRect = isRtl ? RIGHT : LEFT;
    } else if (from == "end") {
      fromRect = isRtl ? LEFT : RIGHT;
    } else if (from) {
      fromRect = from;
    } else {
      fromRect = this.orientation === "horizontal" ? "left" : "top";
    }
    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
    return viewportClientRect - scrollerClientRect;
  }
  measureRenderedContentSize() {
    const contentEl = this._contentWrapper.nativeElement;
    return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
  }
  measureRangeSize(range) {
    if (!this._forOf) {
      return 0;
    }
    return this._forOf.measureRangeSize(range, this.orientation);
  }
  checkViewportSize() {
    this._measureViewportSize();
    this._scrollStrategy.onDataLengthChanged();
  }
  _measureViewportSize() {
    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
  }
  _markChangeDetectionNeeded(runAfter) {
    if (runAfter) {
      this._runAfterChangeDetection.push(runAfter);
    }
    if (untracked(this._changeDetectionNeeded)) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      Promise.resolve().then(() => {
        this.ngZone.run(() => {
          this._changeDetectionNeeded.set(true);
        });
      });
    });
  }
  _doChangeDetection() {
    if (this._isDestroyed) {
      return;
    }
    this.ngZone.run(() => {
      this._changeDetectorRef.markForCheck();
      this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
      afterNextRender(() => {
        this._changeDetectionNeeded.set(false);
        const runAfterChangeDetection = this._runAfterChangeDetection;
        this._runAfterChangeDetection = [];
        for (const fn of runAfterChangeDetection) {
          fn();
        }
      }, {
        injector: this._injector
      });
    });
  }
  _calculateSpacerSize() {
    this._totalContentHeight.set(this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`);
    this._totalContentWidth.set(this.orientation === "horizontal" ? `${this._totalContentSize}px` : "");
  }
  static \u0275fac = function CdkVirtualScrollViewport_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollViewport)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _CdkVirtualScrollViewport,
    selectors: [["cdk-virtual-scroll-viewport"]],
    viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c014, 7);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx._contentWrapper = _t.first);
      }
    },
    hostAttrs: [1, "cdk-virtual-scroll-viewport"],
    hostVars: 4,
    hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
      }
    },
    inputs: {
      orientation: "orientation",
      appendOnly: [2, "appendOnly", "appendOnly", booleanAttribute]
    },
    outputs: {
      scrolledIndexChange: "scrolledIndexChange"
    },
    features: [\u0275\u0275ProvidersFeature([{
      provide: CdkScrollable,
      useFactory: () => inject(VIRTUAL_SCROLLABLE, {
        optional: true
      }) || inject(_CdkVirtualScrollViewport)
    }]), \u0275\u0275InheritDefinitionFeature],
    ngContentSelectors: _c18,
    decls: 4,
    vars: 4,
    consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
    template: function CdkVirtualScrollViewport_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef();
        \u0275\u0275domElementStart(0, "div", 1, 0);
        \u0275\u0275projection(2);
        \u0275\u0275domElementEnd();
        \u0275\u0275domElement(3, "div", 2);
      }
      if (rf & 2) {
        \u0275\u0275advance(3);
        \u0275\u0275styleProp("width", ctx._totalContentWidth())("height", ctx._totalContentHeight());
      }
    },
    styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
    type: Component,
    args: [{
      selector: "cdk-virtual-scroll-viewport",
      host: {
        "class": "cdk-virtual-scroll-viewport",
        "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
        "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
      },
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: CdkScrollable,
        useFactory: () => inject(VIRTUAL_SCROLLABLE, {
          optional: true
        }) || inject(CdkVirtualScrollViewport)
      }],
      template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth()" [style.height]="_totalContentHeight()"></div>\n',
      styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"]
    }]
  }], () => [], {
    orientation: [{
      type: Input
    }],
    appendOnly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    scrolledIndexChange: [{
      type: Output
    }],
    _contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", {
        static: true
      }]
    }]
  });
})();
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var CdkVirtualForOf = class _CdkVirtualForOf {
  _viewContainerRef = inject(ViewContainerRef);
  _template = inject(TemplateRef);
  _differs = inject(IterableDiffers);
  _viewRepeater = inject(_VIEW_REPEATER_STRATEGY);
  _viewport = inject(CdkVirtualScrollViewport, {
    skipSelf: true
  });
  viewChange = new Subject();
  _dataSourceChanges = new Subject();
  get cdkVirtualForOf() {
    return this._cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this._cdkVirtualForOf = value;
    if (isDataSource(value)) {
      this._dataSourceChanges.next(value);
    } else {
      this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
    }
  }
  _cdkVirtualForOf;
  get cdkVirtualForTrackBy() {
    return this._cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(fn) {
    this._needsUpdate = true;
    this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
  }
  _cdkVirtualForTrackBy;
  set cdkVirtualForTemplate(value) {
    if (value) {
      this._needsUpdate = true;
      this._template = value;
    }
  }
  get cdkVirtualForTemplateCacheSize() {
    return this._viewRepeater.viewCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(size) {
    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
  }
  dataStream = this._dataSourceChanges.pipe(startWith(null), pairwise(), switchMap(([prev, cur]) => this._changeDataSource(prev, cur)), shareReplay(1));
  _differ = null;
  _data;
  _renderedItems;
  _renderedRange;
  _needsUpdate = false;
  _destroyed = new Subject();
  constructor() {
    const ngZone = inject(NgZone);
    this.dataStream.subscribe((data) => {
      this._data = data;
      this._onRenderedDataChange();
    });
    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range) => {
      this._renderedRange = range;
      if (this.viewChange.observers.length) {
        ngZone.run(() => this.viewChange.next(this._renderedRange));
      }
      this._onRenderedDataChange();
    });
    this._viewport.attach(this);
  }
  measureRangeSize(range, orientation) {
    if (range.start >= range.end) {
      return 0;
    }
    if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Error: attempted to measure an item that isn't rendered.`);
    }
    const renderedStartIndex = range.start - this._renderedRange.start;
    const rangeLen = range.end - range.start;
    let firstNode;
    let lastNode;
    for (let i = 0; i < rangeLen; i++) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        firstNode = lastNode = view.rootNodes[0];
        break;
      }
    }
    for (let i = rangeLen - 1; i > -1; i--) {
      const view = this._viewContainerRef.get(i + renderedStartIndex);
      if (view && view.rootNodes.length) {
        lastNode = view.rootNodes[view.rootNodes.length - 1];
        break;
      }
    }
    return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
  }
  ngDoCheck() {
    if (this._differ && this._needsUpdate) {
      const changes = this._differ.diff(this._renderedItems);
      if (!changes) {
        this._updateContext();
      } else {
        this._applyChanges(changes);
      }
      this._needsUpdate = false;
    }
  }
  ngOnDestroy() {
    this._viewport.detach();
    this._dataSourceChanges.next(void 0);
    this._dataSourceChanges.complete();
    this.viewChange.complete();
    this._destroyed.next();
    this._destroyed.complete();
    this._viewRepeater.detach();
  }
  _onRenderedDataChange() {
    if (!this._renderedRange) {
      return;
    }
    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
    if (!this._differ) {
      this._differ = this._differs.find(this._renderedItems).create((index, item) => {
        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
      });
    }
    this._needsUpdate = true;
  }
  _changeDataSource(oldDs, newDs) {
    if (oldDs) {
      oldDs.disconnect(this);
    }
    this._needsUpdate = true;
    return newDs ? newDs.connect(this) : of();
  }
  _updateContext() {
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
      view.detectChanges();
    }
  }
  _applyChanges(changes) {
    this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
    changes.forEachIdentityChange((record) => {
      const view = this._viewContainerRef.get(record.currentIndex);
      view.context.$implicit = record.item;
    });
    const count = this._data.length;
    let i = this._viewContainerRef.length;
    while (i--) {
      const view = this._viewContainerRef.get(i);
      view.context.index = this._renderedRange.start + i;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
    }
  }
  _updateComputedContextProperties(context) {
    context.first = context.index === 0;
    context.last = context.index === context.count - 1;
    context.even = context.index % 2 === 0;
    context.odd = !context.even;
  }
  _getEmbeddedViewArgs(record, index) {
    return {
      templateRef: this._template,
      context: {
        $implicit: record.item,
        cdkVirtualForOf: this._cdkVirtualForOf,
        index: -1,
        count: -1,
        first: false,
        last: false,
        odd: false,
        even: false
      },
      index
    };
  }
  static ngTemplateContextGuard(directive, context) {
    return true;
  }
  static \u0275fac = function CdkVirtualForOf_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualForOf)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkVirtualForOf,
    selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
    inputs: {
      cdkVirtualForOf: "cdkVirtualForOf",
      cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
      cdkVirtualForTemplate: "cdkVirtualForTemplate",
      cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
    },
    features: [\u0275\u0275ProvidersFeature([{
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _RecycleViewRepeaterStrategy
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualFor][cdkVirtualForOf]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }]
    }]
  }], () => [], {
    cdkVirtualForOf: [{
      type: Input
    }],
    cdkVirtualForTrackBy: [{
      type: Input
    }],
    cdkVirtualForTemplate: [{
      type: Input
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input
    }]
  });
})();
var CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
  constructor() {
    super();
  }
  measureBoundingClientRectWithScrollOffset(from) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from] - this.measureScrollOffset(from);
  }
  static \u0275fac = function CdkVirtualScrollableElement_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollableElement)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkVirtualScrollableElement,
    selectors: [["", "cdkVirtualScrollingElement", ""]],
    hostAttrs: [1, "cdk-virtual-scrollable"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: VIRTUAL_SCROLLABLE,
      useExisting: _CdkVirtualScrollableElement
    }]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualScrollingElement]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableElement
      }],
      host: {
        "class": "cdk-virtual-scrollable"
      }
    }]
  }], () => [], null);
})();
var CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
  constructor() {
    super();
    const document2 = inject(DOCUMENT);
    this.elementRef = new ElementRef(document2.documentElement);
    this._scrollElement = document2;
  }
  measureBoundingClientRectWithScrollOffset(from) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from];
  }
  static \u0275fac = function CdkVirtualScrollableWindow_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkVirtualScrollableWindow)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkVirtualScrollableWindow,
    selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
    features: [\u0275\u0275ProvidersFeature([{
      provide: VIRTUAL_SCROLLABLE,
      useExisting: _CdkVirtualScrollableWindow
    }]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[scrollWindow]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableWindow
      }]
    }]
  }], () => [], null);
})();
var CdkScrollableModule = class _CdkScrollableModule {
  static \u0275fac = function CdkScrollableModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkScrollableModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _CdkScrollableModule,
    imports: [CdkScrollable],
    exports: [CdkScrollable]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
    type: NgModule,
    args: [{
      exports: [CdkScrollable],
      imports: [CdkScrollable]
    }]
  }], null, null);
})();
var ScrollingModule = class _ScrollingModule {
  static \u0275fac = function ScrollingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollingModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ScrollingModule,
    imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
    exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/_id-generator-chunk.mjs
var counters = {};
var _IdGenerator = class __IdGenerator {
  _appId = inject(APP_ID);
  static _infix = `a${Math.floor(Math.random() * 1e5).toString()}`;
  getId(prefix, randomize = false) {
    if (this._appId !== "ng") {
      prefix += this._appId;
    }
    if (!counters.hasOwnProperty(prefix)) {
      counters[prefix] = 0;
    }
    return `${prefix}${randomize ? __IdGenerator._infix + "-" : ""}${counters[prefix]++}`;
  }
  static \u0275fac = function _IdGenerator_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __IdGenerator)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: __IdGenerator,
    factory: __IdGenerator.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_IdGenerator, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/_array-chunk.mjs
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}

// node_modules/@angular/cdk/fesm2022/drag-drop.mjs
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  for (let i = 0; i < descendantsWithId.length; i++) {
    descendantsWithId[i].removeAttribute("id");
  }
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i = 0; i < descendantElements.length; i++) {
      callback(descendantElements[i], cloneElements[i]);
    }
  }
}
var cloneUniqueId = 0;
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
function transferCanvasData(source, clone) {
  const context = clone.getContext("2d");
  if (context) {
    try {
      context.drawImage(source, 0, 0);
    } catch {
    }
  }
}
function getMutableClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}
function isInsideClientRect(clientRect, x, y) {
  const {
    top,
    bottom,
    left,
    right
  } = clientRect;
  return y >= top && y <= bottom && x >= left && x <= right;
}
function isOverflowingParent(parentRect, childRect) {
  const isLeftOverflowing = childRect.left < parentRect.left;
  const isRightOverflowing = childRect.left + childRect.width > parentRect.right;
  const isTopOverflowing = childRect.top < parentRect.top;
  const isBottomOverflowing = childRect.top + childRect.height > parentRect.bottom;
  return isLeftOverflowing || isRightOverflowing || isTopOverflowing || isBottomOverflowing;
}
function adjustDomRect(domRect, top, left) {
  domRect.top += top;
  domRect.bottom = domRect.top + domRect.height;
  domRect.left += left;
  domRect.right = domRect.left + domRect.width;
}
function isPointerNearDomRect(rect, threshold, pointerX, pointerY) {
  const {
    top,
    right,
    bottom,
    left,
    width,
    height
  } = rect;
  const xThreshold = width * threshold;
  const yThreshold = height * threshold;
  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;
}
var ParentPositionTracker = class {
  _document;
  positions = /* @__PURE__ */ new Map();
  constructor(_document) {
    this._document = _document;
  }
  clear() {
    this.positions.clear();
  }
  cache(elements) {
    this.clear();
    this.positions.set(this._document, {
      scrollPosition: this.getViewportScrollPosition()
    });
    elements.forEach((element) => {
      this.positions.set(element, {
        scrollPosition: {
          top: element.scrollTop,
          left: element.scrollLeft
        },
        clientRect: getMutableClientRect(element)
      });
    });
  }
  handleScroll(event) {
    const target = _getEventTarget(event);
    const cachedPosition = this.positions.get(target);
    if (!cachedPosition) {
      return null;
    }
    const scrollPosition = cachedPosition.scrollPosition;
    let newTop;
    let newLeft;
    if (target === this._document) {
      const viewportScrollPosition = this.getViewportScrollPosition();
      newTop = viewportScrollPosition.top;
      newLeft = viewportScrollPosition.left;
    } else {
      newTop = target.scrollTop;
      newLeft = target.scrollLeft;
    }
    const topDifference = scrollPosition.top - newTop;
    const leftDifference = scrollPosition.left - newLeft;
    this.positions.forEach((position, node) => {
      if (position.clientRect && target !== node && target.contains(node)) {
        adjustDomRect(position.clientRect, topDifference, leftDifference);
      }
    });
    scrollPosition.top = newTop;
    scrollPosition.left = newLeft;
    return {
      top: topDifference,
      left: leftDifference
    };
  }
  getViewportScrollPosition() {
    return {
      top: window.scrollY,
      left: window.scrollX
    };
  }
};
function getRootNode(viewRef, _document) {
  const rootNodes = viewRef.rootNodes;
  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {
    return rootNodes[0];
  }
  const wrapper = _document.createElement("div");
  rootNodes.forEach((node) => wrapper.appendChild(node));
  return wrapper;
}
function extendStyles(dest, source, importantProperties2) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      const value = source[key];
      if (value) {
        dest.setProperty(key, value, importantProperties2?.has(key) ? "important" : "");
      } else {
        dest.removeProperty(key);
      }
    }
  }
  return dest;
}
function toggleNativeDragInteractions(element, enable) {
  const userSelect = enable ? "" : "none";
  extendStyles(element.style, {
    "touch-action": enable ? "" : "none",
    "-webkit-user-drag": enable ? "" : "none",
    "-webkit-tap-highlight-color": enable ? "" : "transparent",
    "user-select": userSelect,
    "-ms-user-select": userSelect,
    "-webkit-user-select": userSelect,
    "-moz-user-select": userSelect
  });
}
function toggleVisibility(element, enable, importantProperties2) {
  extendStyles(element.style, {
    position: enable ? "" : "fixed",
    top: enable ? "" : "0",
    opacity: enable ? "" : "0",
    left: enable ? "" : "-999em"
  }, importantProperties2);
}
function combineTransforms(transform, initialTransform) {
  return initialTransform && initialTransform != "none" ? transform + " " + initialTransform : transform;
}
function matchElementSize(target, sourceRect) {
  target.style.width = `${sourceRect.width}px`;
  target.style.height = `${sourceRect.height}px`;
  target.style.transform = getTransform(sourceRect.left, sourceRect.top);
}
function getTransform(x, y) {
  return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
}
function parseCssTimeUnitsToMs(value) {
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
function getTransformTransitionDurationInMs(element) {
  const computedStyle = getComputedStyle(element);
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const property = transitionedProperties.find((prop) => prop === "transform" || prop === "all");
  if (!property) {
    return 0;
  }
  const propertyIndex = transitionedProperties.indexOf(property);
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(",").map((part) => part.trim());
}
var importantProperties = /* @__PURE__ */ new Set(["position"]);
var PreviewRef = class {
  _document;
  _rootElement;
  _direction;
  _initialDomRect;
  _previewTemplate;
  _previewClass;
  _pickupPositionOnPage;
  _initialTransform;
  _zIndex;
  _renderer;
  _previewEmbeddedView;
  _preview;
  get element() {
    return this._preview;
  }
  constructor(_document, _rootElement, _direction, _initialDomRect, _previewTemplate, _previewClass, _pickupPositionOnPage, _initialTransform, _zIndex, _renderer) {
    this._document = _document;
    this._rootElement = _rootElement;
    this._direction = _direction;
    this._initialDomRect = _initialDomRect;
    this._previewTemplate = _previewTemplate;
    this._previewClass = _previewClass;
    this._pickupPositionOnPage = _pickupPositionOnPage;
    this._initialTransform = _initialTransform;
    this._zIndex = _zIndex;
    this._renderer = _renderer;
  }
  attach(parent) {
    this._preview = this._createPreview();
    parent.appendChild(this._preview);
    if (supportsPopover(this._preview)) {
      this._preview["showPopover"]();
    }
  }
  destroy() {
    this._preview.remove();
    this._previewEmbeddedView?.destroy();
    this._preview = this._previewEmbeddedView = null;
  }
  setTransform(value) {
    this._preview.style.transform = value;
  }
  getBoundingClientRect() {
    return this._preview.getBoundingClientRect();
  }
  addClass(className) {
    this._preview.classList.add(className);
  }
  getTransitionDuration() {
    return getTransformTransitionDurationInMs(this._preview);
  }
  addEventListener(name, handler) {
    return this._renderer.listen(this._preview, name, handler);
  }
  _createPreview() {
    const previewConfig = this._previewTemplate;
    const previewClass = this._previewClass;
    const previewTemplate = previewConfig ? previewConfig.template : null;
    let preview;
    if (previewTemplate && previewConfig) {
      const rootRect = previewConfig.matchSize ? this._initialDomRect : null;
      const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);
      viewRef.detectChanges();
      preview = getRootNode(viewRef, this._document);
      this._previewEmbeddedView = viewRef;
      if (previewConfig.matchSize) {
        matchElementSize(preview, rootRect);
      } else {
        preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
      }
    } else {
      preview = deepCloneNode(this._rootElement);
      matchElementSize(preview, this._initialDomRect);
      if (this._initialTransform) {
        preview.style.transform = this._initialTransform;
      }
    }
    extendStyles(preview.style, {
      "pointer-events": "none",
      "margin": supportsPopover(preview) ? "0 auto 0 0" : "0",
      "position": "fixed",
      "top": "0",
      "left": "0",
      "z-index": this._zIndex + ""
    }, importantProperties);
    toggleNativeDragInteractions(preview, false);
    preview.classList.add("cdk-drag-preview");
    preview.setAttribute("popover", "manual");
    preview.setAttribute("dir", this._direction);
    if (previewClass) {
      if (Array.isArray(previewClass)) {
        previewClass.forEach((className) => preview.classList.add(className));
      } else {
        preview.classList.add(previewClass);
      }
    }
    return preview;
  }
};
function supportsPopover(element) {
  return "showPopover" in element;
}
var passiveEventListenerOptions = {
  passive: true
};
var activeEventListenerOptions = {
  passive: false
};
var activeCapturingEventOptions$1 = {
  passive: false,
  capture: true
};
var MOUSE_EVENT_IGNORE_TIME = 800;
var PLACEHOLDER_CLASS = "cdk-drag-placeholder";
var dragImportantProperties = /* @__PURE__ */ new Set(["position"]);
var DragRef = class {
  _config;
  _document;
  _ngZone;
  _viewportRuler;
  _dragDropRegistry;
  _renderer;
  _rootElementCleanups;
  _cleanupShadowRootSelectStart;
  _preview;
  _previewContainer;
  _placeholderRef;
  _placeholder;
  _pickupPositionInElement;
  _pickupPositionOnPage;
  _marker;
  _anchor = null;
  _passiveTransform = {
    x: 0,
    y: 0
  };
  _activeTransform = {
    x: 0,
    y: 0
  };
  _initialTransform;
  _hasStartedDragging = signal(false, ...ngDevMode ? [{
    debugName: "_hasStartedDragging"
  }] : []);
  _hasMoved;
  _initialContainer;
  _initialIndex;
  _parentPositions;
  _moveEvents = new Subject();
  _pointerDirectionDelta;
  _pointerPositionAtLastDirectionChange;
  _lastKnownPointerPosition;
  _rootElement;
  _ownerSVGElement;
  _rootElementTapHighlight;
  _pointerMoveSubscription = Subscription.EMPTY;
  _pointerUpSubscription = Subscription.EMPTY;
  _scrollSubscription = Subscription.EMPTY;
  _resizeSubscription = Subscription.EMPTY;
  _lastTouchEventTime;
  _dragStartTime;
  _boundaryElement = null;
  _nativeInteractionsEnabled = true;
  _initialDomRect;
  _previewRect;
  _boundaryRect;
  _previewTemplate;
  _placeholderTemplate;
  _handles = [];
  _disabledHandles = /* @__PURE__ */ new Set();
  _dropContainer;
  _direction = "ltr";
  _parentDragRef;
  _cachedShadowRoot;
  lockAxis = null;
  dragStartDelay = 0;
  previewClass;
  scale = 1;
  get disabled() {
    return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
  }
  set disabled(value) {
    if (value !== this._disabled) {
      this._disabled = value;
      this._toggleNativeDragInteractions();
      this._handles.forEach((handle) => toggleNativeDragInteractions(handle, value));
    }
  }
  _disabled = false;
  beforeStarted = new Subject();
  started = new Subject();
  released = new Subject();
  ended = new Subject();
  entered = new Subject();
  exited = new Subject();
  dropped = new Subject();
  moved = this._moveEvents;
  data;
  constrainPosition;
  constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry, _renderer) {
    this._config = _config;
    this._document = _document;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._dragDropRegistry = _dragDropRegistry;
    this._renderer = _renderer;
    this.withRootElement(element).withParent(_config.parentDragRef || null);
    this._parentPositions = new ParentPositionTracker(_document);
    _dragDropRegistry.registerDragItem(this);
  }
  getPlaceholderElement() {
    return this._placeholder;
  }
  getRootElement() {
    return this._rootElement;
  }
  getVisibleElement() {
    return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
  }
  withHandles(handles) {
    this._handles = handles.map((handle) => coerceElement(handle));
    this._handles.forEach((handle) => toggleNativeDragInteractions(handle, this.disabled));
    this._toggleNativeDragInteractions();
    const disabledHandles = /* @__PURE__ */ new Set();
    this._disabledHandles.forEach((handle) => {
      if (this._handles.indexOf(handle) > -1) {
        disabledHandles.add(handle);
      }
    });
    this._disabledHandles = disabledHandles;
    return this;
  }
  withPreviewTemplate(template) {
    this._previewTemplate = template;
    return this;
  }
  withPlaceholderTemplate(template) {
    this._placeholderTemplate = template;
    return this;
  }
  withRootElement(rootElement) {
    const element = coerceElement(rootElement);
    if (element !== this._rootElement) {
      this._removeRootElementListeners();
      const renderer = this._renderer;
      this._rootElementCleanups = this._ngZone.runOutsideAngular(() => [renderer.listen(element, "mousedown", this._pointerDown, activeEventListenerOptions), renderer.listen(element, "touchstart", this._pointerDown, passiveEventListenerOptions), renderer.listen(element, "dragstart", this._nativeDragStart, activeEventListenerOptions)]);
      this._initialTransform = void 0;
      this._rootElement = element;
    }
    if (typeof SVGElement !== "undefined" && this._rootElement instanceof SVGElement) {
      this._ownerSVGElement = this._rootElement.ownerSVGElement;
    }
    return this;
  }
  withBoundaryElement(boundaryElement) {
    this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;
    this._resizeSubscription.unsubscribe();
    if (boundaryElement) {
      this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());
    }
    return this;
  }
  withParent(parent) {
    this._parentDragRef = parent;
    return this;
  }
  dispose() {
    this._removeRootElementListeners();
    if (this.isDragging()) {
      this._rootElement?.remove();
    }
    this._marker?.remove();
    this._destroyPreview();
    this._destroyPlaceholder();
    this._dragDropRegistry.removeDragItem(this);
    this._removeListeners();
    this.beforeStarted.complete();
    this.started.complete();
    this.released.complete();
    this.ended.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this._moveEvents.complete();
    this._handles = [];
    this._disabledHandles.clear();
    this._dropContainer = void 0;
    this._resizeSubscription.unsubscribe();
    this._parentPositions.clear();
    this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._marker = this._parentDragRef = null;
  }
  isDragging() {
    return this._hasStartedDragging() && this._dragDropRegistry.isDragging(this);
  }
  reset() {
    this._rootElement.style.transform = this._initialTransform || "";
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform = {
      x: 0,
      y: 0
    };
  }
  resetToBoundary() {
    if (this._boundaryElement && this._rootElement && isOverflowingParent(this._boundaryElement.getBoundingClientRect(), this._rootElement.getBoundingClientRect())) {
      const parentRect = this._boundaryElement.getBoundingClientRect();
      const childRect = this._rootElement.getBoundingClientRect();
      let offsetX = 0;
      let offsetY = 0;
      if (childRect.left < parentRect.left) {
        offsetX = parentRect.left - childRect.left;
      } else if (childRect.right > parentRect.right) {
        offsetX = parentRect.right - childRect.right;
      }
      if (childRect.top < parentRect.top) {
        offsetY = parentRect.top - childRect.top;
      } else if (childRect.bottom > parentRect.bottom) {
        offsetY = parentRect.bottom - childRect.bottom;
      }
      const currentLeft = this._activeTransform.x;
      const currentTop = this._activeTransform.y;
      let x = currentLeft + offsetX, y = currentTop + offsetY;
      this._rootElement.style.transform = getTransform(x, y);
      this._activeTransform = {
        x,
        y
      };
      this._passiveTransform = {
        x,
        y
      };
    }
  }
  disableHandle(handle) {
    if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {
      this._disabledHandles.add(handle);
      toggleNativeDragInteractions(handle, true);
    }
  }
  enableHandle(handle) {
    if (this._disabledHandles.has(handle)) {
      this._disabledHandles.delete(handle);
      toggleNativeDragInteractions(handle, this.disabled);
    }
  }
  withDirection(direction) {
    this._direction = direction;
    return this;
  }
  _withDropContainer(container) {
    this._dropContainer = container;
  }
  getFreeDragPosition() {
    const position = this.isDragging() ? this._activeTransform : this._passiveTransform;
    return {
      x: position.x,
      y: position.y
    };
  }
  setFreeDragPosition(value) {
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform.x = value.x;
    this._passiveTransform.y = value.y;
    if (!this._dropContainer) {
      this._applyRootElementTransform(value.x, value.y);
    }
    return this;
  }
  withPreviewContainer(value) {
    this._previewContainer = value;
    return this;
  }
  _sortFromLastPointerPosition() {
    const position = this._lastKnownPointerPosition;
    if (position && this._dropContainer) {
      this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);
    }
  }
  _removeListeners() {
    this._pointerMoveSubscription.unsubscribe();
    this._pointerUpSubscription.unsubscribe();
    this._scrollSubscription.unsubscribe();
    this._cleanupShadowRootSelectStart?.();
    this._cleanupShadowRootSelectStart = void 0;
  }
  _destroyPreview() {
    this._preview?.destroy();
    this._preview = null;
  }
  _destroyPlaceholder() {
    this._anchor?.remove();
    this._placeholder?.remove();
    this._placeholderRef?.destroy();
    this._placeholder = this._anchor = this._placeholderRef = null;
  }
  _pointerDown = (event) => {
    this.beforeStarted.next();
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        this._initializeDragSequence(targetHandle, event);
      }
    } else if (!this.disabled) {
      this._initializeDragSequence(this._rootElement, event);
    }
  };
  _pointerMove = (event) => {
    const pointerPosition = this._getPointerPositionOnPage(event);
    if (!this._hasStartedDragging()) {
      const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);
      const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);
      const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;
      if (isOverThreshold) {
        const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);
        const container = this._dropContainer;
        if (!isDelayElapsed) {
          this._endDragSequence(event);
          return;
        }
        if (!container || !container.isDragging() && !container.isReceiving()) {
          if (event.cancelable) {
            event.preventDefault();
          }
          this._hasStartedDragging.set(true);
          this._ngZone.run(() => this._startDragSequence(event));
        }
      }
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);
    this._hasMoved = true;
    this._lastKnownPointerPosition = pointerPosition;
    this._updatePointerDirectionDelta(constrainedPointerPosition);
    if (this._dropContainer) {
      this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);
    } else {
      const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;
      const activeTransform = this._activeTransform;
      activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;
      activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;
      this._applyRootElementTransform(activeTransform.x, activeTransform.y);
    }
    if (this._moveEvents.observers.length) {
      this._ngZone.run(() => {
        this._moveEvents.next({
          source: this,
          pointerPosition: constrainedPointerPosition,
          event,
          distance: this._getDragDistance(constrainedPointerPosition),
          delta: this._pointerDirectionDelta
        });
      });
    }
  };
  _pointerUp = (event) => {
    this._endDragSequence(event);
  };
  _endDragSequence(event) {
    if (!this._dragDropRegistry.isDragging(this)) {
      return;
    }
    this._removeListeners();
    this._dragDropRegistry.stopDragging(this);
    this._toggleNativeDragInteractions();
    if (this._handles) {
      this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;
    }
    if (!this._hasStartedDragging()) {
      return;
    }
    this.released.next({
      source: this,
      event
    });
    if (this._dropContainer) {
      this._dropContainer._stopScrolling();
      this._animatePreviewToPlaceholder().then(() => {
        this._cleanupDragArtifacts(event);
        this._cleanupCachedDimensions();
        this._dragDropRegistry.stopDragging(this);
      });
    } else {
      this._passiveTransform.x = this._activeTransform.x;
      const pointerPosition = this._getPointerPositionOnPage(event);
      this._passiveTransform.y = this._activeTransform.y;
      this._ngZone.run(() => {
        this.ended.next({
          source: this,
          distance: this._getDragDistance(pointerPosition),
          dropPoint: pointerPosition,
          event
        });
      });
      this._cleanupCachedDimensions();
      this._dragDropRegistry.stopDragging(this);
    }
  }
  _startDragSequence(event) {
    if (isTouchEvent(event)) {
      this._lastTouchEventTime = Date.now();
    }
    this._toggleNativeDragInteractions();
    const shadowRoot = this._getShadowRoot();
    const dropContainer = this._dropContainer;
    if (shadowRoot) {
      this._ngZone.runOutsideAngular(() => {
        this._cleanupShadowRootSelectStart = this._renderer.listen(shadowRoot, "selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
      });
    }
    if (dropContainer) {
      const element = this._rootElement;
      const parent = element.parentNode;
      const placeholder = this._placeholder = this._createPlaceholderElement();
      const marker = this._marker = this._marker || this._document.createComment(typeof ngDevMode === "undefined" || ngDevMode ? "cdk-drag-marker" : "");
      parent.insertBefore(marker, element);
      this._initialTransform = element.style.transform || "";
      this._preview = new PreviewRef(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1e3, this._renderer);
      this._preview.attach(this._getPreviewInsertionPoint(parent, shadowRoot));
      toggleVisibility(element, false, dragImportantProperties);
      this._document.body.appendChild(parent.replaceChild(placeholder, element));
      this.started.next({
        source: this,
        event
      });
      dropContainer.start();
      this._initialContainer = dropContainer;
      this._initialIndex = dropContainer.getItemIndex(this);
    } else {
      this.started.next({
        source: this,
        event
      });
      this._initialContainer = this._initialIndex = void 0;
    }
    this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);
  }
  _initializeDragSequence(referenceElement, event) {
    if (this._parentDragRef) {
      event.stopPropagation();
    }
    const isDragging = this.isDragging();
    const isTouchSequence = isTouchEvent(event);
    const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;
    const rootElement = this._rootElement;
    const target = _getEventTarget(event);
    const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();
    const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);
    if (target && target.draggable && event.type === "mousedown") {
      event.preventDefault();
    }
    if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {
      return;
    }
    if (this._handles.length) {
      const rootStyles = rootElement.style;
      this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || "";
      rootStyles.webkitTapHighlightColor = "transparent";
    }
    this._hasMoved = false;
    this._hasStartedDragging.set(this._hasMoved);
    this._removeListeners();
    this._initialDomRect = this._rootElement.getBoundingClientRect();
    this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);
    this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);
    this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((scrollEvent) => this._updateOnScroll(scrollEvent));
    if (this._boundaryElement) {
      this._boundaryRect = getMutableClientRect(this._boundaryElement);
    }
    const previewTemplate = this._previewTemplate;
    this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {
      x: 0,
      y: 0
    } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);
    const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);
    this._pointerDirectionDelta = {
      x: 0,
      y: 0
    };
    this._pointerPositionAtLastDirectionChange = {
      x: pointerPosition.x,
      y: pointerPosition.y
    };
    this._dragStartTime = Date.now();
    this._dragDropRegistry.startDragging(this, event);
  }
  _cleanupDragArtifacts(event) {
    toggleVisibility(this._rootElement, true, dragImportantProperties);
    this._marker.parentNode.replaceChild(this._rootElement, this._marker);
    this._destroyPreview();
    this._destroyPlaceholder();
    this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0;
    this._ngZone.run(() => {
      const container = this._dropContainer;
      const currentIndex = container.getItemIndex(this);
      const pointerPosition = this._getPointerPositionOnPage(event);
      const distance = this._getDragDistance(pointerPosition);
      const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);
      this.ended.next({
        source: this,
        distance,
        dropPoint: pointerPosition,
        event
      });
      this.dropped.next({
        item: this,
        currentIndex,
        previousIndex: this._initialIndex,
        container,
        previousContainer: this._initialContainer,
        isPointerOverContainer,
        distance,
        dropPoint: pointerPosition,
        event
      });
      container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);
      this._dropContainer = this._initialContainer;
    });
  }
  _updateActiveDropContainer({
    x,
    y
  }, {
    x: rawX,
    y: rawY
  }) {
    let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);
    if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x, y)) {
      newContainer = this._initialContainer;
    }
    if (newContainer && newContainer !== this._dropContainer) {
      this._ngZone.run(() => {
        const exitIndex = this._dropContainer.getItemIndex(this);
        const nextItemElement = this._dropContainer.getItemAtIndex(exitIndex + 1)?.getVisibleElement() || null;
        this.exited.next({
          item: this,
          container: this._dropContainer
        });
        this._dropContainer.exit(this);
        this._conditionallyInsertAnchor(newContainer, this._dropContainer, nextItemElement);
        this._dropContainer = newContainer;
        this._dropContainer.enter(this, x, y, newContainer === this._initialContainer && newContainer.sortingDisabled ? this._initialIndex : void 0);
        this.entered.next({
          item: this,
          container: newContainer,
          currentIndex: newContainer.getItemIndex(this)
        });
      });
    }
    if (this.isDragging()) {
      this._dropContainer._startScrollingIfNecessary(rawX, rawY);
      this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);
      if (this.constrainPosition) {
        this._applyPreviewTransform(x, y);
      } else {
        this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);
      }
    }
  }
  _animatePreviewToPlaceholder() {
    if (!this._hasMoved) {
      return Promise.resolve();
    }
    const placeholderRect = this._placeholder.getBoundingClientRect();
    this._preview.addClass("cdk-drag-animating");
    this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);
    const duration = this._preview.getTransitionDuration();
    if (duration === 0) {
      return Promise.resolve();
    }
    return this._ngZone.runOutsideAngular(() => {
      return new Promise((resolve) => {
        const handler = (event) => {
          if (!event || this._preview && _getEventTarget(event) === this._preview.element && event.propertyName === "transform") {
            cleanupListener();
            resolve();
            clearTimeout(timeout);
          }
        };
        const timeout = setTimeout(handler, duration * 1.5);
        const cleanupListener = this._preview.addEventListener("transitionend", handler);
      });
    });
  }
  _createPlaceholderElement() {
    const placeholderConfig = this._placeholderTemplate;
    const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;
    let placeholder;
    if (placeholderTemplate) {
      this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);
      this._placeholderRef.detectChanges();
      placeholder = getRootNode(this._placeholderRef, this._document);
    } else {
      placeholder = deepCloneNode(this._rootElement);
    }
    placeholder.style.pointerEvents = "none";
    placeholder.classList.add(PLACEHOLDER_CLASS);
    return placeholder;
  }
  _getPointerPositionInElement(elementRect, referenceElement, event) {
    const handleElement = referenceElement === this._rootElement ? null : referenceElement;
    const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;
    const point = isTouchEvent(event) ? event.targetTouches[0] : event;
    const scrollPosition = this._getViewportScrollPosition();
    const x = point.pageX - referenceRect.left - scrollPosition.left;
    const y = point.pageY - referenceRect.top - scrollPosition.top;
    return {
      x: referenceRect.left - elementRect.left + x,
      y: referenceRect.top - elementRect.top + y
    };
  }
  _getPointerPositionOnPage(event) {
    const scrollPosition = this._getViewportScrollPosition();
    const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] || {
      pageX: 0,
      pageY: 0
    } : event;
    const x = point.pageX - scrollPosition.left;
    const y = point.pageY - scrollPosition.top;
    if (this._ownerSVGElement) {
      const svgMatrix = this._ownerSVGElement.getScreenCTM();
      if (svgMatrix) {
        const svgPoint = this._ownerSVGElement.createSVGPoint();
        svgPoint.x = x;
        svgPoint.y = y;
        return svgPoint.matrixTransform(svgMatrix.inverse());
      }
    }
    return {
      x,
      y
    };
  }
  _getConstrainedPointerPosition(point) {
    const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;
    let {
      x,
      y
    } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;
    if (this.lockAxis === "x" || dropContainerLock === "x") {
      y = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);
    } else if (this.lockAxis === "y" || dropContainerLock === "y") {
      x = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);
    }
    if (this._boundaryRect) {
      const {
        x: pickupX,
        y: pickupY
      } = !this.constrainPosition ? this._pickupPositionInElement : {
        x: 0,
        y: 0
      };
      const boundaryRect = this._boundaryRect;
      const {
        width: previewWidth,
        height: previewHeight
      } = this._getPreviewRect();
      const minY = boundaryRect.top + pickupY;
      const maxY = boundaryRect.bottom - (previewHeight - pickupY);
      const minX = boundaryRect.left + pickupX;
      const maxX = boundaryRect.right - (previewWidth - pickupX);
      x = clamp$1(x, minX, maxX);
      y = clamp$1(y, minY, maxY);
    }
    return {
      x,
      y
    };
  }
  _updatePointerDirectionDelta(pointerPositionOnPage) {
    const {
      x,
      y
    } = pointerPositionOnPage;
    const delta = this._pointerDirectionDelta;
    const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;
    const changeX = Math.abs(x - positionSinceLastChange.x);
    const changeY = Math.abs(y - positionSinceLastChange.y);
    if (changeX > this._config.pointerDirectionChangeThreshold) {
      delta.x = x > positionSinceLastChange.x ? 1 : -1;
      positionSinceLastChange.x = x;
    }
    if (changeY > this._config.pointerDirectionChangeThreshold) {
      delta.y = y > positionSinceLastChange.y ? 1 : -1;
      positionSinceLastChange.y = y;
    }
    return delta;
  }
  _toggleNativeDragInteractions() {
    if (!this._rootElement || !this._handles) {
      return;
    }
    const shouldEnable = this._handles.length > 0 || !this.isDragging();
    if (shouldEnable !== this._nativeInteractionsEnabled) {
      this._nativeInteractionsEnabled = shouldEnable;
      toggleNativeDragInteractions(this._rootElement, shouldEnable);
    }
  }
  _removeRootElementListeners() {
    this._rootElementCleanups?.forEach((cleanup) => cleanup());
    this._rootElementCleanups = void 0;
  }
  _applyRootElementTransform(x, y) {
    const scale = 1 / this.scale;
    const transform = getTransform(x * scale, y * scale);
    const styles = this._rootElement.style;
    if (this._initialTransform == null) {
      this._initialTransform = styles.transform && styles.transform != "none" ? styles.transform : "";
    }
    styles.transform = combineTransforms(transform, this._initialTransform);
  }
  _applyPreviewTransform(x, y) {
    const initialTransform = this._previewTemplate?.template ? void 0 : this._initialTransform;
    const transform = getTransform(x, y);
    this._preview.setTransform(combineTransforms(transform, initialTransform));
  }
  _getDragDistance(currentPosition) {
    const pickupPosition = this._pickupPositionOnPage;
    if (pickupPosition) {
      return {
        x: currentPosition.x - pickupPosition.x,
        y: currentPosition.y - pickupPosition.y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  _cleanupCachedDimensions() {
    this._boundaryRect = this._previewRect = void 0;
    this._parentPositions.clear();
  }
  _containInsideBoundaryOnResize() {
    let {
      x,
      y
    } = this._passiveTransform;
    if (x === 0 && y === 0 || this.isDragging() || !this._boundaryElement) {
      return;
    }
    const elementRect = this._rootElement.getBoundingClientRect();
    const boundaryRect = this._boundaryElement.getBoundingClientRect();
    if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {
      return;
    }
    const leftOverflow = boundaryRect.left - elementRect.left;
    const rightOverflow = elementRect.right - boundaryRect.right;
    const topOverflow = boundaryRect.top - elementRect.top;
    const bottomOverflow = elementRect.bottom - boundaryRect.bottom;
    if (boundaryRect.width > elementRect.width) {
      if (leftOverflow > 0) {
        x += leftOverflow;
      }
      if (rightOverflow > 0) {
        x -= rightOverflow;
      }
    } else {
      x = 0;
    }
    if (boundaryRect.height > elementRect.height) {
      if (topOverflow > 0) {
        y += topOverflow;
      }
      if (bottomOverflow > 0) {
        y -= bottomOverflow;
      }
    } else {
      y = 0;
    }
    if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {
      this.setFreeDragPosition({
        y,
        x
      });
    }
  }
  _getDragStartDelay(event) {
    const value = this.dragStartDelay;
    if (typeof value === "number") {
      return value;
    } else if (isTouchEvent(event)) {
      return value.touch;
    }
    return value ? value.mouse : 0;
  }
  _updateOnScroll(event) {
    const scrollDifference = this._parentPositions.handleScroll(event);
    if (scrollDifference) {
      const target = _getEventTarget(event);
      if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {
        adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);
      }
      this._pickupPositionOnPage.x += scrollDifference.left;
      this._pickupPositionOnPage.y += scrollDifference.top;
      if (!this._dropContainer) {
        this._activeTransform.x -= scrollDifference.left;
        this._activeTransform.y -= scrollDifference.top;
        this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);
      }
    }
  }
  _getViewportScrollPosition() {
    return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
  }
  _getShadowRoot() {
    if (this._cachedShadowRoot === void 0) {
      this._cachedShadowRoot = _getShadowRoot(this._rootElement);
    }
    return this._cachedShadowRoot;
  }
  _getPreviewInsertionPoint(initialParent, shadowRoot) {
    const previewContainer = this._previewContainer || "global";
    if (previewContainer === "parent") {
      return initialParent;
    }
    if (previewContainer === "global") {
      const documentRef = this._document;
      return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;
    }
    return coerceElement(previewContainer);
  }
  _getPreviewRect() {
    if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {
      this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;
    }
    return this._previewRect;
  }
  _nativeDragStart = (event) => {
    if (this._handles.length) {
      const targetHandle = this._getTargetHandle(event);
      if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
        event.preventDefault();
      }
    } else if (!this.disabled) {
      event.preventDefault();
    }
  };
  _getTargetHandle(event) {
    return this._handles.find((handle) => {
      return event.target && (event.target === handle || handle.contains(event.target));
    });
  }
  _conditionallyInsertAnchor(newContainer, exitContainer, nextItemElement) {
    if (newContainer === this._initialContainer) {
      this._anchor?.remove();
      this._anchor = null;
    } else if (exitContainer === this._initialContainer && exitContainer.hasAnchor) {
      const anchor = this._anchor ??= deepCloneNode(this._placeholder);
      anchor.classList.remove(PLACEHOLDER_CLASS);
      anchor.classList.add("cdk-drag-anchor");
      anchor.style.transform = "";
      if (nextItemElement) {
        nextItemElement.before(anchor);
      } else {
        coerceElement(exitContainer.element).appendChild(anchor);
      }
    }
  }
};
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function isTouchEvent(event) {
  return event.type[0] === "t";
}
function shadowDomSelectStart(event) {
  event.preventDefault();
}
function moveItemInArray(array, fromIndex, toIndex) {
  const from = clamp(fromIndex, array.length - 1);
  const to = clamp(toIndex, array.length - 1);
  if (from === to) {
    return;
  }
  const target = array[from];
  const delta = to < from ? -1 : 1;
  for (let i = from; i !== to; i += delta) {
    array[i] = array[i + delta];
  }
  array[to] = target;
}
function clamp(value, max) {
  return Math.max(0, Math.min(max, value));
}
var SingleAxisSortStrategy = class {
  _dragDropRegistry;
  _element;
  _sortPredicate;
  _itemPositions = [];
  _activeDraggables;
  orientation = "vertical";
  direction;
  constructor(_dragDropRegistry) {
    this._dragDropRegistry = _dragDropRegistry;
  }
  _previousSwap = {
    drag: null,
    delta: 0,
    overlaps: false
  };
  start(items) {
    this.withItems(items);
  }
  sort(item, pointerX, pointerY, pointerDelta) {
    const siblings = this._itemPositions;
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);
    if (newIndex === -1 && siblings.length > 0) {
      return null;
    }
    const isHorizontal = this.orientation === "horizontal";
    const currentIndex = siblings.findIndex((currentItem) => currentItem.drag === item);
    const siblingAtNewPosition = siblings[newIndex];
    const currentPosition = siblings[currentIndex].clientRect;
    const newPosition = siblingAtNewPosition.clientRect;
    const delta = currentIndex > newIndex ? 1 : -1;
    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);
    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);
    const oldOrder = siblings.slice();
    moveItemInArray(siblings, currentIndex, newIndex);
    siblings.forEach((sibling, index) => {
      if (oldOrder[index] === sibling) {
        return;
      }
      const isDraggedItem = sibling.drag === item;
      const offset = isDraggedItem ? itemOffset : siblingOffset;
      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();
      sibling.offset += offset;
      const transformAmount = Math.round(sibling.offset * (1 / sibling.drag.scale));
      if (isHorizontal) {
        elementToOffset.style.transform = combineTransforms(`translate3d(${transformAmount}px, 0, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, 0, offset);
      } else {
        elementToOffset.style.transform = combineTransforms(`translate3d(0, ${transformAmount}px, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, offset, 0);
      }
    });
    this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);
    this._previousSwap.drag = siblingAtNewPosition.drag;
    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;
    return {
      previousIndex: currentIndex,
      currentIndex: newIndex
    };
  }
  enter(item, pointerX, pointerY, index) {
    const newIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;
    const activeDraggables = this._activeDraggables;
    const currentIndex = activeDraggables.indexOf(item);
    const placeholder = item.getPlaceholderElement();
    let newPositionReference = activeDraggables[newIndex];
    if (newPositionReference === item) {
      newPositionReference = activeDraggables[newIndex + 1];
    }
    if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {
      newPositionReference = activeDraggables[0];
    }
    if (currentIndex > -1) {
      activeDraggables.splice(currentIndex, 1);
    }
    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {
      const element = newPositionReference.getRootElement();
      element.parentElement.insertBefore(placeholder, element);
      activeDraggables.splice(newIndex, 0, item);
    } else {
      this._element.appendChild(placeholder);
      activeDraggables.push(item);
    }
    placeholder.style.transform = "";
    this._cacheItemPositions();
  }
  withItems(items) {
    this._activeDraggables = items.slice();
    this._cacheItemPositions();
  }
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  reset() {
    this._activeDraggables?.forEach((item) => {
      const rootElement = item.getRootElement();
      if (rootElement) {
        const initialTransform = this._itemPositions.find((p2) => p2.drag === item)?.initialTransform;
        rootElement.style.transform = initialTransform || "";
      }
    });
    this._itemPositions = [];
    this._activeDraggables = [];
    this._previousSwap.drag = null;
    this._previousSwap.delta = 0;
    this._previousSwap.overlaps = false;
  }
  getActiveItemsSnapshot() {
    return this._activeDraggables;
  }
  getItemIndex(item) {
    return this._getVisualItemPositions().findIndex((currentItem) => currentItem.drag === item);
  }
  getItemAtIndex(index) {
    return this._getVisualItemPositions()[index]?.drag || null;
  }
  updateOnScroll(topDifference, leftDifference) {
    this._itemPositions.forEach(({
      clientRect
    }) => {
      adjustDomRect(clientRect, topDifference, leftDifference);
    });
    this._itemPositions.forEach(({
      drag
    }) => {
      if (this._dragDropRegistry.isDragging(drag)) {
        drag._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    this._element = container;
  }
  _cacheItemPositions() {
    const isHorizontal = this.orientation === "horizontal";
    this._itemPositions = this._activeDraggables.map((drag) => {
      const elementToMeasure = drag.getVisibleElement();
      return {
        drag,
        offset: 0,
        initialTransform: elementToMeasure.style.transform || "",
        clientRect: getMutableClientRect(elementToMeasure)
      };
    }).sort((a, b2) => {
      return isHorizontal ? a.clientRect.left - b2.clientRect.left : a.clientRect.top - b2.clientRect.top;
    });
  }
  _getVisualItemPositions() {
    return this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions;
  }
  _getItemOffsetPx(currentPosition, newPosition, delta) {
    const isHorizontal = this.orientation === "horizontal";
    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;
    if (delta === -1) {
      itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;
    }
    return itemOffset;
  }
  _getSiblingOffsetPx(currentIndex, siblings, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const currentPosition = siblings[currentIndex].clientRect;
    const immediateSibling = siblings[currentIndex + delta * -1];
    let siblingOffset = currentPosition[isHorizontal ? "width" : "height"] * delta;
    if (immediateSibling) {
      const start = isHorizontal ? "left" : "top";
      const end = isHorizontal ? "right" : "bottom";
      if (delta === -1) {
        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];
      } else {
        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];
      }
    }
    return siblingOffset;
  }
  _shouldEnterAsFirstChild(pointerX, pointerY) {
    if (!this._activeDraggables.length) {
      return false;
    }
    const itemPositions = this._itemPositions;
    const isHorizontal = this.orientation === "horizontal";
    const reversed = itemPositions[0].drag !== this._activeDraggables[0];
    if (reversed) {
      const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;
      return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;
    } else {
      const firstItemRect = itemPositions[0].clientRect;
      return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;
    }
  }
  _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const index = this._itemPositions.findIndex(({
      drag,
      clientRect
    }) => {
      if (drag === item) {
        return false;
      }
      if (delta) {
        const direction = isHorizontal ? delta.x : delta.y;
        if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {
          return false;
        }
      }
      return isHorizontal ? pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);
    });
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
};
var MixedSortStrategy = class {
  _document;
  _dragDropRegistry;
  _element;
  _sortPredicate;
  _rootNode;
  _activeItems;
  _previousSwap = {
    drag: null,
    deltaX: 0,
    deltaY: 0,
    overlaps: false
  };
  _relatedNodes = [];
  constructor(_document, _dragDropRegistry) {
    this._document = _document;
    this._dragDropRegistry = _dragDropRegistry;
  }
  start(items) {
    const childNodes = this._element.childNodes;
    this._relatedNodes = [];
    for (let i = 0; i < childNodes.length; i++) {
      const node = childNodes[i];
      this._relatedNodes.push([node, node.nextSibling]);
    }
    this.withItems(items);
  }
  sort(item, pointerX, pointerY, pointerDelta) {
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);
    const previousSwap = this._previousSwap;
    if (newIndex === -1 || this._activeItems[newIndex] === item) {
      return null;
    }
    const toSwapWith = this._activeItems[newIndex];
    if (previousSwap.drag === toSwapWith && previousSwap.overlaps && previousSwap.deltaX === pointerDelta.x && previousSwap.deltaY === pointerDelta.y) {
      return null;
    }
    const previousIndex = this.getItemIndex(item);
    const current = item.getPlaceholderElement();
    const overlapElement = toSwapWith.getRootElement();
    if (newIndex > previousIndex) {
      overlapElement.after(current);
    } else {
      overlapElement.before(current);
    }
    moveItemInArray(this._activeItems, previousIndex, newIndex);
    const newOverlapElement = this._getRootNode().elementFromPoint(pointerX, pointerY);
    previousSwap.deltaX = pointerDelta.x;
    previousSwap.deltaY = pointerDelta.y;
    previousSwap.drag = toSwapWith;
    previousSwap.overlaps = overlapElement === newOverlapElement || overlapElement.contains(newOverlapElement);
    return {
      previousIndex,
      currentIndex: newIndex
    };
  }
  enter(item, pointerX, pointerY, index) {
    const currentIndex = this._activeItems.indexOf(item);
    if (currentIndex > -1) {
      this._activeItems.splice(currentIndex, 1);
    }
    let enterIndex = index == null || index < 0 ? this._getItemIndexFromPointerPosition(item, pointerX, pointerY) : index;
    if (enterIndex === -1) {
      enterIndex = this._getClosestItemIndexToPointer(item, pointerX, pointerY);
    }
    const targetItem = this._activeItems[enterIndex];
    if (targetItem && !this._dragDropRegistry.isDragging(targetItem)) {
      this._activeItems.splice(enterIndex, 0, item);
      targetItem.getRootElement().before(item.getPlaceholderElement());
    } else {
      this._activeItems.push(item);
      this._element.appendChild(item.getPlaceholderElement());
    }
  }
  withItems(items) {
    this._activeItems = items.slice();
  }
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  reset() {
    const root = this._element;
    const previousSwap = this._previousSwap;
    for (let i = this._relatedNodes.length - 1; i > -1; i--) {
      const [node, nextSibling] = this._relatedNodes[i];
      if (node.parentNode === root && node.nextSibling !== nextSibling) {
        if (nextSibling === null) {
          root.appendChild(node);
        } else if (nextSibling.parentNode === root) {
          root.insertBefore(node, nextSibling);
        }
      }
    }
    this._relatedNodes = [];
    this._activeItems = [];
    previousSwap.drag = null;
    previousSwap.deltaX = previousSwap.deltaY = 0;
    previousSwap.overlaps = false;
  }
  getActiveItemsSnapshot() {
    return this._activeItems;
  }
  getItemIndex(item) {
    return this._activeItems.indexOf(item);
  }
  getItemAtIndex(index) {
    return this._activeItems[index] || null;
  }
  updateOnScroll() {
    this._activeItems.forEach((item) => {
      if (this._dragDropRegistry.isDragging(item)) {
        item._sortFromLastPointerPosition();
      }
    });
  }
  withElementContainer(container) {
    if (container !== this._element) {
      this._element = container;
      this._rootNode = void 0;
    }
  }
  _getItemIndexFromPointerPosition(item, pointerX, pointerY) {
    const elementAtPoint = this._getRootNode().elementFromPoint(Math.floor(pointerX), Math.floor(pointerY));
    const index = elementAtPoint ? this._activeItems.findIndex((item2) => {
      const root = item2.getRootElement();
      return elementAtPoint === root || root.contains(elementAtPoint);
    }) : -1;
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
  _getRootNode() {
    if (!this._rootNode) {
      this._rootNode = _getShadowRoot(this._element) || this._document;
    }
    return this._rootNode;
  }
  _getClosestItemIndexToPointer(item, pointerX, pointerY) {
    if (this._activeItems.length === 0) {
      return -1;
    }
    if (this._activeItems.length === 1) {
      return 0;
    }
    let minDistance = Infinity;
    let minIndex = -1;
    for (let i = 0; i < this._activeItems.length; i++) {
      const current = this._activeItems[i];
      if (current !== item) {
        const {
          x,
          y
        } = current.getRootElement().getBoundingClientRect();
        const distance = Math.hypot(pointerX - x, pointerY - y);
        if (distance < minDistance) {
          minDistance = distance;
          minIndex = i;
        }
      }
    }
    return minIndex;
  }
};
var DROP_PROXIMITY_THRESHOLD = 0.05;
var SCROLL_PROXIMITY_THRESHOLD = 0.05;
var AutoScrollVerticalDirection;
(function(AutoScrollVerticalDirection2) {
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["NONE"] = 0] = "NONE";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["UP"] = 1] = "UP";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["DOWN"] = 2] = "DOWN";
})(AutoScrollVerticalDirection || (AutoScrollVerticalDirection = {}));
var AutoScrollHorizontalDirection;
(function(AutoScrollHorizontalDirection2) {
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["NONE"] = 0] = "NONE";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["LEFT"] = 1] = "LEFT";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["RIGHT"] = 2] = "RIGHT";
})(AutoScrollHorizontalDirection || (AutoScrollHorizontalDirection = {}));
var DropListRef = class {
  _dragDropRegistry;
  _ngZone;
  _viewportRuler;
  element;
  disabled = false;
  sortingDisabled = false;
  lockAxis = null;
  autoScrollDisabled = false;
  autoScrollStep = 2;
  hasAnchor = false;
  enterPredicate = () => true;
  sortPredicate = () => true;
  beforeStarted = new Subject();
  entered = new Subject();
  exited = new Subject();
  dropped = new Subject();
  sorted = new Subject();
  receivingStarted = new Subject();
  receivingStopped = new Subject();
  data;
  _container;
  _isDragging = false;
  _parentPositions;
  _sortStrategy;
  _domRect;
  _draggables = [];
  _siblings = [];
  _activeSiblings = /* @__PURE__ */ new Set();
  _viewportScrollSubscription = Subscription.EMPTY;
  _verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  _horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  _scrollNode;
  _stopScrollTimers = new Subject();
  _cachedShadowRoot = null;
  _document;
  _scrollableElements = [];
  _initialScrollSnap;
  _direction = "ltr";
  constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {
    this._dragDropRegistry = _dragDropRegistry;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    const coercedElement = this.element = coerceElement(element);
    this._document = _document;
    this.withOrientation("vertical").withElementContainer(coercedElement);
    _dragDropRegistry.registerDropContainer(this);
    this._parentPositions = new ParentPositionTracker(_document);
  }
  dispose() {
    this._stopScrolling();
    this._stopScrollTimers.complete();
    this._viewportScrollSubscription.unsubscribe();
    this.beforeStarted.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this.sorted.complete();
    this.receivingStarted.complete();
    this.receivingStopped.complete();
    this._activeSiblings.clear();
    this._scrollNode = null;
    this._parentPositions.clear();
    this._dragDropRegistry.removeDropContainer(this);
  }
  isDragging() {
    return this._isDragging;
  }
  start() {
    this._draggingStarted();
    this._notifyReceivingSiblings();
  }
  enter(item, pointerX, pointerY, index) {
    this._draggingStarted();
    if (index == null && this.sortingDisabled) {
      index = this._draggables.indexOf(item);
    }
    this._sortStrategy.enter(item, pointerX, pointerY, index);
    this._cacheParentPositions();
    this._notifyReceivingSiblings();
    this.entered.next({
      item,
      container: this,
      currentIndex: this.getItemIndex(item)
    });
  }
  exit(item) {
    this._reset();
    this.exited.next({
      item,
      container: this
    });
  }
  drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {
    this._reset();
    this.dropped.next({
      item,
      currentIndex,
      previousIndex,
      container: this,
      previousContainer,
      isPointerOverContainer,
      distance,
      dropPoint,
      event
    });
  }
  withItems(items) {
    const previousItems = this._draggables;
    this._draggables = items;
    items.forEach((item) => item._withDropContainer(this));
    if (this.isDragging()) {
      const draggedItems = previousItems.filter((item) => item.isDragging());
      if (draggedItems.every((item) => items.indexOf(item) === -1)) {
        this._reset();
      } else {
        this._sortStrategy.withItems(this._draggables);
      }
    }
    return this;
  }
  withDirection(direction) {
    this._direction = direction;
    if (this._sortStrategy instanceof SingleAxisSortStrategy) {
      this._sortStrategy.direction = direction;
    }
    return this;
  }
  connectedTo(connectedTo) {
    this._siblings = connectedTo.slice();
    return this;
  }
  withOrientation(orientation) {
    if (orientation === "mixed") {
      this._sortStrategy = new MixedSortStrategy(this._document, this._dragDropRegistry);
    } else {
      const strategy = new SingleAxisSortStrategy(this._dragDropRegistry);
      strategy.direction = this._direction;
      strategy.orientation = orientation;
      this._sortStrategy = strategy;
    }
    this._sortStrategy.withElementContainer(this._container);
    this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));
    return this;
  }
  withScrollableParents(elements) {
    const element = this._container;
    this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();
    return this;
  }
  withElementContainer(container) {
    if (container === this._container) {
      return this;
    }
    const element = coerceElement(this.element);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && container !== element && !element.contains(container)) {
      throw new Error("Invalid DOM structure for drop list. Alternate container element must be a descendant of the drop list.");
    }
    const oldContainerIndex = this._scrollableElements.indexOf(this._container);
    const newContainerIndex = this._scrollableElements.indexOf(container);
    if (oldContainerIndex > -1) {
      this._scrollableElements.splice(oldContainerIndex, 1);
    }
    if (newContainerIndex > -1) {
      this._scrollableElements.splice(newContainerIndex, 1);
    }
    if (this._sortStrategy) {
      this._sortStrategy.withElementContainer(container);
    }
    this._cachedShadowRoot = null;
    this._scrollableElements.unshift(container);
    this._container = container;
    return this;
  }
  getScrollableParents() {
    return this._scrollableElements;
  }
  getItemIndex(item) {
    return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);
  }
  getItemAtIndex(index) {
    return this._isDragging ? this._sortStrategy.getItemAtIndex(index) : this._draggables[index] || null;
  }
  isReceiving() {
    return this._activeSiblings.size > 0;
  }
  _sortItem(item, pointerX, pointerY, pointerDelta) {
    if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
      return;
    }
    const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);
    if (result) {
      this.sorted.next({
        previousIndex: result.previousIndex,
        currentIndex: result.currentIndex,
        container: this,
        item
      });
    }
  }
  _startScrollingIfNecessary(pointerX, pointerY) {
    if (this.autoScrollDisabled) {
      return;
    }
    let scrollNode;
    let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
    let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
    this._parentPositions.positions.forEach((position, element) => {
      if (element === this._document || !position.clientRect || scrollNode) {
        return;
      }
      if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
        [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._direction, pointerX, pointerY);
        if (verticalScrollDirection || horizontalScrollDirection) {
          scrollNode = element;
        }
      }
    });
    if (!verticalScrollDirection && !horizontalScrollDirection) {
      const {
        width,
        height
      } = this._viewportRuler.getViewportSize();
      const domRect = {
        width,
        height,
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
      verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);
      horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);
      scrollNode = window;
    }
    if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {
      this._verticalScrollDirection = verticalScrollDirection;
      this._horizontalScrollDirection = horizontalScrollDirection;
      this._scrollNode = scrollNode;
      if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {
        this._ngZone.runOutsideAngular(this._startScrollInterval);
      } else {
        this._stopScrolling();
      }
    }
  }
  _stopScrolling() {
    this._stopScrollTimers.next();
  }
  _draggingStarted() {
    const styles = this._container.style;
    this.beforeStarted.next();
    this._isDragging = true;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && this._container !== coerceElement(this.element)) {
      for (const drag of this._draggables) {
        if (!drag.isDragging() && drag.getVisibleElement().parentNode !== this._container) {
          throw new Error("Invalid DOM structure for drop list. All items must be placed directly inside of the element container.");
        }
      }
    }
    this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || "";
    styles.scrollSnapType = styles.msScrollSnapType = "none";
    this._sortStrategy.start(this._draggables);
    this._cacheParentPositions();
    this._viewportScrollSubscription.unsubscribe();
    this._listenToScrollEvents();
  }
  _cacheParentPositions() {
    this._parentPositions.cache(this._scrollableElements);
    this._domRect = this._parentPositions.positions.get(this._container).clientRect;
  }
  _reset() {
    this._isDragging = false;
    const styles = this._container.style;
    styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;
    this._siblings.forEach((sibling) => sibling._stopReceiving(this));
    this._sortStrategy.reset();
    this._stopScrolling();
    this._viewportScrollSubscription.unsubscribe();
    this._parentPositions.clear();
  }
  _startScrollInterval = () => {
    this._stopScrolling();
    interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {
      const node = this._scrollNode;
      const scrollStep = this.autoScrollStep;
      if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {
        node.scrollBy(0, -scrollStep);
      } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {
        node.scrollBy(0, scrollStep);
      }
      if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {
        node.scrollBy(-scrollStep, 0);
      } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {
        node.scrollBy(scrollStep, 0);
      }
    });
  };
  _isOverContainer(x, y) {
    return this._domRect != null && isInsideClientRect(this._domRect, x, y);
  }
  _getSiblingContainerFromPosition(item, x, y) {
    return this._siblings.find((sibling) => sibling._canReceive(item, x, y));
  }
  _canReceive(item, x, y) {
    if (!this._domRect || !isInsideClientRect(this._domRect, x, y) || !this.enterPredicate(item, this)) {
      return false;
    }
    const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);
    if (!elementFromPoint) {
      return false;
    }
    return elementFromPoint === this._container || this._container.contains(elementFromPoint);
  }
  _startReceiving(sibling, items) {
    const activeSiblings = this._activeSiblings;
    if (!activeSiblings.has(sibling) && items.every((item) => {
      return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;
    })) {
      activeSiblings.add(sibling);
      this._cacheParentPositions();
      this._listenToScrollEvents();
      this.receivingStarted.next({
        initiator: sibling,
        receiver: this,
        items
      });
    }
  }
  _stopReceiving(sibling) {
    this._activeSiblings.delete(sibling);
    this._viewportScrollSubscription.unsubscribe();
    this.receivingStopped.next({
      initiator: sibling,
      receiver: this
    });
  }
  _listenToScrollEvents() {
    this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((event) => {
      if (this.isDragging()) {
        const scrollDifference = this._parentPositions.handleScroll(event);
        if (scrollDifference) {
          this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);
        }
      } else if (this.isReceiving()) {
        this._cacheParentPositions();
      }
    });
  }
  _getShadowRoot() {
    if (!this._cachedShadowRoot) {
      const shadowRoot = _getShadowRoot(this._container);
      this._cachedShadowRoot = shadowRoot || this._document;
    }
    return this._cachedShadowRoot;
  }
  _notifyReceivingSiblings() {
    const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter((item) => item.isDragging());
    this._siblings.forEach((sibling) => sibling._startReceiving(this, draggedItems));
  }
};
function getVerticalScrollDirection(clientRect, pointerY) {
  const {
    top,
    bottom,
    height
  } = clientRect;
  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {
    return AutoScrollVerticalDirection.UP;
  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
    return AutoScrollVerticalDirection.DOWN;
  }
  return AutoScrollVerticalDirection.NONE;
}
function getHorizontalScrollDirection(clientRect, pointerX) {
  const {
    left,
    right,
    width
  } = clientRect;
  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
    return AutoScrollHorizontalDirection.LEFT;
  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
    return AutoScrollHorizontalDirection.RIGHT;
  }
  return AutoScrollHorizontalDirection.NONE;
}
function getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {
  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);
  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);
  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  if (computedVertical) {
    const scrollTop = element.scrollTop;
    if (computedVertical === AutoScrollVerticalDirection.UP) {
      if (scrollTop > 0) {
        verticalScrollDirection = AutoScrollVerticalDirection.UP;
      }
    } else if (element.scrollHeight - scrollTop > element.clientHeight) {
      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;
    }
  }
  if (computedHorizontal) {
    const scrollLeft = element.scrollLeft;
    if (direction === "rtl") {
      if (computedHorizontal === AutoScrollHorizontalDirection.RIGHT) {
        if (scrollLeft < 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
        }
      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
      }
    } else {
      if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {
        if (scrollLeft > 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
        }
      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
      }
    }
  }
  return [verticalScrollDirection, horizontalScrollDirection];
}
var capturingEventOptions = {
  capture: true
};
var activeCapturingEventOptions = {
  passive: false,
  capture: true
};
var _ResetsLoader = class __ResetsLoader {
  static \u0275fac = function _ResetsLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __ResetsLoader)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: __ResetsLoader,
    selectors: [["ng-component"]],
    hostAttrs: ["cdk-drag-resets-container", ""],
    decls: 0,
    vars: 0,
    template: function _ResetsLoader_Template(rf, ctx) {
    },
    styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_ResetsLoader, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "cdk-drag-resets-container": ""
      },
      styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}\n"]
    }]
  }], null, null);
})();
var DragDropRegistry = class _DragDropRegistry {
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _styleLoader = inject(_CdkPrivateStyleLoader);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupDocumentTouchmove;
  _scroll = new Subject();
  _dropInstances = /* @__PURE__ */ new Set();
  _dragInstances = /* @__PURE__ */ new Set();
  _activeDragInstances = signal([], ...ngDevMode ? [{
    debugName: "_activeDragInstances"
  }] : []);
  _globalListeners;
  _draggingPredicate = (item) => item.isDragging();
  _domNodesToDirectives = null;
  pointerMove = new Subject();
  pointerUp = new Subject();
  constructor() {
  }
  registerDropContainer(drop) {
    if (!this._dropInstances.has(drop)) {
      this._dropInstances.add(drop);
    }
  }
  registerDragItem(drag) {
    this._dragInstances.add(drag);
    if (this._dragInstances.size === 1) {
      this._ngZone.runOutsideAngular(() => {
        this._cleanupDocumentTouchmove?.();
        this._cleanupDocumentTouchmove = this._renderer.listen(this._document, "touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
      });
    }
  }
  removeDropContainer(drop) {
    this._dropInstances.delete(drop);
  }
  removeDragItem(drag) {
    this._dragInstances.delete(drag);
    this.stopDragging(drag);
    if (this._dragInstances.size === 0) {
      this._cleanupDocumentTouchmove?.();
    }
  }
  startDragging(drag, event) {
    if (this._activeDragInstances().indexOf(drag) > -1) {
      return;
    }
    this._styleLoader.load(_ResetsLoader);
    this._activeDragInstances.update((instances) => [...instances, drag]);
    if (this._activeDragInstances().length === 1) {
      const isTouchEvent2 = event.type.startsWith("touch");
      const endEventHandler = (e) => this.pointerUp.next(e);
      const toBind = [["scroll", (e) => this._scroll.next(e), capturingEventOptions], ["selectstart", this._preventDefaultWhileDragging, activeCapturingEventOptions]];
      if (isTouchEvent2) {
        toBind.push(["touchend", endEventHandler, capturingEventOptions], ["touchcancel", endEventHandler, capturingEventOptions]);
      } else {
        toBind.push(["mouseup", endEventHandler, capturingEventOptions]);
      }
      if (!isTouchEvent2) {
        toBind.push(["mousemove", (e) => this.pointerMove.next(e), activeCapturingEventOptions]);
      }
      this._ngZone.runOutsideAngular(() => {
        this._globalListeners = toBind.map(([name, handler, options]) => this._renderer.listen(this._document, name, handler, options));
      });
    }
  }
  stopDragging(drag) {
    this._activeDragInstances.update((instances) => {
      const index = instances.indexOf(drag);
      if (index > -1) {
        instances.splice(index, 1);
        return [...instances];
      }
      return instances;
    });
    if (this._activeDragInstances().length === 0) {
      this._clearGlobalListeners();
    }
  }
  isDragging(drag) {
    return this._activeDragInstances().indexOf(drag) > -1;
  }
  scrolled(shadowRoot) {
    const streams = [this._scroll];
    if (shadowRoot && shadowRoot !== this._document) {
      streams.push(new Observable((observer) => {
        return this._ngZone.runOutsideAngular(() => {
          const cleanup = this._renderer.listen(shadowRoot, "scroll", (event) => {
            if (this._activeDragInstances().length) {
              observer.next(event);
            }
          }, capturingEventOptions);
          return () => {
            cleanup();
          };
        });
      }));
    }
    return merge(...streams);
  }
  registerDirectiveNode(node, dragRef) {
    this._domNodesToDirectives ??= /* @__PURE__ */ new WeakMap();
    this._domNodesToDirectives.set(node, dragRef);
  }
  removeDirectiveNode(node) {
    this._domNodesToDirectives?.delete(node);
  }
  getDragDirectiveForNode(node) {
    return this._domNodesToDirectives?.get(node) || null;
  }
  ngOnDestroy() {
    this._dragInstances.forEach((instance) => this.removeDragItem(instance));
    this._dropInstances.forEach((instance) => this.removeDropContainer(instance));
    this._domNodesToDirectives = null;
    this._clearGlobalListeners();
    this.pointerMove.complete();
    this.pointerUp.complete();
  }
  _preventDefaultWhileDragging = (event) => {
    if (this._activeDragInstances().length > 0) {
      event.preventDefault();
    }
  };
  _persistentTouchmoveListener = (event) => {
    if (this._activeDragInstances().length > 0) {
      if (this._activeDragInstances().some(this._draggingPredicate)) {
        event.preventDefault();
      }
      this.pointerMove.next(event);
    }
  };
  _clearGlobalListeners() {
    this._globalListeners?.forEach((cleanup) => cleanup());
    this._globalListeners = void 0;
  }
  static \u0275fac = function DragDropRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDropRegistry)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DragDropRegistry,
    factory: _DragDropRegistry.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var DEFAULT_CONFIG = {
  dragStartThreshold: 5,
  pointerDirectionChangeThreshold: 5
};
var DragDrop = class _DragDrop {
  _document = inject(DOCUMENT);
  _ngZone = inject(NgZone);
  _viewportRuler = inject(ViewportRuler);
  _dragDropRegistry = inject(DragDropRegistry);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  constructor() {
  }
  createDrag(element, config = DEFAULT_CONFIG) {
    return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry, this._renderer);
  }
  createDropList(element) {
    return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
  }
  static \u0275fac = function DragDrop_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDrop)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DragDrop,
    factory: _DragDrop.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDrop, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CDK_DRAG_PARENT = new InjectionToken("CDK_DRAG_PARENT");
function assertElementNode(node, name) {
  if (node.nodeType !== 1) {
    throw Error(`${name} must be attached to an element node. Currently attached to "${node.nodeName}".`);
  }
}
var CDK_DRAG_HANDLE = new InjectionToken("CdkDragHandle");
var CdkDragHandle = class _CdkDragHandle {
  element = inject(ElementRef);
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  _stateChanges = new Subject();
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._stateChanges.next(this);
  }
  _disabled = false;
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDragHandle");
    }
    this._parentDrag?._addHandle(this);
  }
  ngAfterViewInit() {
    if (!this._parentDrag) {
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        const ref = this._dragDropRegistry.getDragDirectiveForNode(parent);
        if (ref) {
          this._parentDrag = ref;
          ref._addHandle(this);
          break;
        }
        parent = parent.parentElement;
      }
    }
  }
  ngOnDestroy() {
    this._parentDrag?._removeHandle(this);
    this._stateChanges.complete();
  }
  static \u0275fac = function CdkDragHandle_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragHandle)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkDragHandle,
    selectors: [["", "cdkDragHandle", ""]],
    hostAttrs: [1, "cdk-drag-handle"],
    inputs: {
      disabled: [2, "cdkDragHandleDisabled", "disabled", booleanAttribute]
    },
    features: [\u0275\u0275ProvidersFeature([{
      provide: CDK_DRAG_HANDLE,
      useExisting: _CdkDragHandle
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragHandle, [{
    type: Directive,
    args: [{
      selector: "[cdkDragHandle]",
      host: {
        "class": "cdk-drag-handle"
      },
      providers: [{
        provide: CDK_DRAG_HANDLE,
        useExisting: CdkDragHandle
      }]
    }]
  }], () => [], {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragHandleDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_CONFIG = new InjectionToken("CDK_DRAG_CONFIG");
var CDK_DROP_LIST = new InjectionToken("CdkDropList");
var CdkDrag = class _CdkDrag {
  element = inject(ElementRef);
  dropContainer = inject(CDK_DROP_LIST, {
    optional: true,
    skipSelf: true
  });
  _ngZone = inject(NgZone);
  _viewContainerRef = inject(ViewContainerRef);
  _dir = inject(Directionality, {
    optional: true
  });
  _changeDetectorRef = inject(ChangeDetectorRef);
  _selfHandle = inject(CDK_DRAG_HANDLE, {
    optional: true,
    self: true
  });
  _parentDrag = inject(CDK_DRAG_PARENT, {
    optional: true,
    skipSelf: true
  });
  _dragDropRegistry = inject(DragDropRegistry);
  _destroyed = new Subject();
  _handles = new BehaviorSubject([]);
  _previewTemplate;
  _placeholderTemplate;
  _dragRef;
  data;
  lockAxis = null;
  rootElementSelector;
  boundaryElement;
  dragStartDelay;
  freeDragPosition;
  get disabled() {
    return this._disabled || !!(this.dropContainer && this.dropContainer.disabled);
  }
  set disabled(value) {
    this._disabled = value;
    this._dragRef.disabled = this._disabled;
  }
  _disabled;
  constrainPosition;
  previewClass;
  previewContainer;
  scale = 1;
  started = new EventEmitter();
  released = new EventEmitter();
  ended = new EventEmitter();
  entered = new EventEmitter();
  exited = new EventEmitter();
  dropped = new EventEmitter();
  moved = new Observable((observer) => {
    const subscription = this._dragRef.moved.pipe(map((movedEvent) => ({
      source: this,
      pointerPosition: movedEvent.pointerPosition,
      event: movedEvent.event,
      delta: movedEvent.delta,
      distance: movedEvent.distance
    }))).subscribe(observer);
    return () => {
      subscription.unsubscribe();
    };
  });
  _injector = inject(Injector);
  constructor() {
    const dropContainer = this.dropContainer;
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    const dragDrop = inject(DragDrop);
    this._dragRef = dragDrop.createDrag(this.element, {
      dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,
      pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null ? config.pointerDirectionChangeThreshold : 5,
      zIndex: config?.zIndex
    });
    this._dragRef.data = this;
    this._dragDropRegistry.registerDirectiveNode(this.element.nativeElement, this);
    if (config) {
      this._assignDefaults(config);
    }
    if (dropContainer) {
      dropContainer.addItem(this);
      dropContainer._dropListRef.beforeStarted.pipe(takeUntil(this._destroyed)).subscribe(() => {
        this._dragRef.scale = this.scale;
      });
    }
    this._syncInputs(this._dragRef);
    this._handleEvents(this._dragRef);
  }
  getPlaceholderElement() {
    return this._dragRef.getPlaceholderElement();
  }
  getRootElement() {
    return this._dragRef.getRootElement();
  }
  reset() {
    this._dragRef.reset();
  }
  resetToBoundary() {
    this._dragRef.resetToBoundary();
  }
  getFreeDragPosition() {
    return this._dragRef.getFreeDragPosition();
  }
  setFreeDragPosition(value) {
    this._dragRef.setFreeDragPosition(value);
  }
  ngAfterViewInit() {
    afterNextRender(() => {
      this._updateRootElement();
      this._setupHandlesListener();
      this._dragRef.scale = this.scale;
      if (this.freeDragPosition) {
        this._dragRef.setFreeDragPosition(this.freeDragPosition);
      }
    }, {
      injector: this._injector
    });
  }
  ngOnChanges(changes) {
    const rootSelectorChange = changes["rootElementSelector"];
    const positionChange = changes["freeDragPosition"];
    if (rootSelectorChange && !rootSelectorChange.firstChange) {
      this._updateRootElement();
    }
    this._dragRef.scale = this.scale;
    if (positionChange && !positionChange.firstChange && this.freeDragPosition) {
      this._dragRef.setFreeDragPosition(this.freeDragPosition);
    }
  }
  ngOnDestroy() {
    if (this.dropContainer) {
      this.dropContainer.removeItem(this);
    }
    this._dragDropRegistry.removeDirectiveNode(this.element.nativeElement);
    this._ngZone.runOutsideAngular(() => {
      this._handles.complete();
      this._destroyed.next();
      this._destroyed.complete();
      this._dragRef.dispose();
    });
  }
  _addHandle(handle) {
    const handles = this._handles.getValue();
    handles.push(handle);
    this._handles.next(handles);
  }
  _removeHandle(handle) {
    const handles = this._handles.getValue();
    const index = handles.indexOf(handle);
    if (index > -1) {
      handles.splice(index, 1);
      this._handles.next(handles);
    }
  }
  _setPreviewTemplate(preview) {
    this._previewTemplate = preview;
  }
  _resetPreviewTemplate(preview) {
    if (preview === this._previewTemplate) {
      this._previewTemplate = null;
    }
  }
  _setPlaceholderTemplate(placeholder) {
    this._placeholderTemplate = placeholder;
  }
  _resetPlaceholderTemplate(placeholder) {
    if (placeholder === this._placeholderTemplate) {
      this._placeholderTemplate = null;
    }
  }
  _updateRootElement() {
    const element = this.element.nativeElement;
    let rootElement = element;
    if (this.rootElementSelector) {
      rootElement = element.closest !== void 0 ? element.closest(this.rootElementSelector) : element.parentElement?.closest(this.rootElementSelector);
    }
    if (rootElement && (typeof ngDevMode === "undefined" || ngDevMode)) {
      assertElementNode(rootElement, "cdkDrag");
    }
    this._dragRef.withRootElement(rootElement || element);
  }
  _getBoundaryElement() {
    const boundary = this.boundaryElement;
    if (!boundary) {
      return null;
    }
    if (typeof boundary === "string") {
      return this.element.nativeElement.closest(boundary);
    }
    return coerceElement(boundary);
  }
  _syncInputs(ref) {
    ref.beforeStarted.subscribe(() => {
      if (!ref.isDragging()) {
        const dir = this._dir;
        const dragStartDelay = this.dragStartDelay;
        const placeholder = this._placeholderTemplate ? {
          template: this._placeholderTemplate.templateRef,
          context: this._placeholderTemplate.data,
          viewContainer: this._viewContainerRef
        } : null;
        const preview = this._previewTemplate ? {
          template: this._previewTemplate.templateRef,
          context: this._previewTemplate.data,
          matchSize: this._previewTemplate.matchSize,
          viewContainer: this._viewContainerRef
        } : null;
        ref.disabled = this.disabled;
        ref.lockAxis = this.lockAxis;
        ref.scale = this.scale;
        ref.dragStartDelay = typeof dragStartDelay === "object" && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);
        ref.constrainPosition = this.constrainPosition;
        ref.previewClass = this.previewClass;
        ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || "global");
        if (dir) {
          ref.withDirection(dir.value);
        }
      }
    });
    ref.beforeStarted.pipe(take(1)).subscribe(() => {
      if (this._parentDrag) {
        ref.withParent(this._parentDrag._dragRef);
        return;
      }
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        const parentDrag = this._dragDropRegistry.getDragDirectiveForNode(parent);
        if (parentDrag) {
          ref.withParent(parentDrag._dragRef);
          break;
        }
        parent = parent.parentElement;
      }
    });
  }
  _handleEvents(ref) {
    ref.started.subscribe((startEvent) => {
      this.started.emit({
        source: this,
        event: startEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.released.subscribe((releaseEvent) => {
      this.released.emit({
        source: this,
        event: releaseEvent.event
      });
    });
    ref.ended.subscribe((endEvent) => {
      this.ended.emit({
        source: this,
        distance: endEvent.distance,
        dropPoint: endEvent.dropPoint,
        event: endEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((enterEvent) => {
      this.entered.emit({
        container: enterEvent.container.data,
        item: this,
        currentIndex: enterEvent.currentIndex
      });
    });
    ref.exited.subscribe((exitEvent) => {
      this.exited.emit({
        container: exitEvent.container.data,
        item: this
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        item: this,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
    });
  }
  _assignDefaults(config) {
    const {
      lockAxis,
      dragStartDelay,
      constrainPosition,
      previewClass,
      boundaryElement,
      draggingDisabled,
      rootElementSelector,
      previewContainer
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.dragStartDelay = dragStartDelay || 0;
    this.lockAxis = lockAxis || null;
    if (constrainPosition) {
      this.constrainPosition = constrainPosition;
    }
    if (previewClass) {
      this.previewClass = previewClass;
    }
    if (boundaryElement) {
      this.boundaryElement = boundaryElement;
    }
    if (rootElementSelector) {
      this.rootElementSelector = rootElementSelector;
    }
    if (previewContainer) {
      this.previewContainer = previewContainer;
    }
  }
  _setupHandlesListener() {
    this._handles.pipe(tap((handles) => {
      const handleElements = handles.map((handle) => handle.element);
      if (this._selfHandle && this.rootElementSelector) {
        handleElements.push(this.element);
      }
      this._dragRef.withHandles(handleElements);
    }), switchMap((handles) => {
      return merge(...handles.map((item) => item._stateChanges.pipe(startWith(item))));
    }), takeUntil(this._destroyed)).subscribe((handleInstance) => {
      const dragRef = this._dragRef;
      const handle = handleInstance.element.nativeElement;
      handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);
    });
  }
  static \u0275fac = function CdkDrag_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDrag)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkDrag,
    selectors: [["", "cdkDrag", ""]],
    hostAttrs: [1, "cdk-drag"],
    hostVars: 4,
    hostBindings: function CdkDrag_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("cdk-drag-disabled", ctx.disabled)("cdk-drag-dragging", ctx._dragRef.isDragging());
      }
    },
    inputs: {
      data: [0, "cdkDragData", "data"],
      lockAxis: [0, "cdkDragLockAxis", "lockAxis"],
      rootElementSelector: [0, "cdkDragRootElement", "rootElementSelector"],
      boundaryElement: [0, "cdkDragBoundary", "boundaryElement"],
      dragStartDelay: [0, "cdkDragStartDelay", "dragStartDelay"],
      freeDragPosition: [0, "cdkDragFreeDragPosition", "freeDragPosition"],
      disabled: [2, "cdkDragDisabled", "disabled", booleanAttribute],
      constrainPosition: [0, "cdkDragConstrainPosition", "constrainPosition"],
      previewClass: [0, "cdkDragPreviewClass", "previewClass"],
      previewContainer: [0, "cdkDragPreviewContainer", "previewContainer"],
      scale: [2, "cdkDragScale", "scale", numberAttribute]
    },
    outputs: {
      started: "cdkDragStarted",
      released: "cdkDragReleased",
      ended: "cdkDragEnded",
      entered: "cdkDragEntered",
      exited: "cdkDragExited",
      dropped: "cdkDragDropped",
      moved: "cdkDragMoved"
    },
    exportAs: ["cdkDrag"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: CDK_DRAG_PARENT,
      useExisting: _CdkDrag
    }]), \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDrag, [{
    type: Directive,
    args: [{
      selector: "[cdkDrag]",
      exportAs: "cdkDrag",
      host: {
        "class": "cdk-drag",
        "[class.cdk-drag-disabled]": "disabled",
        "[class.cdk-drag-dragging]": "_dragRef.isDragging()"
      },
      providers: [{
        provide: CDK_DRAG_PARENT,
        useExisting: CdkDrag
      }]
    }]
  }], () => [], {
    data: [{
      type: Input,
      args: ["cdkDragData"]
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDragLockAxis"]
    }],
    rootElementSelector: [{
      type: Input,
      args: ["cdkDragRootElement"]
    }],
    boundaryElement: [{
      type: Input,
      args: ["cdkDragBoundary"]
    }],
    dragStartDelay: [{
      type: Input,
      args: ["cdkDragStartDelay"]
    }],
    freeDragPosition: [{
      type: Input,
      args: ["cdkDragFreeDragPosition"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragDisabled",
        transform: booleanAttribute
      }]
    }],
    constrainPosition: [{
      type: Input,
      args: ["cdkDragConstrainPosition"]
    }],
    previewClass: [{
      type: Input,
      args: ["cdkDragPreviewClass"]
    }],
    previewContainer: [{
      type: Input,
      args: ["cdkDragPreviewContainer"]
    }],
    scale: [{
      type: Input,
      args: [{
        alias: "cdkDragScale",
        transform: numberAttribute
      }]
    }],
    started: [{
      type: Output,
      args: ["cdkDragStarted"]
    }],
    released: [{
      type: Output,
      args: ["cdkDragReleased"]
    }],
    ended: [{
      type: Output,
      args: ["cdkDragEnded"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDragEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDragExited"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDragDropped"]
    }],
    moved: [{
      type: Output,
      args: ["cdkDragMoved"]
    }]
  });
})();
var CDK_DROP_LIST_GROUP = new InjectionToken("CdkDropListGroup");
var CdkDropListGroup = class _CdkDropListGroup {
  _items = /* @__PURE__ */ new Set();
  disabled = false;
  ngOnDestroy() {
    this._items.clear();
  }
  static \u0275fac = function CdkDropListGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDropListGroup)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkDropListGroup,
    selectors: [["", "cdkDropListGroup", ""]],
    inputs: {
      disabled: [2, "cdkDropListGroupDisabled", "disabled", booleanAttribute]
    },
    exportAs: ["cdkDropListGroup"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: CDK_DROP_LIST_GROUP,
      useExisting: _CdkDropListGroup
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropListGroup, [{
    type: Directive,
    args: [{
      selector: "[cdkDropListGroup]",
      exportAs: "cdkDropListGroup",
      providers: [{
        provide: CDK_DROP_LIST_GROUP,
        useExisting: CdkDropListGroup
      }]
    }]
  }], null, {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListGroupDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CdkDropList = class _CdkDropList {
  element = inject(ElementRef);
  _changeDetectorRef = inject(ChangeDetectorRef);
  _scrollDispatcher = inject(ScrollDispatcher);
  _dir = inject(Directionality, {
    optional: true
  });
  _group = inject(CDK_DROP_LIST_GROUP, {
    optional: true,
    skipSelf: true
  });
  _latestSortedRefs;
  _destroyed = new Subject();
  _scrollableParentsResolved;
  static _dropLists = [];
  _dropListRef;
  connectedTo = [];
  data;
  orientation;
  id = inject(_IdGenerator).getId("cdk-drop-list-");
  lockAxis = null;
  get disabled() {
    return this._disabled || !!this._group && this._group.disabled;
  }
  set disabled(value) {
    this._dropListRef.disabled = this._disabled = value;
  }
  _disabled;
  sortingDisabled;
  enterPredicate = () => true;
  sortPredicate = () => true;
  autoScrollDisabled;
  autoScrollStep;
  elementContainerSelector;
  hasAnchor;
  dropped = new EventEmitter();
  entered = new EventEmitter();
  exited = new EventEmitter();
  sorted = new EventEmitter();
  _unsortedItems = /* @__PURE__ */ new Set();
  constructor() {
    const dragDrop = inject(DragDrop);
    const config = inject(CDK_DRAG_CONFIG, {
      optional: true
    });
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(this.element.nativeElement, "cdkDropList");
    }
    this._dropListRef = dragDrop.createDropList(this.element);
    this._dropListRef.data = this;
    if (config) {
      this._assignDefaults(config);
    }
    this._dropListRef.enterPredicate = (drag, drop) => {
      return this.enterPredicate(drag.data, drop.data);
    };
    this._dropListRef.sortPredicate = (index, drag, drop) => {
      return this.sortPredicate(index, drag.data, drop.data);
    };
    this._setupInputSyncSubscription(this._dropListRef);
    this._handleEvents(this._dropListRef);
    _CdkDropList._dropLists.push(this);
    if (this._group) {
      this._group._items.add(this);
    }
  }
  addItem(item) {
    this._unsortedItems.add(item);
    item._dragRef._withDropContainer(this._dropListRef);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef(this.getSortedItems().map((item2) => item2._dragRef));
    }
  }
  removeItem(item) {
    this._unsortedItems.delete(item);
    if (this._latestSortedRefs) {
      const index = this._latestSortedRefs.indexOf(item._dragRef);
      if (index > -1) {
        this._latestSortedRefs.splice(index, 1);
        this._syncItemsWithRef(this._latestSortedRefs);
      }
    }
  }
  getSortedItems() {
    return Array.from(this._unsortedItems).sort((a, b2) => {
      const documentPosition = a._dragRef.getVisibleElement().compareDocumentPosition(b2._dragRef.getVisibleElement());
      return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
    });
  }
  ngOnDestroy() {
    const index = _CdkDropList._dropLists.indexOf(this);
    if (index > -1) {
      _CdkDropList._dropLists.splice(index, 1);
    }
    if (this._group) {
      this._group._items.delete(this);
    }
    this._latestSortedRefs = void 0;
    this._unsortedItems.clear();
    this._dropListRef.dispose();
    this._destroyed.next();
    this._destroyed.complete();
  }
  _setupInputSyncSubscription(ref) {
    if (this._dir) {
      this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe((value) => ref.withDirection(value));
    }
    ref.beforeStarted.subscribe(() => {
      const siblings = coerceArray(this.connectedTo).map((drop) => {
        if (typeof drop === "string") {
          const correspondingDropList = _CdkDropList._dropLists.find((list) => list.id === drop);
          if (!correspondingDropList && (typeof ngDevMode === "undefined" || ngDevMode)) {
            console.warn(`CdkDropList could not find connected drop list with id "${drop}"`);
          }
          return correspondingDropList;
        }
        return drop;
      });
      if (this._group) {
        this._group._items.forEach((drop) => {
          if (siblings.indexOf(drop) === -1) {
            siblings.push(drop);
          }
        });
      }
      if (!this._scrollableParentsResolved) {
        const scrollableParents = this._scrollDispatcher.getAncestorScrollContainers(this.element).map((scrollable) => scrollable.getElementRef().nativeElement);
        this._dropListRef.withScrollableParents(scrollableParents);
        this._scrollableParentsResolved = true;
      }
      if (this.elementContainerSelector) {
        const container = this.element.nativeElement.querySelector(this.elementContainerSelector);
        if (!container && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw new Error(`CdkDropList could not find an element container matching the selector "${this.elementContainerSelector}"`);
        }
        ref.withElementContainer(container);
      }
      ref.disabled = this.disabled;
      ref.lockAxis = this.lockAxis;
      ref.sortingDisabled = this.sortingDisabled;
      ref.autoScrollDisabled = this.autoScrollDisabled;
      ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);
      ref.hasAnchor = this.hasAnchor;
      ref.connectedTo(siblings.filter((drop) => drop && drop !== this).map((list) => list._dropListRef)).withOrientation(this.orientation);
    });
  }
  _handleEvents(ref) {
    ref.beforeStarted.subscribe(() => {
      this._syncItemsWithRef(this.getSortedItems().map((item) => item._dragRef));
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((event) => {
      this.entered.emit({
        container: this,
        item: event.item.data,
        currentIndex: event.currentIndex
      });
    });
    ref.exited.subscribe((event) => {
      this.exited.emit({
        container: this,
        item: event.item.data
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.sorted.subscribe((event) => {
      this.sorted.emit({
        previousIndex: event.previousIndex,
        currentIndex: event.currentIndex,
        container: this,
        item: event.item.data
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        item: dropEvent.item.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());
  }
  _assignDefaults(config) {
    const {
      lockAxis,
      draggingDisabled,
      sortingDisabled,
      listAutoScrollDisabled,
      listOrientation
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;
    this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;
    this.orientation = listOrientation || "vertical";
    this.lockAxis = lockAxis || null;
  }
  _syncItemsWithRef(items) {
    this._latestSortedRefs = items;
    this._dropListRef.withItems(items);
  }
  static \u0275fac = function CdkDropList_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDropList)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkDropList,
    selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]],
    hostAttrs: [1, "cdk-drop-list"],
    hostVars: 7,
    hostBindings: function CdkDropList_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("id", ctx.id);
        \u0275\u0275classProp("cdk-drop-list-disabled", ctx.disabled)("cdk-drop-list-dragging", ctx._dropListRef.isDragging())("cdk-drop-list-receiving", ctx._dropListRef.isReceiving());
      }
    },
    inputs: {
      connectedTo: [0, "cdkDropListConnectedTo", "connectedTo"],
      data: [0, "cdkDropListData", "data"],
      orientation: [0, "cdkDropListOrientation", "orientation"],
      id: "id",
      lockAxis: [0, "cdkDropListLockAxis", "lockAxis"],
      disabled: [2, "cdkDropListDisabled", "disabled", booleanAttribute],
      sortingDisabled: [2, "cdkDropListSortingDisabled", "sortingDisabled", booleanAttribute],
      enterPredicate: [0, "cdkDropListEnterPredicate", "enterPredicate"],
      sortPredicate: [0, "cdkDropListSortPredicate", "sortPredicate"],
      autoScrollDisabled: [2, "cdkDropListAutoScrollDisabled", "autoScrollDisabled", booleanAttribute],
      autoScrollStep: [0, "cdkDropListAutoScrollStep", "autoScrollStep"],
      elementContainerSelector: [0, "cdkDropListElementContainer", "elementContainerSelector"],
      hasAnchor: [2, "cdkDropListHasAnchor", "hasAnchor", booleanAttribute]
    },
    outputs: {
      dropped: "cdkDropListDropped",
      entered: "cdkDropListEntered",
      exited: "cdkDropListExited",
      sorted: "cdkDropListSorted"
    },
    exportAs: ["cdkDropList"],
    features: [\u0275\u0275ProvidersFeature([{
      provide: CDK_DROP_LIST_GROUP,
      useValue: void 0
    }, {
      provide: CDK_DROP_LIST,
      useExisting: _CdkDropList
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropList, [{
    type: Directive,
    args: [{
      selector: "[cdkDropList], cdk-drop-list",
      exportAs: "cdkDropList",
      providers: [{
        provide: CDK_DROP_LIST_GROUP,
        useValue: void 0
      }, {
        provide: CDK_DROP_LIST,
        useExisting: CdkDropList
      }],
      host: {
        "class": "cdk-drop-list",
        "[attr.id]": "id",
        "[class.cdk-drop-list-disabled]": "disabled",
        "[class.cdk-drop-list-dragging]": "_dropListRef.isDragging()",
        "[class.cdk-drop-list-receiving]": "_dropListRef.isReceiving()"
      }
    }]
  }], () => [], {
    connectedTo: [{
      type: Input,
      args: ["cdkDropListConnectedTo"]
    }],
    data: [{
      type: Input,
      args: ["cdkDropListData"]
    }],
    orientation: [{
      type: Input,
      args: ["cdkDropListOrientation"]
    }],
    id: [{
      type: Input
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDropListLockAxis"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListDisabled",
        transform: booleanAttribute
      }]
    }],
    sortingDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListSortingDisabled",
        transform: booleanAttribute
      }]
    }],
    enterPredicate: [{
      type: Input,
      args: ["cdkDropListEnterPredicate"]
    }],
    sortPredicate: [{
      type: Input,
      args: ["cdkDropListSortPredicate"]
    }],
    autoScrollDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListAutoScrollDisabled",
        transform: booleanAttribute
      }]
    }],
    autoScrollStep: [{
      type: Input,
      args: ["cdkDropListAutoScrollStep"]
    }],
    elementContainerSelector: [{
      type: Input,
      args: ["cdkDropListElementContainer"]
    }],
    hasAnchor: [{
      type: Input,
      args: [{
        alias: "cdkDropListHasAnchor",
        transform: booleanAttribute
      }]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDropListDropped"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDropListEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDropListExited"]
    }],
    sorted: [{
      type: Output,
      args: ["cdkDropListSorted"]
    }]
  });
})();
var CDK_DRAG_PREVIEW = new InjectionToken("CdkDragPreview");
var CdkDragPreview = class _CdkDragPreview {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  data;
  matchSize = false;
  constructor() {
    this._drag?._setPreviewTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPreviewTemplate(this);
  }
  static \u0275fac = function CdkDragPreview_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragPreview)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkDragPreview,
    selectors: [["ng-template", "cdkDragPreview", ""]],
    inputs: {
      data: "data",
      matchSize: [2, "matchSize", "matchSize", booleanAttribute]
    },
    features: [\u0275\u0275ProvidersFeature([{
      provide: CDK_DRAG_PREVIEW,
      useExisting: _CdkDragPreview
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPreview, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPreview]",
      providers: [{
        provide: CDK_DRAG_PREVIEW,
        useExisting: CdkDragPreview
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }],
    matchSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_PLACEHOLDER = new InjectionToken("CdkDragPlaceholder");
var CdkDragPlaceholder = class _CdkDragPlaceholder {
  templateRef = inject(TemplateRef);
  _drag = inject(CDK_DRAG_PARENT, {
    optional: true
  });
  data;
  constructor() {
    this._drag?._setPlaceholderTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPlaceholderTemplate(this);
  }
  static \u0275fac = function CdkDragPlaceholder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkDragPlaceholder)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkDragPlaceholder,
    selectors: [["ng-template", "cdkDragPlaceholder", ""]],
    inputs: {
      data: "data"
    },
    features: [\u0275\u0275ProvidersFeature([{
      provide: CDK_DRAG_PLACEHOLDER,
      useExisting: _CdkDragPlaceholder
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPlaceholder, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPlaceholder]",
      providers: [{
        provide: CDK_DRAG_PLACEHOLDER,
        useExisting: CdkDragPlaceholder
      }]
    }]
  }], () => [], {
    data: [{
      type: Input
    }]
  });
})();
var DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];
var DragDropModule = class _DragDropModule {
  static \u0275fac = function DragDropModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragDropModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _DragDropModule,
    imports: [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder],
    exports: [CdkScrollableModule, CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [DragDrop],
    imports: [CdkScrollableModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropModule, [{
    type: NgModule,
    args: [{
      imports: DRAG_DROP_DIRECTIVES,
      exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],
      providers: [DragDrop]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/listbox/index.mjs
var style11 = "\n    .p-listbox {\n        display: block;\n        background: dt('listbox.background');\n        color: dt('listbox.color');\n        border: 1px solid dt('listbox.border.color');\n        border-radius: dt('listbox.border.radius');\n        transition:\n            background dt('listbox.transition.duration'),\n            color dt('listbox.transition.duration'),\n            border-color dt('listbox.transition.duration'),\n            box-shadow dt('listbox.transition.duration'),\n            outline-color dt('listbox.transition.duration');\n        outline-color: transparent;\n        box-shadow: dt('listbox.shadow');\n    }\n\n    .p-listbox.p-disabled {\n        opacity: 1;\n        background: dt('listbox.disabled.background');\n        color: dt('listbox.disabled.color');\n    }\n\n    .p-listbox.p-disabled .p-listbox-option {\n        color: dt('listbox.disabled.color');\n    }\n\n    .p-listbox.p-invalid {\n        border-color: dt('listbox.invalid.border.color');\n    }\n\n    .p-listbox-header {\n        padding: dt('listbox.list.header.padding');\n    }\n\n    .p-listbox-filter {\n        width: 100%;\n    }\n\n    .p-listbox-list-container {\n        overflow: auto;\n    }\n\n    .p-listbox-list {\n        list-style-type: none;\n        margin: 0;\n        padding: dt('listbox.list.padding');\n        outline: 0 none;\n        display: flex;\n        flex-direction: column;\n        gap: dt('listbox.list.gap');\n    }\n\n    .p-listbox-option {\n        display: flex;\n        align-items: center;\n        cursor: pointer;\n        position: relative;\n        overflow: hidden;\n        padding: dt('listbox.option.padding');\n        border: 0 none;\n        border-radius: dt('listbox.option.border.radius');\n        color: dt('listbox.option.color');\n        transition:\n            background dt('listbox.transition.duration'),\n            color dt('listbox.transition.duration'),\n            border-color dt('listbox.transition.duration'),\n            box-shadow dt('listbox.transition.duration'),\n            outline-color dt('listbox.transition.duration');\n    }\n\n    .p-listbox-striped li:nth-child(even of .p-listbox-option) {\n        background: dt('listbox.option.striped.background');\n    }\n\n    .p-listbox .p-listbox-list .p-listbox-option.p-listbox-option-selected {\n        background: dt('listbox.option.selected.background');\n        color: dt('listbox.option.selected.color');\n    }\n\n    .p-listbox:not(.p-disabled) .p-listbox-option.p-listbox-option-selected.p-focus {\n        background: dt('listbox.option.selected.focus.background');\n        color: dt('listbox.option.selected.focus.color');\n    }\n\n    .p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled).p-focus {\n        background: dt('listbox.option.focus.background');\n        color: dt('listbox.option.focus.color');\n    }\n\n    .p-listbox:not(.p-disabled) .p-listbox-option:not(.p-listbox-option-selected):not(.p-disabled):hover {\n        background: dt('listbox.option.focus.background');\n        color: dt('listbox.option.focus.color');\n    }\n\n    .p-listbox-option-blank-icon {\n        flex-shrink: 0;\n    }\n\n    .p-listbox-option-check-icon {\n        position: relative;\n        flex-shrink: 0;\n        margin-inline-start: dt('listbox.checkmark.gutter.start');\n        margin-inline-end: dt('listbox.checkmark.gutter.end');\n        color: dt('listbox.checkmark.color');\n    }\n\n    .p-listbox-option-group {\n        margin: 0;\n        padding: dt('listbox.option.group.padding');\n        color: dt('listbox.option.group.color');\n        background: dt('listbox.option.group.background');\n        font-weight: dt('listbox.option.group.font.weight');\n    }\n\n    .p-listbox-empty-message {\n        padding: dt('listbox.empty.message.padding');\n    }\n\n    .p-listbox-fluid {\n        width: 100%;\n    }\n";

// node_modules/primeng/fesm2022/primeng-listbox.mjs
var _c015 = ["item"];
var _c19 = ["group"];
var _c27 = ["header"];
var _c36 = ["filter"];
var _c45 = ["footer"];
var _c55 = ["emptyfilter"];
var _c64 = ["empty"];
var _c74 = ["filtericon"];
var _c83 = ["checkicon"];
var _c93 = ["checkmark"];
var _c102 = ["loader"];
var _c112 = ["headerchkbox"];
var _c123 = ["lastHiddenFocusableElement"];
var _c133 = ["firstHiddenFocusableElement"];
var _c143 = ["scroller"];
var _c153 = ["list"];
var _c162 = ["container"];
var _c172 = [[["p-header"]], [["p-footer"]]];
var _c182 = ["p-header", "p-footer"];
var _c192 = (a0, a1) => ({
  $implicit: a0,
  options: a1
});
var _c20 = (a0) => ({
  $implicit: a0
});
var _c21 = (a0) => ({
  options: a0
});
var _c222 = (a0) => ({
  height: a0
});
var _c232 = () => ({});
var _c242 = (a0, a1, a2) => ({
  option: a0,
  i: a1,
  scrollerOptions: a2
});
var _c252 = (a0, a1, a2, a3) => ({
  $implicit: a0,
  index: a1,
  selected: a2,
  disabled: a3
});
var _c262 = (a0) => ({
  implicit: a0
});
function Listbox_div_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Listbox_div_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275projection(1);
    \u0275\u0275template(2, Listbox_div_2_ng_container_2_Template, 1, 0, "ng-container", 22);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cx("header"));
    \u0275\u0275property("pBind", ctx_r1.ptm("header"));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.headerTemplate || ctx_r1._headerTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(5, _c192, ctx_r1.modelValue(), ctx_r1.visibleOptions()));
  }
}
function Listbox_div_3_p_checkbox_1_ng_container_2_ng_template_1_0_ng_template_0_Template(rf, ctx) {
}
function Listbox_div_3_p_checkbox_1_ng_container_2_ng_template_1_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_div_3_p_checkbox_1_ng_container_2_ng_template_1_0_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function Listbox_div_3_p_checkbox_1_ng_container_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_div_3_p_checkbox_1_ng_container_2_ng_template_1_0_Template, 1, 0, null, 22);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.checkIconTemplate || ctx_r1._checkIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c20, ctx_r1.allSelected()));
  }
}
function Listbox_div_3_p_checkbox_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Listbox_div_3_p_checkbox_1_ng_container_2_ng_template_1_Template, 1, 4, "ng-template", null, 5, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
}
function Listbox_div_3_p_checkbox_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-checkbox", 25, 4);
    \u0275\u0275listener("onChange", function Listbox_div_3_p_checkbox_1_Template_p_checkbox_onChange_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onToggleAll($event));
    });
    \u0275\u0275template(2, Listbox_div_3_p_checkbox_1_ng_container_2_Template, 3, 0, "ng-container", 18);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cx("optionCheckIcon"));
    \u0275\u0275property("ngModel", ctx_r1.allSelected())("disabled", ctx_r1.$disabled())("tabindex", -1)("variant", ctx_r1.config.inputStyle() === "filled" || ctx_r1.config.inputVariant() === "filled" ? "filled" : "outlined")("binary", true)("pt", ctx_r1.ptm("pcCheckbox"))("unstyled", ctx_r1.unstyled());
    \u0275\u0275attribute("aria-label", ctx_r1.toggleAllAriaLabel);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.checkIconTemplate || ctx_r1._checkIconTemplate);
  }
}
function Listbox_div_3_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Listbox_div_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Listbox_div_3_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 22);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.filterTemplate || ctx_r1._filterTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c21, ctx_r1.filterOptions));
  }
}
function Listbox_div_3_ng_template_3_Conditional_0__svg_svg_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 31);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("pBind", ctx_r1.ptm("filterIcon"));
    \u0275\u0275attribute("aria-hidden", true);
  }
}
function Listbox_div_3_ng_template_3_Conditional_0_span_5_1_ng_template_0_Template(rf, ctx) {
}
function Listbox_div_3_ng_template_3_Conditional_0_span_5_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_div_3_ng_template_3_Conditional_0_span_5_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function Listbox_div_3_ng_template_3_Conditional_0_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275template(1, Listbox_div_3_ng_template_3_Conditional_0_span_5_1_Template, 1, 0, null, 32);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275attribute("aria-hidden", true);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.filterIconTemplate || ctx_r1._filterIconTemplate);
  }
}
function Listbox_div_3_ng_template_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-iconfield", 26)(1, "input", 28, 6);
    \u0275\u0275listener("input", function Listbox_div_3_ng_template_3_Conditional_0_Template_input_input_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onFilterChange($event));
    })("keydown", function Listbox_div_3_ng_template_3_Conditional_0_Template_input_keydown_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onFilterKeyDown($event));
    })("blur", function Listbox_div_3_ng_template_3_Conditional_0_Template_input_blur_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onFilterBlur($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "p-inputicon", 29);
    \u0275\u0275template(4, Listbox_div_3_ng_template_3_Conditional_0__svg_svg_4_Template, 1, 2, "svg", 30)(5, Listbox_div_3_ng_template_3_Conditional_0_span_5_Template, 2, 2, "span", 18);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("pt", ctx_r1.ptm("pcFilterContainer"))("unstyled", ctx_r1.unstyled());
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("pcFilter"));
    \u0275\u0275property("value", ctx_r1._filterValue() || "")("pt", ctx_r1.ptm("pcFilter"))("unstyled", ctx_r1.unstyled());
    \u0275\u0275attribute("disabled", ctx_r1.$disabled() ? "" : void 0)("aria-owns", ctx_r1.id + "_list")("aria-activedescendant", ctx_r1.focusedOptionId)("placeholder", ctx_r1.filterPlaceHolder)("aria-label", ctx_r1.ariaFilterLabel)("tabindex", !ctx_r1.$disabled() && !ctx_r1.focused ? ctx_r1.tabindex : -1);
    \u0275\u0275advance(2);
    \u0275\u0275property("pt", ctx_r1.ptm("pcFilterIconContainer"))("unstyled", ctx_r1.unstyled());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.filterIconTemplate && !ctx_r1._filterIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.filterIconTemplate || ctx_r1._filterIconTemplate);
  }
}
function Listbox_div_3_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, Listbox_div_3_ng_template_3_Conditional_0_Template, 6, 17, "p-iconfield", 26);
    \u0275\u0275elementStart(1, "span", 27);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(ctx_r1.filter ? 0 : -1);
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r1.ptm("hiddenFilterResult"));
    \u0275\u0275attribute("aria-live", "polite")("data-p-hidden-accessible", true);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.filterResultMessageText, " ");
  }
}
function Listbox_div_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275template(1, Listbox_div_3_p_checkbox_1_Template, 3, 11, "p-checkbox", 23)(2, Listbox_div_3_ng_container_2_Template, 2, 4, "ng-container", 24)(3, Listbox_div_3_ng_template_3_Template, 3, 5, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const builtInFilterElement_r5 = \u0275\u0275reference(4);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cx("header"));
    \u0275\u0275property("pBind", ctx_r1.ptm("header"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.checkbox && ctx_r1.multiple && ctx_r1.showToggleAll);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.filterTemplate || ctx_r1._filterTemplate)("ngIfElse", builtInFilterElement_r5);
  }
}
function Listbox_Conditional_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.emptyFilterMessageText, " ");
  }
}
function Listbox_Conditional_6_Conditional_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, null, 7);
  }
}
function Listbox_Conditional_6_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_Conditional_6_Conditional_2_ng_container_0_Template, 2, 0, "ng-container", 32);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.emptyFilterTemplate || ctx_r1._emptyFilterTemplate || ctx_r1._emptyTemplate || ctx_r1.emptyTemplate);
  }
}
function Listbox_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275conditionalCreate(1, Listbox_Conditional_6_Conditional_1_Template, 1, 1)(2, Listbox_Conditional_6_Conditional_2_Template, 1, 1, "ng-container");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cx("emptyMessage"));
    \u0275\u0275property("pBind", ctx_r1.ptm("emptyMessage"));
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r1.emptyFilterTemplate && !ctx_r1._emptyFilterTemplate && !ctx_r1._emptyTemplate && !ctx_r1.emptyTemplate ? 1 : 2);
  }
}
function Listbox_Conditional_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.emptyMessage, " ");
  }
}
function Listbox_Conditional_7_Conditional_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, null, 8);
  }
}
function Listbox_Conditional_7_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_Conditional_7_Conditional_2_ng_container_0_Template, 2, 0, "ng-container", 32);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.emptyTemplate || ctx_r1._emptyTemplate);
  }
}
function Listbox_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275conditionalCreate(1, Listbox_Conditional_7_Conditional_1_Template, 1, 1)(2, Listbox_Conditional_7_Conditional_2_Template, 1, 1, "ng-container");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cx("emptyMessage"));
    \u0275\u0275property("pBind", ctx_r1.ptm("emptyMessage"));
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r1.emptyTemplate && !ctx_r1._emptyTemplate ? 1 : 2);
  }
}
function Listbox_Conditional_8_p_scroller_0_ng_template_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Listbox_Conditional_8_p_scroller_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_Conditional_8_p_scroller_0_ng_template_2_ng_container_0_Template, 1, 0, "ng-container", 22);
  }
  if (rf & 2) {
    const items_r7 = ctx.$implicit;
    const scrollerOptions_r8 = ctx.options;
    \u0275\u0275nextContext(2);
    const buildInItems_r9 = \u0275\u0275reference(3);
    \u0275\u0275property("ngTemplateOutlet", buildInItems_r9)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c192, items_r7, scrollerOptions_r8));
  }
}
function Listbox_Conditional_8_p_scroller_0_Conditional_4_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Listbox_Conditional_8_p_scroller_0_Conditional_4_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_Conditional_8_p_scroller_0_Conditional_4_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 22);
  }
  if (rf & 2) {
    const scrollerOptions_r10 = ctx.options;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.loaderTemplate || ctx_r1._loaderTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c21, scrollerOptions_r10));
  }
}
function Listbox_Conditional_8_p_scroller_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_Conditional_8_p_scroller_0_Conditional_4_ng_template_0_Template, 1, 4, "ng-template", null, 12, \u0275\u0275templateRefExtractor);
  }
}
function Listbox_Conditional_8_p_scroller_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-scroller", 34, 10);
    \u0275\u0275listener("onLazyLoad", function Listbox_Conditional_8_p_scroller_0_Template_p_scroller_onLazyLoad_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onLazyLoad.emit($event));
    });
    \u0275\u0275template(2, Listbox_Conditional_8_p_scroller_0_ng_template_2_Template, 1, 5, "ng-template", null, 11, \u0275\u0275templateRefExtractor);
    \u0275\u0275conditionalCreate(4, Listbox_Conditional_8_p_scroller_0_Conditional_4_Template, 2, 0);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275styleMap(\u0275\u0275pureFunction1(10, _c222, ctx_r1.scrollHeight));
    \u0275\u0275property("pt", ctx_r1.ptm("virtualScroller"))("items", ctx_r1.visibleOptions())("itemSize", ctx_r1.virtualScrollItemSize)("autoSize", true)("lazy", ctx_r1.lazy)("options", ctx_r1.virtualScrollOptions)("tabindex", ctx_r1.scrollerTabIndex);
    \u0275\u0275advance(4);
    \u0275\u0275conditional(ctx_r1.loaderTemplate || ctx_r1._loaderTemplate ? 4 : -1);
  }
}
function Listbox_Conditional_8_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Listbox_Conditional_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Listbox_Conditional_8_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 22);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const buildInItems_r9 = \u0275\u0275reference(3);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", buildInItems_r9)("ngTemplateOutletContext", \u0275\u0275pureFunction2(3, _c192, ctx_r1.visibleOptions(), \u0275\u0275pureFunction0(2, _c232)));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_0_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r13 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.getOptionGroupLabel(option_r13.optionGroup));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "li", 37);
    \u0275\u0275listener("cdkDragStarted", function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_0_Template_li_cdkDragStarted_1_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.isDragging.set(true));
    })("cdkDragEnded", function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_0_Template_li_cdkDragEnded_1_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.isDragging.set(false));
    });
    \u0275\u0275template(2, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_0_span_2_Template, 2, 1, "span", 18)(3, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_0_ng_container_3_Template, 1, 0, "ng-container", 22);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r13 = \u0275\u0275nextContext();
    const option_r13 = ctx_r13.$implicit;
    const i_r15 = ctx_r13.index;
    const scrollerOptions_r16 = \u0275\u0275nextContext().options;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("optionGroup"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions(option_r13.optionGroup, scrollerOptions_r16, i_r15, "optionGroup"))("ngStyle", \u0275\u0275pureFunction1(10, _c222, scrollerOptions_r16.itemSize + "px"))("cdkDragData", option_r13)("cdkDragDisabled", !ctx_r1.dragdrop);
    \u0275\u0275attribute("id", ctx_r1.id + "_" + ctx_r1.getOptionIndex(i_r15, scrollerOptions_r16));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.groupTemplate && !ctx_r1._groupTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.groupTemplate || ctx_r1._groupTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(12, _c20, option_r13.optionGroup));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_ng_container_1_ng_template_1_0_ng_template_0_Template(rf, ctx) {
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_ng_container_1_ng_template_1_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_ng_container_1_ng_template_1_0_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_ng_container_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_ng_container_1_ng_template_1_0_Template, 1, 0, null, 22);
  }
  if (rf & 2) {
    const option_r13 = \u0275\u0275nextContext(4).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.checkIconTemplate || ctx_r1._checkIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c20, ctx_r1.isSelected(option_r13)));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_ng_container_1_ng_template_1_Template, 1, 4, "ng-template", null, 5, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "p-checkbox", 40);
    \u0275\u0275template(1, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_ng_container_1_Template, 3, 0, "ng-container", 18);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r13 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r1.cx("optionCheckIcon"));
    \u0275\u0275property("ngModel", ctx_r1.isSelected(option_r13))("readonly", true)("disabled", ctx_r1.$disabled() || ctx_r1.isOptionDisabled(option_r13))("tabindex", -1)("variant", ctx_r1.config.inputStyle() === "filled" || ctx_r1.config.inputVariant() === "filled" ? "filled" : "outlined")("binary", true)("pt", ctx_r1.ptm("pcCheckbox"))("unstyled", ctx_r1.unstyled());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.checkIconTemplate || ctx_r1._checkIconTemplate);
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_ng_container_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 43);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(7);
    \u0275\u0275classMap(ctx_r1.cx("optionBlankIcon"));
    \u0275\u0275property("pBind", ctx_r1.ptm("optionBlankIcon"));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_ng_container_1__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 44);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(7);
    \u0275\u0275classMap(ctx_r1.cx("optionCheckIcon"));
    \u0275\u0275property("pBind", ctx_r1.ptm("optionCheckIcon"));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_ng_container_1__svg_svg_1_Template, 1, 3, "svg", 41)(2, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_ng_container_1__svg_svg_2_Template, 1, 3, "svg", 42);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const option_r13 = \u0275\u0275nextContext(3).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.isSelected(option_r13));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isSelected(option_r13));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_ng_container_1_Template, 3, 2, "ng-container", 18)(2, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_ng_container_2_Template, 1, 0, "ng-container", 22);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const option_r13 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.checkmarkTemplate && !ctx_r1._checkmarkTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.checkmarkTemplate || ctx_r1._checkmarkTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(3, _c262, ctx_r1.isSelected(option_r13)));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r13 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.getOptionLabel(option_r13));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "li", 38);
    \u0275\u0275listener("click", function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_Template_li_click_1_listener($event) {
      \u0275\u0275restoreView(_r17);
      const ctx_r13 = \u0275\u0275nextContext();
      const option_r13 = ctx_r13.$implicit;
      const i_r15 = ctx_r13.index;
      const scrollerOptions_r16 = \u0275\u0275nextContext().options;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onOptionSelect($event, option_r13, ctx_r1.getOptionIndex(i_r15, scrollerOptions_r16)));
    })("dblclick", function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_Template_li_dblclick_1_listener($event) {
      \u0275\u0275restoreView(_r17);
      const option_r13 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.onOptionDoubleClick($event, option_r13));
    })("mousedown", function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_Template_li_mousedown_1_listener($event) {
      \u0275\u0275restoreView(_r17);
      const i_r15 = \u0275\u0275nextContext().index;
      const scrollerOptions_r16 = \u0275\u0275nextContext().options;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onOptionMouseDown($event, ctx_r1.getOptionIndex(i_r15, scrollerOptions_r16)));
    })("mouseenter", function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_Template_li_mouseenter_1_listener($event) {
      \u0275\u0275restoreView(_r17);
      const i_r15 = \u0275\u0275nextContext().index;
      const scrollerOptions_r16 = \u0275\u0275nextContext().options;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onOptionMouseEnter($event, ctx_r1.getOptionIndex(i_r15, scrollerOptions_r16)));
    })("touchend", function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_Template_li_touchend_1_listener() {
      \u0275\u0275restoreView(_r17);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.onOptionTouchEnd());
    })("cdkDragStarted", function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_Template_li_cdkDragStarted_1_listener() {
      \u0275\u0275restoreView(_r17);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.isDragging.set(true));
    })("cdkDragEnded", function Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_Template_li_cdkDragEnded_1_listener() {
      \u0275\u0275restoreView(_r17);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.isDragging.set(false));
    });
    \u0275\u0275template(2, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_p_checkbox_2_Template, 2, 11, "p-checkbox", 39)(3, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_3_Template, 3, 5, "ng-container", 18)(4, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_span_4_Template, 2, 1, "span", 18)(5, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_ng_container_5_Template, 1, 0, "ng-container", 22);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r13 = \u0275\u0275nextContext();
    const option_r13 = ctx_r13.$implicit;
    const i_r15 = ctx_r13.index;
    const scrollerOptions_r16 = \u0275\u0275nextContext().options;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("option", \u0275\u0275pureFunction3(20, _c242, option_r13, i_r15, scrollerOptions_r16)));
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(24, _c222, scrollerOptions_r16.itemSize + "px"))("pBind", ctx_r1.getPTOptions(option_r13, scrollerOptions_r16, i_r15, "option"))("cdkDragData", option_r13)("cdkDragDisabled", !ctx_r1.dragdrop);
    \u0275\u0275attribute("id", ctx_r1.id + "_" + ctx_r1.getOptionIndex(i_r15, scrollerOptions_r16))("aria-label", ctx_r1.getOptionLabel(option_r13))("aria-selected", ctx_r1.isSelected(option_r13))("aria-disabled", ctx_r1.isOptionDisabled(option_r13))("aria-setsize", ctx_r1.ariaSetSize)("ariaPosInset", ctx_r1.getAriaPosInset(ctx_r1.getOptionIndex(i_r15, scrollerOptions_r16)))("data-p-selected", ctx_r1.isSelected(option_r13))("data-p-focused", ctx_r1.focusedOptionIndex() === ctx_r1.getOptionIndex(i_r15, scrollerOptions_r16))("data-p-disabled", ctx_r1.isOptionDisabled(option_r13));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.checkbox && ctx_r1.multiple);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.checkmark);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.itemTemplate && !ctx_r1._itemTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.itemTemplate || ctx_r1._itemTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction4(26, _c252, option_r13, ctx_r1.getOptionIndex(i_r15, scrollerOptions_r16), ctx_r1.isSelected(option_r13), ctx_r1.isOptionDisabled(option_r13)));
  }
}
function Listbox_Conditional_8_ng_template_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_0_Template, 4, 14, "ng-container", 18)(1, Listbox_Conditional_8_ng_template_2_ng_template_2_ng_container_1_Template, 6, 31, "ng-container", 18);
  }
  if (rf & 2) {
    const option_r13 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngIf", ctx_r1.isOptionGroup(option_r13));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.isOptionGroup(option_r13));
  }
}
function Listbox_Conditional_8_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "ul", 35, 13);
    \u0275\u0275listener("focus", function Listbox_Conditional_8_ng_template_2_Template_ul_focus_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onListFocus($event));
    })("blur", function Listbox_Conditional_8_ng_template_2_Template_ul_blur_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onListBlur($event));
    })("keydown", function Listbox_Conditional_8_ng_template_2_Template_ul_keydown_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onListKeyDown($event));
    });
    \u0275\u0275template(2, Listbox_Conditional_8_ng_template_2_ng_template_2_Template, 2, 2, "ng-template", 36);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const items_r18 = ctx.$implicit;
    const scrollerOptions_r16 = ctx.options;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275styleMap(scrollerOptions_r16.contentStyle);
    \u0275\u0275classMap(ctx_r1.cx("list"));
    \u0275\u0275property("id", ctx_r1.id + "_list")("tabindex", -1)("ngClass", scrollerOptions_r16.contentStyleClass)("pBind", ctx_r1.ptm("list"));
    \u0275\u0275attribute("aria-multiselectable", true)("aria-activedescendant", ctx_r1.focused ? ctx_r1.focusedOptionId : void 0)("aria-label", ctx_r1.ariaLabel)("aria-disabled", ctx_r1.$disabled());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", items_r18);
  }
}
function Listbox_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Listbox_Conditional_8_p_scroller_0_Template, 5, 12, "p-scroller", 33)(1, Listbox_Conditional_8_ng_container_1_Template, 2, 6, "ng-container", 18)(2, Listbox_Conditional_8_ng_template_2_Template, 3, 13, "ng-template", null, 9, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r1.virtualScroll);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.virtualScroll);
  }
}
function Listbox_div_9_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Listbox_div_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275projection(1, 1);
    \u0275\u0275template(2, Listbox_div_9_ng_container_2_Template, 1, 0, "ng-container", 22);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.footerTemplate || ctx_r1._footerTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c192, ctx_r1.modelValue(), ctx_r1.visibleOptions()));
  }
}
function Listbox_span_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 20);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("pBind", ctx_r1.ptm("hiddenEmptyMessage"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.emptyMessage, " ");
  }
}
var style12 = (
  /*css*/
  `
    ${style11}

    /* For PrimeNG */
    .p-listbox.ng-invalid.ng-dirty {
        border-color: dt('listbox.invalid.border.color');
    }

    .p-listbox-header {
        display: flex;
        align-items: center;
    }

    .p-listbox-header > .p-iconfield {
        flex-grow: 1;
    }

    .p-listbox-list-container {
        height: 100%;
    }

    /* CDK Drag & Drop styles */
    .p-listbox-option.cdk-drag-preview {
        background: dt('listbox.background');
    }

    .p-listbox-dragging .p-listbox-option:not(.cdk-drag-preview) {
        pointer-events: none !important;
    }

    .p-listbox-dragging .p-listbox-option:not(.cdk-drag-preview):hover {
        background: inherit !important;
        color: inherit !important;
    }

    .cdk-drag-placeholder {
        pointer-events: none;
    }
`
);
var classes9 = {
  root: ({
    instance
  }) => ["p-listbox p-component", {
    "p-listbox-striped": instance.striped,
    "p-disabled": instance.$disabled(),
    "p-invalid": instance.invalid(),
    "p-listbox-fluid": instance.fluid(),
    "p-listbox-dragging": instance.isDragging()
  }],
  header: "p-listbox-header",
  pcFilter: "p-listbox-filter",
  listContainer: "p-listbox-list-container",
  list: "p-listbox-list",
  optionGroup: "p-listbox-option-group",
  option: ({
    instance,
    option,
    i,
    scrollerOptions
  }) => ["p-listbox-option", {
    "p-listbox-option-selected": instance.isSelected(option) && instance.highlightOnSelect,
    "p-focus": instance.focusedOptionIndex() === instance.getOptionIndex(i, scrollerOptions),
    "p-disabled": instance.isOptionDisabled(option)
  }],
  optionCheckIcon: "p-listbox-option-check-icon",
  optionBlankIcon: "p-listbox-option-blank-icon",
  emptyMessage: "p-listbox-empty-message"
};
var ListBoxStyle = class _ListBoxStyle extends BaseStyle {
  name = "listbox";
  style = style12;
  classes = classes9;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275ListBoxStyle_BaseFactory;
    return function ListBoxStyle_Factory(__ngFactoryType__) {
      return (\u0275ListBoxStyle_BaseFactory || (\u0275ListBoxStyle_BaseFactory = \u0275\u0275getInheritedFactory(_ListBoxStyle)))(__ngFactoryType__ || _ListBoxStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ListBoxStyle,
    factory: _ListBoxStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListBoxStyle, [{
    type: Injectable
  }], null, null);
})();
var ListboxClasses;
(function(ListboxClasses2) {
  ListboxClasses2["root"] = "p-listbox";
  ListboxClasses2["header"] = "p-listbox-header";
  ListboxClasses2["pcFilter"] = "p-listbox-filter";
  ListboxClasses2["listContainer"] = "p-listbox-list-container";
  ListboxClasses2["list"] = "p-listbox-list";
  ListboxClasses2["optionGroup"] = "p-listbox-option-group";
  ListboxClasses2["option"] = "p-listbox-option";
  ListboxClasses2["optionCheckIcon"] = "p-listbox-option-check-icon";
  ListboxClasses2["optionBlankIcon"] = "p-listbox-option-blank-icon";
  ListboxClasses2["emptyMessage"] = "p-listbox-empty-message";
})(ListboxClasses || (ListboxClasses = {}));
var LISTBOX_INSTANCE = new InjectionToken("LISTBOX_INSTANCE");
var LISTBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => Listbox),
  multi: true
};
var Listbox = class _Listbox extends BaseEditableHolder {
  filterService;
  hostName = "";
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  $pcListbox = inject(LISTBOX_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * Unique identifier of the component.
   * @group Props
   */
  id;
  /**
   * Text to display when the search is active. Defaults to global value in i18n translation configuration.
   * @group Props
   * @defaultValue '{0} results are available'
   */
  searchMessage;
  /**
   * Text to display when filtering does not return any results. Defaults to global value in i18n translation configuration.
   * @group Props
   * @defaultValue 'No selected item'
   */
  emptySelectionMessage;
  /**
   * Text to be displayed in hidden accessible field when options are selected. Defaults to global value in i18n translation configuration.
   * @group Props
   * @defaultValue '{0} items selected'
   */
  selectionMessage;
  /**
   * Whether to focus on the first visible or selected element when the overlay panel is shown.
   * @group Props
   */
  autoOptionFocus = true;
  /**
   * Defines a string that labels the input for accessibility.
   * @group Props
   */
  ariaLabel;
  /**
   * When enabled, the focused option is selected.
   * @group Props
   */
  selectOnFocus;
  /**
   * Locale to use in searching. The default locale is the host environment's current locale.
   * @group Props
   */
  searchLocale;
  /**
   * When enabled, the hovered option will be focused.
   * @group Props
   */
  focusOnHover = true;
  /**
   * Text to display when filtering.
   * @group Props
   */
  filterMessage;
  /**
   * Fields used when filtering the options, defaults to optionLabel.
   * @group Props
   */
  filterFields;
  /**
   * Defines if data is loaded and interacted with in lazy manner.
   * @group Props
   */
  lazy = false;
  /**
   * Whether the data should be loaded on demand during scroll.
   * @group Props
   */
  virtualScroll;
  /**
   * Height of an item in the list for VirtualScrolling.
   * @group Props
   */
  virtualScrollItemSize;
  /**
   * Whether to use the scroller feature. The properties of scroller component can be used like an object in it.
   * @group Props
   */
  virtualScrollOptions;
  /**
   * Height of the viewport in pixels, a scrollbar is defined if height of list exceeds this value.
   * @group Props
   */
  scrollHeight = "14rem";
  /**
   * Index of the element in tabbing order.
   * @group Props
   */
  tabindex = 0;
  /**
   * When specified, allows selecting multiple values.
   * @group Props
   */
  multiple;
  /**
   * Style class of the container.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Inline style of the list element.
   * @group Props
   */
  listStyle;
  /**
   * Style class of the list element.
   * @group Props
   */
  listStyleClass;
  /**
   * When present, it specifies that the element value cannot be changed.
   * @group Props
   */
  readonly;
  /**
   * When specified, allows selecting items with checkboxes.
   * @group Props
   */
  checkbox = false;
  /**
   * When specified, displays a filter input at header.
   * @group Props
   */
  filter = false;
  /**
   * When filtering is enabled, filterBy decides which field or fields (comma separated) to search against.
   * @group Props
   */
  filterBy;
  /**
   * Defines how the items are filtered.
   * @group Props
   */
  filterMatchMode = "contains";
  /**
   * Locale to use in filtering. The default locale is the host environment's current locale.
   * @group Props
   */
  filterLocale;
  /**
   * Defines how multiple items can be selected, when true metaKey needs to be pressed to select or unselect an item and when set to false selection of each item can be toggled individually. On touch enabled devices, metaKeySelection is turned off automatically.
   * @group Props
   */
  metaKeySelection = false;
  /**
   * A property to uniquely identify a value in options.
   * @group Props
   */
  dataKey;
  /**
   * Whether header checkbox is shown in multiple mode.
   * @group Props
   */
  showToggleAll = true;
  /**
   * Name of the label field of an option.
   * @group Props
   */
  optionLabel;
  /**
   * Name of the value field of an option.
   * @group Props
   */
  optionValue;
  /**
   * Name of the options field of an option group.
   * @group Props
   */
  optionGroupChildren = "items";
  /**
   * Name of the label field of an option group.
   * @group Props
   */
  optionGroupLabel = "label";
  /**
   * Name of the disabled field of an option or function to determine disabled state.
   * @group Props
   */
  optionDisabled;
  /**
   * Defines a string that labels the filter input.
   * @group Props
   */
  ariaFilterLabel;
  /**
   * Defines placeholder of the filter input.
   * @group Props
   */
  filterPlaceHolder;
  /**
   * Text to display when filtering does not return any results.
   * @group Props
   */
  emptyFilterMessage;
  /**
   * Text to display when there is no data. Defaults to global value in i18n translation configuration.
   * @group Props
   */
  emptyMessage;
  /**
   * Whether to display options as grouped when nested options are provided.
   * @group Props
   */
  group;
  /**
   * An array of selectitems to display as the available options.
   * @group Props
   */
  get options() {
    return this._options();
  }
  set options(val) {
    this._options.set(val);
  }
  /**
   * When specified, filter displays with this value.
   * @group Props
   */
  get filterValue() {
    return this._filterValue() || "";
  }
  set filterValue(val) {
    this._filterValue.set(val);
  }
  /**
   * Whether all data is selected.
   * @group Props
   */
  get selectAll() {
    return this._selectAll;
  }
  set selectAll(value) {
    this._selectAll = value;
  }
  /**
   * Whether to displays rows with alternating colors.
   * @group Props
   * @defaultValue false
   */
  striped = false;
  /**
   * Whether the selected option will be add highlight class.
   * @group Props
   * @defaultValue true
   */
  highlightOnSelect = true;
  /**
   * Whether the selected option will be shown with a check mark.
   * @group Props
   * @defaultValue false
   */
  checkmark = false;
  /**
   * Whether to enable dragdrop based reordering.
   * @group Props
   */
  dragdrop = false;
  /**
   * Array to use for CDK drop list data binding. When not provided, uses options array.
   * @group Props
   */
  dropListData;
  /**
   * Computed property for stable CDK drop list data reference
   */
  cdkDropData = computed(() => {
    return this.dropListData || this._options();
  }, ...ngDevMode ? [{
    debugName: "cdkDropData"
  }] : []);
  /**
   * Spans 100% width of the container when enabled.
   * @defaultValue undefined
   * @group Props
   */
  fluid = input(void 0, __spreadProps(__spreadValues({}, ngDevMode ? {
    debugName: "fluid"
  } : {}), {
    transform: booleanAttribute
  }));
  /**
   * Callback to invoke on value change.
   * @param {ListboxChangeEvent} event - Custom change event.
   * @group Emits
   */
  onChange = new EventEmitter();
  /**
   * Callback to invoke when option is clicked.
   * @param {ListboxClickEvent} event - Custom click event.
   * @group Emits
   */
  onClick = new EventEmitter();
  /**
   * Callback to invoke when option is double clicked.
   * @param {ListboxDoubleClickEvent} event - Custom double click event.
   * @group Emits
   */
  onDblClick = new EventEmitter();
  /**
   * Callback to invoke when data is filtered.
   * @param {ListboxFilterEvent} event - Custom filter event.
   * @group Emits
   */
  onFilter = new EventEmitter();
  /**
   * Callback to invoke when component receives focus.
   * @param {FocusEvent} event - Focus event.
   * @group Emits
   */
  onFocus = new EventEmitter();
  /**
   * Callback to invoke when component loses focus.
   * @param {FocusEvent} event - Blur event.
   * @group Emits
   */
  onBlur = new EventEmitter();
  /**
   * Callback to invoke when all data is selected.
   * @param {ListboxSelectAllChangeEvent} event - Custom select event.
   * @group Emits
   */
  onSelectAllChange = new EventEmitter();
  /**
   * Emits on lazy load.
   * @param {ScrollerLazyLoadEvent} event - Scroller lazy load event.
   * @group Emits
   */
  onLazyLoad = new EventEmitter();
  /**
   * Emits on item is dropped.
   * @param {CdkDragDrop<string[]>} event - Scroller lazy load event.
   * @group Emits
   */
  onDrop = new EventEmitter();
  headerCheckboxViewChild;
  filterViewChild;
  lastHiddenFocusableElement;
  firstHiddenFocusableElement;
  scroller;
  listViewChild;
  containerViewChild;
  headerFacet;
  footerFacet;
  /**
   * Custom item template.
   * @param {ListboxItemTemplateContext} context - item context.
   * @see {@link ListboxItemTemplateContext}
   * @group Templates
   */
  itemTemplate;
  /**
   * Custom group template.
   * @param {ListboxGroupTemplateContext} context - group context.
   * @see {@link ListboxGroupTemplateContext}
   * @group Templates
   */
  groupTemplate;
  /**
   * Custom header template.
   * @param {ListboxHeaderTemplateContext} context - header context.
   * @see {@link ListboxHeaderTemplateContext}
   * @group Templates
   */
  headerTemplate;
  /**
   * Custom filter template.
   * @param {ListboxFilterTemplateContext} context - filter context.
   * @see {@link ListboxFilterTemplateContext}
   * @group Templates
   */
  filterTemplate;
  /**
   * Custom footer template.
   * @param {ListboxFooterTemplateContext} context - footer context.
   * @see {@link ListboxFooterTemplateContext}
   * @group Templates
   */
  footerTemplate;
  /**
   * Custom empty filter message template.
   * @group Templates
   */
  emptyFilterTemplate;
  /**
   * Custom empty message template.
   * @group Templates
   */
  emptyTemplate;
  /**
   * Custom filter icon template.
   * @group Templates
   */
  filterIconTemplate;
  /**
   * Custom check icon template.
   * @param {ListboxCheckIconTemplateContext} context - check icon context.
   * @see {@link ListboxCheckIconTemplateContext}
   * @group Templates
   */
  checkIconTemplate;
  /**
   * Custom checkmark icon template.
   * @param {ListboxCheckmarkTemplateContext} context - checkmark context.
   * @see {@link ListboxCheckmarkTemplateContext}
   * @group Templates
   */
  checkmarkTemplate;
  /**
   * Custom loader template.
   * @param {ListboxLoaderTemplateContext} context - loader context.
   * @see {@link ListboxLoaderTemplateContext}
   * @group Templates
   */
  loaderTemplate;
  templates;
  _itemTemplate;
  _groupTemplate;
  _headerTemplate;
  _filterTemplate;
  _footerTemplate;
  _emptyFilterTemplate;
  _emptyTemplate;
  _filterIconTemplate;
  _checkIconTemplate;
  _checkmarkTemplate;
  _loaderTemplate;
  _filterValue = signal(null, ...ngDevMode ? [{
    debugName: "_filterValue"
  }] : []);
  _filteredOptions;
  filterOptions;
  filtered;
  value;
  optionTouched;
  focus;
  headerCheckboxFocus;
  translationSubscription;
  focused;
  scrollerTabIndex = "0";
  _componentStyle = inject(ListBoxStyle);
  get focusedOptionId() {
    return this.focusedOptionIndex() !== -1 ? `${this.id}_${this.focusedOptionIndex()}` : null;
  }
  get filterResultMessageText() {
    return s(this.visibleOptions()) ? this.filterMessageText.replaceAll("{0}", this.visibleOptions().length) : this.emptyFilterMessageText;
  }
  get filterMessageText() {
    return this.filterMessage || this.config.translation.searchMessage || "";
  }
  get searchMessageText() {
    return this.searchMessage || this.config.translation.searchMessage || "";
  }
  get emptyFilterMessageText() {
    return this.emptyFilterMessage || this.config.translation.emptySearchMessage || this.config.translation.emptyFilterMessage || "";
  }
  get selectionMessageText() {
    return this.selectionMessage || this.config.translation.selectionMessage || "";
  }
  get emptySelectionMessageText() {
    return this.emptySelectionMessage || this.config.translation.emptySelectionMessage || "";
  }
  get selectedMessageText() {
    return this.hasSelectedOption() ? this.selectionMessageText.replaceAll("{0}", this.multiple ? this.modelValue().length : "1") : this.emptySelectionMessageText;
  }
  get ariaSetSize() {
    return this.visibleOptions().filter((option) => !this.isOptionGroup(option)).length;
  }
  get virtualScrollerDisabled() {
    return !this.virtualScroll;
  }
  get searchFields() {
    return this.filterBy?.split(",") || this.filterFields || [this.optionLabel];
  }
  get toggleAllAriaLabel() {
    return this.config.translation.aria ? this.config.translation.aria[this.allSelected() ? "selectAll" : "unselectAll"] : void 0;
  }
  searchValue;
  searchTimeout;
  _selectAll = null;
  _options = signal(null, ...ngDevMode ? [{
    debugName: "_options"
  }] : []);
  startRangeIndex = signal(-1, ...ngDevMode ? [{
    debugName: "startRangeIndex"
  }] : []);
  focusedOptionIndex = signal(-1, ...ngDevMode ? [{
    debugName: "focusedOptionIndex"
  }] : []);
  isDragging = signal(false, ...ngDevMode ? [{
    debugName: "isDragging"
  }] : []);
  onHostFocusOut(event) {
    this.onFocusout(event);
  }
  visibleOptions = computed(() => {
    const options = this.group ? this.flatOptions(this._options()) : this._options() || [];
    return this._filterValue() ? this.filterService.filter(options, this.searchFields, this._filterValue(), this.filterMatchMode, this.filterLocale) : options;
  }, ...ngDevMode ? [{
    debugName: "visibleOptions"
  }] : []);
  constructor(filterService) {
    super();
    this.filterService = filterService;
  }
  onInit() {
    this.id = this.id || s2("pn_id_");
    this.translationSubscription = this.config.translationObserver.subscribe(() => {
      this.cd.markForCheck();
    });
    this.autoUpdateModel();
    if (this.filterBy) {
      this.filterOptions = {
        filter: (value) => this.onFilterChange(value),
        reset: () => this.resetFilter()
      };
    }
  }
  onAfterContentInit() {
    this.templates.forEach((item) => {
      switch (item.getType()) {
        case "item":
          this._itemTemplate = item.template;
          break;
        case "group":
          this._groupTemplate = item.template;
          break;
        case "header":
          this._headerTemplate = item.template;
          break;
        case "filter":
          this._filterTemplate = item.template;
          break;
        case "footer":
          this._footerTemplate = item.template;
          break;
        case "empty":
          this._emptyTemplate = item.template;
          break;
        case "emptyfilter":
          this._emptyFilterTemplate = item.template;
          break;
        case "filtericon":
          this._filterIconTemplate = item.template;
          break;
        case "checkicon":
          this._checkIconTemplate = item.template;
          break;
        case "checkmark":
          this._checkmarkTemplate = item.template;
          break;
        case "loader":
          this._loaderTemplate = item.template;
          break;
        default:
          this._itemTemplate = item.template;
          break;
      }
    });
  }
  flatOptions(options) {
    return (options || []).reduce((result, option, index) => {
      result.push({
        optionGroup: option,
        group: true,
        index
      });
      const optionGroupChildren = this.getOptionGroupChildren(option);
      optionGroupChildren && optionGroupChildren.forEach((o) => result.push(o));
      return result;
    }, []);
  }
  autoUpdateModel() {
    if (this.selectOnFocus && this.autoOptionFocus && !this.hasSelectedOption() && !this.multiple) {
      const focusedOptionIndex = this.findFirstFocusedOptionIndex();
      this.focusedOptionIndex.set(focusedOptionIndex);
      this.onOptionSelect(null, this.visibleOptions()[this.focusedOptionIndex()]);
    }
  }
  /**
   * Updates the model value.
   * @group Method
   */
  updateModel(value, event) {
    this.value = value;
    this.writeModelValue(value);
    this.onModelChange(value);
    this.onChange.emit({
      originalEvent: event,
      value: this.value
    });
  }
  removeOption(option) {
    return this.modelValue().filter((val) => !k2(val, this.getOptionValue(option), this.equalityKey() || ""));
  }
  onOptionSelect(event, option, index = -1) {
    if (this.$disabled() || this.isOptionDisabled(option) || this.readonly) {
      return;
    }
    event && this.onClick.emit({
      originalEvent: event,
      option,
      value: this.value
    });
    this.multiple ? this.onOptionSelectMultiple(event, option) : this.onOptionSelectSingle(event, option);
    this.optionTouched = false;
    index !== -1 && this.focusedOptionIndex.set(index);
  }
  onOptionSelectMultiple(event, option) {
    let selected = this.isSelected(option);
    let value = [];
    let metaSelection = this.optionTouched ? false : this.metaKeySelection;
    if (metaSelection) {
      let metaKey = event.metaKey || event.ctrlKey;
      if (selected) {
        value = metaKey ? this.removeOption(option) : [this.getOptionValue(option)];
      } else {
        value = metaKey ? this.modelValue() || [] : [];
        value = [...value || [], this.getOptionValue(option)];
      }
    } else {
      value = selected ? this.removeOption(option) : [...this.modelValue() || [], this.getOptionValue(option)];
    }
    this.updateModel(value, event);
  }
  onOptionSelectSingle(event, option) {
    let selected = this.isSelected(option);
    let valueChanged = false;
    let value = null;
    let metaSelection = this.optionTouched ? false : this.metaKeySelection;
    if (metaSelection) {
      let metaKey = event.metaKey || event.ctrlKey;
      if (selected) {
        if (metaKey) {
          value = null;
          valueChanged = true;
        }
      } else {
        value = this.getOptionValue(option);
        valueChanged = true;
      }
    } else {
      value = selected ? null : this.getOptionValue(option);
      valueChanged = true;
    }
    if (valueChanged) {
      this.updateModel(value, event);
    }
  }
  onOptionSelectRange(event, start = -1, end = -1) {
    start === -1 && (start = this.findNearestSelectedOptionIndex(end, true));
    end === -1 && (end = this.findNearestSelectedOptionIndex(start));
    if (start !== -1 && end !== -1) {
      const rangeStart = Math.min(start, end);
      const rangeEnd = Math.max(start, end);
      const value = this.visibleOptions().slice(rangeStart, rangeEnd + 1).filter((option) => this.isValidOption(option)).map((option) => this.getOptionValue(option));
      this.updateModel(value, event);
    }
  }
  onToggleAll(event) {
    if (this.$disabled() || this.readonly) {
      return;
    }
    bt(this.headerCheckboxViewChild?.nativeElement);
    if (this.selectAll !== null) {
      this.onSelectAllChange.emit({
        originalEvent: event,
        checked: !this.allSelected()
      });
    } else {
      const value = this.allSelected() ? [] : this.visibleOptions().filter((option) => this.isValidOption(option)).map((option) => this.getOptionValue(option));
      this.updateModel(value, event);
      this.onChange.emit({
        originalEvent: event,
        value: this.value
      });
    }
  }
  allSelected() {
    return this.selectAll !== null ? this.selectAll : s(this.visibleOptions()) && this.visibleOptions().every((option) => this.isOptionGroup(option) || this.isOptionDisabled(option) || this.isSelected(option));
  }
  onOptionTouchEnd() {
    if (this.$disabled()) {
      return;
    }
    this.optionTouched = true;
  }
  onOptionMouseDown(event, index) {
    this.changeFocusedOptionIndex(event, index);
  }
  onOptionMouseEnter(event, index) {
    if (this.focusOnHover && this.focused) {
      this.changeFocusedOptionIndex(event, index);
    }
  }
  onOptionDoubleClick(event, option) {
    if (this.$disabled() || this.isOptionDisabled(option) || this.readonly) {
      return;
    }
    this.onDblClick.emit({
      originalEvent: event,
      option,
      value: this.value
    });
  }
  onFirstHiddenFocus(event) {
    bt(this.listViewChild?.nativeElement);
    const firstFocusableEl = vt(this.el?.nativeElement, ':not([data-p-hidden-focusable="true"])');
    this.lastHiddenFocusableElement?.nativeElement && (this.lastHiddenFocusableElement.nativeElement.tabIndex = l(firstFocusableEl) ? -1 : void 0);
    this.firstHiddenFocusableElement?.nativeElement && (this.firstHiddenFocusableElement.nativeElement.tabIndex = -1);
  }
  onLastHiddenFocus(event) {
    const relatedTarget = event.relatedTarget;
    if (relatedTarget === this.listViewChild?.nativeElement) {
      const firstFocusableEl = vt(this.el?.nativeElement, ':not([data-p-hidden-focusable="true"])');
      bt(firstFocusableEl);
      this.firstHiddenFocusableElement?.nativeElement && (this.firstHiddenFocusableElement.nativeElement.tabIndex = void 0);
    } else {
      bt(this.firstHiddenFocusableElement?.nativeElement);
    }
    this.lastHiddenFocusableElement?.nativeElement && (this.lastHiddenFocusableElement.nativeElement.tabIndex = -1);
  }
  onFocusout(event) {
    if (!this.el.nativeElement.contains(event.relatedTarget) && this.lastHiddenFocusableElement && this.firstHiddenFocusableElement) {
      this.firstHiddenFocusableElement.nativeElement.tabIndex = this.lastHiddenFocusableElement.nativeElement.tabIndex = void 0;
      this.scrollerTabIndex = "0";
    }
  }
  onListFocus(event) {
    this.focused = true;
    const focusedOptionIndex = this.focusedOptionIndex() !== -1 ? this.focusedOptionIndex() : this.autoOptionFocus ? this.findFirstFocusedOptionIndex() : this.findSelectedOptionIndex();
    this.focusedOptionIndex.set(focusedOptionIndex);
    this.scrollInView(focusedOptionIndex);
    this.onFocus.emit(event);
    this.scrollerTabIndex = "-1";
  }
  onListBlur(event) {
    this.focused = false;
    this.focusedOptionIndex.set(-1);
    this.startRangeIndex.set(-1);
    this.searchValue = "";
    this.onBlur.emit(event);
  }
  onHeaderCheckboxKeyDown(event) {
    if (this.$disabled()) {
      event.preventDefault();
      return;
    }
    switch (event.code) {
      case "Space":
        this.onToggleAll(event);
        break;
      case "Enter":
        this.onToggleAll(event);
        break;
      case "Tab":
        this.onHeaderCheckboxTabKeyDown(event);
        break;
      default:
        break;
    }
  }
  onHeaderCheckboxTabKeyDown(event) {
    bt(this.listViewChild?.nativeElement);
    event.preventDefault();
  }
  onFilterChange(event) {
    let value = event.target.value?.trim();
    this._filterValue.set(value);
    this.focusedOptionIndex.set(-1);
    this.startRangeIndex.set(-1);
    this.onFilter.emit({
      originalEvent: event,
      filter: this._filterValue()
    });
    !this.virtualScrollerDisabled && this.scroller?.scrollToIndex(0);
  }
  onFilterBlur(event) {
    this.focusedOptionIndex.set(-1);
    this.startRangeIndex.set(-1);
  }
  onListKeyDown(event) {
    const metaKey = event.metaKey || event.ctrlKey;
    switch (event.code) {
      case "ArrowDown":
        this.onArrowDownKey(event);
        break;
      case "ArrowUp":
        this.onArrowUpKey(event);
        break;
      case "Home":
        this.onHomeKey(event);
        break;
      case "End":
        this.onEndKey(event);
        break;
      case "PageDown":
        this.onPageDownKey(event);
        break;
      case "PageUp":
        this.onPageUpKey(event);
        break;
      case "Enter":
      case "Space":
      case "NumpadEnter":
        this.onSpaceKey(event);
        break;
      case "Tab":
        break;
      case "ShiftLeft":
      case "ShiftRight":
        this.onShiftKey();
        break;
      default:
        if (this.multiple && event.code === "KeyA" && metaKey) {
          const value = this.visibleOptions().filter((option) => this.isValidOption(option)).map((option) => this.getOptionValue(option));
          this.updateModel(value, event);
          event.preventDefault();
          break;
        }
        if (!metaKey && J(event.key)) {
          this.searchOptions(event, event.key);
          event.preventDefault();
        }
        break;
    }
  }
  onFilterKeyDown(event) {
    switch (event.code) {
      case "ArrowDown":
        this.onArrowDownKey(event);
        break;
      case "ArrowUp":
        this.onArrowUpKey(event);
        break;
      case "ArrowLeft":
      case "ArrowRight":
        this.onArrowLeftKey(event, true);
        break;
      case "Home":
        this.onHomeKey(event, true);
        break;
      case "End":
        this.onEndKey(event, true);
        break;
      case "Enter":
        this.onEnterKey(event);
        break;
      case "ShiftLeft":
      case "ShiftRight":
        this.onShiftKey();
        break;
      default:
        break;
    }
  }
  onArrowDownKey(event) {
    const optionIndex = this.focusedOptionIndex() !== -1 ? this.findNextOptionIndex(this.focusedOptionIndex()) : this.findFirstFocusedOptionIndex();
    if (this.multiple && event.shiftKey) {
      this.onOptionSelectRange(event, this.startRangeIndex(), optionIndex);
    }
    this.changeFocusedOptionIndex(event, optionIndex);
    event.preventDefault();
  }
  onArrowUpKey(event) {
    const optionIndex = this.focusedOptionIndex() !== -1 ? this.findPrevOptionIndex(this.focusedOptionIndex()) : this.findLastFocusedOptionIndex();
    if (this.multiple && event.shiftKey) {
      this.onOptionSelectRange(event, optionIndex, this.startRangeIndex());
    }
    this.changeFocusedOptionIndex(event, optionIndex);
    event.preventDefault();
  }
  onArrowLeftKey(event, pressedInInputText = false) {
    pressedInInputText && this.focusedOptionIndex.set(-1);
  }
  onHomeKey(event, pressedInInputText = false) {
    if (pressedInInputText) {
      event.currentTarget.setSelectionRange(0, 0);
      this.focusedOptionIndex.set(-1);
    } else {
      let metaKey = event.metaKey || event.ctrlKey;
      let optionIndex = this.findFirstOptionIndex();
      if (this.multiple && event.shiftKey && metaKey) {
        this.onOptionSelectRange(event, optionIndex, this.startRangeIndex());
      }
      this.changeFocusedOptionIndex(event, optionIndex);
    }
    event.preventDefault();
  }
  onEndKey(event, pressedInInputText = false) {
    if (pressedInInputText) {
      const target = event.currentTarget;
      const len = target.value.length;
      target.setSelectionRange(len, len);
      this.focusedOptionIndex.set(-1);
    } else {
      let metaKey = event.metaKey || event.ctrlKey;
      let optionIndex = this.findLastOptionIndex();
      if (this.multiple && event.shiftKey && metaKey) {
        this.onOptionSelectRange(event, this.startRangeIndex(), optionIndex);
      }
      this.changeFocusedOptionIndex(event, optionIndex);
    }
    event.preventDefault();
  }
  onPageDownKey(event) {
    this.scrollInView(0);
    event.preventDefault();
  }
  onPageUpKey(event) {
    this.scrollInView(this.visibleOptions().length - 1);
    event.preventDefault();
  }
  onEnterKey(event) {
    if (this.focusedOptionIndex() !== -1) {
      if (this.multiple && event.shiftKey) this.onOptionSelectRange(event, this.focusedOptionIndex());
      else this.onOptionSelect(event, this.visibleOptions()[this.focusedOptionIndex()]);
    }
    event.preventDefault();
  }
  onSpaceKey(event) {
    this.onEnterKey(event);
  }
  onShiftKey() {
    const focusedOptionIndex = this.focusedOptionIndex();
    this.startRangeIndex.set(focusedOptionIndex);
  }
  getOptionGroupChildren(optionGroup) {
    return this.optionGroupChildren ? p(optionGroup, this.optionGroupChildren) : optionGroup.items;
  }
  getOptionGroupLabel(optionGroup) {
    return this.optionGroupLabel ? p(optionGroup, this.optionGroupLabel) : optionGroup && optionGroup.label !== void 0 ? optionGroup.label : optionGroup;
  }
  getOptionLabel(option) {
    return this.optionLabel ? p(option, this.optionLabel) : option.label != void 0 ? option.label : option;
  }
  getOptionIndex(index, scrollerOptions) {
    return this.virtualScrollerDisabled ? index : scrollerOptions && scrollerOptions.getItemOptions(index)["index"];
  }
  getOptionValue(option) {
    return this.optionValue ? p(option, this.optionValue) : !this.optionLabel && option && option.value !== void 0 ? option.value : option;
  }
  getAriaPosInset(index) {
    return (this.optionGroupLabel ? index - this.visibleOptions().slice(0, index).filter((option) => this.isOptionGroup(option)).length : index) + 1;
  }
  getPTOptions(option, itemOptions, index, key) {
    return this.ptm(key, {
      context: {
        selected: this.isSelected(option),
        focused: this.focusedOptionIndex() === this.getOptionIndex(index, itemOptions),
        disabled: this.isOptionDisabled(option)
      }
    });
  }
  hasSelectedOption() {
    return s(this.modelValue());
  }
  isOptionGroup(option) {
    return this.optionGroupLabel && option.optionGroup && option.group;
  }
  changeFocusedOptionIndex(event, index) {
    if (this.focusedOptionIndex() !== index) {
      this.focusedOptionIndex.set(index);
      this.scrollInView();
      if (this.selectOnFocus && !this.multiple) {
        this.onOptionSelect(event, this.visibleOptions()[index]);
      }
    }
  }
  searchOptions(event, char) {
    this.searchValue = (this.searchValue || "") + char;
    let optionIndex = -1;
    let matched = false;
    if (this.focusedOptionIndex() !== -1) {
      optionIndex = this.visibleOptions().slice(this.focusedOptionIndex()).findIndex((option) => this.isOptionMatched(option));
      optionIndex = optionIndex === -1 ? this.visibleOptions().slice(0, this.focusedOptionIndex()).findIndex((option) => this.isOptionMatched(option)) : optionIndex + this.focusedOptionIndex();
    } else {
      optionIndex = this.visibleOptions().findIndex((option) => this.isOptionMatched(option));
    }
    if (optionIndex !== -1) {
      matched = true;
    }
    if (optionIndex === -1 && this.focusedOptionIndex() === -1) {
      optionIndex = this.findFirstFocusedOptionIndex();
    }
    if (optionIndex !== -1) {
      this.changeFocusedOptionIndex(event, optionIndex);
    }
    if (this.searchTimeout) {
      clearTimeout(this.searchTimeout);
    }
    this.searchTimeout = setTimeout(() => {
      this.searchValue = "";
      this.searchTimeout = null;
    }, 500);
    return matched;
  }
  isOptionMatched(option) {
    return this.isValidOption(option) && this.getOptionLabel(option)?.toLocaleLowerCase(this.filterLocale).startsWith(this.searchValue?.toLocaleLowerCase(this.filterLocale));
  }
  scrollInView(index = -1) {
    const id = index !== -1 ? `${this.id}_${index}` : this.focusedOptionId;
    const element = z(this.listViewChild?.nativeElement, `li[id="${id}"]`);
    if (element) {
      element.scrollIntoView && element.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    } else if (!this.virtualScrollerDisabled) {
      this.virtualScroll && this.scroller?.scrollToIndex(index !== -1 ? index : this.focusedOptionIndex());
    }
  }
  findFirstOptionIndex() {
    return this.visibleOptions().findIndex((option) => this.isValidOption(option));
  }
  findLastOptionIndex() {
    return M(this.visibleOptions(), (option) => this.isValidOption(option));
  }
  findFirstFocusedOptionIndex() {
    const selectedIndex = this.findFirstSelectedOptionIndex();
    return selectedIndex < 0 ? this.findFirstOptionIndex() : selectedIndex;
  }
  findLastFocusedOptionIndex() {
    const selectedIndex = this.findLastSelectedOptionIndex();
    return selectedIndex < 0 ? this.findLastOptionIndex() : selectedIndex;
  }
  findLastSelectedOptionIndex() {
    return this.hasSelectedOption() ? M(this.visibleOptions(), (option) => this.isValidSelectedOption(option)) : -1;
  }
  findNextOptionIndex(index) {
    const matchedOptionIndex = index < this.visibleOptions().length - 1 ? this.visibleOptions().slice(index + 1).findIndex((option) => this.isValidOption(option)) : -1;
    return matchedOptionIndex > -1 ? matchedOptionIndex + index + 1 : index;
  }
  findNextSelectedOptionIndex(index) {
    const matchedOptionIndex = this.hasSelectedOption() && index < this.visibleOptions().length - 1 ? this.visibleOptions().slice(index + 1).findIndex((option) => this.isValidSelectedOption(option)) : -1;
    return matchedOptionIndex > -1 ? matchedOptionIndex + index + 1 : -1;
  }
  findPrevSelectedOptionIndex(index) {
    const matchedOptionIndex = this.hasSelectedOption() && index > 0 ? M(this.visibleOptions().slice(0, index), (option) => this.isValidSelectedOption(option)) : -1;
    return matchedOptionIndex > -1 ? matchedOptionIndex : -1;
  }
  findFirstSelectedOptionIndex() {
    return this.hasSelectedOption() ? this.visibleOptions().findIndex((option) => this.isValidSelectedOption(option)) : -1;
  }
  findPrevOptionIndex(index) {
    const matchedOptionIndex = index > 0 ? M(this.visibleOptions().slice(0, index), (option) => this.isValidOption(option)) : -1;
    return matchedOptionIndex > -1 ? matchedOptionIndex : index;
  }
  findSelectedOptionIndex() {
    if (this.$filled()) {
      if (this.multiple) {
        for (let index = this.modelValue().length - 1; index >= 0; index--) {
          const value = this.modelValue()[index];
          const matchedOptionIndex = this.visibleOptions().findIndex((option) => this.isValidSelectedOption(option) && this.isEquals(value, this.getOptionValue(option)));
          if (matchedOptionIndex > -1) return matchedOptionIndex;
        }
      } else {
        return this.visibleOptions().findIndex((option) => this.isValidSelectedOption(option));
      }
    }
    return -1;
  }
  findNearestSelectedOptionIndex(index, firstCheckUp = false) {
    let matchedOptionIndex = -1;
    if (this.hasSelectedOption()) {
      if (firstCheckUp) {
        matchedOptionIndex = this.findPrevSelectedOptionIndex(index);
        matchedOptionIndex = matchedOptionIndex === -1 ? this.findNextSelectedOptionIndex(index) : matchedOptionIndex;
      } else {
        matchedOptionIndex = this.findNextSelectedOptionIndex(index);
        matchedOptionIndex = matchedOptionIndex === -1 ? this.findPrevSelectedOptionIndex(index) : matchedOptionIndex;
      }
    }
    return matchedOptionIndex > -1 ? matchedOptionIndex : index;
  }
  equalityKey() {
    return this.optionValue ? null : this.dataKey;
  }
  isValidSelectedOption(option) {
    return this.isValidOption(option) && this.isSelected(option);
  }
  isOptionDisabled(option) {
    if (c(this.optionDisabled)) {
      return this.optionDisabled(option);
    }
    return this.optionDisabled ? p(option, this.optionDisabled) : false;
  }
  isEquals(value1, value2) {
    return k2(value1, value2, this.equalityKey() || "");
  }
  isSelected(option) {
    const optionValue = this.getOptionValue(option);
    if (this.multiple) return (this.modelValue() || []).some((value) => this.isEquals(value, optionValue));
    else return this.isEquals(this.modelValue(), optionValue);
  }
  isValidOption(option) {
    return option && !(this.isOptionDisabled(option) || this.isOptionGroup(option));
  }
  isEmpty() {
    return !this._options()?.length || !this.visibleOptions()?.length;
  }
  hasFilter() {
    return this._filterValue() && (this._filterValue()?.trim().length || 0) > 0;
  }
  resetFilter() {
    if (this.filterViewChild && this.filterViewChild.nativeElement) {
      this.filterViewChild.nativeElement.value = "";
    }
    this._filterValue.set(null);
  }
  onDragEntered() {
    this.isDragging.set(true);
    this.el.nativeElement.setAttribute("p-listbox-dragging", "true");
  }
  onDragExited() {
    this.isDragging.set(false);
    this.el.nativeElement.setAttribute("p-listbox-dragging", "false");
  }
  drop(event) {
    this.isDragging.set(false);
    if (event) {
      if (this.dragdrop && event.previousContainer === event.container) {
        const currentOptions = [...this._options()];
        moveItemInArray(currentOptions, event.previousIndex, event.currentIndex);
        this._options.set(currentOptions);
        this.changeFocusedOptionIndex(event, event.currentIndex);
        if (this.modelValue()) {
          this.writeModelValue(this.modelValue());
          this.onModelChange(this.modelValue());
        }
        this.cd.markForCheck();
      }
      this.onDrop.emit(event);
    }
  }
  get containerDataP() {
    return this.cn({
      invalid: this.invalid(),
      disabled: this.$disabled()
    });
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value, setModelValue) {
    this.value = value;
    setModelValue(this.value);
    this.cd.markForCheck();
  }
  onDestroy() {
    if (this.translationSubscription) {
      this.translationSubscription.unsubscribe();
    }
  }
  static \u0275fac = function Listbox_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Listbox)(\u0275\u0275directiveInject(FilterService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _Listbox,
    selectors: [["p-listbox"], ["p-listBox"], ["p-list-box"]],
    contentQueries: function Listbox_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, Header, 5);
        \u0275\u0275contentQuery(dirIndex, Footer, 5);
        \u0275\u0275contentQuery(dirIndex, _c015, 4);
        \u0275\u0275contentQuery(dirIndex, _c19, 4);
        \u0275\u0275contentQuery(dirIndex, _c27, 4);
        \u0275\u0275contentQuery(dirIndex, _c36, 4);
        \u0275\u0275contentQuery(dirIndex, _c45, 4);
        \u0275\u0275contentQuery(dirIndex, _c55, 4);
        \u0275\u0275contentQuery(dirIndex, _c64, 4);
        \u0275\u0275contentQuery(dirIndex, _c74, 4);
        \u0275\u0275contentQuery(dirIndex, _c83, 4);
        \u0275\u0275contentQuery(dirIndex, _c93, 4);
        \u0275\u0275contentQuery(dirIndex, _c102, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerFacet = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.footerFacet = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.itemTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.groupTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.filterTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.footerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.emptyFilterTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.emptyTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.filterIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.checkIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.checkmarkTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.loaderTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function Listbox_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c112, 5);
        \u0275\u0275viewQuery(_c36, 5);
        \u0275\u0275viewQuery(_c123, 5);
        \u0275\u0275viewQuery(_c133, 5);
        \u0275\u0275viewQuery(_c143, 5);
        \u0275\u0275viewQuery(_c153, 5);
        \u0275\u0275viewQuery(_c162, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerCheckboxViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.filterViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.lastHiddenFocusableElement = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.firstHiddenFocusableElement = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scroller = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.listViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.containerViewChild = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function Listbox_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("focusout", function Listbox_focusout_HostBindingHandler($event) {
          return ctx.onHostFocusOut($event);
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("id", ctx.id)("data-p", ctx.containerDataP);
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      hostName: "hostName",
      id: "id",
      searchMessage: "searchMessage",
      emptySelectionMessage: "emptySelectionMessage",
      selectionMessage: "selectionMessage",
      autoOptionFocus: [2, "autoOptionFocus", "autoOptionFocus", booleanAttribute],
      ariaLabel: "ariaLabel",
      selectOnFocus: [2, "selectOnFocus", "selectOnFocus", booleanAttribute],
      searchLocale: [2, "searchLocale", "searchLocale", booleanAttribute],
      focusOnHover: [2, "focusOnHover", "focusOnHover", booleanAttribute],
      filterMessage: "filterMessage",
      filterFields: "filterFields",
      lazy: [2, "lazy", "lazy", booleanAttribute],
      virtualScroll: [2, "virtualScroll", "virtualScroll", booleanAttribute],
      virtualScrollItemSize: [2, "virtualScrollItemSize", "virtualScrollItemSize", numberAttribute],
      virtualScrollOptions: "virtualScrollOptions",
      scrollHeight: "scrollHeight",
      tabindex: [2, "tabindex", "tabindex", numberAttribute],
      multiple: [2, "multiple", "multiple", booleanAttribute],
      styleClass: "styleClass",
      listStyle: "listStyle",
      listStyleClass: "listStyleClass",
      readonly: [2, "readonly", "readonly", booleanAttribute],
      checkbox: [2, "checkbox", "checkbox", booleanAttribute],
      filter: [2, "filter", "filter", booleanAttribute],
      filterBy: "filterBy",
      filterMatchMode: "filterMatchMode",
      filterLocale: "filterLocale",
      metaKeySelection: [2, "metaKeySelection", "metaKeySelection", booleanAttribute],
      dataKey: "dataKey",
      showToggleAll: [2, "showToggleAll", "showToggleAll", booleanAttribute],
      optionLabel: "optionLabel",
      optionValue: "optionValue",
      optionGroupChildren: "optionGroupChildren",
      optionGroupLabel: "optionGroupLabel",
      optionDisabled: "optionDisabled",
      ariaFilterLabel: "ariaFilterLabel",
      filterPlaceHolder: "filterPlaceHolder",
      emptyFilterMessage: "emptyFilterMessage",
      emptyMessage: "emptyMessage",
      group: [2, "group", "group", booleanAttribute],
      options: "options",
      filterValue: "filterValue",
      selectAll: "selectAll",
      striped: [2, "striped", "striped", booleanAttribute],
      highlightOnSelect: [2, "highlightOnSelect", "highlightOnSelect", booleanAttribute],
      checkmark: [2, "checkmark", "checkmark", booleanAttribute],
      dragdrop: [2, "dragdrop", "dragdrop", booleanAttribute],
      dropListData: "dropListData",
      fluid: [1, "fluid"]
    },
    outputs: {
      onChange: "onChange",
      onClick: "onClick",
      onDblClick: "onDblClick",
      onFilter: "onFilter",
      onFocus: "onFocus",
      onBlur: "onBlur",
      onSelectAllChange: "onSelectAllChange",
      onLazyLoad: "onLazyLoad",
      onDrop: "onDrop"
    },
    features: [\u0275\u0275ProvidersFeature([LISTBOX_VALUE_ACCESSOR, ListBoxStyle, {
      provide: CDK_DRAG_CONFIG,
      useValue: {
        zIndex: 1200
      }
    }, {
      provide: LISTBOX_INSTANCE,
      useExisting: _Listbox
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _Listbox
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    ngContentSelectors: _c182,
    decls: 15,
    vars: 20,
    consts: [["firstHiddenFocusableElement", ""], ["container", ""], ["lastHiddenFocusableElement", ""], ["builtInFilterElement", ""], ["headerchkbox", ""], ["icon", ""], ["filterInput", ""], ["emptyFilter", ""], ["empty", ""], ["buildInItems", ""], ["scroller", ""], ["content", ""], ["loader", ""], ["list", ""], ["role", "presentation", 1, "p-hidden-accessible", "p-hidden-focusable", 3, "focus", "tabindex", "pBind"], [3, "class", "pBind", 4, "ngIf"], ["cdkDropList", "", 3, "cdkDropListDropped", "cdkDropListEntered", "cdkDropListExited", "ngStyle", "cdkDropListData", "pBind"], [3, "class", "pBind"], [4, "ngIf"], ["role", "status", "aria-live", "polite", "class", "p-hidden-accessible", 3, "pBind", 4, "ngIf"], ["role", "status", "aria-live", "polite", 1, "p-hidden-accessible", 3, "pBind"], [3, "pBind"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "class", "ngModel", "disabled", "tabindex", "variant", "binary", "pt", "unstyled", "onChange", 4, "ngIf"], [4, "ngIf", "ngIfElse"], [3, "onChange", "ngModel", "disabled", "tabindex", "variant", "binary", "pt", "unstyled"], ["hostName", "listbox", 3, "pt", "unstyled"], ["role", "status", 1, "p-hidden-accessible", 3, "pBind"], ["pInputText", "", "type", "text", "role", "searchbox", "hostName", "listbox", 3, "input", "keydown", "blur", "value", "pt", "unstyled"], [3, "pt", "unstyled"], ["data-p-icon", "search", 3, "pBind", 4, "ngIf"], ["data-p-icon", "search", 3, "pBind"], [4, "ngTemplateOutlet"], ["hostName", "listbox", 3, "pt", "items", "style", "itemSize", "autoSize", "lazy", "options", "tabindex", "onLazyLoad", 4, "ngIf"], ["hostName", "listbox", 3, "onLazyLoad", "pt", "items", "itemSize", "autoSize", "lazy", "options", "tabindex"], ["role", "listbox", 3, "focus", "blur", "keydown", "id", "tabindex", "ngClass", "pBind"], ["ngFor", "", 3, "ngForOf"], ["role", "option", "cdkDrag", "", 3, "cdkDragStarted", "cdkDragEnded", "pBind", "ngStyle", "cdkDragData", "cdkDragDisabled"], ["pRipple", "", "role", "option", "cdkDrag", "", 3, "click", "dblclick", "mousedown", "mouseenter", "touchend", "cdkDragStarted", "cdkDragEnded", "ngStyle", "pBind", "cdkDragData", "cdkDragDisabled"], ["hostName", "listbox", 3, "class", "ngModel", "readonly", "disabled", "tabindex", "variant", "binary", "pt", "unstyled", 4, "ngIf"], ["hostName", "listbox", 3, "ngModel", "readonly", "disabled", "tabindex", "variant", "binary", "pt", "unstyled"], ["data-p-icon", "blank", 3, "class", "pBind", 4, "ngIf"], ["data-p-icon", "check", 3, "class", "pBind", 4, "ngIf"], ["data-p-icon", "blank", 3, "pBind"], ["data-p-icon", "check", 3, "pBind"]],
    template: function Listbox_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275projectionDef(_c172);
        \u0275\u0275elementStart(0, "span", 14, 0);
        \u0275\u0275listener("focus", function Listbox_Template_span_focus_0_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onFirstHiddenFocus($event));
        });
        \u0275\u0275elementEnd();
        \u0275\u0275template(2, Listbox_div_2_Template, 3, 8, "div", 15)(3, Listbox_div_3_Template, 5, 6, "div", 15);
        \u0275\u0275elementStart(4, "div", 16, 1);
        \u0275\u0275listener("cdkDropListDropped", function Listbox_Template_div_cdkDropListDropped_4_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.drop($event));
        })("cdkDropListEntered", function Listbox_Template_div_cdkDropListEntered_4_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDragEntered());
        })("cdkDropListExited", function Listbox_Template_div_cdkDropListExited_4_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDragExited());
        });
        \u0275\u0275conditionalCreate(6, Listbox_Conditional_6_Template, 3, 4, "div", 17)(7, Listbox_Conditional_7_Template, 3, 4, "div", 17)(8, Listbox_Conditional_8_Template, 4, 2);
        \u0275\u0275elementEnd();
        \u0275\u0275template(9, Listbox_div_9_Template, 3, 5, "div", 18)(10, Listbox_span_10_Template, 2, 2, "span", 19);
        \u0275\u0275elementStart(11, "span", 20);
        \u0275\u0275text(12);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(13, "span", 14, 2);
        \u0275\u0275listener("focus", function Listbox_Template_span_focus_13_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onLastHiddenFocus($event));
        });
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275property("tabindex", !ctx.$disabled() ? ctx.tabindex : -1)("pBind", ctx.ptm("hiddenFirstFocusableElement"));
        \u0275\u0275attribute("data-p-hidden-focusable", true);
        \u0275\u0275advance(2);
        \u0275\u0275property("ngIf", ctx.headerFacet || ctx.headerTemplate || ctx._headerTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.checkbox && ctx.multiple && ctx.showToggleAll || ctx.filter);
        \u0275\u0275advance();
        \u0275\u0275classMap(ctx.cn(ctx.cx("listContainer"), ctx.listStyleClass));
        \u0275\u0275styleProp("max-height", ctx.virtualScroll ? "auto" : ctx.scrollHeight || "auto");
        \u0275\u0275property("ngStyle", ctx.listStyle)("cdkDropListData", ctx.cdkDropData())("pBind", ctx.ptm("listContainer"));
        \u0275\u0275advance(2);
        \u0275\u0275conditional(ctx.hasFilter() && ctx.isEmpty() ? 6 : !ctx.hasFilter() && ctx.isEmpty() ? 7 : 8);
        \u0275\u0275advance(3);
        \u0275\u0275property("ngIf", ctx.footerFacet || ctx.footerTemplate || ctx._footerTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.isEmpty());
        \u0275\u0275advance();
        \u0275\u0275property("pBind", ctx.ptm("hiddenSelectedMessage"));
        \u0275\u0275advance();
        \u0275\u0275textInterpolate1(" ", ctx.selectedMessageText, " ");
        \u0275\u0275advance();
        \u0275\u0275property("tabindex", !ctx.$disabled() ? ctx.tabindex : -1)("pBind", ctx.ptm("hiddenLastFocusableEl"));
        \u0275\u0275attribute("data-p-hidden-focusable", true);
      }
    },
    dependencies: [CommonModule, NgClass, NgForOf, NgIf, NgTemplateOutlet, NgStyle, Ripple, Scroller, InputIcon, SearchIcon, Checkbox, CheckIcon, IconField, InputText, BlankIcon, FormsModule, NgControlStatus, NgModel, SharedModule, DragDropModule, CdkDropList, CdkDrag, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Listbox, [{
    type: Component,
    args: [{
      selector: "p-listbox, p-listBox, p-list-box",
      standalone: true,
      imports: [CommonModule, Ripple, Scroller, InputIcon, SearchIcon, Checkbox, CheckIcon, IconField, InputText, BlankIcon, FormsModule, SharedModule, DragDropModule, BindModule],
      template: `
        <span
            #firstHiddenFocusableElement
            role="presentation"
            class="p-hidden-accessible p-hidden-focusable"
            [tabindex]="!$disabled() ? tabindex : -1"
            (focus)="onFirstHiddenFocus($event)"
            [attr.data-p-hidden-focusable]="true"
            [pBind]="ptm('hiddenFirstFocusableElement')"
        >
        </span>
        <div [class]="cx('header')" *ngIf="headerFacet || headerTemplate || _headerTemplate" [pBind]="ptm('header')">
            <ng-content select="p-header"></ng-content>
            <ng-container *ngTemplateOutlet="headerTemplate || _headerTemplate; context: { $implicit: modelValue(), options: visibleOptions() }"></ng-container>
        </div>
        <div [class]="cx('header')" *ngIf="(checkbox && multiple && showToggleAll) || filter" [pBind]="ptm('header')">
            <p-checkbox
                #headerchkbox
                (onChange)="onToggleAll($event)"
                *ngIf="checkbox && multiple && showToggleAll"
                [class]="cx('optionCheckIcon')"
                [ngModel]="allSelected()"
                [disabled]="$disabled()"
                [tabindex]="-1"
                [variant]="config.inputStyle() === 'filled' || config.inputVariant() === 'filled' ? 'filled' : 'outlined'"
                [binary]="true"
                [attr.aria-label]="toggleAllAriaLabel"
                [pt]="ptm('pcCheckbox')"
                [unstyled]="unstyled()"
            >
                <ng-container *ngIf="checkIconTemplate || _checkIconTemplate">
                    <ng-template #icon>
                        <ng-template *ngTemplateOutlet="checkIconTemplate || _checkIconTemplate; context: { $implicit: allSelected() }"></ng-template>
                    </ng-template>
                </ng-container>
            </p-checkbox>
            <ng-container *ngIf="filterTemplate || _filterTemplate; else builtInFilterElement">
                <ng-container *ngTemplateOutlet="filterTemplate || _filterTemplate; context: { options: filterOptions }"></ng-container>
            </ng-container>
            <ng-template #builtInFilterElement>
                @if (filter) {
                    <p-iconfield [pt]="ptm('pcFilterContainer')" hostName="listbox" [unstyled]="unstyled()">
                        <input
                            #filterInput
                            pInputText
                            type="text"
                            [class]="cx('pcFilter')"
                            role="searchbox"
                            [value]="_filterValue() || ''"
                            [attr.disabled]="$disabled() ? '' : undefined"
                            [attr.aria-owns]="id + '_list'"
                            [attr.aria-activedescendant]="focusedOptionId"
                            [attr.placeholder]="filterPlaceHolder"
                            [attr.aria-label]="ariaFilterLabel"
                            [attr.tabindex]="!$disabled() && !focused ? tabindex : -1"
                            (input)="onFilterChange($event)"
                            (keydown)="onFilterKeyDown($event)"
                            (blur)="onFilterBlur($event)"
                            [pt]="ptm('pcFilter')"
                            [unstyled]="unstyled()"
                            hostName="listbox"
                        />
                        <p-inputicon [pt]="ptm('pcFilterIconContainer')" [unstyled]="unstyled()">
                            <svg data-p-icon="search" *ngIf="!filterIconTemplate && !_filterIconTemplate" [attr.aria-hidden]="true" [pBind]="ptm('filterIcon')" />
                            <span *ngIf="filterIconTemplate || _filterIconTemplate" [attr.aria-hidden]="true">
                                <ng-template *ngTemplateOutlet="filterIconTemplate || _filterIconTemplate"></ng-template>
                            </span>
                        </p-inputicon>
                    </p-iconfield>
                }
                <span role="status" [pBind]="ptm('hiddenFilterResult')" [attr.aria-live]="'polite'" class="p-hidden-accessible" [attr.data-p-hidden-accessible]="true">
                    {{ filterResultMessageText }}
                </span>
            </ng-template>
        </div>
        <div
            #container
            [class]="cn(cx('listContainer'), listStyleClass)"
            [ngStyle]="listStyle"
            [style.max-height]="virtualScroll ? 'auto' : scrollHeight || 'auto'"
            cdkDropList
            [cdkDropListData]="cdkDropData()"
            (cdkDropListDropped)="drop($event)"
            (cdkDropListEntered)="onDragEntered()"
            (cdkDropListExited)="onDragExited()"
            [pBind]="ptm('listContainer')"
        >
            @if (hasFilter() && isEmpty()) {
                <div [class]="cx('emptyMessage')" [pBind]="ptm('emptyMessage')">
                    @if (!emptyFilterTemplate && !_emptyFilterTemplate && !_emptyTemplate && !emptyTemplate) {
                        {{ emptyFilterMessageText }}
                    } @else {
                        <ng-container #emptyFilter *ngTemplateOutlet="emptyFilterTemplate || _emptyFilterTemplate || _emptyTemplate || emptyTemplate"></ng-container>
                    }
                </div>
            } @else if (!hasFilter() && isEmpty()) {
                <div [class]="cx('emptyMessage')" [pBind]="ptm('emptyMessage')">
                    @if (!emptyTemplate && !_emptyTemplate) {
                        {{ emptyMessage }}
                    } @else {
                        <ng-container #empty *ngTemplateOutlet="emptyTemplate || _emptyTemplate"></ng-container>
                    }
                </div>
            } @else {
                <p-scroller
                    [pt]="ptm('virtualScroller')"
                    hostName="listbox"
                    #scroller
                    *ngIf="virtualScroll"
                    [items]="visibleOptions()"
                    [style]="{ height: scrollHeight }"
                    [itemSize]="virtualScrollItemSize"
                    [autoSize]="true"
                    [lazy]="lazy"
                    [options]="virtualScrollOptions"
                    (onLazyLoad)="onLazyLoad.emit($event)"
                    [tabindex]="scrollerTabIndex"
                >
                    <ng-template #content let-items let-scrollerOptions="options">
                        <ng-container *ngTemplateOutlet="buildInItems; context: { $implicit: items, options: scrollerOptions }"></ng-container>
                    </ng-template>
                    @if (loaderTemplate || _loaderTemplate) {
                        <ng-template #loader let-scrollerOptions="options">
                            <ng-container *ngTemplateOutlet="loaderTemplate || _loaderTemplate; context: { options: scrollerOptions }"></ng-container>
                        </ng-template>
                    }
                </p-scroller>
                <ng-container *ngIf="!virtualScroll">
                    <ng-container *ngTemplateOutlet="buildInItems; context: { $implicit: visibleOptions(), options: {} }"></ng-container>
                </ng-container>

                <ng-template #buildInItems let-items let-scrollerOptions="options">
                    <ul
                        #list
                        [id]="id + '_list'"
                        [class]="cx('list')"
                        role="listbox"
                        [tabindex]="-1"
                        [attr.aria-multiselectable]="true"
                        [ngClass]="scrollerOptions.contentStyleClass"
                        [style]="scrollerOptions.contentStyle"
                        [attr.aria-activedescendant]="focused ? focusedOptionId : undefined"
                        [attr.aria-label]="ariaLabel"
                        [attr.aria-disabled]="$disabled()"
                        (focus)="onListFocus($event)"
                        (blur)="onListBlur($event)"
                        (keydown)="onListKeyDown($event)"
                        [pBind]="ptm('list')"
                    >
                        <ng-template ngFor let-option [ngForOf]="items" let-i="index">
                            <ng-container *ngIf="isOptionGroup(option)">
                                <li
                                    [attr.id]="id + '_' + getOptionIndex(i, scrollerOptions)"
                                    [class]="cx('optionGroup')"
                                    [pBind]="getPTOptions(option.optionGroup, scrollerOptions, i, 'optionGroup')"
                                    [ngStyle]="{ height: scrollerOptions.itemSize + 'px' }"
                                    role="option"
                                    cdkDrag
                                    [cdkDragData]="option"
                                    [cdkDragDisabled]="!dragdrop"
                                    (cdkDragStarted)="isDragging.set(true)"
                                    (cdkDragEnded)="isDragging.set(false)"
                                >
                                    <span *ngIf="!groupTemplate && !_groupTemplate">{{ getOptionGroupLabel(option.optionGroup) }}</span>
                                    <ng-container *ngTemplateOutlet="groupTemplate || _groupTemplate; context: { $implicit: option.optionGroup }"></ng-container>
                                </li>
                            </ng-container>
                            <ng-container *ngIf="!isOptionGroup(option)">
                                <li
                                    pRipple
                                    [class]="cx('option', { option, i, scrollerOptions })"
                                    role="option"
                                    [attr.id]="id + '_' + getOptionIndex(i, scrollerOptions)"
                                    [ngStyle]="{ height: scrollerOptions.itemSize + 'px' }"
                                    [attr.aria-label]="getOptionLabel(option)"
                                    [attr.aria-selected]="isSelected(option)"
                                    [attr.aria-disabled]="isOptionDisabled(option)"
                                    [attr.aria-setsize]="ariaSetSize"
                                    [attr.ariaPosInset]="getAriaPosInset(getOptionIndex(i, scrollerOptions))"
                                    [attr.data-p-selected]="isSelected(option)"
                                    [attr.data-p-focused]="focusedOptionIndex() === getOptionIndex(i, scrollerOptions)"
                                    [attr.data-p-disabled]="isOptionDisabled(option)"
                                    [pBind]="getPTOptions(option, scrollerOptions, i, 'option')"
                                    (click)="onOptionSelect($event, option, getOptionIndex(i, scrollerOptions))"
                                    (dblclick)="onOptionDoubleClick($event, option)"
                                    (mousedown)="onOptionMouseDown($event, getOptionIndex(i, scrollerOptions))"
                                    (mouseenter)="onOptionMouseEnter($event, getOptionIndex(i, scrollerOptions))"
                                    (touchend)="onOptionTouchEnd()"
                                    cdkDrag
                                    [cdkDragData]="option"
                                    [cdkDragDisabled]="!dragdrop"
                                    (cdkDragStarted)="isDragging.set(true)"
                                    (cdkDragEnded)="isDragging.set(false)"
                                >
                                    <p-checkbox
                                        *ngIf="checkbox && multiple"
                                        [class]="cx('optionCheckIcon')"
                                        [ngModel]="isSelected(option)"
                                        [readonly]="true"
                                        [disabled]="$disabled() || isOptionDisabled(option)"
                                        [tabindex]="-1"
                                        [variant]="config.inputStyle() === 'filled' || config.inputVariant() === 'filled' ? 'filled' : 'outlined'"
                                        [binary]="true"
                                        [pt]="ptm('pcCheckbox')"
                                        hostName="listbox"
                                        [unstyled]="unstyled()"
                                    >
                                        <ng-container *ngIf="checkIconTemplate || _checkIconTemplate">
                                            <ng-template #icon>
                                                <ng-template *ngTemplateOutlet="checkIconTemplate || _checkIconTemplate; context: { $implicit: isSelected(option) }"></ng-template>
                                            </ng-template>
                                        </ng-container>
                                    </p-checkbox>
                                    <ng-container *ngIf="checkmark">
                                        <ng-container *ngIf="!checkmarkTemplate && !_checkmarkTemplate">
                                            <svg data-p-icon="blank" *ngIf="!isSelected(option)" [class]="cx('optionBlankIcon')" [pBind]="ptm('optionBlankIcon')" />
                                            <svg data-p-icon="check" *ngIf="isSelected(option)" [class]="cx('optionCheckIcon')" [pBind]="ptm('optionCheckIcon')" />
                                        </ng-container>
                                        <ng-container *ngTemplateOutlet="checkmarkTemplate || _checkmarkTemplate; context: { implicit: isSelected(option) }"></ng-container>
                                    </ng-container>
                                    <span *ngIf="!itemTemplate && !_itemTemplate">{{ getOptionLabel(option) }}</span>
                                    <ng-container
                                        *ngTemplateOutlet="
                                            itemTemplate || _itemTemplate;
                                            context: {
                                                $implicit: option,
                                                index: getOptionIndex(i, scrollerOptions),
                                                selected: isSelected(option),
                                                disabled: isOptionDisabled(option)
                                            }
                                        "
                                    ></ng-container>
                                </li>
                            </ng-container>
                        </ng-template>
                    </ul>
                </ng-template>
            }
        </div>
        <div *ngIf="footerFacet || footerTemplate || _footerTemplate">
            <ng-content select="p-footer"></ng-content>
            <ng-container *ngTemplateOutlet="footerTemplate || _footerTemplate; context: { $implicit: modelValue(), options: visibleOptions() }"></ng-container>
        </div>
        <span *ngIf="isEmpty()" role="status" aria-live="polite" class="p-hidden-accessible" [pBind]="ptm('hiddenEmptyMessage')">
            {{ emptyMessage }}
        </span>
        <span role="status" aria-live="polite" class="p-hidden-accessible" [pBind]="ptm('hiddenSelectedMessage')">
            {{ selectedMessageText }}
        </span>
        <span
            #lastHiddenFocusableElement
            role="presentation"
            class="p-hidden-accessible p-hidden-focusable"
            [tabindex]="!$disabled() ? tabindex : -1"
            (focus)="onLastHiddenFocus($event)"
            [attr.data-p-hidden-focusable]="true"
            [pBind]="ptm('hiddenLastFocusableEl')"
        >
        </span>
    `,
      providers: [LISTBOX_VALUE_ACCESSOR, ListBoxStyle, {
        provide: CDK_DRAG_CONFIG,
        useValue: {
          zIndex: 1200
        }
      }, {
        provide: LISTBOX_INSTANCE,
        useExisting: Listbox
      }, {
        provide: PARENT_INSTANCE,
        useExisting: Listbox
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[attr.id]": "id",
        "[class]": "cn(cx('root'), styleClass)",
        "[attr.data-p]": "containerDataP"
      },
      hostDirectives: [Bind]
    }]
  }], () => [{
    type: FilterService
  }], {
    hostName: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    searchMessage: [{
      type: Input
    }],
    emptySelectionMessage: [{
      type: Input
    }],
    selectionMessage: [{
      type: Input
    }],
    autoOptionFocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    ariaLabel: [{
      type: Input
    }],
    selectOnFocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    searchLocale: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    focusOnHover: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    filterMessage: [{
      type: Input
    }],
    filterFields: [{
      type: Input
    }],
    lazy: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    virtualScroll: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    virtualScrollItemSize: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    virtualScrollOptions: [{
      type: Input
    }],
    scrollHeight: [{
      type: Input
    }],
    tabindex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    multiple: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    styleClass: [{
      type: Input
    }],
    listStyle: [{
      type: Input
    }],
    listStyleClass: [{
      type: Input
    }],
    readonly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    checkbox: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    filter: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    filterBy: [{
      type: Input
    }],
    filterMatchMode: [{
      type: Input
    }],
    filterLocale: [{
      type: Input
    }],
    metaKeySelection: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    dataKey: [{
      type: Input
    }],
    showToggleAll: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    optionLabel: [{
      type: Input
    }],
    optionValue: [{
      type: Input
    }],
    optionGroupChildren: [{
      type: Input
    }],
    optionGroupLabel: [{
      type: Input
    }],
    optionDisabled: [{
      type: Input
    }],
    ariaFilterLabel: [{
      type: Input
    }],
    filterPlaceHolder: [{
      type: Input
    }],
    emptyFilterMessage: [{
      type: Input
    }],
    emptyMessage: [{
      type: Input
    }],
    group: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    options: [{
      type: Input
    }],
    filterValue: [{
      type: Input
    }],
    selectAll: [{
      type: Input
    }],
    striped: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    highlightOnSelect: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    checkmark: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    dragdrop: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    dropListData: [{
      type: Input
    }],
    fluid: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "fluid",
        required: false
      }]
    }],
    onChange: [{
      type: Output
    }],
    onClick: [{
      type: Output
    }],
    onDblClick: [{
      type: Output
    }],
    onFilter: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    onBlur: [{
      type: Output
    }],
    onSelectAllChange: [{
      type: Output
    }],
    onLazyLoad: [{
      type: Output
    }],
    onDrop: [{
      type: Output
    }],
    headerCheckboxViewChild: [{
      type: ViewChild,
      args: ["headerchkbox"]
    }],
    filterViewChild: [{
      type: ViewChild,
      args: ["filter"]
    }],
    lastHiddenFocusableElement: [{
      type: ViewChild,
      args: ["lastHiddenFocusableElement"]
    }],
    firstHiddenFocusableElement: [{
      type: ViewChild,
      args: ["firstHiddenFocusableElement"]
    }],
    scroller: [{
      type: ViewChild,
      args: ["scroller"]
    }],
    listViewChild: [{
      type: ViewChild,
      args: ["list"]
    }],
    containerViewChild: [{
      type: ViewChild,
      args: ["container"]
    }],
    headerFacet: [{
      type: ContentChild,
      args: [Header]
    }],
    footerFacet: [{
      type: ContentChild,
      args: [Footer]
    }],
    itemTemplate: [{
      type: ContentChild,
      args: ["item", {
        descendants: false
      }]
    }],
    groupTemplate: [{
      type: ContentChild,
      args: ["group", {
        descendants: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: ["header", {
        descendants: false
      }]
    }],
    filterTemplate: [{
      type: ContentChild,
      args: ["filter", {
        descendants: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: ["footer", {
        descendants: false
      }]
    }],
    emptyFilterTemplate: [{
      type: ContentChild,
      args: ["emptyfilter", {
        descendants: false
      }]
    }],
    emptyTemplate: [{
      type: ContentChild,
      args: ["empty", {
        descendants: false
      }]
    }],
    filterIconTemplate: [{
      type: ContentChild,
      args: ["filtericon", {
        descendants: false
      }]
    }],
    checkIconTemplate: [{
      type: ContentChild,
      args: ["checkicon", {
        descendants: false
      }]
    }],
    checkmarkTemplate: [{
      type: ContentChild,
      args: ["checkmark", {
        descendants: false
      }]
    }],
    loaderTemplate: [{
      type: ContentChild,
      args: ["loader", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }],
    onHostFocusOut: [{
      type: HostListener,
      args: ["focusout", ["$event"]]
    }]
  });
})();
var ListboxModule = class _ListboxModule {
  static \u0275fac = function ListboxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ListboxModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ListboxModule,
    imports: [Listbox, SharedModule],
    exports: [Listbox, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [Listbox, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListboxModule, [{
    type: NgModule,
    args: [{
      imports: [Listbox, SharedModule],
      exports: [Listbox, SharedModule]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/tree/index.mjs
var style13 = `
    .p-tree {
        display: block;
        background: dt('tree.background');
        color: dt('tree.color');
        padding: dt('tree.padding');
        position: relative;
    }

    .p-tree-root-children,
    .p-tree-node-children {
        display: flex;
        list-style-type: none;
        flex-direction: column;
        margin: 0;
        gap: dt('tree.gap');
    }

    .p-tree-root-children {
        padding: 0;
        padding-block-start: dt('tree.gap');
    }

    .p-tree-node-children {
        padding: 0;
        padding-block-start: dt('tree.gap');
        padding-inline-start: dt('tree.indent');
    }

    .p-tree-node {
        padding: 0;
        outline: 0 none;
    }

    .p-tree-node-content {
        border-radius: dt('tree.node.border.radius');
        padding: dt('tree.node.padding');
        display: flex;
        align-items: center;
        outline-color: transparent;
        color: dt('tree.node.color');
        gap: dt('tree.node.gap');
        transition:
            background dt('tree.transition.duration'),
            color dt('tree.transition.duration'),
            outline-color dt('tree.transition.duration'),
            box-shadow dt('tree.transition.duration');
    }

    .p-tree-node-content[data-p-dragging] {
        outline: 1px dashed dt('primary.color');
        outline-offset: -1px;
    }

    .p-tree-node-content[data-pc-section="drag-image"] {
        background: dt('tree.background');
    }

    .p-tree-node:focus-visible > .p-tree-node-content {
        box-shadow: dt('tree.node.focus.ring.shadow');
        outline: dt('tree.node.focus.ring.width') dt('tree.node.focus.ring.style') dt('tree.node.focus.ring.color');
        outline-offset: dt('tree.node.focus.ring.offset');
    }

    .p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover {
        background: dt('tree.node.hover.background');
        color: dt('tree.node.hover.color');
    }

    .p-tree-node-content.p-tree-node-selectable:not(.p-tree-node-selected):hover .p-tree-node-icon {
        color: dt('tree.node.icon.hover.color');
    }

    .p-tree-node-content.p-tree-node-selected {
        background: dt('tree.node.selected.background');
        color: dt('tree.node.selected.color');
    }

    .p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button {
        color: inherit;
    }

    .p-tree-node-content.p-tree-node-dragover {
        background: dt('tree.node.hover.background');
        color: dt('tree.node.hover.color');
    }

    .p-tree-node-content:focus-visible,
    .p-tree-node-content.p-tree-node-contextmenu-selected {
        box-shadow: dt('tree.node.focus.ring.shadow');
        outline: dt('tree.node.focus.ring.width') dt('tree.node.focus.ring.style') dt('tree.node.focus.ring.color');
        outline-offset: dt('tree.node.focus.ring.offset');
    }

    .p-tree-node-drop-point {
		outline: 1px solid dt('primary.color');
	}

    .p-tree-node-toggle-button {
        cursor: pointer;
        user-select: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
        flex-shrink: 0;
        width: dt('tree.node.toggle.button.size');
        height: dt('tree.node.toggle.button.size');
        color: dt('tree.node.toggle.button.color');
        border: 0 none;
        background: transparent;
        border-radius: dt('tree.node.toggle.button.border.radius');
        transition:
            background dt('tree.transition.duration'),
            color dt('tree.transition.duration'),
            border-color dt('tree.transition.duration'),
            outline-color dt('tree.transition.duration'),
            box-shadow dt('tree.transition.duration');
        outline-color: transparent;
        padding: 0;
    }

    .p-tree-node-toggle-button:enabled:hover {
        background: dt('tree.node.toggle.button.hover.background');
        color: dt('tree.node.toggle.button.hover.color');
    }

    .p-tree-node-content.p-tree-node-selected .p-tree-node-toggle-button:hover {
        background: dt('tree.node.toggle.button.selected.hover.background');
        color: dt('tree.node.toggle.button.selected.hover.color');
    }

    .p-tree-root {
        overflow: auto;
    }

    .p-tree-node-selectable {
        cursor: pointer;
        user-select: none;
    }

    .p-tree-node-leaf > .p-tree-node-content .p-tree-node-toggle-button {
        visibility: hidden;
    }

    .p-tree-node-icon {
        color: dt('tree.node.icon.color');
        transition: color dt('tree.transition.duration');
    }

    .p-tree-node-content.p-tree-node-selected .p-tree-node-icon {
        color: dt('tree.node.icon.selected.color');
    }

    .p-tree-filter {
        margin: dt('tree.filter.margin');
    }

    .p-tree-filter-input {
        width: 100%;
    }

    .p-tree-loading-icon {
        font-size: dt('tree.loading.icon.size');
        width: dt('tree.loading.icon.size');
        height: dt('tree.loading.icon.size');
    }

    .p-tree .p-tree-mask {
        position: absolute;
        z-index: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .p-tree-flex-scrollable {
        display: flex;
        flex: 1;
        height: 100%;
        flex-direction: column;
    }

    .p-tree-flex-scrollable .p-tree-root {
        flex: 1;
    }
`;

// node_modules/primeng/fesm2022/primeng-tree.mjs
var _c016 = (a0) => ({
  height: a0
});
var _c110 = (a0, a1) => ({
  $implicit: a0,
  loading: a1
});
var _c28 = (a0, a1, a2) => ({
  $implicit: a0,
  partialSelected: a1,
  class: a2
});
var _c37 = (a0) => ({
  $implicit: a0
});
var _c46 = () => ({
  next: true
});
function UITreeNode_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cx("dropPoint"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions("dropPoint"));
    \u0275\u0275attribute("aria-hidden", true);
  }
}
function UITreeNode_Conditional_0_ng_container_4_ng_container_1__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 13);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275classMap(ctx_r1.cx("nodeToggleIcon"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions("nodeToggleIcon"));
  }
}
function UITreeNode_Conditional_0_ng_container_4_ng_container_1__svg_svg_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 14);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275classMap(ctx_r1.cx("nodeToggleIcon"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions("nodeToggleIcon"));
  }
}
function UITreeNode_Conditional_0_ng_container_4_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, UITreeNode_Conditional_0_ng_container_4_ng_container_1__svg_svg_1_Template, 1, 3, "svg", 11)(2, UITreeNode_Conditional_0_ng_container_4_ng_container_1__svg_svg_2_Template, 1, 3, "svg", 12);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.node.expanded);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.node.expanded);
  }
}
function UITreeNode_Conditional_0_ng_container_4_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(1, "svg", 15);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("nodeToggleIcon"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions("nodeToggleIcon"));
  }
}
function UITreeNode_Conditional_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, UITreeNode_Conditional_0_ng_container_4_ng_container_1_Template, 3, 2, "ng-container", 6)(2, UITreeNode_Conditional_0_ng_container_4_ng_container_2_Template, 2, 3, "ng-container", 6);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.node.loading);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.loadingMode === "icon" && ctx_r1.node.loading);
  }
}
function UITreeNode_Conditional_0_span_5_1_ng_template_0_Template(rf, ctx) {
}
function UITreeNode_Conditional_0_span_5_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, UITreeNode_Conditional_0_span_5_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function UITreeNode_Conditional_0_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 9);
    \u0275\u0275template(1, UITreeNode_Conditional_0_span_5_1_Template, 1, 0, null, 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cx("nodeToggleIcon"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions("nodeToggleIcon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.tree.togglerIconTemplate || ctx_r1.tree._togglerIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(5, _c110, ctx_r1.node.expanded, ctx_r1.node.loading));
  }
}
function UITreeNode_Conditional_0_p_checkbox_6_ng_container_1_ng_template_1_0_ng_template_0_Template(rf, ctx) {
}
function UITreeNode_Conditional_0_p_checkbox_6_ng_container_1_ng_template_1_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, UITreeNode_Conditional_0_p_checkbox_6_ng_container_1_ng_template_1_0_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function UITreeNode_Conditional_0_p_checkbox_6_ng_container_1_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, UITreeNode_Conditional_0_p_checkbox_6_ng_container_1_ng_template_1_0_Template, 1, 0, null, 16);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.tree.checkboxIconTemplate || ctx_r1.tree._checkboxIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction3(2, _c28, ctx_r1.isSelected(), ctx_r1.node.partialSelected, ctx_r1.cx("nodeCheckbox")));
  }
}
function UITreeNode_Conditional_0_p_checkbox_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, UITreeNode_Conditional_0_p_checkbox_6_ng_container_1_ng_template_1_Template, 1, 6, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
}
function UITreeNode_Conditional_0_p_checkbox_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-checkbox", 17);
    \u0275\u0275listener("click", function UITreeNode_Conditional_0_p_checkbox_6_Template_p_checkbox_click_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      return \u0275\u0275resetView($event.preventDefault());
    });
    \u0275\u0275template(1, UITreeNode_Conditional_0_p_checkbox_6_ng_container_1_Template, 3, 0, "ng-container", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngModel", ctx_r1.isSelected())("styleClass", ctx_r1.cx("nodeCheckbox"))("binary", true)("indeterminate", ctx_r1.node.partialSelected)("disabled", ctx_r1.node.selectable === false)("variant", (ctx_r1.tree == null ? null : ctx_r1.tree.config.inputStyle()) === "filled" || (ctx_r1.tree == null ? null : ctx_r1.tree.config.inputVariant()) === "filled" ? "filled" : "outlined")("tabindex", -1)("pt", ctx_r1.getPTOptions("pcNodeCheckbox"))("unstyled", ctx_r1.unstyled());
    \u0275\u0275attribute("data-p-partialchecked", ctx_r1.node.partialSelected);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.tree.checkboxIconTemplate || ctx_r1.tree._checkboxIconTemplate);
  }
}
function UITreeNode_Conditional_0_span_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.getIcon());
    \u0275\u0275property("pBind", ctx_r1.getPTOptions("nodeIcon"));
  }
}
function UITreeNode_Conditional_0_span_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.node.label);
  }
}
function UITreeNode_Conditional_0_span_10_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function UITreeNode_Conditional_0_span_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275template(1, UITreeNode_Conditional_0_span_10_ng_container_1_Template, 1, 0, "ng-container", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.tree.getTemplateForNode(ctx_r1.node))("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c37, ctx_r1.node));
  }
}
function UITreeNode_Conditional_0_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cx("dropPoint", \u0275\u0275pureFunction0(4, _c46)));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions("dropPoint"));
    \u0275\u0275attribute("aria-hidden", true);
  }
}
function UITreeNode_Conditional_0_ul_12_p_treeNode_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-treeNode", 20);
  }
  if (rf & 2) {
    const childNode_r4 = ctx.$implicit;
    const firstChild_r5 = ctx.first;
    const lastChild_r6 = ctx.last;
    const index_r7 = ctx.index;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("node", childNode_r4)("parentNode", ctx_r1.node)("firstChild", firstChild_r5)("lastChild", lastChild_r6)("index", index_r7)("itemSize", ctx_r1.itemSize)("level", ctx_r1.level + 1)("loadingMode", ctx_r1.loadingMode)("pt", ctx_r1.pt)("unstyled", ctx_r1.unstyled());
  }
}
function UITreeNode_Conditional_0_ul_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 18);
    \u0275\u0275template(1, UITreeNode_Conditional_0_ul_12_p_treeNode_1_Template, 1, 10, "p-treeNode", 19);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cx("nodeChildren"));
    \u0275\u0275property("pBind", ctx_r1.ptm("nodeChildren"));
    \u0275\u0275advance();
    \u0275\u0275property("ngForOf", ctx_r1.node.children)("ngForTrackBy", ctx_r1.tree.trackBy.bind(ctx_r1));
  }
}
function UITreeNode_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 2);
    \u0275\u0275listener("keydown", function UITreeNode_Conditional_0_Template_li_keydown_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onKeyDown($event));
    });
    \u0275\u0275conditionalCreate(1, UITreeNode_Conditional_0_Conditional_1_Template, 1, 4, "div", 3);
    \u0275\u0275elementStart(2, "div", 4);
    \u0275\u0275listener("click", function UITreeNode_Conditional_0_Template_div_click_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeClick($event));
    })("contextmenu", function UITreeNode_Conditional_0_Template_div_contextmenu_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeRightClick($event));
    })("dblclick", function UITreeNode_Conditional_0_Template_div_dblclick_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeDblClick($event));
    })("touchend", function UITreeNode_Conditional_0_Template_div_touchend_2_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeTouchEnd());
    })("drop", function UITreeNode_Conditional_0_Template_div_drop_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeDrop($event));
    })("dragstart", function UITreeNode_Conditional_0_Template_div_dragstart_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeDragStart($event));
    })("dragover", function UITreeNode_Conditional_0_Template_div_dragover_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeDragOver($event));
    })("dragleave", function UITreeNode_Conditional_0_Template_div_dragleave_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeDragLeave($event));
    })("dragend", function UITreeNode_Conditional_0_Template_div_dragend_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onNodeDragEnd($event));
    });
    \u0275\u0275elementStart(3, "button", 5);
    \u0275\u0275listener("click", function UITreeNode_Conditional_0_Template_button_click_3_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggle($event));
    });
    \u0275\u0275template(4, UITreeNode_Conditional_0_ng_container_4_Template, 3, 2, "ng-container", 6)(5, UITreeNode_Conditional_0_span_5_Template, 2, 8, "span", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275template(6, UITreeNode_Conditional_0_p_checkbox_6_Template, 2, 11, "p-checkbox", 8)(7, UITreeNode_Conditional_0_span_7_Template, 1, 3, "span", 7);
    \u0275\u0275elementStart(8, "span", 9);
    \u0275\u0275template(9, UITreeNode_Conditional_0_span_9_Template, 2, 1, "span", 6)(10, UITreeNode_Conditional_0_span_10_Template, 2, 4, "span", 6);
    \u0275\u0275elementEnd()();
    \u0275\u0275conditionalCreate(11, UITreeNode_Conditional_0_Conditional_11_Template, 1, 5, "div", 3);
    \u0275\u0275template(12, UITreeNode_Conditional_0_ul_12_Template, 2, 5, "ul", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r1.node.style);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("node"), ctx_r1.node.styleClass));
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(36, _c016, ctx_r1.itemSize + "px"))("pBind", ctx_r1.getPTOptions("node"));
    \u0275\u0275attribute("aria-label", ctx_r1.node.label)("aria-checked", ctx_r1.checked)("aria-setsize", ctx_r1.node.children ? ctx_r1.node.children.length : 0)("aria-selected", ctx_r1.selected)("aria-expanded", ctx_r1.node.expanded)("aria-posinset", ctx_r1.index + 1)("aria-level", ctx_r1.level + 1)("tabindex", ctx_r1.index === 0 ? 0 : -1)("data-id", ctx_r1.node.key);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.isPrevDropPointActive() ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("nodeContent"));
    \u0275\u0275styleProp("padding-left", ctx_r1.level * ctx_r1.indentation + "rem");
    \u0275\u0275property("draggable", ctx_r1.tree.draggableNodes)("pBind", ctx_r1.getPTOptions("nodeContent"));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("nodeToggleButton"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions("nodeToggleButton"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.tree.togglerIconTemplate && !ctx_r1.tree._togglerIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.tree.togglerIconTemplate || ctx_r1.tree._togglerIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.tree.selectionMode == "checkbox");
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.node.icon || ctx_r1.node.expandedIcon || ctx_r1.node.collapsedIcon);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("nodeLabel"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions("nodeLabel"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.tree.getTemplateForNode(ctx_r1.node));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.tree.getTemplateForNode(ctx_r1.node));
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.isNextDropPointActive() ? 11 : -1);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.tree.virtualScroll && ctx_r1.node.children && ctx_r1.node.expanded);
  }
}
var _c56 = ["filter"];
var _c65 = ["node"];
var _c75 = ["header"];
var _c84 = ["footer"];
var _c94 = ["loader"];
var _c103 = ["empty"];
var _c113 = ["togglericon"];
var _c124 = ["checkboxicon"];
var _c134 = ["loadingicon"];
var _c144 = ["filtericon"];
var _c154 = ["scroller"];
var _c163 = ["wrapper"];
var _c173 = ["content"];
var _c183 = (a0) => ({
  options: a0
});
function Tree_div_0_i_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 11);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.cn(ctx_r0.cx("loadingIcon"), "pi-spin" + ctx_r0.loadingIcon));
    \u0275\u0275property("pBind", ctx_r0.ptm("loadingIcon"));
  }
}
function Tree_div_0_ng_container_2__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 13);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r0.cx("loadingIcon"));
    \u0275\u0275property("pBind", ctx_r0.ptm("loadingIcon"));
  }
}
function Tree_div_0_ng_container_2_span_2_1_ng_template_0_Template(rf, ctx) {
}
function Tree_div_0_ng_container_2_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Tree_div_0_ng_container_2_span_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function Tree_div_0_ng_container_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 11);
    \u0275\u0275template(1, Tree_div_0_ng_container_2_span_2_1_Template, 1, 0, null, 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r0.cx("loadingIcon"));
    \u0275\u0275property("pBind", ctx_r0.ptm("loadingIcon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.loadingIconTemplate || ctx_r0._loadingIconTemplate);
  }
}
function Tree_div_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Tree_div_0_ng_container_2__svg_svg_1_Template, 1, 3, "svg", 12)(2, Tree_div_0_ng_container_2_span_2_Template, 2, 4, "span", 7);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.loadingIconTemplate && !ctx_r0._loadingIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.loadingIconTemplate || ctx_r0._loadingIconTemplate);
  }
}
function Tree_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275animateLeave("p-overlay-mask-leave-active");
    \u0275\u0275animateEnter("p-overlay-mask-enter-active");
    \u0275\u0275template(1, Tree_div_0_i_1_Template, 1, 3, "i", 7)(2, Tree_div_0_ng_container_2_Template, 3, 2, "ng-container", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r0.cx("mask"));
    \u0275\u0275property("pBind", ctx_r0.ptm("mask"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.loadingIcon);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.loadingIcon);
  }
}
function Tree_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Tree_Conditional_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Tree_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Tree_Conditional_2_ng_container_0_Template, 1, 0, "ng-container", 14);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.filterTemplate || ctx_r0._filterTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c37, ctx_r0.filterOptions));
  }
}
function Tree_Conditional_3_p_iconfield_0__svg_svg_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 19);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r0.cx("filterIcon"));
    \u0275\u0275property("pBind", ctx_r0.ptm("filterIcon"));
  }
}
function Tree_Conditional_3_p_iconfield_0_span_5_1_ng_template_0_Template(rf, ctx) {
}
function Tree_Conditional_3_p_iconfield_0_span_5_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Tree_Conditional_3_p_iconfield_0_span_5_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function Tree_Conditional_3_p_iconfield_0_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 11);
    \u0275\u0275template(1, Tree_Conditional_3_p_iconfield_0_span_5_1_Template, 1, 0, null, 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r0.cx("filterIcon"));
    \u0275\u0275property("pBind", ctx_r0.ptm("filterIcon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.filterIconTemplate || ctx_r0._filterIconTemplate);
  }
}
function Tree_Conditional_3_p_iconfield_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-iconfield", 16)(1, "input", 17, 0);
    \u0275\u0275listener("keydown.enter", function Tree_Conditional_3_p_iconfield_0_Template_input_keydown_enter_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      return \u0275\u0275resetView($event.preventDefault());
    })("input", function Tree_Conditional_3_p_iconfield_0_Template_input_input_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0._filter($event.target == null ? null : $event.target.value));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "p-inputicon", 16);
    \u0275\u0275template(4, Tree_Conditional_3_p_iconfield_0__svg_svg_4_Template, 1, 3, "svg", 18)(5, Tree_Conditional_3_p_iconfield_0_span_5_Template, 2, 4, "span", 7);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.cx("pcFilterContainer"));
    \u0275\u0275property("pt", ctx_r0.ptm("pcFilterContainer"))("unstyled", ctx_r0.unstyled());
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r0.cx("pcFilterInput"));
    \u0275\u0275property("pAutoFocus", ctx_r0.filterInputAutoFocus)("pt", ctx_r0.ptm("pcFilterInput"))("unstyled", ctx_r0.unstyled());
    \u0275\u0275attribute("placeholder", ctx_r0.filterPlaceholder);
    \u0275\u0275advance(2);
    \u0275\u0275property("pt", ctx_r0.ptm("pcFilterIconContainer"))("unstyled", ctx_r0.unstyled());
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.filterIconTemplate && !ctx_r0._filterIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.filterIconTemplate || ctx_r0._filterIconTemplate);
  }
}
function Tree_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Tree_Conditional_3_p_iconfield_0_Template, 6, 14, "p-iconfield", 15);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r0.filter);
  }
}
function Tree_ng_container_4_p_scroller_1_ng_template_2_ul_0_p_treeNode_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-treeNode", 25, 3);
  }
  if (rf & 2) {
    const rowNode_r4 = ctx.$implicit;
    const firstChild_r5 = ctx.first;
    const lastChild_r6 = ctx.last;
    const index_r7 = ctx.index;
    const scrollerOptions_r8 = \u0275\u0275nextContext(2).options;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275property("level", rowNode_r4.level)("rowNode", rowNode_r4)("node", rowNode_r4.node)("parentNode", rowNode_r4.parent)("firstChild", firstChild_r5)("lastChild", lastChild_r6)("index", ctx_r0.getIndex(scrollerOptions_r8, index_r7))("itemSize", scrollerOptions_r8.itemSize)("indentation", ctx_r0.indentation)("loadingMode", ctx_r0.loadingMode)("pt", ctx_r0.pt)("unstyled", ctx_r0.unstyled());
  }
}
function Tree_ng_container_4_p_scroller_1_ng_template_2_ul_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 23, 2);
    \u0275\u0275template(2, Tree_ng_container_4_p_scroller_1_ng_template_2_ul_0_p_treeNode_2_Template, 2, 12, "p-treeNode", 24);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = \u0275\u0275nextContext();
    const items_r10 = ctx_r8.$implicit;
    const scrollerOptions_r8 = ctx_r8.options;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275styleMap(scrollerOptions_r8.contentStyle);
    \u0275\u0275classMap(ctx_r0.cx("rootChildren"));
    \u0275\u0275property("ngClass", scrollerOptions_r8.contentStyleClass)("pBind", ctx_r0.ptm("rootChildren"));
    \u0275\u0275attribute("aria-label", ctx_r0.ariaLabel)("aria-labelledby", ctx_r0.ariaLabelledBy);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", items_r10)("ngForTrackBy", ctx_r0.trackBy);
  }
}
function Tree_ng_container_4_p_scroller_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Tree_ng_container_4_p_scroller_1_ng_template_2_ul_0_Template, 3, 10, "ul", 22);
  }
  if (rf & 2) {
    const items_r10 = ctx.$implicit;
    \u0275\u0275property("ngIf", items_r10);
  }
}
function Tree_ng_container_4_p_scroller_1_ng_container_4_ng_template_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function Tree_ng_container_4_p_scroller_1_ng_container_4_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Tree_ng_container_4_p_scroller_1_ng_container_4_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 14);
  }
  if (rf & 2) {
    const scrollerOptions_r11 = ctx.options;
    const ctx_r0 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.loaderTemplate || ctx_r0._loaderTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c183, scrollerOptions_r11));
  }
}
function Tree_ng_container_4_p_scroller_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Tree_ng_container_4_p_scroller_1_ng_container_4_ng_template_1_Template, 1, 4, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
}
function Tree_ng_container_4_p_scroller_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-scroller", 21, 1);
    \u0275\u0275listener("onScroll", function Tree_ng_container_4_p_scroller_1_Template_p_scroller_onScroll_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onScroll.emit($event));
    })("onScrollIndexChange", function Tree_ng_container_4_p_scroller_1_Template_p_scroller_onScrollIndexChange_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onScrollIndexChange.emit($event));
    })("onLazyLoad", function Tree_ng_container_4_p_scroller_1_Template_p_scroller_onLazyLoad_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onLazyLoad.emit($event));
    });
    \u0275\u0275template(2, Tree_ng_container_4_p_scroller_1_ng_template_2_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(4, Tree_ng_container_4_p_scroller_1_ng_container_4_Template, 3, 0, "ng-container", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275styleMap(\u0275\u0275pureFunction1(12, _c016, ctx_r0.scrollHeight !== "flex" ? ctx_r0.scrollHeight : void 0));
    \u0275\u0275property("items", ctx_r0.serializedValue)("tabindex", -1)("styleClass", ctx_r0.cx("wrapper"))("scrollHeight", ctx_r0.scrollHeight !== "flex" ? void 0 : "100%")("itemSize", ctx_r0.virtualScrollItemSize)("lazy", ctx_r0.lazy)("options", ctx_r0.virtualScrollOptions)("pt", ctx_r0.ptm("virtualScroller"));
    \u0275\u0275attribute("data-p", ctx_r0.wrapperDataP);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngIf", ctx_r0.loaderTemplate || ctx_r0._loaderTemplate);
  }
}
function Tree_ng_container_4_ng_container_2_ul_3_p_treeNode_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-treeNode", 29);
  }
  if (rf & 2) {
    const node_r12 = ctx.$implicit;
    const firstChild_r13 = ctx.first;
    const lastChild_r14 = ctx.last;
    const index_r15 = ctx.index;
    const ctx_r0 = \u0275\u0275nextContext(4);
    \u0275\u0275property("node", node_r12)("firstChild", firstChild_r13)("lastChild", lastChild_r14)("index", index_r15)("level", 0)("loadingMode", ctx_r0.loadingMode)("pt", ctx_r0.pt)("unstyled", ctx_r0.unstyled());
  }
}
function Tree_ng_container_4_ng_container_2_ul_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 27, 2);
    \u0275\u0275template(2, Tree_ng_container_4_ng_container_2_ul_3_p_treeNode_2_Template, 1, 8, "p-treeNode", 28);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r0.cx("rootChildren"));
    \u0275\u0275property("pBind", ctx_r0.ptm("rootChildren"));
    \u0275\u0275attribute("aria-label", ctx_r0.ariaLabel)("aria-labelledby", ctx_r0.ariaLabelledBy);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r0.getRootNode())("ngForTrackBy", ctx_r0.trackBy.bind(ctx_r0));
  }
}
function Tree_ng_container_4_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "div", 11, 5);
    \u0275\u0275template(3, Tree_ng_container_4_ng_container_2_ul_3_Template, 3, 7, "ul", 26);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r0.cx("wrapper"));
    \u0275\u0275styleProp("max-height", ctx_r0.scrollHeight);
    \u0275\u0275property("pBind", ctx_r0.ptm("wrapper"));
    \u0275\u0275attribute("data-p", ctx_r0.wrapperDataP);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r0.getRootNode());
  }
}
function Tree_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, Tree_ng_container_4_p_scroller_1_Template, 5, 14, "p-scroller", 20)(2, Tree_ng_container_4_ng_container_2_Template, 4, 7, "ng-container", 10);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r0.virtualScroll);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.virtualScroll);
  }
}
function Tree_div_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.emptyMessageLabel, " ");
  }
}
function Tree_div_5_2_ng_template_0_Template(rf, ctx) {
}
function Tree_div_5_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, Tree_div_5_2_ng_template_0_Template, 0, 0, "ng-template", null, 6, \u0275\u0275templateRefExtractor);
  }
}
function Tree_div_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275template(1, Tree_div_5_ng_container_1_Template, 2, 1, "ng-container", 30)(2, Tree_div_5_2_Template, 2, 0, null, 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r0.cx("emptyMessage"));
    \u0275\u0275property("pBind", ctx_r0.ptm("emptyMessage"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r0.emptyTemplate && !ctx_r0._emptyTemplate)("ngIfElse", ctx_r0.emptyFilter);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.emptyTemplate || ctx_r0._emptyTemplate);
  }
}
function Tree_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
var classes10 = {
  root: ({
    instance
  }) => ["p-tree p-component", {
    "p-tree-selectable": instance.selectionMode != null,
    "p-tree-loading": instance.loading,
    "p-tree-flex-scrollable": instance.scrollHeight === "flex",
    "p-tree-node-dragover": instance.dragHover
  }],
  mask: "p-tree-mask p-overlay-mask",
  loadingIcon: "p-tree-loading-icon",
  pcFilterInput: "p-tree-filter-input",
  wrapper: "p-tree-root",
  rootChildren: "p-tree-root-children",
  node: ({
    instance
  }) => ({
    "p-tree-node": true,
    "p-tree-node-leaf": instance.isLeaf()
  }),
  nodeContent: ({
    instance
  }) => ({
    "p-tree-node-content": true,
    "p-tree-node-selectable": instance.selectable,
    "p-tree-node-dragover": instance.isNodeDropActive(),
    "p-tree-node-selected": instance.selectionMode === "checkbox" && instance.tree.highlightOnSelect ? instance.checked : instance.selected,
    "p-tree-node-contextmenu-selected": instance.isContextMenuSelected()
  }),
  nodeToggleButton: "p-tree-node-toggle-button",
  nodeToggleIcon: "p-tree-node-toggle-icon",
  nodeCheckbox: "p-tree-node-checkbox",
  nodeIcon: "p-tree-node-icon",
  nodeLabel: "p-tree-node-label",
  nodeChildren: "p-tree-node-children",
  emptyMessage: "p-tree-empty-message",
  dropPoint: "p-tree-node-drop-point"
};
var TreeStyle = class _TreeStyle extends BaseStyle {
  name = "tree";
  style = style13;
  classes = classes10;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275TreeStyle_BaseFactory;
    return function TreeStyle_Factory(__ngFactoryType__) {
      return (\u0275TreeStyle_BaseFactory || (\u0275TreeStyle_BaseFactory = \u0275\u0275getInheritedFactory(_TreeStyle)))(__ngFactoryType__ || _TreeStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TreeStyle,
    factory: _TreeStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeStyle, [{
    type: Injectable
  }], null, null);
})();
var TreeClasses;
(function(TreeClasses2) {
  TreeClasses2["root"] = "p-tree";
  TreeClasses2["mask"] = "p-tree-mask";
  TreeClasses2["loadingIcon"] = "p-tree-loading-icon";
  TreeClasses2["pcFilterInput"] = "p-tree-filter-input";
  TreeClasses2["wrapper"] = "p-tree-root";
  TreeClasses2["rootChildren"] = "p-tree-root-children";
  TreeClasses2["node"] = "p-tree-node";
  TreeClasses2["nodeContent"] = "p-tree-node-content";
  TreeClasses2["nodeToggleButton"] = "p-tree-node-toggle-button";
  TreeClasses2["nodeToggleIcon"] = "p-tree-node-toggle-icon";
  TreeClasses2["nodeCheckbox"] = "p-tree-node-checkbox";
  TreeClasses2["nodeIcon"] = "p-tree-node-icon";
  TreeClasses2["nodeLabel"] = "p-tree-node-label";
  TreeClasses2["nodeChildren"] = "p-tree-node-children";
  TreeClasses2["emptyMessage"] = "p-tree-empty-message";
  TreeClasses2["dropPoint"] = "p-tree-node-droppoint";
})(TreeClasses || (TreeClasses = {}));
var TREE_INSTANCE = new InjectionToken("TREE_INSTANCE");
var TREENODE_INSTANCE = new InjectionToken("TREENODE_INSTANCE");
var UITreeNode = class _UITreeNode extends BaseComponent {
  $pcTreeNode = inject(TREENODE_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  static ICON_CLASS = "p-tree-node-icon ";
  rowNode;
  node;
  parentNode;
  root;
  index;
  firstChild;
  lastChild;
  level;
  indentation;
  itemSize;
  loadingMode;
  tree = inject(forwardRef(() => Tree));
  timeout;
  isPrevDropPointHovered = signal(false, ...ngDevMode ? [{
    debugName: "isPrevDropPointHovered"
  }] : []);
  isNextDropPointHovered = signal(false, ...ngDevMode ? [{
    debugName: "isNextDropPointHovered"
  }] : []);
  isNodeDropHovered = signal(false, ...ngDevMode ? [{
    debugName: "isNodeDropHovered"
  }] : []);
  isPrevDropPointActive = computed(() => this.isPrevDropPointHovered() && this.isDroppable(), ...ngDevMode ? [{
    debugName: "isPrevDropPointActive"
  }] : []);
  isNextDropPointActive = computed(() => this.isNextDropPointHovered() && this.isDroppable(), ...ngDevMode ? [{
    debugName: "isNextDropPointActive"
  }] : []);
  isNodeDropActive = computed(() => this.isNodeDropHovered() && this.isNodeDroppable(), ...ngDevMode ? [{
    debugName: "isNodeDropActive"
  }] : []);
  dropPosition = computed(() => this.isPrevDropPointActive() ? -1 : this.isNextDropPointActive() ? 1 : 0, ...ngDevMode ? [{
    debugName: "dropPosition"
  }] : []);
  _componentStyle = inject(TreeStyle);
  /**
   * Computed signal that reactively tracks selection state.
   */
  _selected = computed(() => {
    this.tree.selection();
    return this.tree.isSelected(this.node);
  }, ...ngDevMode ? [{
    debugName: "_selected"
  }] : []);
  /**
   * Computed signal that reactively tracks context menu selection state.
   */
  _contextMenuSelected = computed(() => {
    const selection = this.tree.contextMenuSelection();
    if (!selection || !this.node) {
      return false;
    }
    return selection === this.node || selection.key && selection.key === this.node.key;
  }, ...ngDevMode ? [{
    debugName: "_contextMenuSelected"
  }] : []);
  get selected() {
    return this.tree.selectionMode === "single" || this.tree.selectionMode === "multiple" ? this._selected() : void 0;
  }
  get checked() {
    return this.tree.selectionMode === "checkbox" ? this._selected() : void 0;
  }
  get nodeClass() {
    return this.tree._componentStyle.classes.node({
      instance: this
    });
  }
  get selectable() {
    return this.node?.selectable === false ? false : this.tree?.selectionMode != null;
  }
  get subNodes() {
    return this.node?.parent ? this.node.parent.children : this.tree.value;
  }
  getPTOptions(key) {
    return this.ptm(key, {
      context: {
        node: this.node,
        index: this.index,
        expanded: this.node?.expanded,
        selected: this.selected,
        checked: this.checked,
        partialChecked: this.node?.partialSelected,
        leaf: this.isLeaf()
      }
    });
  }
  onInit() {
    this.node.parent = this.parentNode;
    const nativeElement = this.tree.el.nativeElement;
    const pDialogWrapper = nativeElement.closest("p-dialog");
    if (this.parentNode && !pDialogWrapper) {
      this.setAllNodesTabIndexes();
      this.tree.syncNodeOption(this.node, this.tree.value, "parent", this.tree.getNodeWithKey(this.parentNode.key, this.tree.value));
    }
  }
  getIcon() {
    let icon;
    if (this.node.icon) icon = this.node.icon;
    else icon = this.node.expanded && this.node.children && this.node.children?.length ? this.node.expandedIcon : this.node.collapsedIcon;
    return _UITreeNode.ICON_CLASS + " " + icon + " p-tree-node-icon";
  }
  isLeaf() {
    return this.tree.isNodeLeaf(this.node);
  }
  isSelected() {
    return this._selected();
  }
  isContextMenuSelected() {
    return this._contextMenuSelected();
  }
  isSameNode(event) {
    return event.currentTarget && (event.currentTarget.isSameNode(event.target) || event.currentTarget.isSameNode(event.target.closest('[role="treeitem"]')));
  }
  isDraggable() {
    return this.tree.draggableNodes;
  }
  isDroppable() {
    return this.tree.droppableNodes && this.tree.allowDrop(this.tree.dragNode, this.node, this.tree.dragNodeScope);
  }
  isNodeDroppable() {
    return this.node?.droppable !== false && this.isDroppable();
  }
  isNodeDraggable() {
    return this.node?.draggable !== false && this.isDraggable();
  }
  toggle(event) {
    if (this.node.expanded) this.collapse(event);
    else this.expand(event);
    event.stopPropagation();
  }
  expand(event) {
    this.node.expanded = true;
    if (this.tree.virtualScroll) {
      this.tree.updateSerializedValue();
      this.focusVirtualNode();
    }
    this.tree.onNodeExpand.emit({
      originalEvent: event,
      node: this.node
    });
  }
  collapse(event) {
    this.node.expanded = false;
    if (this.tree.virtualScroll) {
      this.tree.updateSerializedValue();
      this.focusVirtualNode();
    }
    this.tree.onNodeCollapse.emit({
      originalEvent: event,
      node: this.node
    });
  }
  onNodeClick(event) {
    this.tree.onNodeClick(event, this.node);
  }
  onNodeKeydown(event) {
    if (event.key === "Enter") {
      this.tree.onNodeClick(event, this.node);
    }
  }
  onNodeTouchEnd() {
    this.tree.onNodeTouchEnd();
  }
  onNodeRightClick(event) {
    this.tree.onNodeRightClick(event, this.node);
  }
  onNodeDblClick(event) {
    this.tree.onNodeDblClick(event, this.node);
  }
  insertNodeOnDrop() {
    const {
      dragNode,
      dragNodeIndex,
      dragNodeSubNodes
    } = this.tree;
    if (!this.node || dragNodeIndex == null || !dragNode || !dragNodeSubNodes) {
      return;
    }
    const position = this.dropPosition();
    const subNodes = this.subNodes || [];
    const index = this.index || 0;
    const dropIndex = dragNodeSubNodes === subNodes ? dragNodeIndex > index ? index : index - 1 : index;
    dragNodeSubNodes.splice(dragNodeIndex, 1);
    if (position < 0) {
      subNodes.splice(dropIndex, 0, dragNode);
    } else if (position > 0) {
      subNodes.splice(dropIndex + 1, 0, dragNode);
    } else {
      this.node.children = this.node.children || [];
      this.node.children.push(dragNode);
    }
    this.tree.dragDropService.stopDrag({
      node: dragNode,
      subNodes,
      index: dragNodeIndex
    });
  }
  onNodeDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.isDroppable()) {
      const {
        dragNode
      } = this.tree;
      const position = this.dropPosition();
      const isValidDrop = position !== 0 || position === 0 && this.isNodeDroppable();
      if (isValidDrop) {
        if (this.tree.validateDrop) {
          this.tree.onNodeDrop.emit({
            originalEvent: event,
            dragNode,
            dropNode: this.node,
            index: this.index,
            accept: () => {
              this.insertNodeOnDrop();
            }
          });
        } else {
          this.insertNodeOnDrop();
          this.tree.onNodeDrop.emit({
            originalEvent: event,
            dragNode,
            dropNode: this.node,
            index: this.index
          });
        }
      }
    }
    this.isPrevDropPointHovered.set(false);
    this.isNextDropPointHovered.set(false);
    this.isNodeDropHovered.set(false);
  }
  onNodeDragStart(event) {
    if (this.isNodeDraggable()) {
      event.dataTransfer.effectAllowed = "all";
      event.dataTransfer?.setData("text", "data");
      const target = event.currentTarget;
      const dragEl = target.cloneNode(true);
      const toggler = dragEl.querySelector('[data-pc-section="nodetogglebutton"]');
      const checkbox = dragEl.querySelector('[data-pc-name="pcnodecheckbox"]');
      target.setAttribute("data-p-dragging", "true");
      dragEl.style.width = v(target) + "px";
      dragEl.style.height = C(target) + "px";
      dragEl.setAttribute("data-pc-section", "drag-image");
      toggler.style.visibility = "hidden";
      checkbox?.remove();
      document.body.appendChild(dragEl);
      event.dataTransfer?.setDragImage(dragEl, 0, 0);
      setTimeout(() => document.body.removeChild(dragEl), 0);
      this.tree.dragDropService.startDrag({
        tree: this,
        node: this.node,
        subNodes: this.subNodes,
        index: this.index,
        scope: this.tree.draggableScope
      });
    } else {
      event.preventDefault();
    }
  }
  onNodeDragOver(event) {
    if (this.isDroppable()) {
      event.dataTransfer.dropEffect = "copy";
      const nodeElement = event.currentTarget;
      const rect = nodeElement.getBoundingClientRect();
      const y = event.clientY - parseInt(rect.top);
      this.isPrevDropPointHovered.set(false);
      this.isNextDropPointHovered.set(false);
      this.isNodeDropHovered.set(false);
      if (y < rect.height * 0.25) {
        this.isPrevDropPointHovered.set(true);
      } else if (y > rect.height * 0.75) {
        this.isNextDropPointHovered.set(true);
      } else if (this.isNodeDroppable()) {
        this.isNodeDropHovered.set(true);
      }
    } else {
      event.dataTransfer.dropEffect = "none";
    }
    if (this.tree.droppableNodes) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  onNodeDragLeave() {
    this.isPrevDropPointHovered.set(false);
    this.isNextDropPointHovered.set(false);
    this.isNodeDropHovered.set(false);
  }
  onNodeDragEnd(event) {
    event.currentTarget?.removeAttribute("data-p-dragging");
    this.tree.dragDropService.stopDrag({
      node: this.node,
      subNodes: this.subNodes,
      index: this.index
    });
  }
  onKeyDown(event) {
    if (!this.isSameNode(event) || this.tree.contextMenu && this.tree.contextMenu.containerViewChild?.nativeElement.style.display === "block") {
      return;
    }
    switch (event.code) {
      //down arrow
      case "ArrowDown":
        this.onArrowDown(event);
        break;
      //up arrow
      case "ArrowUp":
        this.onArrowUp(event);
        break;
      //right arrow
      case "ArrowRight":
        this.onArrowRight(event);
        break;
      //left arrow
      case "ArrowLeft":
        this.onArrowLeft(event);
        break;
      //enter
      case "Enter":
      case "Space":
      case "NumpadEnter":
        this.onEnter(event);
        break;
      //tab
      case "Tab":
        this.setAllNodesTabIndexes();
        break;
      default:
        break;
    }
  }
  onArrowUp(event) {
    const nodeElement = event.target.getAttribute("data-pc-section") === "nodetogglebutton" ? event.target.closest('[role="treeitem"]') : event.target.parentElement;
    if (nodeElement?.previousElementSibling) {
      this.focusRowChange(nodeElement, nodeElement.previousElementSibling, this.findLastVisibleDescendant(nodeElement.previousElementSibling));
    } else {
      let parentNodeElement = this.getParentNodeElement(nodeElement);
      if (parentNodeElement) {
        this.focusRowChange(nodeElement, parentNodeElement);
      }
    }
    event.preventDefault();
  }
  onArrowDown(event) {
    const nodeElement = event.target.getAttribute("data-pc-section") === "nodetogglebutton" ? event.target.closest('[role="treeitem"]') : event.target;
    const listElement = nodeElement?.children[1];
    if (listElement && listElement.children.length > 0) {
      this.focusRowChange(nodeElement, listElement.children[0]);
    } else {
      if (nodeElement?.parentElement?.nextElementSibling) {
        this.focusRowChange(nodeElement, nodeElement.parentElement.nextElementSibling);
      } else {
        let nextSiblingAncestor = this.findNextSiblingOfAncestor(nodeElement?.parentElement);
        if (nextSiblingAncestor) {
          this.focusRowChange(nodeElement, nextSiblingAncestor);
        }
      }
    }
    event.preventDefault();
  }
  onArrowRight(event) {
    if (!this.node?.expanded && !this.tree.isNodeLeaf(this.node)) {
      this.expand(event);
      event.currentTarget.tabIndex = -1;
      setTimeout(() => {
        this.onArrowDown(event);
      }, 1);
    }
    event.preventDefault();
  }
  onArrowLeft(event) {
    const nodeElement = event.target.getAttribute("data-pc-section") === "nodetogglebutton" ? event.target.closest('[role="treeitem"]') : event.target;
    if (this.level === 0 && !this.node?.expanded) {
      return false;
    }
    if (this.node?.expanded) {
      this.collapse(event);
      return;
    }
    let parentNodeElement = this.getParentNodeElement(nodeElement?.parentElement);
    if (parentNodeElement) {
      this.focusRowChange(event.currentTarget, parentNodeElement);
    }
    event.preventDefault();
  }
  onEnter(event) {
    this.tree.onNodeClick(event, this.node);
    this.setTabIndexForSelectionMode(event, this.tree.nodeTouched);
    event.preventDefault();
  }
  setAllNodesTabIndexes() {
    const nodes = Y(this.tree.el.nativeElement, '[data-pc-section="node"]');
    const hasSelectedNode = [...nodes].some((node) => node.getAttribute("aria-selected") === "true" || node.getAttribute("aria-checked") === "true");
    [...nodes].forEach((node) => {
      node.tabIndex = -1;
    });
    if (hasSelectedNode) {
      const selectedNodes = [...nodes].filter((node) => node.getAttribute("aria-selected") === "true" || node.getAttribute("aria-checked") === "true");
      selectedNodes[0].tabIndex = 0;
      return;
    }
    if (nodes.length) {
      [...nodes][0].tabIndex = 0;
    }
  }
  setTabIndexForSelectionMode(event, nodeTouched) {
    if (this.tree.selectionMode !== null) {
      const elements = [...Y(this.tree.el.nativeElement, '[role="treeitem"]')];
      event.currentTarget.tabIndex = nodeTouched === false ? -1 : 0;
      if (elements.every((element) => element.tabIndex === -1)) {
        elements[0].tabIndex = 0;
      }
    }
  }
  findNextSiblingOfAncestor(nodeElement) {
    let parentNodeElement = this.getParentNodeElement(nodeElement);
    if (parentNodeElement) {
      if (parentNodeElement.nextElementSibling) return parentNodeElement.nextElementSibling;
      else return this.findNextSiblingOfAncestor(parentNodeElement);
    } else {
      return null;
    }
  }
  findLastVisibleDescendant(nodeElement) {
    const listElement = Array.from(nodeElement.children).find((el) => el.getAttribute("data-pc-section") === "node");
    const childrenListElement = listElement?.children[1];
    if (childrenListElement && childrenListElement.children.length > 0) {
      const lastChildElement = childrenListElement.children[childrenListElement.children.length - 1];
      return this.findLastVisibleDescendant(lastChildElement);
    } else {
      return nodeElement;
    }
  }
  getParentNodeElement(nodeElement) {
    const parentNodeElement = nodeElement.parentElement?.parentElement?.parentElement;
    return parentNodeElement?.tagName === "P-TREENODE" ? parentNodeElement : null;
  }
  focusNode(element) {
    if (this.tree.droppableNodes) element.children[1].focus();
    else element.children[0].focus();
  }
  focusRowChange(firstFocusableRow, currentFocusedRow, lastVisibleDescendant) {
    firstFocusableRow.tabIndex = "-1";
    currentFocusedRow.children[0].tabIndex = "0";
    this.focusNode(lastVisibleDescendant || currentFocusedRow);
  }
  focusVirtualNode() {
    this.timeout = setTimeout(() => {
      let node = z(this.tree?.contentViewChild?.nativeElement, `[data-id="${this.node?.key ?? this.node?.data}"]`);
      bt(node);
    }, 1);
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275UITreeNode_BaseFactory;
    return function UITreeNode_Factory(__ngFactoryType__) {
      return (\u0275UITreeNode_BaseFactory || (\u0275UITreeNode_BaseFactory = \u0275\u0275getInheritedFactory(_UITreeNode)))(__ngFactoryType__ || _UITreeNode);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _UITreeNode,
    selectors: [["p-treeNode"]],
    inputs: {
      rowNode: "rowNode",
      node: "node",
      parentNode: "parentNode",
      root: [2, "root", "root", booleanAttribute],
      index: [2, "index", "index", numberAttribute],
      firstChild: [2, "firstChild", "firstChild", booleanAttribute],
      lastChild: [2, "lastChild", "lastChild", booleanAttribute],
      level: [2, "level", "level", numberAttribute],
      indentation: [2, "indentation", "indentation", numberAttribute],
      itemSize: [2, "itemSize", "itemSize", numberAttribute],
      loadingMode: "loadingMode"
    },
    features: [\u0275\u0275ProvidersFeature([TreeStyle, {
      provide: TREENODE_INSTANCE,
      useExisting: _UITreeNode
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _UITreeNode
    }]), \u0275\u0275InheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["icon", ""], ["role", "treeitem", 3, "class", "ngStyle", "style", "pBind"], ["role", "treeitem", 3, "keydown", "ngStyle", "pBind"], [3, "class", "pBind"], [3, "click", "contextmenu", "dblclick", "touchend", "drop", "dragstart", "dragover", "dragleave", "dragend", "draggable", "pBind"], ["type", "button", "pRipple", "", "tabindex", "-1", 3, "click", "pBind"], [4, "ngIf"], [3, "class", "pBind", 4, "ngIf"], [3, "ngModel", "styleClass", "binary", "indeterminate", "disabled", "variant", "tabindex", "pt", "unstyled", "click", 4, "ngIf"], [3, "pBind"], ["role", "group", 3, "class", "pBind", 4, "ngIf"], ["data-p-icon", "chevron-right", 3, "class", "pBind", 4, "ngIf"], ["data-p-icon", "chevron-down", 3, "class", "pBind", 4, "ngIf"], ["data-p-icon", "chevron-right", 3, "pBind"], ["data-p-icon", "chevron-down", 3, "pBind"], ["data-p-icon", "spinner", "spin", "", 3, "pBind"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "click", "ngModel", "styleClass", "binary", "indeterminate", "disabled", "variant", "tabindex", "pt", "unstyled"], ["role", "group", 3, "pBind"], [3, "node", "parentNode", "firstChild", "lastChild", "index", "itemSize", "level", "loadingMode", "pt", "unstyled", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "node", "parentNode", "firstChild", "lastChild", "index", "itemSize", "level", "loadingMode", "pt", "unstyled"]],
    template: function UITreeNode_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275conditionalCreate(0, UITreeNode_Conditional_0_Template, 13, 38, "li", 1);
      }
      if (rf & 2) {
        \u0275\u0275conditional(ctx.node ? 0 : -1);
      }
    },
    dependencies: [_UITreeNode, CommonModule, NgForOf, NgIf, NgTemplateOutlet, NgStyle, Ripple, Checkbox, FormsModule, NgControlStatus, NgModel, ChevronRightIcon, ChevronDownIcon, SpinnerIcon, SharedModule, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UITreeNode, [{
    type: Component,
    args: [{
      selector: "p-treeNode",
      standalone: true,
      imports: [CommonModule, Ripple, Checkbox, FormsModule, ChevronRightIcon, ChevronDownIcon, SpinnerIcon, SharedModule, BindModule],
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
        @if (node) {
            <li
                [class]="cn(cx('node'), node.styleClass)"
                [ngStyle]="{ height: itemSize + 'px' }"
                [style]="node.style"
                [attr.aria-label]="node.label"
                [attr.aria-checked]="checked"
                [attr.aria-setsize]="node.children ? node.children.length : 0"
                [attr.aria-selected]="selected"
                [attr.aria-expanded]="node.expanded"
                [attr.aria-posinset]="index + 1"
                [attr.aria-level]="level + 1"
                [attr.tabindex]="index === 0 ? 0 : -1"
                [attr.data-id]="node.key"
                role="treeitem"
                (keydown)="onKeyDown($event)"
                [pBind]="getPTOptions('node')"
            >
                @if (isPrevDropPointActive()) {
                    <div [class]="cx('dropPoint')" [attr.aria-hidden]="true" [pBind]="getPTOptions('dropPoint')"></div>
                }
                <div
                    [class]="cx('nodeContent')"
                    [style.paddingLeft]="level * indentation + 'rem'"
                    (click)="onNodeClick($event)"
                    (contextmenu)="onNodeRightClick($event)"
                    (dblclick)="onNodeDblClick($event)"
                    (touchend)="onNodeTouchEnd()"
                    (drop)="onNodeDrop($event)"
                    (dragstart)="onNodeDragStart($event)"
                    (dragover)="onNodeDragOver($event)"
                    (dragleave)="onNodeDragLeave($event)"
                    (dragend)="onNodeDragEnd($event)"
                    [draggable]="tree.draggableNodes"
                    [pBind]="getPTOptions('nodeContent')"
                >
                    <button type="button" [class]="cx('nodeToggleButton')" (click)="toggle($event)" pRipple tabindex="-1" [pBind]="getPTOptions('nodeToggleButton')">
                        <ng-container *ngIf="!tree.togglerIconTemplate && !tree._togglerIconTemplate">
                            <ng-container *ngIf="!node.loading">
                                <svg data-p-icon="chevron-right" *ngIf="!node.expanded" [class]="cx('nodeToggleIcon')" [pBind]="getPTOptions('nodeToggleIcon')" />
                                <svg data-p-icon="chevron-down" *ngIf="node.expanded" [class]="cx('nodeToggleIcon')" [pBind]="getPTOptions('nodeToggleIcon')" />
                            </ng-container>
                            <ng-container *ngIf="loadingMode === 'icon' && node.loading">
                                <svg data-p-icon="spinner" [class]="cx('nodeToggleIcon')" spin [pBind]="getPTOptions('nodeToggleIcon')" />
                            </ng-container>
                        </ng-container>
                        <span *ngIf="tree.togglerIconTemplate || tree._togglerIconTemplate" [class]="cx('nodeToggleIcon')" [pBind]="getPTOptions('nodeToggleIcon')">
                            <ng-template *ngTemplateOutlet="tree.togglerIconTemplate || tree._togglerIconTemplate; context: { $implicit: node.expanded, loading: node.loading }"></ng-template>
                        </span>
                    </button>

                    <p-checkbox
                        [ngModel]="isSelected()"
                        [styleClass]="cx('nodeCheckbox')"
                        [binary]="true"
                        [indeterminate]="node.partialSelected"
                        *ngIf="tree.selectionMode == 'checkbox'"
                        [disabled]="node.selectable === false"
                        [variant]="tree?.config.inputStyle() === 'filled' || tree?.config.inputVariant() === 'filled' ? 'filled' : 'outlined'"
                        [attr.data-p-partialchecked]="node.partialSelected"
                        [tabindex]="-1"
                        (click)="$event.preventDefault()"
                        [pt]="getPTOptions('pcNodeCheckbox')"
                        [unstyled]="unstyled()"
                    >
                        <ng-container *ngIf="tree.checkboxIconTemplate || tree._checkboxIconTemplate">
                            <ng-template #icon>
                                <ng-template
                                    *ngTemplateOutlet="
                                        tree.checkboxIconTemplate || tree._checkboxIconTemplate;
                                        context: {
                                            $implicit: isSelected(),
                                            partialSelected: node.partialSelected,
                                            class: cx('nodeCheckbox')
                                        }
                                    "
                                ></ng-template>
                            </ng-template>
                        </ng-container>
                    </p-checkbox>

                    <span [class]="getIcon()" *ngIf="node.icon || node.expandedIcon || node.collapsedIcon" [pBind]="getPTOptions('nodeIcon')"></span>
                    <span [class]="cx('nodeLabel')" [pBind]="getPTOptions('nodeLabel')">
                        <span *ngIf="!tree.getTemplateForNode(node)">{{ node.label }}</span>
                        <span *ngIf="tree.getTemplateForNode(node)">
                            <ng-container *ngTemplateOutlet="tree.getTemplateForNode(node); context: { $implicit: node }"></ng-container>
                        </span>
                    </span>
                </div>
                @if (isNextDropPointActive()) {
                    <div [class]="cx('dropPoint', { next: true })" [attr.aria-hidden]="true" [pBind]="getPTOptions('dropPoint')"></div>
                }
                <ul [class]="cx('nodeChildren')" *ngIf="!tree.virtualScroll && node.children && node.expanded" role="group" [pBind]="ptm('nodeChildren')">
                    <p-treeNode
                        *ngFor="let childNode of node.children; let firstChild = first; let lastChild = last; let index = index; trackBy: tree.trackBy.bind(this)"
                        [node]="childNode"
                        [parentNode]="node"
                        [firstChild]="firstChild"
                        [lastChild]="lastChild"
                        [index]="index"
                        [itemSize]="itemSize"
                        [level]="level + 1"
                        [loadingMode]="loadingMode"
                        [pt]="pt"
                        [unstyled]="unstyled()"
                    ></p-treeNode>
                </ul>
            </li>
        }
    `,
      encapsulation: ViewEncapsulation.None,
      providers: [TreeStyle, {
        provide: TREENODE_INSTANCE,
        useExisting: UITreeNode
      }, {
        provide: PARENT_INSTANCE,
        useExisting: UITreeNode
      }]
    }]
  }], null, {
    rowNode: [{
      type: Input
    }],
    node: [{
      type: Input
    }],
    parentNode: [{
      type: Input
    }],
    root: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    index: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    firstChild: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    lastChild: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    level: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    indentation: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    itemSize: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    loadingMode: [{
      type: Input
    }]
  });
})();
var Tree = class _Tree extends BaseComponent {
  dragDropService;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  $pcTree = inject(TREE_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * An array of treenodes.
   * @group Props
   */
  value;
  /**
   * Defines the selection mode.
   * @group Props
   */
  selectionMode;
  /**
   * Loading mode display.
   * @group Props
   */
  loadingMode = "mask";
  /**
   * A single treenode instance or an array to refer to the selections.
   * @group Props
   */
  selection = model(null, ...ngDevMode ? [{
    debugName: "selection"
  }] : []);
  /**
   * Style class of the component.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Context menu instance.
   * @group Props
   */
  contextMenu;
  /**
   * Defines the behavior of context menu selection, in "separate" mode context menu updates contextMenuSelection property whereas in joint mode selection property is used instead so that when row selection is enabled, both row selection and context menu selection use the same property.
   * @group Props
   */
  contextMenuSelectionMode = "joint";
  /**
   * Selected node with a context menu.
   * @group Props
   */
  contextMenuSelection = model(null, ...ngDevMode ? [{
    debugName: "contextMenuSelection"
  }] : []);
  /**
   * Scope of the draggable nodes to match a droppableScope.
   * @group Props
   */
  draggableScope;
  /**
   * Scope of the droppable nodes to match a draggableScope.
   * @group Props
   */
  droppableScope;
  /**
   * Whether the nodes are draggable.
   * @group Props
   */
  draggableNodes;
  /**
   * Whether the nodes are droppable.
   * @group Props
   */
  droppableNodes;
  /**
   * Defines how multiple items can be selected, when true metaKey needs to be pressed to select or unselect an item and when set to false selection of each item can be toggled individually. On touch enabled devices, metaKeySelection is turned off automatically.
   * @group Props
   */
  metaKeySelection = false;
  /**
   * Whether checkbox selections propagate to ancestor nodes.
   * @group Props
   */
  propagateSelectionUp = true;
  /**
   * Whether checkbox selections propagate to descendant nodes.
   * @group Props
   */
  propagateSelectionDown = true;
  /**
   * Displays a loader to indicate data load is in progress.
   * @group Props
   */
  loading;
  /**
   * The icon to show while indicating data load is in progress.
   * @group Props
   */
  loadingIcon;
  /**
   * Text to display when there is no data.
   * @group Props
   */
  emptyMessage = "";
  /**
   * Used to define a string that labels the tree.
   * @group Props
   */
  ariaLabel;
  /**
   * Defines a string that labels the toggler icon for accessibility.
   * @group Props
   */
  togglerAriaLabel;
  /**
   * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
   * @group Props
   */
  ariaLabelledBy;
  /**
   * When enabled, drop can be accepted or rejected based on condition defined at onNodeDrop.
   * @group Props
   */
  validateDrop;
  /**
   * When specified, displays an input field to filter the items.
   * @group Props
   */
  filter;
  /**
   * Determines whether the filter input should be automatically focused when the component is rendered.
   * @group Props
   */
  filterInputAutoFocus = false;
  /**
   * When filtering is enabled, filterBy decides which field or fields (comma separated) to search against.
   * @group Props
   */
  filterBy = "label";
  /**
   * Mode for filtering valid values are "lenient" and "strict". Default is lenient.
   * @group Props
   */
  filterMode = "lenient";
  /**
   * Mode for filtering valid values are "lenient" and "strict". Default is lenient.
   * @group Props
   */
  filterOptions;
  /**
   * Placeholder text to show when filter input is empty.
   * @group Props
   */
  filterPlaceholder;
  /**
   * Values after the tree nodes are filtered.
   * @group Props
   */
  filteredNodes;
  /**
   * Locale to use in filtering. The default locale is the host environment's current locale.
   * @group Props
   */
  filterLocale;
  /**
   * Height of the scrollable viewport.
   * @group Props
   */
  scrollHeight;
  /**
   * Defines if data is loaded and interacted with in lazy manner.
   * @group Props
   */
  lazy = false;
  /**
   * Whether the data should be loaded on demand during scroll.
   * @group Props
   */
  virtualScroll;
  /**
   * Height of an item in the list for VirtualScrolling.
   * @group Props
   */
  virtualScrollItemSize;
  /**
   * Whether to use the scroller feature. The properties of scroller component can be used like an object in it.
   * @group Props
   */
  virtualScrollOptions;
  /**
   * Indentation factor for spacing of the nested node when virtual scrolling is enabled.
   * @group Props
   */
  indentation = 1.5;
  /**
   * Custom templates of the component.
   * @group Props
   */
  _templateMap;
  /**
   * Function to optimize the node list rendering, default algorithm checks for object identity.
   * @group Props
   */
  trackBy = (index, item) => item;
  /**
   * Highlights the node on select.
   * @group Props
   */
  highlightOnSelect = false;
  /**
   * Callback to invoke when a node is selected.
   * @param {TreeNodeSelectEvent} event - Node select event.
   * @group Emits
   */
  onNodeSelect = new EventEmitter();
  /**
   * Callback to invoke when a node is unselected.
   * @param {TreeNodeUnSelectEvent} event - Node unselect event.
   * @group Emits
   */
  onNodeUnselect = new EventEmitter();
  /**
   * Callback to invoke when a node is expanded.
   * @param {TreeNodeExpandEvent} event - Node expand event.
   * @group Emits
   */
  onNodeExpand = new EventEmitter();
  /**
   * Callback to invoke when a node is collapsed.
   * @param {TreeNodeCollapseEvent} event - Node collapse event.
   * @group Emits
   */
  onNodeCollapse = new EventEmitter();
  /**
   * Callback to invoke when a node is selected with right click.
   * @param {onNodeContextMenuSelect} event - Node context menu select event.
   * @group Emits
   */
  onNodeContextMenuSelect = new EventEmitter();
  /**
   * Callback to invoke when a node is double clicked.
   * @param {TreeNodeDoubleClickEvent} event - Node double click event.
   * @group Emits
   */
  onNodeDoubleClick = new EventEmitter();
  /**
   * Callback to invoke when a node is dropped.
   * @param {TreeNodeDropEvent} event - Node drop event.
   * @group Emits
   */
  onNodeDrop = new EventEmitter();
  /**
   * Callback to invoke in lazy mode to load new data.
   * @param {TreeLazyLoadEvent} event - Custom lazy load event.
   * @group Emits
   */
  onLazyLoad = new EventEmitter();
  /**
   * Callback to invoke in virtual scroll mode when scroll position changes.
   * @param {TreeScrollEvent} event - Custom scroll event.
   * @group Emits
   */
  onScroll = new EventEmitter();
  /**
   * Callback to invoke in virtual scroll mode when scroll position and item's range in view changes.
   * @param {TreeScrollIndexChangeEvent} event - Scroll index change event.
   * @group Emits
   */
  onScrollIndexChange = new EventEmitter();
  /**
   * Callback to invoke when data is filtered.
   * @param {TreeFilterEvent} event - Custom filter event.
   * @group Emits
   */
  onFilter = new EventEmitter();
  /**
   * Custom filter template.
   * @param {TreeFilterTemplateContext} context - filter context.
   * @see {@link TreeFilterTemplateContext}
   * @group Templates
   */
  filterTemplate;
  /**
   * Custom node template.
   * @group Templates
   */
  nodeTemplate;
  /**
   * Custom header template.
   * @group Templates
   */
  headerTemplate;
  /**
   * Custom footer template.
   * @group Templates
   */
  footerTemplate;
  /**
   * Custom loader template.
   * @param {TreeLoaderTemplateContext} context - loader context.
   * @see {@link TreeLoaderTemplateContext}
   * @group Templates
   */
  loaderTemplate;
  /**
   * Custom empty message template.
   * @group Templates
   */
  emptyTemplate;
  /**
   * Custom toggler icon template.
   * @param {TreeTogglerIconTemplateContext} context - toggler icon context.
   * @see {@link TreeTogglerIconTemplateContext}
   * @group Templates
   */
  togglerIconTemplate;
  /**
   * Custom checkbox icon template.
   * @param {TreeCheckboxIconTemplateContext} context - checkbox icon context.
   * @see {@link TreeCheckboxIconTemplateContext}
   * @group Templates
   */
  checkboxIconTemplate;
  /**
   * Custom loading icon template.
   * @group Templates
   */
  loadingIconTemplate;
  /**
   * Custom filter icon template.
   * @group Templates
   */
  filterIconTemplate;
  filterViewChild;
  scroller;
  wrapperViewChild;
  contentViewChild;
  templates;
  _headerTemplate;
  _emptyTemplate;
  _footerTemplate;
  _loaderTemplate;
  _togglerIconTemplate;
  _checkboxIconTemplate;
  _loadingIconTemplate;
  _filterIconTemplate;
  _filterTemplate;
  onAfterContentInit() {
    if (this.templates.length) {
      this._templateMap = {};
    }
    this.templates.forEach((item) => {
      switch (item.getType()) {
        case "header":
          this._headerTemplate = item.template;
          break;
        case "empty":
          this._emptyTemplate = item.template;
          break;
        case "footer":
          this._footerTemplate = item.template;
          break;
        case "loader":
          this._loaderTemplate = item.template;
          break;
        case "togglericon":
          this._togglerIconTemplate = item.template;
          break;
        case "checkboxicon":
          this._checkboxIconTemplate = item.template;
          break;
        case "loadingicon":
          this._loadingIconTemplate = item.template;
          break;
        case "filtericon":
          this._filterIconTemplate = item.template;
          break;
        case "filter":
          this._filterTemplate = item.template;
          break;
        default:
          this._templateMap[item.name] = item.template;
          break;
      }
    });
  }
  serializedValue;
  nodeTouched;
  dragNodeTree;
  dragNode;
  dragNodeSubNodes;
  dragNodeIndex;
  dragNodeScope;
  dragHover;
  dragStartSubscription;
  dragStopSubscription;
  _componentStyle = inject(TreeStyle);
  handleDropEvent(event) {
    this.onDrop(event);
  }
  handleDragOverEvent(event) {
    this.onDragOver(event);
  }
  handleDragEnterEvent() {
    this.onDragEnter();
  }
  handleDragLeaveEvent(event) {
    this.onDragLeave(event);
  }
  constructor(dragDropService) {
    super();
    this.dragDropService = dragDropService;
  }
  onInit() {
    if (this.filterBy) {
      this.filterOptions = {
        filter: (value) => this._filter(value),
        reset: () => this.resetFilter()
      };
    }
    if (this.droppableNodes) {
      this.dragStartSubscription = this.dragDropService.dragStart$.subscribe((event) => {
        this.dragNodeTree = event.tree;
        this.dragNode = event.node;
        this.dragNodeSubNodes = event.subNodes;
        this.dragNodeIndex = event.index;
        this.dragNodeScope = event.scope;
      });
      this.dragStopSubscription = this.dragDropService.dragStop$.subscribe((event) => {
        this.dragNodeTree = null;
        this.dragNode = null;
        this.dragNodeSubNodes = null;
        this.dragNodeIndex = null;
        this.dragNodeScope = null;
        this.dragHover = false;
      });
    }
  }
  onChanges(simpleChange) {
    if (simpleChange.value) {
      this.updateSerializedValue();
      if (this.hasFilterActive()) {
        this._filter(this.filterViewChild?.nativeElement?.value);
      }
    }
  }
  get emptyMessageLabel() {
    return this.emptyMessage || this.config.getTranslation(TranslationKeys.EMPTY_MESSAGE);
  }
  updateSerializedValue() {
    this.serializedValue = [];
    this.serializeNodes(null, this.getRootNode(), 0, true);
  }
  serializeNodes(parent, nodes, level, visible) {
    if (nodes && nodes.length) {
      for (let node of nodes) {
        node.parent = parent;
        const rowNode = {
          node,
          parent,
          level,
          visible: visible && (parent ? parent.expanded : true)
        };
        this.serializedValue.push(rowNode);
        if (rowNode.visible && node.expanded) {
          this.serializeNodes(node, node.children, level + 1, rowNode.visible);
        }
      }
    }
  }
  onNodeClick(event, node) {
    let eventTarget = event.target;
    const section = eventTarget?.getAttribute?.("data-pc-section");
    if (section === "nodetogglebutton" || section === "nodetoggleicon") {
      return;
    }
    if (this.selectionMode) {
      if (node.selectable === false) {
        node.style = "--p-focus-ring-color: none;";
        return;
      } else {
        if (!node.style?.includes("--p-focus-ring-color")) {
          node.style = node.style ? `${node.style}--p-focus-ring-color: var(--primary-color)` : "--p-focus-ring-color: var(--primary-color)";
        }
      }
      if (this.hasFilteredNodes()) {
        node = this.getNodeWithKey(node.key, this.filteredNodes);
        if (!node) {
          return;
        }
      }
      let index = this.findIndexInSelection(node);
      let selected = index >= 0;
      const currentSelection = this.selection();
      if (this.isCheckboxSelectionMode()) {
        if (selected) {
          if (this.propagateSelectionDown) this.propagateDown(node, false);
          else this.selection.set(currentSelection.filter((_val, i) => i != index));
          if (this.propagateSelectionUp && node.parent) {
            this.propagateUp(node.parent, false);
          }
          this.onNodeUnselect.emit({
            originalEvent: event,
            node
          });
        } else {
          if (this.propagateSelectionDown) this.propagateDown(node, true);
          else this.selection.set([...currentSelection || [], node]);
          if (this.propagateSelectionUp && node.parent) {
            this.propagateUp(node.parent, true);
          }
          this.onNodeSelect.emit({
            originalEvent: event,
            node
          });
        }
      } else {
        let metaSelection = this.nodeTouched ? false : this.metaKeySelection;
        if (metaSelection) {
          let metaKey = event.metaKey || event.ctrlKey;
          if (selected && metaKey) {
            if (this.isSingleSelectionMode()) {
              this.selection.set(null);
            } else {
              this.selection.set(currentSelection.filter((_val, i) => i != index));
            }
            this.onNodeUnselect.emit({
              originalEvent: event,
              node
            });
          } else {
            if (this.isSingleSelectionMode()) {
              this.selection.set(node);
            } else if (this.isMultipleSelectionMode()) {
              const base = !metaKey ? [] : currentSelection || [];
              this.selection.set([...base, node]);
            }
            this.onNodeSelect.emit({
              originalEvent: event,
              node
            });
          }
        } else {
          if (this.isSingleSelectionMode()) {
            if (selected) {
              this.selection.set(null);
              this.onNodeUnselect.emit({
                originalEvent: event,
                node
              });
            } else {
              this.selection.set(node);
              setTimeout(() => {
                this.onNodeSelect.emit({
                  originalEvent: event,
                  node
                });
              });
            }
          } else {
            if (selected) {
              this.selection.set(currentSelection.filter((_val, i) => i != index));
              this.onNodeUnselect.emit({
                originalEvent: event,
                node
              });
            } else {
              this.selection.set([...currentSelection || [], node]);
              setTimeout(() => {
                this.onNodeSelect.emit({
                  originalEvent: event,
                  node
                });
              });
            }
          }
        }
      }
    }
    this.nodeTouched = false;
  }
  onNodeTouchEnd() {
    this.nodeTouched = true;
  }
  onNodeRightClick(event, node) {
    if (this.contextMenu) {
      let eventTarget = event.target;
      const section = eventTarget.getAttribute("data-pc-section");
      if (section === "nodetogglebutton" || section === "nodetoggleicon") {
        return;
      }
      let index = this.findIndexInSelection(node);
      let isNodeSelected = index >= 0;
      const onContextMenuCallback = () => {
        this.contextMenu.show(event);
        this.contextMenu.hideCallback = () => {
          this.contextMenuSelection.set(null);
        };
        this.onNodeContextMenuSelect.emit({
          originalEvent: event,
          node
        });
      };
      if (this.contextMenuSelectionMode === "separate") {
        this.contextMenuSelection.set(node);
        onContextMenuCallback();
      } else if (this.contextMenuSelectionMode === "joint") {
        if (!isNodeSelected) {
          if (this.isSingleSelectionMode()) {
            this.selection.set(node);
          } else {
            this.selection.set([node]);
          }
        }
        onContextMenuCallback();
      }
    }
  }
  onNodeDblClick(event, node) {
    this.onNodeDoubleClick.emit({
      originalEvent: event,
      node
    });
  }
  findIndexInSelection(node) {
    let index = -1;
    const currentSelection = this.selection();
    if (this.selectionMode && currentSelection) {
      if (this.isSingleSelectionMode()) {
        const sel = currentSelection;
        let areNodesEqual = sel.key && sel.key === node.key || sel == node;
        index = areNodesEqual ? 0 : -1;
      } else {
        const selArray = currentSelection;
        for (let i = 0; i < selArray.length; i++) {
          let selectedNode = selArray[i];
          let areNodesEqual = selectedNode.key && selectedNode.key === node.key || selectedNode == node;
          if (areNodesEqual) {
            index = i;
            break;
          }
        }
      }
    }
    return index;
  }
  syncNodeOption(node, parentNodes, option, value) {
    const _node = this.hasFilteredNodes() ? this.getNodeWithKey(node.key, parentNodes) : null;
    if (_node) {
      _node[option] = value || node[option];
    }
  }
  hasFilteredNodes() {
    return this.filter && this.filteredNodes && this.filteredNodes.length;
  }
  hasFilterActive() {
    return this.filter && this.filterViewChild?.nativeElement?.value.length > 0;
  }
  getNodeWithKey(key, nodes) {
    for (let node of nodes) {
      if (node.key === key) {
        return node;
      }
      if (node.children) {
        let matchedNode = this.getNodeWithKey(key, node.children);
        if (matchedNode) {
          return matchedNode;
        }
      }
    }
  }
  propagateUp(node, select) {
    if (node.children && node.children.length) {
      let selectedCount = 0;
      let childPartialSelected = false;
      for (let child of node.children) {
        if (this.isSelected(child)) {
          selectedCount++;
        } else if (child.partialSelected) {
          childPartialSelected = true;
        }
      }
      const currentSelection = this.selection() || [];
      if (select && selectedCount == node.children.length) {
        this.selection.set([...currentSelection, node]);
        node.partialSelected = false;
      } else {
        if (!select) {
          let index = this.findIndexInSelection(node);
          if (index >= 0) {
            this.selection.set(currentSelection.filter((_val, i) => i != index));
          }
        }
        if (childPartialSelected || selectedCount > 0 && selectedCount != node.children.length) node.partialSelected = true;
        else node.partialSelected = false;
      }
      this.syncNodeOption(node, this.filteredNodes, "partialSelected");
    }
    let parent = node.parent;
    if (parent) {
      this.propagateUp(parent, select);
    }
  }
  propagateDown(node, select) {
    let index = this.findIndexInSelection(node);
    const currentSelection = this.selection() || [];
    if (select && index == -1) {
      this.selection.set([...currentSelection, node]);
    } else if (!select && index > -1) {
      this.selection.set(currentSelection.filter((_val, i) => i != index));
    }
    node.partialSelected = false;
    this.syncNodeOption(node, this.filteredNodes, "partialSelected");
    if (node.children && node.children.length) {
      for (let child of node.children) {
        this.propagateDown(child, select);
      }
    }
  }
  isSelected(node) {
    return this.findIndexInSelection(node) != -1;
  }
  isSingleSelectionMode() {
    return this.selectionMode && this.selectionMode == "single";
  }
  isMultipleSelectionMode() {
    return this.selectionMode && this.selectionMode == "multiple";
  }
  isCheckboxSelectionMode() {
    return this.selectionMode && this.selectionMode == "checkbox";
  }
  isNodeLeaf(node) {
    return node.leaf == false ? false : !(node.children && node.children.length);
  }
  getRootNode() {
    return this.filteredNodes ? this.filteredNodes : this.value;
  }
  getTemplateForNode(node) {
    if (this._templateMap) return node.type ? this._templateMap[node.type] : this._templateMap["default"];
    else return null;
  }
  onDragOver(event) {
    if (this.droppableNodes && this.allowDrop(this.dragNode, null, this.dragNodeScope)) {
      event.dataTransfer.dropEffect = "copy";
      event.preventDefault();
    }
  }
  onDrop(event) {
    if (this.droppableNodes) {
      event.preventDefault();
      let dragNode = this.dragNode;
      if (this.isSameTreeScope(this.dragNodeScope)) {
        return;
      }
      if (this.allowDrop(dragNode, null, this.dragNodeScope)) {
        let dragNodeIndex = this.dragNodeIndex;
        this.value = this.value || [];
        if (this.validateDrop) {
          this.onNodeDrop.emit({
            originalEvent: event,
            dragNode,
            dropNode: null,
            index: dragNodeIndex,
            accept: () => {
              this.processTreeDrop(dragNode, dragNodeIndex);
            }
          });
        } else {
          this.onNodeDrop.emit({
            originalEvent: event,
            dragNode,
            dropNode: null,
            index: dragNodeIndex
          });
          this.processTreeDrop(dragNode, dragNodeIndex);
        }
      }
    }
  }
  processTreeDrop(dragNode, dragNodeIndex) {
    this.dragNodeSubNodes.splice(dragNodeIndex, 1);
    this.value.push(dragNode);
    this.dragDropService.stopDrag({
      node: dragNode
    });
  }
  onDragEnter() {
    if (this.droppableNodes && this.allowDrop(this.dragNode, null, this.dragNodeScope)) {
      this.dragHover = true;
    }
  }
  onDragLeave(event) {
    if (this.droppableNodes) {
      let rect = event.currentTarget.getBoundingClientRect();
      if (event.x > parseInt(rect.left) + rect.width || event.x < parseInt(rect.left) || event.y > parseInt(rect.top) + rect.height || event.y < parseInt(rect.top)) {
        this.dragHover = false;
      }
    }
  }
  allowDrop(dragNode, dropNode, dragNodeScope) {
    if (!dragNode) {
      return false;
    } else if (this.isValidDragScope(dragNodeScope)) {
      let allow = true;
      if (dropNode) {
        if (dragNode === dropNode) {
          allow = false;
        } else {
          let parent = dropNode.parent;
          while (parent != null) {
            if (parent === dragNode) {
              allow = false;
              break;
            }
            parent = parent.parent;
          }
        }
      }
      return allow;
    } else {
      return false;
    }
  }
  hasCommonScope(dragScope, dropScope) {
    if (typeof dropScope === "string") {
      if (typeof dragScope === "string") return dropScope === dragScope;
      else if (Array.isArray(dragScope)) return dragScope.indexOf(dropScope) != -1;
    } else if (Array.isArray(dropScope)) {
      if (typeof dragScope === "string") {
        return dropScope.indexOf(dragScope) != -1;
      } else if (Array.isArray(dragScope)) {
        for (let s3 of dropScope) {
          for (let ds of dragScope) {
            if (s3 === ds) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }
  isSameTreeScope(dragScope) {
    return this.hasCommonScope(dragScope, this.draggableScope);
  }
  isValidDragScope(dragScope) {
    let dropScope = this.droppableScope;
    if (dropScope) {
      return this.hasCommonScope(dragScope, dropScope);
    } else {
      return true;
    }
  }
  _filter(value) {
    let filterValue = value;
    if (filterValue === "") {
      this.filteredNodes = null;
    } else {
      this.filteredNodes = [];
      const searchFields = this.filterBy.split(",");
      const filterText = X(filterValue).toLocaleLowerCase(this.filterLocale);
      const isStrictMode = this.filterMode === "strict";
      for (let node of this.value) {
        let copyNode = __spreadValues({}, node);
        let paramsWithoutNode = {
          searchFields,
          filterText,
          isStrictMode
        };
        if (isStrictMode && (this.findFilteredNodes(copyNode, paramsWithoutNode) || this.isFilterMatched(copyNode, paramsWithoutNode)) || !isStrictMode && (this.isFilterMatched(copyNode, paramsWithoutNode) || this.findFilteredNodes(copyNode, paramsWithoutNode))) {
          this.filteredNodes.push(copyNode);
        }
      }
    }
    this.updateSerializedValue();
    this.onFilter.emit({
      filter: filterValue,
      filteredValue: this.filteredNodes
    });
  }
  /**
   * Resets filter.
   * @group Method
   */
  resetFilter() {
    this.filteredNodes = null;
    if (this.filterViewChild && this.filterViewChild.nativeElement) {
      this.filterViewChild.nativeElement.value = "";
    }
  }
  /**
   * Scrolls to virtual index.
   * @param {number} number - Index to be scrolled.
   * @group Method
   */
  scrollToVirtualIndex(index) {
    this.virtualScroll && this.scroller?.scrollToIndex(index);
  }
  /**
   * Scrolls to virtual index.
   * @param {ScrollToOptions} options - Scroll options.
   * @group Method
   */
  scrollTo(options) {
    if (this.virtualScroll) {
      this.scroller?.scrollTo(options);
    } else if (this.wrapperViewChild && this.wrapperViewChild.nativeElement) {
      if (this.wrapperViewChild.nativeElement.scrollTo) {
        this.wrapperViewChild.nativeElement.scrollTo(options);
      } else {
        this.wrapperViewChild.nativeElement.scrollLeft = options.left;
        this.wrapperViewChild.nativeElement.scrollTop = options.top;
      }
    }
  }
  findFilteredNodes(node, paramsWithoutNode) {
    if (node) {
      let matched = false;
      if (node.children) {
        let childNodes = [...node.children];
        node.children = [];
        for (let childNode of childNodes) {
          let copyChildNode = __spreadValues({}, childNode);
          if (this.isFilterMatched(copyChildNode, paramsWithoutNode)) {
            matched = true;
            node.children.push(copyChildNode);
          }
        }
      }
      if (matched) {
        node.expanded = true;
        return true;
      }
    }
  }
  isFilterMatched(node, params) {
    let {
      searchFields,
      filterText,
      isStrictMode
    } = params;
    let matched = false;
    for (let field of searchFields) {
      let fieldValue = X(String(p(node, field))).toLocaleLowerCase(this.filterLocale);
      if (fieldValue.indexOf(filterText) > -1) {
        matched = true;
      }
    }
    if (!matched || isStrictMode && !this.isNodeLeaf(node)) {
      matched = this.findFilteredNodes(node, {
        searchFields,
        filterText,
        isStrictMode
      }) || matched;
    }
    return matched;
  }
  getIndex(options, index) {
    const getItemOptions = options["getItemOptions"];
    return getItemOptions ? getItemOptions(index).index : index;
  }
  getBlockableElement() {
    return this.el.nativeElement.children[0];
  }
  onDestroy() {
    if (this.dragStartSubscription) {
      this.dragStartSubscription.unsubscribe();
    }
    if (this.dragStopSubscription) {
      this.dragStopSubscription.unsubscribe();
    }
  }
  get containerDataP() {
    return this.cn({
      loading: this.loading,
      scrollable: this.scrollHeight === "flex"
    });
  }
  get wrapperDataP() {
    return this.cn({
      scrollable: this.scrollHeight === "flex"
    });
  }
  static \u0275fac = function Tree_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Tree)(\u0275\u0275directiveInject(TreeDragDropService, 8));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _Tree,
    selectors: [["p-tree"]],
    contentQueries: function Tree_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c56, 4);
        \u0275\u0275contentQuery(dirIndex, _c65, 4);
        \u0275\u0275contentQuery(dirIndex, _c75, 4);
        \u0275\u0275contentQuery(dirIndex, _c84, 4);
        \u0275\u0275contentQuery(dirIndex, _c94, 4);
        \u0275\u0275contentQuery(dirIndex, _c103, 4);
        \u0275\u0275contentQuery(dirIndex, _c113, 4);
        \u0275\u0275contentQuery(dirIndex, _c124, 4);
        \u0275\u0275contentQuery(dirIndex, _c134, 4);
        \u0275\u0275contentQuery(dirIndex, _c144, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.filterTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.nodeTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.footerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.loaderTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.emptyTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.togglerIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.checkboxIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.loadingIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.filterIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function Tree_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c56, 5);
        \u0275\u0275viewQuery(_c154, 5);
        \u0275\u0275viewQuery(_c163, 5);
        \u0275\u0275viewQuery(_c173, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.filterViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.scroller = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.wrapperViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contentViewChild = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function Tree_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("drop", function Tree_drop_HostBindingHandler($event) {
          return ctx.handleDropEvent($event);
        })("dragover", function Tree_dragover_HostBindingHandler($event) {
          return ctx.handleDragOverEvent($event);
        })("dragenter", function Tree_dragenter_HostBindingHandler() {
          return ctx.handleDragEnterEvent();
        })("dragleave", function Tree_dragleave_HostBindingHandler($event) {
          return ctx.handleDragLeaveEvent($event);
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("data-p", ctx.containerDataP);
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      value: "value",
      selectionMode: "selectionMode",
      loadingMode: "loadingMode",
      selection: [1, "selection"],
      styleClass: "styleClass",
      contextMenu: "contextMenu",
      contextMenuSelectionMode: "contextMenuSelectionMode",
      contextMenuSelection: [1, "contextMenuSelection"],
      draggableScope: "draggableScope",
      droppableScope: "droppableScope",
      draggableNodes: [2, "draggableNodes", "draggableNodes", booleanAttribute],
      droppableNodes: [2, "droppableNodes", "droppableNodes", booleanAttribute],
      metaKeySelection: [2, "metaKeySelection", "metaKeySelection", booleanAttribute],
      propagateSelectionUp: [2, "propagateSelectionUp", "propagateSelectionUp", booleanAttribute],
      propagateSelectionDown: [2, "propagateSelectionDown", "propagateSelectionDown", booleanAttribute],
      loading: [2, "loading", "loading", booleanAttribute],
      loadingIcon: "loadingIcon",
      emptyMessage: "emptyMessage",
      ariaLabel: "ariaLabel",
      togglerAriaLabel: "togglerAriaLabel",
      ariaLabelledBy: "ariaLabelledBy",
      validateDrop: [2, "validateDrop", "validateDrop", booleanAttribute],
      filter: [2, "filter", "filter", booleanAttribute],
      filterInputAutoFocus: [2, "filterInputAutoFocus", "filterInputAutoFocus", booleanAttribute],
      filterBy: "filterBy",
      filterMode: "filterMode",
      filterOptions: "filterOptions",
      filterPlaceholder: "filterPlaceholder",
      filteredNodes: "filteredNodes",
      filterLocale: "filterLocale",
      scrollHeight: "scrollHeight",
      lazy: [2, "lazy", "lazy", booleanAttribute],
      virtualScroll: [2, "virtualScroll", "virtualScroll", booleanAttribute],
      virtualScrollItemSize: [2, "virtualScrollItemSize", "virtualScrollItemSize", numberAttribute],
      virtualScrollOptions: "virtualScrollOptions",
      indentation: [2, "indentation", "indentation", numberAttribute],
      _templateMap: "_templateMap",
      trackBy: "trackBy",
      highlightOnSelect: [2, "highlightOnSelect", "highlightOnSelect", booleanAttribute]
    },
    outputs: {
      selection: "selectionChange",
      contextMenuSelection: "contextMenuSelectionChange",
      onNodeSelect: "onNodeSelect",
      onNodeUnselect: "onNodeUnselect",
      onNodeExpand: "onNodeExpand",
      onNodeCollapse: "onNodeCollapse",
      onNodeContextMenuSelect: "onNodeContextMenuSelect",
      onNodeDoubleClick: "onNodeDoubleClick",
      onNodeDrop: "onNodeDrop",
      onLazyLoad: "onLazyLoad",
      onScroll: "onScroll",
      onScrollIndexChange: "onScrollIndexChange",
      onFilter: "onFilter"
    },
    features: [\u0275\u0275ProvidersFeature([TreeStyle, {
      provide: TREE_INSTANCE,
      useExisting: _Tree
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _Tree
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 7,
    vars: 6,
    consts: [["filter", ""], ["scroller", ""], ["content", ""], ["treeNode", ""], ["loader", ""], ["wrapper", ""], ["emptyFilter", ""], [3, "class", "pBind", 4, "ngIf"], [4, "ngTemplateOutlet"], [3, "class", "pt", "unstyled"], [4, "ngIf"], [3, "pBind"], ["data-p-icon", "spinner", "spin", "", 3, "class", "pBind", 4, "ngIf"], ["data-p-icon", "spinner", "spin", "", 3, "pBind"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "class", "pt", "unstyled", 4, "ngIf"], [3, "pt", "unstyled"], ["pInputText", "", "type", "search", "autocomplete", "off", 3, "keydown.enter", "input", "pAutoFocus", "pt", "unstyled"], ["data-p-icon", "search", 3, "class", "pBind", 4, "ngIf"], ["data-p-icon", "search", 3, "pBind"], ["hostName", "tree", 3, "items", "tabindex", "styleClass", "style", "scrollHeight", "itemSize", "lazy", "options", "pt", "onScroll", "onScrollIndexChange", "onLazyLoad", 4, "ngIf"], ["hostName", "tree", 3, "onScroll", "onScrollIndexChange", "onLazyLoad", "items", "tabindex", "styleClass", "scrollHeight", "itemSize", "lazy", "options", "pt"], ["role", "tree", 3, "class", "ngClass", "style", "pBind", 4, "ngIf"], ["role", "tree", 3, "ngClass", "pBind"], [3, "level", "rowNode", "node", "parentNode", "firstChild", "lastChild", "index", "itemSize", "indentation", "loadingMode", "pt", "unstyled", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "level", "rowNode", "node", "parentNode", "firstChild", "lastChild", "index", "itemSize", "indentation", "loadingMode", "pt", "unstyled"], ["role", "tree", 3, "class", "pBind", 4, "ngIf"], ["role", "tree", 3, "pBind"], [3, "node", "firstChild", "lastChild", "index", "level", "loadingMode", "pt", "unstyled", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "node", "firstChild", "lastChild", "index", "level", "loadingMode", "pt", "unstyled"], [4, "ngIf", "ngIfElse"]],
    template: function Tree_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275template(0, Tree_div_0_Template, 3, 5, "div", 7)(1, Tree_ng_container_1_Template, 1, 0, "ng-container", 8);
        \u0275\u0275conditionalCreate(2, Tree_Conditional_2_Template, 1, 4, "ng-container")(3, Tree_Conditional_3_Template, 1, 1, "p-iconfield", 9);
        \u0275\u0275template(4, Tree_ng_container_4_Template, 3, 2, "ng-container", 10)(5, Tree_div_5_Template, 3, 6, "div", 7)(6, Tree_ng_container_6_Template, 1, 0, "ng-container", 8);
      }
      if (rf & 2) {
        let tmp_3_0;
        \u0275\u0275property("ngIf", ctx.loading && ctx.loadingMode === "mask");
        \u0275\u0275advance();
        \u0275\u0275property("ngTemplateOutlet", ctx.headerTemplate || ctx._headerTemplate);
        \u0275\u0275advance();
        \u0275\u0275conditional(ctx.filterTemplate || ctx._filterTemplate ? 2 : 3);
        \u0275\u0275advance(2);
        \u0275\u0275property("ngIf", (tmp_3_0 = ctx.getRootNode()) == null ? null : tmp_3_0.length);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", !ctx.loading && (ctx.getRootNode() == null || ctx.getRootNode().length === 0));
        \u0275\u0275advance();
        \u0275\u0275property("ngTemplateOutlet", ctx.footerTemplate || ctx._footerTemplate);
      }
    },
    dependencies: [CommonModule, NgClass, NgForOf, NgIf, NgTemplateOutlet, Scroller, SharedModule, SearchIcon, SpinnerIcon, InputText, FormsModule, IconField, InputIcon, UITreeNode, AutoFocusModule, AutoFocus, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Tree, [{
    type: Component,
    args: [{
      selector: "p-tree",
      standalone: true,
      imports: [CommonModule, Scroller, SharedModule, SearchIcon, SpinnerIcon, InputText, FormsModule, IconField, InputIcon, UITreeNode, AutoFocusModule, Bind],
      template: `
        <div [class]="cx('mask')" *ngIf="loading && loadingMode === 'mask'" [pBind]="ptm('mask')" animate.enter="p-overlay-mask-enter-active" animate.leave="p-overlay-mask-leave-active">
            <i *ngIf="loadingIcon" [class]="cn(cx('loadingIcon'), 'pi-spin' + loadingIcon)" [pBind]="ptm('loadingIcon')"></i>
            <ng-container *ngIf="!loadingIcon">
                <svg data-p-icon="spinner" *ngIf="!loadingIconTemplate && !_loadingIconTemplate" spin [class]="cx('loadingIcon')" [pBind]="ptm('loadingIcon')" />
                <span *ngIf="loadingIconTemplate || _loadingIconTemplate" [class]="cx('loadingIcon')" [pBind]="ptm('loadingIcon')">
                    <ng-template *ngTemplateOutlet="loadingIconTemplate || _loadingIconTemplate"></ng-template>
                </span>
            </ng-container>
        </div>
        <ng-container *ngTemplateOutlet="headerTemplate || _headerTemplate"></ng-container>
        @if (filterTemplate || _filterTemplate) {
            <ng-container *ngTemplateOutlet="filterTemplate || _filterTemplate; context: { $implicit: filterOptions }"></ng-container>
        } @else {
            <p-iconfield *ngIf="filter" [class]="cx('pcFilterContainer')" [pt]="ptm('pcFilterContainer')" [unstyled]="unstyled()">
                <input
                    #filter
                    [pAutoFocus]="filterInputAutoFocus"
                    pInputText
                    type="search"
                    autocomplete="off"
                    [class]="cx('pcFilterInput')"
                    [attr.placeholder]="filterPlaceholder"
                    (keydown.enter)="$event.preventDefault()"
                    (input)="_filter($event.target?.value)"
                    [pt]="ptm('pcFilterInput')"
                    [unstyled]="unstyled()"
                />
                <p-inputicon [pt]="ptm('pcFilterIconContainer')" [unstyled]="unstyled()">
                    <svg data-p-icon="search" *ngIf="!filterIconTemplate && !_filterIconTemplate" [class]="cx('filterIcon')" [pBind]="ptm('filterIcon')" />
                    <span *ngIf="filterIconTemplate || _filterIconTemplate" [class]="cx('filterIcon')" [pBind]="ptm('filterIcon')">
                        <ng-template *ngTemplateOutlet="filterIconTemplate || _filterIconTemplate"></ng-template>
                    </span>
                </p-inputicon>
            </p-iconfield>
        }

        <ng-container *ngIf="getRootNode()?.length">
            <p-scroller
                #scroller
                *ngIf="virtualScroll"
                [items]="serializedValue"
                [tabindex]="-1"
                [styleClass]="cx('wrapper')"
                [style]="{ height: scrollHeight !== 'flex' ? scrollHeight : undefined }"
                [scrollHeight]="scrollHeight !== 'flex' ? undefined : '100%'"
                [itemSize]="virtualScrollItemSize"
                [lazy]="lazy"
                (onScroll)="onScroll.emit($event)"
                (onScrollIndexChange)="onScrollIndexChange.emit($event)"
                (onLazyLoad)="onLazyLoad.emit($event)"
                [options]="virtualScrollOptions"
                [pt]="ptm('virtualScroller')"
                hostName="tree"
                [attr.data-p]="wrapperDataP"
            >
                <ng-template #content let-items let-scrollerOptions="options">
                    <ul
                        *ngIf="items"
                        #content
                        [class]="cx('rootChildren')"
                        [ngClass]="scrollerOptions.contentStyleClass"
                        [style]="scrollerOptions.contentStyle"
                        role="tree"
                        [attr.aria-label]="ariaLabel"
                        [attr.aria-labelledby]="ariaLabelledBy"
                        [pBind]="ptm('rootChildren')"
                    >
                        <p-treeNode
                            #treeNode
                            *ngFor="let rowNode of items; let firstChild = first; let lastChild = last; let index = index; trackBy: trackBy"
                            [level]="rowNode.level"
                            [rowNode]="rowNode"
                            [node]="rowNode.node"
                            [parentNode]="rowNode.parent"
                            [firstChild]="firstChild"
                            [lastChild]="lastChild"
                            [index]="getIndex(scrollerOptions, index)"
                            [itemSize]="scrollerOptions.itemSize"
                            [indentation]="indentation"
                            [loadingMode]="loadingMode"
                            [pt]="pt"
                            [unstyled]="unstyled()"
                        ></p-treeNode>
                    </ul>
                </ng-template>
                <ng-container *ngIf="loaderTemplate || _loaderTemplate">
                    <ng-template #loader let-scrollerOptions="options">
                        <ng-container *ngTemplateOutlet="loaderTemplate || _loaderTemplate; context: { options: scrollerOptions }"></ng-container>
                    </ng-template>
                </ng-container>
            </p-scroller>
            <ng-container *ngIf="!virtualScroll">
                <div #wrapper [class]="cx('wrapper')" [style.max-height]="scrollHeight" [pBind]="ptm('wrapper')" [attr.data-p]="wrapperDataP">
                    <ul #content [class]="cx('rootChildren')" *ngIf="getRootNode()" role="tree" [attr.aria-label]="ariaLabel" [attr.aria-labelledby]="ariaLabelledBy" [pBind]="ptm('rootChildren')">
                        <p-treeNode
                            *ngFor="let node of getRootNode(); let firstChild = first; let lastChild = last; let index = index; trackBy: trackBy.bind(this)"
                            [node]="node"
                            [firstChild]="firstChild"
                            [lastChild]="lastChild"
                            [index]="index"
                            [level]="0"
                            [loadingMode]="loadingMode"
                            [pt]="pt"
                            [unstyled]="unstyled()"
                        ></p-treeNode>
                    </ul>
                </div>
            </ng-container>
        </ng-container>

        <div [class]="cx('emptyMessage')" *ngIf="!loading && (getRootNode() == null || getRootNode().length === 0)" [pBind]="ptm('emptyMessage')">
            <ng-container *ngIf="!emptyTemplate && !_emptyTemplate; else emptyFilter">
                {{ emptyMessageLabel }}
            </ng-container>
            <ng-template #emptyFilter *ngTemplateOutlet="emptyTemplate || _emptyTemplate"></ng-template>
        </div>
        <ng-container *ngTemplateOutlet="footerTemplate || _footerTemplate"></ng-container>
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [TreeStyle, {
        provide: TREE_INSTANCE,
        useExisting: Tree
      }, {
        provide: PARENT_INSTANCE,
        useExisting: Tree
      }],
      host: {
        "[class]": "cn(cx('root'), styleClass)",
        "[attr.data-p]": "containerDataP"
      },
      hostDirectives: [Bind]
    }]
  }], () => [{
    type: TreeDragDropService,
    decorators: [{
      type: Optional
    }]
  }], {
    value: [{
      type: Input
    }],
    selectionMode: [{
      type: Input
    }],
    loadingMode: [{
      type: Input
    }],
    selection: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "selection",
        required: false
      }]
    }, {
      type: Output,
      args: ["selectionChange"]
    }],
    styleClass: [{
      type: Input
    }],
    contextMenu: [{
      type: Input
    }],
    contextMenuSelectionMode: [{
      type: Input
    }],
    contextMenuSelection: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "contextMenuSelection",
        required: false
      }]
    }, {
      type: Output,
      args: ["contextMenuSelectionChange"]
    }],
    draggableScope: [{
      type: Input
    }],
    droppableScope: [{
      type: Input
    }],
    draggableNodes: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    droppableNodes: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    metaKeySelection: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    propagateSelectionUp: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    propagateSelectionDown: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    loading: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    loadingIcon: [{
      type: Input
    }],
    emptyMessage: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    togglerAriaLabel: [{
      type: Input
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    validateDrop: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    filter: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    filterInputAutoFocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    filterBy: [{
      type: Input
    }],
    filterMode: [{
      type: Input
    }],
    filterOptions: [{
      type: Input
    }],
    filterPlaceholder: [{
      type: Input
    }],
    filteredNodes: [{
      type: Input
    }],
    filterLocale: [{
      type: Input
    }],
    scrollHeight: [{
      type: Input
    }],
    lazy: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    virtualScroll: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    virtualScrollItemSize: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    virtualScrollOptions: [{
      type: Input
    }],
    indentation: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    _templateMap: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    highlightOnSelect: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    onNodeSelect: [{
      type: Output
    }],
    onNodeUnselect: [{
      type: Output
    }],
    onNodeExpand: [{
      type: Output
    }],
    onNodeCollapse: [{
      type: Output
    }],
    onNodeContextMenuSelect: [{
      type: Output
    }],
    onNodeDoubleClick: [{
      type: Output
    }],
    onNodeDrop: [{
      type: Output
    }],
    onLazyLoad: [{
      type: Output
    }],
    onScroll: [{
      type: Output
    }],
    onScrollIndexChange: [{
      type: Output
    }],
    onFilter: [{
      type: Output
    }],
    filterTemplate: [{
      type: ContentChild,
      args: ["filter", {
        descendants: false
      }]
    }],
    nodeTemplate: [{
      type: ContentChild,
      args: ["node", {
        descendants: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: ["header", {
        descendants: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: ["footer", {
        descendants: false
      }]
    }],
    loaderTemplate: [{
      type: ContentChild,
      args: ["loader", {
        descendants: false
      }]
    }],
    emptyTemplate: [{
      type: ContentChild,
      args: ["empty", {
        descendants: false
      }]
    }],
    togglerIconTemplate: [{
      type: ContentChild,
      args: ["togglericon", {
        descendants: false
      }]
    }],
    checkboxIconTemplate: [{
      type: ContentChild,
      args: ["checkboxicon", {
        descendants: false
      }]
    }],
    loadingIconTemplate: [{
      type: ContentChild,
      args: ["loadingicon", {
        descendants: false
      }]
    }],
    filterIconTemplate: [{
      type: ContentChild,
      args: ["filtericon", {
        descendants: false
      }]
    }],
    filterViewChild: [{
      type: ViewChild,
      args: ["filter"]
    }],
    scroller: [{
      type: ViewChild,
      args: ["scroller"]
    }],
    wrapperViewChild: [{
      type: ViewChild,
      args: ["wrapper"]
    }],
    contentViewChild: [{
      type: ViewChild,
      args: ["content"]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }],
    handleDropEvent: [{
      type: HostListener,
      args: ["drop", ["$event"]]
    }],
    handleDragOverEvent: [{
      type: HostListener,
      args: ["dragover", ["$event"]]
    }],
    handleDragEnterEvent: [{
      type: HostListener,
      args: ["dragenter"]
    }],
    handleDragLeaveEvent: [{
      type: HostListener,
      args: ["dragleave", ["$event"]]
    }]
  });
})();
var TreeModule = class _TreeModule {
  static \u0275fac = function TreeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _TreeModule,
    imports: [Tree, SharedModule],
    exports: [Tree, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [Tree, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeModule, [{
    type: NgModule,
    args: [{
      imports: [Tree, SharedModule],
      exports: [Tree, SharedModule]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/treeselect/index.mjs
var style14 = "\n    .p-treeselect {\n        display: inline-flex;\n        cursor: pointer;\n        position: relative;\n        user-select: none;\n        background: dt('treeselect.background');\n        border: 1px solid dt('treeselect.border.color');\n        transition:\n            background dt('treeselect.transition.duration'),\n            color dt('treeselect.transition.duration'),\n            border-color dt('treeselect.transition.duration'),\n            outline-color dt('treeselect.transition.duration'),\n            box-shadow dt('treeselect.transition.duration');\n        border-radius: dt('treeselect.border.radius');\n        outline-color: transparent;\n        box-shadow: dt('treeselect.shadow');\n    }\n\n    .p-treeselect:not(.p-disabled):hover {\n        border-color: dt('treeselect.hover.border.color');\n    }\n\n    .p-treeselect:not(.p-disabled).p-focus {\n        border-color: dt('treeselect.focus.border.color');\n        box-shadow: dt('treeselect.focus.ring.shadow');\n        outline: dt('treeselect.focus.ring.width') dt('treeselect.focus.ring.style') dt('treeselect.focus.ring.color');\n        outline-offset: dt('treeselect.focus.ring.offset');\n    }\n\n    .p-treeselect.p-variant-filled {\n        background: dt('treeselect.filled.background');\n    }\n\n    .p-treeselect.p-variant-filled:not(.p-disabled):hover {\n        background: dt('treeselect.filled.hover.background');\n    }\n\n    .p-treeselect.p-variant-filled.p-focus {\n        background: dt('treeselect.filled.focus.background');\n    }\n\n    .p-treeselect.p-invalid {\n        border-color: dt('treeselect.invalid.border.color');\n    }\n\n    .p-treeselect.p-disabled {\n        opacity: 1;\n        background: dt('treeselect.disabled.background');\n    }\n\n    .p-treeselect-clear-icon {\n        align-self: center;\n        color: dt('treeselect.clear.icon.color');\n        inset-inline-end: dt('treeselect.dropdown.width');\n    }\n\n    .p-treeselect-dropdown {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        flex-shrink: 0;\n        background: transparent;\n        color: dt('treeselect.dropdown.color');\n        width: dt('treeselect.dropdown.width');\n        border-start-end-radius: dt('border.radius.md');\n        border-end-end-radius: dt('border.radius.md');\n    }\n\n    .p-treeselect-label-container {\n        overflow: hidden;\n        flex: 1 1 auto;\n        cursor: pointer;\n    }\n\n    .p-treeselect-label {\n        display: flex;\n        align-items: center;\n        gap: calc(dt('treeselect.padding.y') / 2);\n        white-space: nowrap;\n        cursor: pointer;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        padding: dt('treeselect.padding.y') dt('treeselect.padding.x');\n        color: dt('treeselect.color');\n    }\n\n    .p-treeselect-label.p-placeholder {\n        color: dt('treeselect.placeholder.color');\n    }\n\n    .p-treeselect.p-invalid .p-treeselect-label.p-placeholder {\n        color: dt('treeselect.invalid.placeholder.color');\n    }\n\n    .p-treeselect:has(.p-select-clear-icon) .p-treeselect-label {\n        padding-inline-end: dt('treeselect.padding.x');\n    }\n\n    .p-treeselect.p-disabled .p-treeselect-label {\n        color: dt('treeselect.disabled.color');\n    }\n\n    .p-treeselect-label-empty {\n        overflow: hidden;\n        visibility: hidden;\n    }\n\n    .p-treeselect-overlay {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background: dt('treeselect.overlay.background');\n        color: dt('treeselect.overlay.color');\n        border: 1px solid dt('treeselect.overlay.border.color');\n        border-radius: dt('treeselect.overlay.border.radius');\n        box-shadow: dt('treeselect.overlay.shadow');\n        overflow: hidden;\n        min-width: 100%;\n        will-change: transform;\n    }\n\n    .p-treeselect-tree-container {\n        overflow: auto;\n    }\n\n    .p-treeselect-empty-message {\n        padding: dt('treeselect.empty.message.padding');\n        background: transparent;\n    }\n\n    .p-treeselect-fluid {\n        display: flex;\n    }\n\n    .p-treeselect-overlay .p-tree {\n        padding: dt('treeselect.tree.padding');\n    }\n\n    .p-treeselect-overlay .p-tree-loading {\n        min-height: 3rem;\n    }\n\n    .p-treeselect-label .p-chip {\n        padding-block-start: calc(dt('treeselect.padding.y') / 2);\n        padding-block-end: calc(dt('treeselect.padding.y') / 2);\n        border-radius: dt('treeselect.chip.border.radius');\n    }\n\n    .p-treeselect-label:has(.p-chip) {\n        padding: calc(dt('treeselect.padding.y') / 2) calc(dt('treeselect.padding.x') / 2);\n    }\n\n    .p-treeselect-sm .p-treeselect-label {\n        font-size: dt('treeselect.sm.font.size');\n        padding-block: dt('treeselect.sm.padding.y');\n        padding-inline: dt('treeselect.sm.padding.x');\n    }\n\n    .p-treeselect-sm .p-treeselect-dropdown .p-icon {\n        font-size: dt('treeselect.sm.font.size');\n        width: dt('treeselect.sm.font.size');\n        height: dt('treeselect.sm.font.size');\n    }\n\n    .p-treeselect-lg .p-treeselect-label {\n        font-size: dt('treeselect.lg.font.size');\n        padding-block: dt('treeselect.lg.padding.y');\n        padding-inline: dt('treeselect.lg.padding.x');\n    }\n\n    .p-treeselect-lg .p-treeselect-dropdown .p-icon {\n        font-size: dt('treeselect.lg.font.size');\n        width: dt('treeselect.lg.font.size');\n        height: dt('treeselect.lg.font.size');\n    }\n";

// node_modules/primeng/fesm2022/primeng-treeselect.mjs
var _c017 = ["value"];
var _c111 = ["header"];
var _c29 = ["empty"];
var _c38 = ["footer"];
var _c47 = ["clearicon"];
var _c57 = ["triggericon"];
var _c66 = ["dropdownicon"];
var _c76 = ["filtericon"];
var _c85 = ["closeicon"];
var _c95 = ["itemtogglericon"];
var _c104 = ["itemcheckboxicon"];
var _c114 = ["itemloadingicon"];
var _c125 = ["focusInput"];
var _c135 = ["filter"];
var _c145 = ["tree"];
var _c155 = ["panel"];
var _c164 = ["overlay"];
var _c174 = ["firstHiddenFocusableEl"];
var _c184 = ["lastHiddenFocusableEl"];
var _c193 = (a0, a1) => ({
  $implicit: a0,
  placeholder: a1
});
var _c202 = (a0, a1) => ({
  $implicit: a0,
  options: a1
});
var _c212 = (a0) => ({
  "max-height": a0
});
var _c223 = (a0) => ({
  $implicit: a0
});
var _c233 = (a0, a1) => ({
  $implicit: a0,
  partialSelected: a1
});
function TreeSelect_ng_container_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function TreeSelect_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TreeSelect_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 23);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.valueTemplate || ctx_r1._valueTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c193, ctx_r1.value, ctx_r1.placeholder));
  }
}
function TreeSelect_ng_template_6_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.label || "empty", " ");
  }
}
function TreeSelect_ng_template_6_ng_template_1_div_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275element(1, "p-chip", 25);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const node_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275classMap(ctx_r1.cx("chipItem"));
    \u0275\u0275property("pBind", ctx_r1.ptm("chipItem"));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("pcChip"));
    \u0275\u0275property("unstyled", ctx_r1.unstyled())("label", node_r3.label)("pt", ctx_r1.ptm("pcChip"));
  }
}
function TreeSelect_ng_template_6_ng_template_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275text(1);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.placeholder || "empty");
  }
}
function TreeSelect_ng_template_6_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_template_6_ng_template_1_div_0_Template, 2, 8, "div", 24)(1, TreeSelect_ng_template_6_ng_template_1_ng_container_1_Template, 2, 1, "ng-container", 18);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngForOf", ctx_r1.value);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.emptyValue);
  }
}
function TreeSelect_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_template_6_ng_container_0_Template, 2, 1, "ng-container", 17)(1, TreeSelect_ng_template_6_ng_template_1_Template, 2, 2, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
  }
  if (rf & 2) {
    const chipsValueTemplate_r4 = \u0275\u0275reference(2);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngIf", ctx_r1.display === "comma")("ngIfElse", chipsValueTemplate_r4);
  }
}
function TreeSelect_ng_container_8__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg", 28);
    \u0275\u0275listener("click", function TreeSelect_ng_container_8__svg_svg_1_Template_svg_click_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.clear($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cx("clearIcon"));
    \u0275\u0275property("pBind", ctx_r1.ptm("clearIcon"));
  }
}
function TreeSelect_ng_container_8_span_2_1_ng_template_0_Template(rf, ctx) {
}
function TreeSelect_ng_container_8_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_container_8_span_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function TreeSelect_ng_container_8_span_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 29);
    \u0275\u0275listener("click", function TreeSelect_ng_container_8_span_2_Template_span_click_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.clear($event));
    });
    \u0275\u0275template(1, TreeSelect_ng_container_8_span_2_1_Template, 1, 0, null, 30);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cx("clearIcon"));
    \u0275\u0275property("pBind", ctx_r1.ptm("clearIcon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.clearIconTemplate || ctx_r1._clearIconTemplate);
  }
}
function TreeSelect_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TreeSelect_ng_container_8__svg_svg_1_Template, 1, 3, "svg", 26)(2, TreeSelect_ng_container_8_span_2_Template, 2, 4, "span", 27);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.clearIconTemplate && !ctx_r1._clearIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.clearIconTemplate || ctx_r1.clearIconTemplate);
  }
}
function TreeSelect__svg_svg_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 31);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cx("dropdownIcon"));
    \u0275\u0275property("pBind", ctx_r1.ptm("dropdownIcon"));
  }
}
function TreeSelect_span_11_1_ng_template_0_Template(rf, ctx) {
}
function TreeSelect_span_11_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_span_11_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function TreeSelect_span_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 15);
    \u0275\u0275template(1, TreeSelect_span_11_1_Template, 1, 0, null, 30);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cx("dropdownIcon"));
    \u0275\u0275property("pBind", ctx_r1.ptm("dropdownIcon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.triggerIconTemplate || ctx_r1._triggerIconTemplate || ctx_r1.dropdownIconTemplate || ctx_r1._dropdownIconTemplate);
  }
}
function TreeSelect_ng_template_14_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function TreeSelect_ng_template_14_ng_container_8_ng_template_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function TreeSelect_ng_template_14_ng_container_8_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_template_14_ng_container_8_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 30);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.emptyTemplate || ctx_r1._emptyTemplate);
  }
}
function TreeSelect_ng_template_14_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TreeSelect_ng_template_14_ng_container_8_ng_template_1_Template, 1, 1, "ng-template", null, 9, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementContainerEnd();
  }
}
function TreeSelect_ng_template_14_9_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function TreeSelect_ng_template_14_9_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_template_14_9_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 23);
  }
  if (rf & 2) {
    const expanded_r8 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.itemTogglerIconTemplate || ctx_r1._itemTogglerIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c223, expanded_r8));
  }
}
function TreeSelect_ng_template_14_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_template_14_9_ng_template_0_Template, 1, 4, "ng-template", null, 10, \u0275\u0275templateRefExtractor);
  }
}
function TreeSelect_ng_template_14_10_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function TreeSelect_ng_template_14_10_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_template_14_10_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 23);
  }
  if (rf & 2) {
    const selected_r9 = ctx.$implicit;
    const partialSelected_r10 = ctx.partialSelected;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.itemCheckboxIconTemplate || ctx_r1._itemCheckboxIconTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c233, selected_r9, partialSelected_r10));
  }
}
function TreeSelect_ng_template_14_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_template_14_10_ng_template_0_Template, 1, 5, "ng-template", null, 11, \u0275\u0275templateRefExtractor);
  }
}
function TreeSelect_ng_template_14_11_ng_template_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function TreeSelect_ng_template_14_11_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_template_14_11_ng_template_0_ng_container_0_Template, 1, 0, "ng-container", 30);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.itemLoadingIconTemplate || ctx_r1._itemLoadingIconTemplate);
  }
}
function TreeSelect_ng_template_14_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TreeSelect_ng_template_14_11_ng_template_0_Template, 1, 1, "ng-template", null, 12, \u0275\u0275templateRefExtractor);
  }
}
function TreeSelect_ng_template_14_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function TreeSelect_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 16, 5)(2, "span", 32, 6);
    \u0275\u0275listener("focus", function TreeSelect_ng_template_14_Template_span_focus_2_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onFirstHiddenFocus($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275template(4, TreeSelect_ng_template_14_ng_container_4_Template, 1, 0, "ng-container", 23);
    \u0275\u0275elementStart(5, "div", 16)(6, "p-tree", 33, 7);
    \u0275\u0275listener("selectionChange", function TreeSelect_ng_template_14_Template_p_tree_selectionChange_6_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onSelectionChange($event));
    })("onNodeExpand", function TreeSelect_ng_template_14_Template_p_tree_onNodeExpand_6_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.nodeExpand($event));
    })("onNodeCollapse", function TreeSelect_ng_template_14_Template_p_tree_onNodeCollapse_6_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.nodeCollapse($event));
    })("onNodeSelect", function TreeSelect_ng_template_14_Template_p_tree_onNodeSelect_6_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onSelect($event));
    })("onNodeUnselect", function TreeSelect_ng_template_14_Template_p_tree_onNodeUnselect_6_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onUnselect($event));
    });
    \u0275\u0275template(8, TreeSelect_ng_template_14_ng_container_8_Template, 3, 0, "ng-container", 18)(9, TreeSelect_ng_template_14_9_Template, 2, 0, null, 18)(10, TreeSelect_ng_template_14_10_Template, 2, 0, null, 18)(11, TreeSelect_ng_template_14_11_Template, 2, 0, null, 18);
    \u0275\u0275elementEnd()();
    \u0275\u0275template(12, TreeSelect_ng_template_14_ng_container_12_Template, 1, 0, "ng-container", 23);
    \u0275\u0275elementStart(13, "span", 32, 8);
    \u0275\u0275listener("focus", function TreeSelect_ng_template_14_Template_span_focus_13_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onLastHiddenFocus($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("panel"), ctx_r1.panelStyleClass, ctx_r1.panelClass));
    \u0275\u0275property("ngStyle", ctx_r1.panelStyle)("pBind", ctx_r1.ptm("panel"));
    \u0275\u0275attribute("id", ctx_r1.listId);
    \u0275\u0275advance(2);
    \u0275\u0275property("pBind", ctx_r1.ptm("hiddenFirstFocusableEl"));
    \u0275\u0275attribute("tabindex", 0)("data-p-hidden-accessible", true)("data-p-hidden-focusable", true);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.headerTemplate || ctx_r1._headerTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(47, _c202, ctx_r1.value, ctx_r1.options));
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.cx("treeContainer"));
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(50, _c212, ctx_r1.scrollHeight))("pBind", ctx_r1.ptm("treeContainer"));
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r1.options)("propagateSelectionDown", ctx_r1.propagateSelectionDown)("propagateSelectionUp", ctx_r1.propagateSelectionUp)("selectionMode", ctx_r1.selectionMode)("selection", ctx_r1.value)("metaKeySelection", ctx_r1.metaKeySelection)("emptyMessage", ctx_r1.emptyMessage)("filter", ctx_r1.filter)("filterBy", ctx_r1.filterBy)("filterMode", ctx_r1.filterMode)("filterPlaceholder", ctx_r1.filterPlaceholder)("filterLocale", ctx_r1.filterLocale)("filteredNodes", ctx_r1.filteredNodes)("virtualScroll", ctx_r1.virtualScroll)("virtualScrollItemSize", ctx_r1.virtualScrollItemSize)("virtualScrollOptions", ctx_r1.virtualScrollOptions)("_templateMap", ctx_r1.templateMap)("loading", ctx_r1.loading)("filterInputAutoFocus", ctx_r1.filterInputAutoFocus)("loadingMode", ctx_r1.loadingMode)("pt", ctx_r1.ptm("pcTree"))("unstyled", ctx_r1.unstyled());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngIf", ctx_r1.emptyTemplate || ctx_r1._emptyTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.itemTogglerIconTemplate || ctx_r1._itemTogglerIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.itemCheckboxIconTemplate || ctx_r1._itemCheckboxIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.itemLoadingIconTemplate || ctx_r1._itemLoadingIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.footerTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(52, _c202, ctx_r1.value, ctx_r1.options));
    \u0275\u0275advance();
    \u0275\u0275property("pBind", ctx_r1.ptm("hiddenLastFocusableEl"));
    \u0275\u0275attribute("tabindex", 0)("data-p-hidden-accessible", true)("data-p-hidden-focusable", true);
  }
}
var style15 = (
  /*css*/
  `
    ${style14}

    /* For PrimeNG */

    .p-treeselect.ng-invalid.ng-dirty {
        border-color: dt('treeselect.invalid.border.color');
    }

    p-treeselect.ng-invalid.ng-dirty.p-focus {
        border-color: dt('treeselect.focus.border.color');
    }

    p-treeselect.ng-invalid.ng-dirty .p-treeselect-label.p-placeholder {
        color: dt('treeselect.invalid.placeholder.color');
    }

    .p-treeselect-clear-icon.p-icon {
        flex-shrink: 0;
    }
`
);
var inlineStyles3 = {
  root: ({
    instance
  }) => __spreadValues({
    position: instance.$appendTo() === "self" ? "relative" : void 0
  }, instance.containerStyle)
};
var classes11 = {
  root: ({
    instance
  }) => ["p-treeselect p-component p-inputwrapper", {
    "p-treeselect-display-chip": instance.display === "chip",
    "p-disabled": instance.$disabled(),
    "p-invalid": instance.invalid(),
    "p-focus": instance.focused,
    "p-variant-filled": instance.$variant() === "filled",
    "p-inputwrapper-filled": !instance.emptyValue,
    "p-inputwrapper-focus": instance.focused || instance.overlayVisible,
    "p-treeselect-open": instance.overlayVisible,
    "p-treeselect-clearable": instance.showClear,
    "p-treeselect-fluid": instance.hasFluid,
    "p-treeselect-sm p-inputfield-sm": instance.size() === "small",
    "p-treeselect-lg p-inputfield-lg": instance.size() === "large"
  }],
  labelContainer: "p-treeselect-label-container",
  label: ({
    instance
  }) => ["p-treeselect-label", {
    "p-placeholder": instance.label === instance.placeholder,
    "p-treeselect-label-empty": !instance.placeholder && instance.emptyValue
  }],
  clearIcon: "p-treeselect-clear-icon",
  chip: "p-treeselect-chip-item",
  pcChip: "p-treeselect-chip",
  dropdown: "p-treeselect-dropdown",
  dropdownIcon: "p-treeselect-dropdown-icon",
  panel: "p-treeselect-overlay p-component-overlay p-component",
  treeContainer: "p-treeselect-tree-container",
  emptyMessage: "p-treeselect-empty-message"
};
var TreeSelectStyle = class _TreeSelectStyle extends BaseStyle {
  name = "treeselect";
  style = style15;
  classes = classes11;
  inlineStyles = inlineStyles3;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275TreeSelectStyle_BaseFactory;
    return function TreeSelectStyle_Factory(__ngFactoryType__) {
      return (\u0275TreeSelectStyle_BaseFactory || (\u0275TreeSelectStyle_BaseFactory = \u0275\u0275getInheritedFactory(_TreeSelectStyle)))(__ngFactoryType__ || _TreeSelectStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TreeSelectStyle,
    factory: _TreeSelectStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeSelectStyle, [{
    type: Injectable
  }], null, null);
})();
var TreeSelectClasses;
(function(TreeSelectClasses2) {
  TreeSelectClasses2["root"] = "p-treeselect";
  TreeSelectClasses2["labelContainer"] = "p-treeselect-label-container";
  TreeSelectClasses2["label"] = "p-treeselect-label";
  TreeSelectClasses2["chipItem"] = "p-treeselect-chip-item";
  TreeSelectClasses2["clearIcon"] = "p-treeselect-clear-icon";
  TreeSelectClasses2["pcChip"] = "p-treeselect-chip";
  TreeSelectClasses2["dropdown"] = "p-treeselect-dropdown";
  TreeSelectClasses2["dropdownIcon"] = "p-treeselect-dropdown-icon";
  TreeSelectClasses2["panel"] = "p-treeselect-overlay";
  TreeSelectClasses2["treeContainer"] = "p-treeselect-tree-container";
  TreeSelectClasses2["emptyMessage"] = "p-treeselect-empty-message";
})(TreeSelectClasses || (TreeSelectClasses = {}));
var TREESELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => TreeSelect),
  multi: true
};
var TREESELECT_INSTANCE = new InjectionToken("TREESELECT_INSTANCE");
var TreeSelect = class _TreeSelect extends BaseEditableHolder {
  $pcTreeSelect = inject(TREESELECT_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  _componentStyle = inject(TreeSelectStyle);
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * Identifier of the underlying input element.
   * @group Props
   */
  inputId;
  /**
   * Height of the viewport, a scrollbar is defined if height of list exceeds this value.
   * @group Props
   */
  scrollHeight = "400px";
  /**
   * Defines how multiple items can be selected, when true metaKey needs to be pressed to select or unselect an item and when set to false selection of each item can be toggled individually. On touch enabled devices, metaKeySelection is turned off automatically.
   * @group Props
   */
  metaKeySelection = false;
  /**
   * Defines how the selected items are displayed.
   * @group Props
   */
  display = "comma";
  /**
   * Defines the selection mode.
   * @group Props
   */
  selectionMode = "single";
  /**
   * Index of the element in tabbing order.
   * @group Props
   */
  tabindex = "0";
  /**
   * Defines a string that labels the input for accessibility.
   * @group Props
   */
  ariaLabel;
  /**
   * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
   * @group Props
   */
  ariaLabelledBy;
  /**
   * Label to display when there are no selections.
   * @group Props
   */
  placeholder;
  /**
   * Style class of the overlay panel.
   * @group Props
   */
  panelClass;
  /**
   * Inline style of the panel element.
   * @group Props
   */
  panelStyle;
  /**
   * Style class of the panel element.
   * @group Props
   */
  panelStyleClass;
  /**
   * Inline style of the container element.
   * @deprecated since v20.0.0, use `style` instead.
   * @group Props
   */
  containerStyle;
  /**
   * Style class of the container element.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  containerStyleClass;
  /**
   * Inline style of the label element.
   * @group Props
   */
  labelStyle;
  /**
   * Style class of the label element.
   * @group Props
   */
  labelStyleClass;
  /**
   * Specifies the options for the overlay.
   * @group Props
   */
  overlayOptions;
  /**
   * Text to display when there are no options available. Defaults to value from PrimeNG locale configuration.
   * @group Props
   */
  emptyMessage = "";
  /**
   * When specified, displays an input field to filter the items.
   * @group Props
   */
  filter = false;
  /**
   * When filtering is enabled, filterBy decides which field or fields (comma separated) to search against.
   * @group Props
   */
  filterBy = "label";
  /**
   * Mode for filtering valid values are "lenient" and "strict". Default is lenient.
   * @group Props
   */
  filterMode = "lenient";
  /**
   * Placeholder text to show when filter input is empty.
   * @group Props
   */
  filterPlaceholder;
  /**
   * Locale to use in filtering. The default locale is the host environment's current locale.
   * @group Props
   */
  filterLocale;
  /**
   * Determines whether the filter input should be automatically focused when the component is rendered.
   * @group Props
   */
  filterInputAutoFocus = true;
  /**
   * Whether checkbox selections propagate to descendant nodes.
   * @group Props
   */
  propagateSelectionDown = true;
  /**
   * Whether checkbox selections propagate to ancestor nodes.
   * @group Props
   */
  propagateSelectionUp = true;
  /**
   * When enabled, a clear icon is displayed to clear the value.
   * @group Props
   */
  showClear = false;
  /**
   * Clears the filter value when hiding the dropdown.
   * @group Props
   */
  resetFilterOnHide = true;
  /**
   * Whether the data should be loaded on demand during scroll.
   * @group Props
   */
  virtualScroll;
  /**
   * Height of an item in the list for VirtualScrolling.
   * @group Props
   */
  virtualScrollItemSize;
  /**
   * Whether to use the scroller feature. The properties of scroller component can be used like an object in it.
   * @group Props
   */
  virtualScrollOptions;
  /**
   * When present, it specifies that the component should automatically get focus on load.
   * @group Props
   */
  autofocus;
  /**
   * An array of treenodes.
   * @defaultValue undefined
   * @group Props
   */
  get options() {
    return this._options;
  }
  set options(options) {
    this._options = options;
    this.updateTreeState();
  }
  /**
   * Displays a loader to indicate data load is in progress.
   * @group Props
   */
  loading;
  /**
   * Loading mode display.
   * @group Props
   */
  loadingMode = "mask";
  /**
   * Specifies the size of the component.
   * @defaultValue undefined
   * @group Props
   */
  size = input(...ngDevMode ? [void 0, {
    debugName: "size"
  }] : []);
  /**
   * Specifies the input variant of the component.
   * @defaultValue undefined
   * @group Props
   */
  variant = input(...ngDevMode ? [void 0, {
    debugName: "variant"
  }] : []);
  /**
   * Spans 100% width of the container when enabled.
   * @defaultValue undefined
   * @group Props
   */
  fluid = input(void 0, __spreadProps(__spreadValues({}, ngDevMode ? {
    debugName: "fluid"
  } : {}), {
    transform: booleanAttribute
  }));
  /**
   * Target element to attach the overlay, valid values are "body" or a local ng-template variable of another element (note: use binding with brackets for template variables, e.g. [appendTo]="mydiv" for a div element having #mydiv as variable name).
   * @defaultValue 'self'
   * @group Props
   */
  appendTo = input(void 0, ...ngDevMode ? [{
    debugName: "appendTo"
  }] : []);
  /**
   * The motion options.
   * @group Props
   */
  motionOptions = input(void 0, ...ngDevMode ? [{
    debugName: "motionOptions"
  }] : []);
  /**
   * Callback to invoke when a node is expanded.
   * @param {TreeSelectNodeExpandEvent} event - Custom node expand event.
   * @group Emits
   */
  onNodeExpand = new EventEmitter();
  /**
   * Callback to invoke when a node is collapsed.
   * @param {TreeSelectNodeCollapseEvent} event - Custom node collapse event.
   * @group Emits
   */
  onNodeCollapse = new EventEmitter();
  /**
   * Callback to invoke when the overlay is shown.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onShow = new EventEmitter();
  /**
   * Callback to invoke when the overlay is hidden.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onHide = new EventEmitter();
  /**
   * Callback to invoke when input field is cleared.
   * @group Emits
   */
  onClear = new EventEmitter();
  /**
   * Callback to invoke when data is filtered.
   * @group Emits
   */
  onFilter = new EventEmitter();
  /**
   * Callback to invoke when treeselect gets focus.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onFocus = new EventEmitter();
  /**
   * Callback to invoke when treeselect loses focus.
   * @param {Event} event - Browser event.
   * @group Emits
   */
  onBlur = new EventEmitter();
  /**
   * Callback to invoke when a node is unselected.
   * @param {TreeNodeUnSelectEvent} event - node unselect event.
   * @group Emits
   */
  onNodeUnselect = new EventEmitter();
  /**
   * Callback to invoke when a node is selected.
   * @param {TreeNodeSelectEvent} event - node select event.
   * @group Emits
   */
  onNodeSelect = new EventEmitter();
  $appendTo = computed(() => this.appendTo() || this.config.overlayAppendTo(), ...ngDevMode ? [{
    debugName: "$appendTo"
  }] : []);
  focusInput;
  filterViewChild;
  treeViewChild;
  panelEl;
  overlayViewChild;
  firstHiddenFocusableElementOnOverlay;
  lastHiddenFocusableElementOnOverlay;
  $variant = computed(() => this.variant() || this.config.inputStyle() || this.config.inputVariant(), ...ngDevMode ? [{
    debugName: "$variant"
  }] : []);
  pcFluid = inject(Fluid, {
    optional: true,
    host: true,
    skipSelf: true
  });
  get hasFluid() {
    return this.fluid() ?? !!this.pcFluid;
  }
  filteredNodes;
  filterValue = null;
  serializedValue;
  /**
   * Custom value template.
   * @param {TreeSelectValueTemplateContext} context - value context.
   * @see {@link TreeSelectValueTemplateContext}
   * @group Templates
   */
  valueTemplate;
  /**
   * Custom header template.
   * @param {TreeSelectHeaderTemplateContext} context - header context.
   * @see {@link TreeSelectHeaderTemplateContext}
   * @group Templates
   */
  headerTemplate;
  /**
   * Custom empty message template.
   * @group Templates
   */
  emptyTemplate;
  /**
   * Custom footer template.
   * @param {TreeSelectHeaderTemplateContext} context - footer context.
   * @see {@link TreeSelectHeaderTemplateContext}
   * @group Templates
   */
  footerTemplate;
  /**
   * Custom clear icon template.
   * @group Templates
   */
  clearIconTemplate;
  /**
   * Custom trigger icon template.
   * @group Templates
   */
  triggerIconTemplate;
  /**
   * Custom dropdown icon template.
   * @group Templates
   */
  dropdownIconTemplate;
  /**
   * Custom filter icon template.
   * @group Templates
   */
  filterIconTemplate;
  /**
   * Custom close icon template.
   * @group Templates
   */
  closeIconTemplate;
  /**
   * Custom item toggler icon template.
   * @param {TreeSelectItemTogglerIconTemplateContext} context - toggler icon context.
   * @see {@link TreeSelectItemTogglerIconTemplateContext}
   * @group Templates
   */
  itemTogglerIconTemplate;
  /**
   * Custom item checkbox icon template.
   * @param {TreeSelectItemCheckboxIconTemplateContext} context - checkbox icon context.
   * @see {@link TreeSelectItemCheckboxIconTemplateContext}
   * @group Templates
   */
  itemCheckboxIconTemplate;
  /**
   * Custom item loading icon template.
   * @group Templates
   */
  itemLoadingIconTemplate;
  templates;
  _valueTemplate;
  _headerTemplate;
  _emptyTemplate;
  _footerTemplate;
  _clearIconTemplate;
  _triggerIconTemplate;
  _filterIconTemplate;
  _closeIconTemplate;
  _itemTogglerIconTemplate;
  _itemCheckboxIconTemplate;
  _itemLoadingIconTemplate;
  _dropdownIconTemplate;
  focused;
  overlayVisible;
  value;
  expandedNodes = [];
  _options;
  templateMap;
  listId = "";
  onHostClick(event) {
    this.onClick(event);
  }
  onInit() {
    this.listId = s2("pn_id_") + "_list";
    this.updateTreeState();
  }
  onAfterContentInit() {
    if (this.templates.length) {
      this.templateMap = {};
    }
    this.templates.forEach((item) => {
      switch (item.getType()) {
        case "value":
          this._valueTemplate = item.template;
          break;
        case "header":
          this._headerTemplate = item.template;
          break;
        case "empty":
          this._emptyTemplate = item.template;
          break;
        case "footer":
          this._footerTemplate = item.template;
          break;
        case "clearicon":
          this._clearIconTemplate = item.template;
          break;
        case "triggericon":
          this._triggerIconTemplate = item.template;
          break;
        case "filtericon":
          this._filterIconTemplate = item.template;
          break;
        case "closeicon":
          this._closeIconTemplate = item.template;
          break;
        case "itemtogglericon":
          this._itemTogglerIconTemplate = item.template;
          break;
        case "itemcheckboxicon":
          this._itemCheckboxIconTemplate = item.template;
          break;
        case "dropdownicon":
          this._dropdownIconTemplate = item.template;
          break;
        case "itemloadingicon":
          this._itemLoadingIconTemplate = item.template;
          break;
        default:
          if (item.name) this.templateMap[item.name] = item.template;
          else this.valueTemplate = item.template;
          break;
      }
    });
  }
  onOverlayBeforeEnter() {
    if (this.filter) {
      s(this.filterValue) && this.treeViewChild?._filter(this.filterValue);
      this.filterInputAutoFocus && this.filterViewChild?.nativeElement.focus();
    } else {
      let focusableElements = b(this.panelEl?.nativeElement);
      if (focusableElements && focusableElements.length > 0) {
        focusableElements[0].focus();
      }
    }
  }
  onOverlayBeforeHide() {
    let focusableElements = b(this.el.nativeElement);
    if (focusableElements && focusableElements.length > 0) {
      focusableElements[0].focus();
    }
  }
  onSelectionChange(event) {
    this.value = event;
    this.onModelChange(this.value);
    this.cd.markForCheck();
  }
  onClick(event) {
    if (this.$disabled()) {
      return;
    }
    const section = event.target?.getAttribute?.("data-pc-section");
    if (!this.overlayViewChild?.el?.nativeElement?.contains(event.target) && section !== "box" && section !== "icon") {
      if (this.overlayVisible) {
        this.hide();
      } else {
        this.show();
      }
      this.focusInput?.nativeElement.focus();
    }
  }
  onKeyDown(event) {
    switch (event.code) {
      //down
      case "ArrowDown":
        if (!this.overlayVisible) {
          this.show();
          event.preventDefault();
        }
        this.onArrowDown(event);
        event.preventDefault();
        break;
      //space
      case "Space":
      case "Enter":
        if (!this.overlayVisible) {
          this.show();
          event.preventDefault();
        }
        break;
      //escape
      case "Escape":
        if (this.overlayVisible) {
          this.hide();
          this.focusInput?.nativeElement.focus();
          event.preventDefault();
        }
        break;
      //tab
      case "Tab":
        this.onTabKey(event);
        break;
      default:
        break;
    }
  }
  onFilterInput(event) {
    this.filterValue = event.target.value;
    this.treeViewChild?._filter(this.filterValue);
    this.onFilter.emit({
      filter: this.filterValue,
      filteredValue: this.treeViewChild?.filteredNodes
    });
    setTimeout(() => {
      this.overlayViewChild?.alignOverlay();
    });
  }
  onArrowDown(event) {
    if (this.overlayVisible && this.panelEl?.nativeElement) {
      let focusableElements = b(this.panelEl.nativeElement, '[data-pc-section="node"]');
      if (focusableElements && focusableElements.length > 0) {
        focusableElements[0].focus();
      }
      event.preventDefault();
    }
  }
  onFirstHiddenFocus(event) {
    const focusableEl = event.relatedTarget === this.focusInput?.nativeElement ? vt(this.overlayViewChild?.overlayViewChild?.nativeElement, ':not([data-p-hidden-focusable="true"])') : this.focusInput?.nativeElement;
    bt(focusableEl);
  }
  onLastHiddenFocus(event) {
    const focusableEl = event.relatedTarget === this.focusInput?.nativeElement ? Lt(this.overlayViewChild?.overlayViewChild?.nativeElement, ':not([data-p-hidden-focusable="true"])') : this.focusInput?.nativeElement;
    bt(focusableEl);
  }
  show() {
    this.overlayVisible = true;
  }
  hide(event) {
    this.overlayVisible = false;
    this.resetFilter();
    this.onHide.emit(event);
    this.cd.markForCheck();
  }
  clear(event) {
    this.value = null;
    this.resetExpandedNodes();
    this.resetPartialSelected();
    this.onModelChange(this.value);
    this.onClear.emit();
    event.stopPropagation();
  }
  checkValue() {
    return this.value !== null && s(this.value);
  }
  onTabKey(event, pressedInInputText = false) {
    if (!pressedInInputText) {
      if (this.overlayVisible && this.hasFocusableElements()) {
        bt(event.shiftKey ? this.lastHiddenFocusableElementOnOverlay?.nativeElement : this.firstHiddenFocusableElementOnOverlay?.nativeElement);
        event.preventDefault();
      } else {
        this.overlayVisible && this.hide(this.filter);
      }
    }
  }
  hasFocusableElements() {
    return b(this.overlayViewChild?.overlayViewChild?.nativeElement, ':not([data-p-hidden-focusable="true"])').length > 0;
  }
  resetFilter() {
    if (this.filter && !this.resetFilterOnHide) {
      this.filteredNodes = this.treeViewChild?.filteredNodes;
      this.treeViewChild?.resetFilter();
    } else {
      this.filterValue = null;
    }
  }
  updateTreeState() {
    if (this.value) {
      let selectedNodes = this.selectionMode === "single" ? [this.value] : [...this.value];
      this.resetExpandedNodes();
      this.resetPartialSelected();
      if (selectedNodes && this.options) {
        this.updateTreeBranchState(null, null, selectedNodes);
      }
    }
  }
  updateTreeBranchState(node, path, selectedNodes) {
    if (node) {
      if (this.isSelected(node)) {
        this.expandPath(path);
        selectedNodes.splice(selectedNodes.indexOf(node), 1);
      }
      if (selectedNodes.length > 0 && node.children) {
        for (let childNode of node.children) {
          this.updateTreeBranchState(childNode, [...path, node], selectedNodes);
        }
      }
    } else {
      for (let childNode of this.options) {
        this.updateTreeBranchState(childNode, [], selectedNodes);
      }
    }
  }
  expandPath(expandedNodes) {
    for (let node of expandedNodes) {
      node.expanded = true;
    }
    this.expandedNodes = [...expandedNodes];
  }
  nodeExpand(event) {
    this.onNodeExpand.emit(event);
    this.expandedNodes.push(event.node);
    setTimeout(() => {
      this.overlayViewChild?.alignOverlay();
    });
  }
  nodeCollapse(event) {
    this.onNodeCollapse.emit(event);
    this.expandedNodes.splice(this.expandedNodes.indexOf(event.node), 1);
    setTimeout(() => {
      this.overlayViewChild?.alignOverlay();
    });
  }
  resetExpandedNodes() {
    for (let node of this.expandedNodes) {
      node.expanded = false;
    }
    this.expandedNodes = [];
  }
  resetPartialSelected(nodes = this.options) {
    if (!nodes) {
      return;
    }
    for (let node of nodes) {
      node.partialSelected = false;
      if (node.children && node.children?.length > 0) {
        this.resetPartialSelected(node.children);
      }
    }
  }
  findSelectedNodes(node, keys, selectedNodes) {
    if (node) {
      if (this.isSelected(node)) {
        selectedNodes.push(node);
        delete keys[node.key];
      }
      if (Object.keys(keys).length && node.children) {
        for (let childNode of node.children) {
          this.findSelectedNodes(childNode, keys, selectedNodes);
        }
      }
    } else {
      for (let childNode of this.options) {
        this.findSelectedNodes(childNode, keys, selectedNodes);
      }
    }
  }
  isSelected(node) {
    return this.findIndexInSelection(node) != -1;
  }
  findIndexInSelection(node) {
    let index = -1;
    if (this.value) {
      if (this.selectionMode === "single") {
        let areNodesEqual = this.value.key && this.value.key === node.key || this.value == node;
        index = areNodesEqual ? 0 : -1;
      } else {
        for (let i = 0; i < this.value.length; i++) {
          let selectedNode = this.value[i];
          let areNodesEqual = selectedNode.key && selectedNode.key === node.key || selectedNode == node;
          if (areNodesEqual) {
            index = i;
            break;
          }
        }
      }
    }
    return index;
  }
  onSelect(event) {
    this.onNodeSelect.emit(event);
    if (this.selectionMode === "single") {
      this.hide();
      this.focusInput?.nativeElement.focus();
    }
  }
  onUnselect(event) {
    this.onNodeUnselect.emit(event);
  }
  onInputFocus(event) {
    if (this.$disabled()) {
      return;
    }
    this.focused = true;
    this.onFocus.emit(event);
  }
  onInputBlur(event) {
    this.focused = false;
    this.onBlur.emit(event);
    this.onModelTouched();
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value) {
    this.value = value;
    this.updateTreeState();
    this.cd.markForCheck();
  }
  get emptyValue() {
    return !this.value || Object.keys(this.value).length === 0;
  }
  get emptyOptions() {
    return !this.options || this.options.length === 0;
  }
  get label() {
    let value = this.value || [];
    return value.length ? value.map((node) => node.label).join(", ") : this.selectionMode === "single" && this.value ? value.label : this.placeholder;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275TreeSelect_BaseFactory;
    return function TreeSelect_Factory(__ngFactoryType__) {
      return (\u0275TreeSelect_BaseFactory || (\u0275TreeSelect_BaseFactory = \u0275\u0275getInheritedFactory(_TreeSelect)))(__ngFactoryType__ || _TreeSelect);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _TreeSelect,
    selectors: [["p-treeSelect"], ["p-treeselect"], ["p-tree-select"]],
    contentQueries: function TreeSelect_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c017, 4);
        \u0275\u0275contentQuery(dirIndex, _c111, 4);
        \u0275\u0275contentQuery(dirIndex, _c29, 4);
        \u0275\u0275contentQuery(dirIndex, _c38, 4);
        \u0275\u0275contentQuery(dirIndex, _c47, 4);
        \u0275\u0275contentQuery(dirIndex, _c57, 4);
        \u0275\u0275contentQuery(dirIndex, _c66, 4);
        \u0275\u0275contentQuery(dirIndex, _c76, 4);
        \u0275\u0275contentQuery(dirIndex, _c85, 4);
        \u0275\u0275contentQuery(dirIndex, _c95, 4);
        \u0275\u0275contentQuery(dirIndex, _c104, 4);
        \u0275\u0275contentQuery(dirIndex, _c114, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.valueTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.headerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.emptyTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.footerTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.clearIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.triggerIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.dropdownIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.filterIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.closeIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.itemTogglerIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.itemCheckboxIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.itemLoadingIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function TreeSelect_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c125, 5);
        \u0275\u0275viewQuery(_c135, 5);
        \u0275\u0275viewQuery(_c145, 5);
        \u0275\u0275viewQuery(_c155, 5);
        \u0275\u0275viewQuery(_c164, 5);
        \u0275\u0275viewQuery(_c174, 5);
        \u0275\u0275viewQuery(_c184, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.focusInput = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.filterViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.treeViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.panelEl = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.overlayViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.firstHiddenFocusableElementOnOverlay = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.lastHiddenFocusableElementOnOverlay = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function TreeSelect_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("mousedown", function TreeSelect_mousedown_HostBindingHandler($event) {
          return ctx.onHostClick($event);
        });
      }
      if (rf & 2) {
        \u0275\u0275styleMap(ctx.sx("root"));
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.containerStyleClass));
      }
    },
    inputs: {
      inputId: "inputId",
      scrollHeight: "scrollHeight",
      metaKeySelection: [2, "metaKeySelection", "metaKeySelection", booleanAttribute],
      display: "display",
      selectionMode: "selectionMode",
      tabindex: "tabindex",
      ariaLabel: "ariaLabel",
      ariaLabelledBy: "ariaLabelledBy",
      placeholder: "placeholder",
      panelClass: "panelClass",
      panelStyle: "panelStyle",
      panelStyleClass: "panelStyleClass",
      containerStyle: "containerStyle",
      containerStyleClass: "containerStyleClass",
      labelStyle: "labelStyle",
      labelStyleClass: "labelStyleClass",
      overlayOptions: "overlayOptions",
      emptyMessage: "emptyMessage",
      filter: [2, "filter", "filter", booleanAttribute],
      filterBy: "filterBy",
      filterMode: "filterMode",
      filterPlaceholder: "filterPlaceholder",
      filterLocale: "filterLocale",
      filterInputAutoFocus: [2, "filterInputAutoFocus", "filterInputAutoFocus", booleanAttribute],
      propagateSelectionDown: [2, "propagateSelectionDown", "propagateSelectionDown", booleanAttribute],
      propagateSelectionUp: [2, "propagateSelectionUp", "propagateSelectionUp", booleanAttribute],
      showClear: [2, "showClear", "showClear", booleanAttribute],
      resetFilterOnHide: [2, "resetFilterOnHide", "resetFilterOnHide", booleanAttribute],
      virtualScroll: "virtualScroll",
      virtualScrollItemSize: "virtualScrollItemSize",
      virtualScrollOptions: "virtualScrollOptions",
      autofocus: [2, "autofocus", "autofocus", booleanAttribute],
      options: "options",
      loading: [2, "loading", "loading", booleanAttribute],
      loadingMode: "loadingMode",
      size: [1, "size"],
      variant: [1, "variant"],
      fluid: [1, "fluid"],
      appendTo: [1, "appendTo"],
      motionOptions: [1, "motionOptions"]
    },
    outputs: {
      onNodeExpand: "onNodeExpand",
      onNodeCollapse: "onNodeCollapse",
      onShow: "onShow",
      onHide: "onHide",
      onClear: "onClear",
      onFilter: "onFilter",
      onFocus: "onFocus",
      onBlur: "onBlur",
      onNodeUnselect: "onNodeUnselect",
      onNodeSelect: "onNodeSelect"
    },
    features: [\u0275\u0275ProvidersFeature([TREESELECT_VALUE_ACCESSOR, TreeSelectStyle, {
      provide: TREESELECT_INSTANCE,
      useExisting: _TreeSelect
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _TreeSelect
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 16,
    vars: 37,
    consts: [["focusInput", ""], ["defaultValueTemplate", ""], ["overlay", ""], ["content", ""], ["chipsValueTemplate", ""], ["panel", ""], ["firstHiddenFocusableEl", ""], ["tree", ""], ["lastHiddenFocusableEl", ""], ["empty", ""], ["togglericon", ""], ["checkboxicon", ""], ["loadingicon", ""], [1, "p-hidden-accessible", 3, "pBind"], ["type", "text", "role", "combobox", "readonly", "", 3, "focus", "blur", "keydown", "pAutoFocus", "pBind"], [3, "pBind"], [3, "ngStyle", "pBind"], [4, "ngIf", "ngIfElse"], [4, "ngIf"], ["role", "button", "aria-haspopup", "tree", 3, "pBind"], ["data-p-icon", "chevron-down", 3, "class", "pBind", 4, "ngIf"], [3, "class", "pBind", 4, "ngIf"], [3, "visibleChange", "onBeforeEnter", "onBeforeHide", "onShow", "onHide", "hostAttrSelector", "visible", "options", "target", "appendTo", "unstyled", "pt", "motionOptions"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "class", "pBind", 4, "ngFor", "ngForOf"], [3, "unstyled", "label", "pt"], ["data-p-icon", "times", 3, "class", "pBind", "click", 4, "ngIf"], [3, "class", "pBind", "click", 4, "ngIf"], ["data-p-icon", "times", 3, "click", "pBind"], [3, "click", "pBind"], [4, "ngTemplateOutlet"], ["data-p-icon", "chevron-down", 3, "pBind"], ["role", "presentation", 1, "p-hidden-accessible", "p-hidden-focusable", 3, "focus", "pBind"], [3, "selectionChange", "onNodeExpand", "onNodeCollapse", "onNodeSelect", "onNodeUnselect", "value", "propagateSelectionDown", "propagateSelectionUp", "selectionMode", "selection", "metaKeySelection", "emptyMessage", "filter", "filterBy", "filterMode", "filterPlaceholder", "filterLocale", "filteredNodes", "virtualScroll", "virtualScrollItemSize", "virtualScrollOptions", "_templateMap", "loading", "filterInputAutoFocus", "loadingMode", "pt", "unstyled"]],
    template: function TreeSelect_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "div", 13)(1, "input", 14, 0);
        \u0275\u0275listener("focus", function TreeSelect_Template_input_focus_1_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onInputFocus($event));
        })("blur", function TreeSelect_Template_input_blur_1_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onInputBlur($event));
        })("keydown", function TreeSelect_Template_input_keydown_1_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onKeyDown($event));
        });
        \u0275\u0275elementEnd()();
        \u0275\u0275elementStart(3, "div", 15)(4, "div", 16);
        \u0275\u0275template(5, TreeSelect_ng_container_5_Template, 2, 5, "ng-container", 17)(6, TreeSelect_ng_template_6_Template, 3, 2, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd()();
        \u0275\u0275template(8, TreeSelect_ng_container_8_Template, 3, 2, "ng-container", 18);
        \u0275\u0275elementStart(9, "div", 19);
        \u0275\u0275template(10, TreeSelect__svg_svg_10_Template, 1, 3, "svg", 20)(11, TreeSelect_span_11_Template, 2, 4, "span", 21);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(12, "p-overlay", 22, 2);
        \u0275\u0275twoWayListener("visibleChange", function TreeSelect_Template_p_overlay_visibleChange_12_listener($event) {
          \u0275\u0275restoreView(_r1);
          \u0275\u0275twoWayBindingSet(ctx.overlayVisible, $event) || (ctx.overlayVisible = $event);
          return \u0275\u0275resetView($event);
        });
        \u0275\u0275listener("onBeforeEnter", function TreeSelect_Template_p_overlay_onBeforeEnter_12_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onOverlayBeforeEnter());
        })("onBeforeHide", function TreeSelect_Template_p_overlay_onBeforeHide_12_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onOverlayBeforeHide());
        })("onShow", function TreeSelect_Template_p_overlay_onShow_12_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onShow.emit($event));
        })("onHide", function TreeSelect_Template_p_overlay_onHide_12_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.hide($event));
        });
        \u0275\u0275template(14, TreeSelect_ng_template_14_Template, 15, 55, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        const defaultValueTemplate_r11 = \u0275\u0275reference(7);
        \u0275\u0275property("pBind", ctx.ptm("hiddenInputContainer"));
        \u0275\u0275attribute("data-p-hidden-accessible", true);
        \u0275\u0275advance();
        \u0275\u0275property("pAutoFocus", ctx.autofocus)("pBind", ctx.ptm("hiddenInput"));
        \u0275\u0275attribute("id", ctx.inputId)("disabled", ctx.$disabled() ? "" : void 0)("tabindex", !ctx.$disabled() ? ctx.tabindex : -1)("aria-controls", ctx.overlayVisible ? ctx.listId : null)("aria-haspopup", "tree")("aria-expanded", ctx.overlayVisible ?? false)("aria-labelledby", ctx.ariaLabelledBy)("aria-label", ctx.ariaLabel || (ctx.label === "p-emptylabel" ? void 0 : ctx.label));
        \u0275\u0275advance(2);
        \u0275\u0275classMap(ctx.cx("labelContainer"));
        \u0275\u0275property("pBind", ctx.ptm("labelContainer"));
        \u0275\u0275advance();
        \u0275\u0275classMap(ctx.cn(ctx.cx("label"), ctx.labelStyleClass));
        \u0275\u0275property("ngStyle", ctx.labelStyle)("pBind", ctx.ptm("label"));
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.valueTemplate || ctx._valueTemplate)("ngIfElse", defaultValueTemplate_r11);
        \u0275\u0275advance(3);
        \u0275\u0275property("ngIf", ctx.checkValue() && !ctx.$disabled() && ctx.showClear);
        \u0275\u0275advance();
        \u0275\u0275classMap(ctx.cx("dropdown"));
        \u0275\u0275property("pBind", ctx.ptm("dropdown"));
        \u0275\u0275attribute("aria-expanded", ctx.overlayVisible ?? false)("aria-label", "treeselect trigger");
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", !ctx.triggerIconTemplate && !ctx._triggerIconTemplate && !ctx.dropdownIconTemplate && !ctx._dropdownIconTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.triggerIconTemplate || ctx._triggerIconTemplate || ctx.dropdownIconTemplate || ctx._dropdownIconTemplate);
        \u0275\u0275advance();
        \u0275\u0275property("hostAttrSelector", ctx.$attrSelector);
        \u0275\u0275twoWayProperty("visible", ctx.overlayVisible);
        \u0275\u0275property("options", ctx.overlayOptions)("target", "@parent")("appendTo", ctx.$appendTo())("unstyled", ctx.unstyled())("pt", ctx.ptm("pcOverlay"))("motionOptions", ctx.motionOptions());
      }
    },
    dependencies: [CommonModule, NgForOf, NgIf, NgTemplateOutlet, NgStyle, Overlay, SharedModule, Tree, AutoFocus, TimesIcon, ChevronDownIcon, Chip, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeSelect, [{
    type: Component,
    args: [{
      selector: "p-treeSelect, p-treeselect, p-tree-select",
      standalone: true,
      imports: [CommonModule, Overlay, SharedModule, Tree, AutoFocus, TimesIcon, ChevronDownIcon, Chip, Bind],
      hostDirectives: [Bind],
      template: `
        <div class="p-hidden-accessible" [pBind]="ptm('hiddenInputContainer')" [attr.data-p-hidden-accessible]="true">
            <input
                #focusInput
                type="text"
                role="combobox"
                [attr.id]="inputId"
                readonly
                [attr.disabled]="$disabled() ? '' : undefined"
                (focus)="onInputFocus($event)"
                (blur)="onInputBlur($event)"
                (keydown)="onKeyDown($event)"
                [attr.tabindex]="!$disabled() ? tabindex : -1"
                [attr.aria-controls]="overlayVisible ? listId : null"
                [attr.aria-haspopup]="'tree'"
                [attr.aria-expanded]="overlayVisible ?? false"
                [attr.aria-labelledby]="ariaLabelledBy"
                [attr.aria-label]="ariaLabel || (label === 'p-emptylabel' ? undefined : label)"
                [pAutoFocus]="autofocus"
                [pBind]="ptm('hiddenInput')"
            />
        </div>
        <div [class]="cx('labelContainer')" [pBind]="ptm('labelContainer')">
            <div [class]="cn(cx('label'), labelStyleClass)" [ngStyle]="labelStyle" [pBind]="ptm('label')">
                <ng-container *ngIf="valueTemplate || _valueTemplate; else defaultValueTemplate">
                    <ng-container *ngTemplateOutlet="valueTemplate || _valueTemplate; context: { $implicit: value, placeholder: placeholder }"></ng-container>
                </ng-container>
                <ng-template #defaultValueTemplate>
                    <ng-container *ngIf="display === 'comma'; else chipsValueTemplate">
                        {{ label || 'empty' }}
                    </ng-container>
                    <ng-template #chipsValueTemplate>
                        <div *ngFor="let node of value" [class]="cx('chipItem')" [pBind]="ptm('chipItem')">
                            <p-chip [unstyled]="unstyled()" [label]="node.label" [class]="cx('pcChip')" [pt]="ptm('pcChip')" />
                        </div>
                        <ng-container *ngIf="emptyValue">{{ placeholder || 'empty' }}</ng-container>
                    </ng-template>
                </ng-template>
            </div>
        </div>
        <ng-container *ngIf="checkValue() && !$disabled() && showClear">
            <svg data-p-icon="times" *ngIf="!clearIconTemplate && !_clearIconTemplate" [class]="cx('clearIcon')" (click)="clear($event)" [pBind]="ptm('clearIcon')" />
            <span *ngIf="clearIconTemplate || clearIconTemplate" [class]="cx('clearIcon')" (click)="clear($event)" [pBind]="ptm('clearIcon')">
                <ng-template *ngTemplateOutlet="clearIconTemplate || _clearIconTemplate"></ng-template>
            </span>
        </ng-container>
        <div [class]="cx('dropdown')" role="button" aria-haspopup="tree" [attr.aria-expanded]="overlayVisible ?? false" [attr.aria-label]="'treeselect trigger'" [pBind]="ptm('dropdown')">
            <svg data-p-icon="chevron-down" *ngIf="!triggerIconTemplate && !_triggerIconTemplate && !dropdownIconTemplate && !_dropdownIconTemplate" [class]="cx('dropdownIcon')" [pBind]="ptm('dropdownIcon')" />
            <span *ngIf="triggerIconTemplate || _triggerIconTemplate || dropdownIconTemplate || _dropdownIconTemplate" [class]="cx('dropdownIcon')" [pBind]="ptm('dropdownIcon')">
                <ng-template *ngTemplateOutlet="triggerIconTemplate || _triggerIconTemplate || dropdownIconTemplate || _dropdownIconTemplate"></ng-template>
            </span>
        </div>
        <p-overlay
            #overlay
            [hostAttrSelector]="$attrSelector"
            [(visible)]="overlayVisible"
            [options]="overlayOptions"
            [target]="'@parent'"
            [appendTo]="$appendTo()"
            [unstyled]="unstyled()"
            [pt]="ptm('pcOverlay')"
            [motionOptions]="motionOptions()"
            (onBeforeEnter)="onOverlayBeforeEnter()"
            (onBeforeHide)="onOverlayBeforeHide()"
            (onShow)="onShow.emit($event)"
            (onHide)="hide($event)"
        >
            <ng-template #content>
                <div #panel [attr.id]="listId" [class]="cn(cx('panel'), panelStyleClass, panelClass)" [ngStyle]="panelStyle" [pBind]="ptm('panel')">
                    <span
                        #firstHiddenFocusableEl
                        role="presentation"
                        class="p-hidden-accessible p-hidden-focusable"
                        [attr.tabindex]="0"
                        (focus)="onFirstHiddenFocus($event)"
                        [attr.data-p-hidden-accessible]="true"
                        [attr.data-p-hidden-focusable]="true"
                        [pBind]="ptm('hiddenFirstFocusableEl')"
                    >
                    </span>
                    <ng-container *ngTemplateOutlet="headerTemplate || _headerTemplate; context: { $implicit: value, options: options }"></ng-container>
                    <div [class]="cx('treeContainer')" [ngStyle]="{ 'max-height': scrollHeight }" [pBind]="ptm('treeContainer')">
                        <p-tree
                            #tree
                            [value]="options"
                            [propagateSelectionDown]="propagateSelectionDown"
                            [propagateSelectionUp]="propagateSelectionUp"
                            [selectionMode]="selectionMode"
                            (selectionChange)="onSelectionChange($event)"
                            [selection]="value"
                            [metaKeySelection]="metaKeySelection"
                            (onNodeExpand)="nodeExpand($event)"
                            (onNodeCollapse)="nodeCollapse($event)"
                            (onNodeSelect)="onSelect($event)"
                            [emptyMessage]="emptyMessage"
                            (onNodeUnselect)="onUnselect($event)"
                            [filter]="filter"
                            [filterBy]="filterBy"
                            [filterMode]="filterMode"
                            [filterPlaceholder]="filterPlaceholder"
                            [filterLocale]="filterLocale"
                            [filteredNodes]="filteredNodes"
                            [virtualScroll]="virtualScroll"
                            [virtualScrollItemSize]="virtualScrollItemSize"
                            [virtualScrollOptions]="virtualScrollOptions"
                            [_templateMap]="templateMap"
                            [loading]="loading"
                            [filterInputAutoFocus]="filterInputAutoFocus"
                            [loadingMode]="loadingMode"
                            [pt]="ptm('pcTree')"
                            [unstyled]="unstyled()"
                        >
                            <ng-container *ngIf="emptyTemplate || _emptyTemplate">
                                <ng-template #empty>
                                    <ng-container *ngTemplateOutlet="emptyTemplate || _emptyTemplate"></ng-container>
                                </ng-template>
                            </ng-container>
                            <ng-template #togglericon let-expanded *ngIf="itemTogglerIconTemplate || _itemTogglerIconTemplate">
                                <ng-container *ngTemplateOutlet="itemTogglerIconTemplate || _itemTogglerIconTemplate; context: { $implicit: expanded }"></ng-container>
                            </ng-template>
                            <ng-template #checkboxicon let-selected let-partialSelected="partialSelected" *ngIf="itemCheckboxIconTemplate || _itemCheckboxIconTemplate">
                                <ng-container *ngTemplateOutlet="itemCheckboxIconTemplate || _itemCheckboxIconTemplate; context: { $implicit: selected, partialSelected: partialSelected }"></ng-container>
                            </ng-template>
                            <ng-template #loadingicon *ngIf="itemLoadingIconTemplate || _itemLoadingIconTemplate">
                                <ng-container *ngTemplateOutlet="itemLoadingIconTemplate || _itemLoadingIconTemplate"></ng-container>
                            </ng-template>
                        </p-tree>
                    </div>
                    <ng-container *ngTemplateOutlet="footerTemplate; context: { $implicit: value, options: options }"></ng-container>
                    <span
                        #lastHiddenFocusableEl
                        role="presentation"
                        class="p-hidden-accessible p-hidden-focusable"
                        [attr.tabindex]="0"
                        (focus)="onLastHiddenFocus($event)"
                        [attr.data-p-hidden-accessible]="true"
                        [attr.data-p-hidden-focusable]="true"
                        [pBind]="ptm('hiddenLastFocusableEl')"
                    ></span>
                </div>
            </ng-template>
        </p-overlay>
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [TREESELECT_VALUE_ACCESSOR, TreeSelectStyle, {
        provide: TREESELECT_INSTANCE,
        useExisting: TreeSelect
      }, {
        provide: PARENT_INSTANCE,
        useExisting: TreeSelect
      }],
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cn(cx('root'), containerStyleClass)",
        "[style]": "sx('root')"
      }
    }]
  }], null, {
    inputId: [{
      type: Input
    }],
    scrollHeight: [{
      type: Input
    }],
    metaKeySelection: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    display: [{
      type: Input
    }],
    selectionMode: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    panelClass: [{
      type: Input
    }],
    panelStyle: [{
      type: Input
    }],
    panelStyleClass: [{
      type: Input
    }],
    containerStyle: [{
      type: Input
    }],
    containerStyleClass: [{
      type: Input
    }],
    labelStyle: [{
      type: Input
    }],
    labelStyleClass: [{
      type: Input
    }],
    overlayOptions: [{
      type: Input
    }],
    emptyMessage: [{
      type: Input
    }],
    filter: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    filterBy: [{
      type: Input
    }],
    filterMode: [{
      type: Input
    }],
    filterPlaceholder: [{
      type: Input
    }],
    filterLocale: [{
      type: Input
    }],
    filterInputAutoFocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    propagateSelectionDown: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    propagateSelectionUp: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showClear: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    resetFilterOnHide: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    virtualScroll: [{
      type: Input
    }],
    virtualScrollItemSize: [{
      type: Input
    }],
    virtualScrollOptions: [{
      type: Input
    }],
    autofocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    options: [{
      type: Input
    }],
    loading: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    loadingMode: [{
      type: Input
    }],
    size: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "size",
        required: false
      }]
    }],
    variant: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "variant",
        required: false
      }]
    }],
    fluid: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "fluid",
        required: false
      }]
    }],
    appendTo: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "appendTo",
        required: false
      }]
    }],
    motionOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "motionOptions",
        required: false
      }]
    }],
    onNodeExpand: [{
      type: Output
    }],
    onNodeCollapse: [{
      type: Output
    }],
    onShow: [{
      type: Output
    }],
    onHide: [{
      type: Output
    }],
    onClear: [{
      type: Output
    }],
    onFilter: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    onBlur: [{
      type: Output
    }],
    onNodeUnselect: [{
      type: Output
    }],
    onNodeSelect: [{
      type: Output
    }],
    focusInput: [{
      type: ViewChild,
      args: ["focusInput"]
    }],
    filterViewChild: [{
      type: ViewChild,
      args: ["filter"]
    }],
    treeViewChild: [{
      type: ViewChild,
      args: ["tree"]
    }],
    panelEl: [{
      type: ViewChild,
      args: ["panel"]
    }],
    overlayViewChild: [{
      type: ViewChild,
      args: ["overlay"]
    }],
    firstHiddenFocusableElementOnOverlay: [{
      type: ViewChild,
      args: ["firstHiddenFocusableEl"]
    }],
    lastHiddenFocusableElementOnOverlay: [{
      type: ViewChild,
      args: ["lastHiddenFocusableEl"]
    }],
    valueTemplate: [{
      type: ContentChild,
      args: ["value", {
        descendants: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: ["header", {
        descendants: false
      }]
    }],
    emptyTemplate: [{
      type: ContentChild,
      args: ["empty", {
        descendants: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: ["footer", {
        descendants: false
      }]
    }],
    clearIconTemplate: [{
      type: ContentChild,
      args: ["clearicon", {
        descendants: false
      }]
    }],
    triggerIconTemplate: [{
      type: ContentChild,
      args: ["triggericon", {
        descendants: false
      }]
    }],
    dropdownIconTemplate: [{
      type: ContentChild,
      args: ["dropdownicon", {
        descendants: false
      }]
    }],
    filterIconTemplate: [{
      type: ContentChild,
      args: ["filtericon", {
        descendants: false
      }]
    }],
    closeIconTemplate: [{
      type: ContentChild,
      args: ["closeicon", {
        descendants: false
      }]
    }],
    itemTogglerIconTemplate: [{
      type: ContentChild,
      args: ["itemtogglericon", {
        descendants: false
      }]
    }],
    itemCheckboxIconTemplate: [{
      type: ContentChild,
      args: ["itemcheckboxicon", {
        descendants: false
      }]
    }],
    itemLoadingIconTemplate: [{
      type: ContentChild,
      args: ["itemloadingicon", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }],
    onHostClick: [{
      type: HostListener,
      args: ["mousedown", ["$event"]]
    }]
  });
})();
var TreeSelectModule = class _TreeSelectModule {
  static \u0275fac = function TreeSelectModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeSelectModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _TreeSelectModule,
    imports: [TreeSelect, SharedModule],
    exports: [TreeSelect, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [TreeSelect, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeSelectModule, [{
    type: NgModule,
    args: [{
      imports: [TreeSelect, SharedModule],
      exports: [TreeSelect, SharedModule]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/scrollpanel/index.mjs
var style16 = "\n    .p-scrollpanel-content-container {\n        overflow: hidden;\n        width: 100%;\n        height: 100%;\n        position: relative;\n        z-index: 1;\n        float: left;\n    }\n\n    .p-scrollpanel-content {\n        height: calc(100% + calc(2 * dt('scrollpanel.bar.size')));\n        width: calc(100% + calc(2 * dt('scrollpanel.bar.size')));\n        padding-inline: 0 calc(2 * dt('scrollpanel.bar.size'));\n        padding-block: 0 calc(2 * dt('scrollpanel.bar.size'));\n        position: relative;\n        overflow: auto;\n        box-sizing: border-box;\n        scrollbar-width: none;\n    }\n\n    .p-scrollpanel-content::-webkit-scrollbar {\n        display: none;\n    }\n\n    .p-scrollpanel-bar {\n        position: relative;\n        border-radius: dt('scrollpanel.bar.border.radius');\n        z-index: 2;\n        cursor: pointer;\n        opacity: 0;\n        outline-color: transparent;\n        background: dt('scrollpanel.bar.background');\n        border: 0 none;\n        transition:\n            outline-color dt('scrollpanel.transition.duration'),\n            opacity dt('scrollpanel.transition.duration');\n    }\n\n    .p-scrollpanel-bar:focus-visible {\n        box-shadow: dt('scrollpanel.bar.focus.ring.shadow');\n        outline: dt('scrollpanel.barfocus.ring.width') dt('scrollpanel.bar.focus.ring.style') dt('scrollpanel.bar.focus.ring.color');\n        outline-offset: dt('scrollpanel.barfocus.ring.offset');\n    }\n\n    .p-scrollpanel-bar-y {\n        width: dt('scrollpanel.bar.size');\n        inset-block-start: 0;\n    }\n\n    .p-scrollpanel-bar-x {\n        height: dt('scrollpanel.bar.size');\n        inset-block-end: 0;\n    }\n\n    .p-scrollpanel-hidden {\n        visibility: hidden;\n    }\n\n    .p-scrollpanel:hover .p-scrollpanel-bar,\n    .p-scrollpanel:active .p-scrollpanel-bar {\n        opacity: 1;\n    }\n\n    .p-scrollpanel-grabbed {\n        user-select: none;\n    }\n";

// node_modules/primeng/fesm2022/primeng-scrollpanel.mjs
var _c018 = ["content"];
var _c115 = ["xBar"];
var _c210 = ["yBar"];
var _c39 = ["*"];
function ScrollPanel_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
function ScrollPanel_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
var style17 = (
  /*css*/
  `
    ${style16}

    .p-scrollpanel {
        display: block;
    }
`
);
var classes12 = {
  root: "p-scrollpanel p-component",
  contentContainer: "p-scrollpanel-content-container",
  content: "p-scrollpanel-content",
  barX: "p-scrollpanel-bar p-scrollpanel-bar-x",
  barY: "p-scrollpanel-bar p-scrollpanel-bar-y"
};
var ScrollPanelStyle = class _ScrollPanelStyle extends BaseStyle {
  name = "scrollpanel";
  style = style17;
  classes = classes12;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275ScrollPanelStyle_BaseFactory;
    return function ScrollPanelStyle_Factory(__ngFactoryType__) {
      return (\u0275ScrollPanelStyle_BaseFactory || (\u0275ScrollPanelStyle_BaseFactory = \u0275\u0275getInheritedFactory(_ScrollPanelStyle)))(__ngFactoryType__ || _ScrollPanelStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ScrollPanelStyle,
    factory: _ScrollPanelStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollPanelStyle, [{
    type: Injectable
  }], null, null);
})();
var ScrollPanelClasses;
(function(ScrollPanelClasses2) {
  ScrollPanelClasses2["root"] = "p-scrollpanel";
  ScrollPanelClasses2["contentContainer"] = "p-scrollpanel-content-container";
  ScrollPanelClasses2["content"] = "p-scrollpanel-content";
  ScrollPanelClasses2["barX"] = "p-scrollpanel-bar-x";
  ScrollPanelClasses2["barY"] = "p-scrollpanel-bar-y";
})(ScrollPanelClasses || (ScrollPanelClasses = {}));
var SCROLLPANEL_INSTANCE = new InjectionToken("SCROLLPANEL_INSTANCE");
var ScrollPanel = class _ScrollPanel extends BaseComponent {
  $pcScrollPanel = inject(SCROLLPANEL_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * Style class of the component.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Step factor to scroll the content while pressing the arrow keys.
   * @group Props
   */
  step = 5;
  contentViewChild;
  xBarViewChild;
  yBarViewChild;
  /**
   * Custom content template.
   * @group Templates
   */
  contentTemplate;
  templates;
  _contentTemplate;
  scrollYRatio;
  scrollXRatio;
  timeoutFrame = (fn) => setTimeout(fn, 0);
  initialized = false;
  lastPageY;
  lastPageX;
  isXBarClicked = false;
  isYBarClicked = false;
  lastScrollLeft = 0;
  lastScrollTop = 0;
  orientation = "vertical";
  timer;
  contentId;
  windowResizeListener;
  contentScrollListener;
  mouseEnterListener;
  xBarMouseDownListener;
  yBarMouseDownListener;
  documentMouseMoveListener;
  documentMouseUpListener;
  _componentStyle = inject(ScrollPanelStyle);
  zone = inject(NgZone);
  onInit() {
    this.contentId = s2("pn_id_") + "_content";
  }
  onAfterViewInit() {
    if (isPlatformBrowser(this.platformId)) {
      this.zone.runOutsideAngular(() => {
        this.moveBar();
        this.moveBar = this.moveBar.bind(this);
        this.onXBarMouseDown = this.onXBarMouseDown.bind(this);
        this.onYBarMouseDown = this.onYBarMouseDown.bind(this);
        this.onDocumentMouseMove = this.onDocumentMouseMove.bind(this);
        this.onDocumentMouseUp = this.onDocumentMouseUp.bind(this);
        this.windowResizeListener = this.renderer.listen(window, "resize", this.moveBar);
        this.contentScrollListener = this.renderer.listen(this.contentViewChild.nativeElement, "scroll", this.moveBar);
        this.mouseEnterListener = this.renderer.listen(this.contentViewChild.nativeElement, "mouseenter", this.moveBar);
        this.xBarMouseDownListener = this.renderer.listen(this.xBarViewChild.nativeElement, "mousedown", this.onXBarMouseDown);
        this.yBarMouseDownListener = this.renderer.listen(this.yBarViewChild.nativeElement, "mousedown", this.onYBarMouseDown);
        this.calculateContainerHeight();
        this.initialized = true;
      });
    }
  }
  onAfterContentInit() {
    this.templates.forEach((item) => {
      switch (item.getType()) {
        case "content":
          this._contentTemplate = item.template;
          break;
        default:
          this._contentTemplate = item.template;
          break;
      }
    });
  }
  calculateContainerHeight() {
    let container = this.el.nativeElement;
    let content = this.contentViewChild.nativeElement;
    let xBar = this.xBarViewChild.nativeElement;
    const window2 = this.document.defaultView;
    let containerStyles = window2.getComputedStyle(container), xBarStyles = window2.getComputedStyle(xBar), pureContainerHeight = Tt(container) - parseInt(xBarStyles["height"], 10);
    if (containerStyles["max-height"] != "none" && pureContainerHeight == 0) {
      if (content.offsetHeight + parseInt(xBarStyles["height"], 10) > parseInt(containerStyles["max-height"], 10)) {
        container.style.height = containerStyles["max-height"];
      } else {
        container.style.height = content.offsetHeight + parseFloat(containerStyles.paddingTop) + parseFloat(containerStyles.paddingBottom) + parseFloat(containerStyles.borderTopWidth) + parseFloat(containerStyles.borderBottomWidth) + "px";
      }
    }
  }
  moveBar() {
    let container = this.el.nativeElement;
    let content = this.contentViewChild.nativeElement;
    let xBar = this.xBarViewChild.nativeElement;
    let totalWidth = content.scrollWidth;
    let ownWidth = content.clientWidth;
    let bottom = (container.clientHeight - xBar.clientHeight) * -1;
    this.scrollXRatio = ownWidth / totalWidth;
    let yBar = this.yBarViewChild.nativeElement;
    let totalHeight = content.scrollHeight;
    let ownHeight = content.clientHeight;
    let right = (container.clientWidth - yBar.clientWidth) * -1;
    this.scrollYRatio = ownHeight / totalHeight;
    this.requestAnimationFrame(() => {
      if (this.scrollXRatio >= 1) {
        xBar.setAttribute("data-p-scrollpanel-hidden", "true");
        !this.$unstyled() && W(xBar, "p-scrollpanel-hidden");
      } else {
        xBar.setAttribute("data-p-scrollpanel-hidden", "false");
        !this.$unstyled() && P(xBar, "p-scrollpanel-hidden");
        const xBarWidth = Math.max(this.scrollXRatio * 100, 10);
        const xBarLeft = Math.abs(content.scrollLeft * (100 - xBarWidth) / (totalWidth - ownWidth));
        xBar.style.cssText = "width:" + xBarWidth + "%; inset-inline-start:" + xBarLeft + "%;bottom:" + bottom + "px;";
      }
      if (this.scrollYRatio >= 1) {
        yBar.setAttribute("data-p-scrollpanel-hidden", "true");
        !this.$unstyled() && W(yBar, "p-scrollpanel-hidden");
      } else {
        yBar.setAttribute("data-p-scrollpanel-hidden", "false");
        !this.$unstyled() && P(yBar, "p-scrollpanel-hidden");
        const yBarHeight = Math.max(this.scrollYRatio * 100, 10);
        const yBarTop = content.scrollTop * (100 - yBarHeight) / (totalHeight - ownHeight);
        yBar.style.cssText = "height:" + yBarHeight + "%; top: calc(" + yBarTop + "% - " + xBar.clientHeight + "px); inset-inline-end:" + right + "px;";
      }
    });
    this.cd.markForCheck();
  }
  onScroll(event) {
    if (this.lastScrollLeft !== event.target.scrollLeft) {
      this.lastScrollLeft = event.target.scrollLeft;
      this.orientation = "horizontal";
    } else if (this.lastScrollTop !== event.target.scrollTop) {
      this.lastScrollTop = event.target.scrollTop;
      this.orientation = "vertical";
    }
    this.moveBar();
  }
  onKeyDown(event) {
    if (this.orientation === "vertical") {
      switch (event.code) {
        case "ArrowDown": {
          this.setTimer("scrollTop", this.step);
          event.preventDefault();
          break;
        }
        case "ArrowUp": {
          this.setTimer("scrollTop", this.step * -1);
          event.preventDefault();
          break;
        }
        case "ArrowLeft":
        case "ArrowRight": {
          event.preventDefault();
          break;
        }
        default:
          break;
      }
    } else if (this.orientation === "horizontal") {
      switch (event.code) {
        case "ArrowRight": {
          this.setTimer("scrollLeft", this.step);
          event.preventDefault();
          break;
        }
        case "ArrowLeft": {
          this.setTimer("scrollLeft", this.step * -1);
          event.preventDefault();
          break;
        }
        case "ArrowDown":
        case "ArrowUp": {
          event.preventDefault();
          break;
        }
        default:
          break;
      }
    }
  }
  onKeyUp() {
    this.clearTimer();
  }
  repeat(bar, step) {
    this.contentViewChild?.nativeElement && (this.contentViewChild.nativeElement[bar] += step);
    this.moveBar();
  }
  setTimer(bar, step) {
    this.clearTimer();
    this.timer = setTimeout(() => {
      this.repeat(bar, step);
    }, 40);
  }
  clearTimer() {
    if (this.timer) {
      clearTimeout(this.timer);
    }
  }
  bindDocumentMouseListeners() {
    if (!this.documentMouseMoveListener) {
      this.documentMouseMoveListener = (e) => {
        this.onDocumentMouseMove(e);
      };
      this.document.addEventListener("mousemove", this.documentMouseMoveListener);
    }
    if (!this.documentMouseUpListener) {
      this.documentMouseUpListener = (e) => {
        this.onDocumentMouseUp(e);
      };
      this.document.addEventListener("mouseup", this.documentMouseUpListener);
    }
  }
  unbindDocumentMouseListeners() {
    if (this.documentMouseMoveListener) {
      this.document.removeEventListener("mousemove", this.documentMouseMoveListener);
      this.documentMouseMoveListener = null;
    }
    if (this.documentMouseUpListener) {
      document.removeEventListener("mouseup", this.documentMouseUpListener);
      this.documentMouseUpListener = null;
    }
  }
  onYBarMouseDown(e) {
    this.isYBarClicked = true;
    this.yBarViewChild?.nativeElement?.focus();
    this.lastPageY = e.pageY;
    this.yBarViewChild?.nativeElement?.setAttribute("data-p-scrollpanel-grabbed", "true");
    !this.$unstyled() && W(this.yBarViewChild.nativeElement, "p-scrollpanel-grabbed");
    this.document.body.setAttribute("data-p-scrollpanel-grabbed", "true");
    !this.$unstyled() && W(this.document.body, "p-scrollpanel-grabbed");
    this.bindDocumentMouseListeners();
    e.preventDefault();
  }
  onXBarMouseDown(e) {
    this.isXBarClicked = true;
    this.xBarViewChild?.nativeElement?.focus();
    this.lastPageX = e.pageX;
    this.xBarViewChild?.nativeElement?.setAttribute("data-p-scrollpanel-grabbed", "false");
    !this.$unstyled() && W(this.xBarViewChild.nativeElement, "p-scrollpanel-grabbed");
    this.document.body.setAttribute("data-p-scrollpanel-grabbed", "false");
    !this.$unstyled() && W(this.document.body, "p-scrollpanel-grabbed");
    this.bindDocumentMouseListeners();
    e.preventDefault();
  }
  onDocumentMouseMove(e) {
    if (this.isXBarClicked) {
      this.onMouseMoveForXBar(e);
    } else if (this.isYBarClicked) {
      this.onMouseMoveForYBar(e);
    } else {
      this.onMouseMoveForXBar(e);
      this.onMouseMoveForYBar(e);
    }
  }
  onMouseMoveForXBar(e) {
    let deltaX = e.pageX - this.lastPageX;
    this.lastPageX = e.pageX;
    this.requestAnimationFrame(() => {
      this.contentViewChild.nativeElement.scrollLeft += deltaX / this.scrollXRatio;
    });
  }
  onMouseMoveForYBar(e) {
    let deltaY = e.pageY - this.lastPageY;
    this.lastPageY = e.pageY;
    this.requestAnimationFrame(() => {
      this.contentViewChild.nativeElement.scrollTop += deltaY / this.scrollYRatio;
    });
  }
  /**
   * Scrolls the top location to the given value.
   * @param scrollTop
   * @group Method
   */
  scrollTop(scrollTop) {
    let scrollableHeight = this.contentViewChild.nativeElement.scrollHeight - this.contentViewChild.nativeElement.clientHeight;
    scrollTop = scrollTop > scrollableHeight ? scrollableHeight : scrollTop > 0 ? scrollTop : 0;
    this.contentViewChild.nativeElement.scrollTop = scrollTop;
  }
  onFocus(event) {
    if (this.xBarViewChild?.nativeElement?.isSameNode(event.target)) {
      this.orientation = "horizontal";
    } else if (this.yBarViewChild?.nativeElement?.isSameNode(event.target)) {
      this.orientation = "vertical";
    }
  }
  onBlur() {
    if (this.orientation === "horizontal") {
      this.orientation = "vertical";
    }
  }
  onDocumentMouseUp(e) {
    this.yBarViewChild?.nativeElement?.setAttribute("data-p-scrollpanel-grabbed", "false");
    !this.$unstyled() && P(this.yBarViewChild.nativeElement, "p-scrollpanel-grabbed");
    this.xBarViewChild?.nativeElement?.setAttribute("data-p-scrollpanel-grabbed", "false");
    !this.$unstyled() && P(this.xBarViewChild.nativeElement, "p-scrollpanel-grabbed");
    this.document.body.setAttribute("data-p-scrollpanel-grabbed", "false");
    !this.$unstyled() && P(this.document.body, "p-scrollpanel-grabbed");
    this.unbindDocumentMouseListeners();
    this.isXBarClicked = false;
    this.isYBarClicked = false;
  }
  requestAnimationFrame(f) {
    let frame = window.requestAnimationFrame || this.timeoutFrame;
    frame(f);
  }
  unbindListeners() {
    if (this.windowResizeListener) {
      this.windowResizeListener();
      this.windowResizeListener = null;
    }
    if (this.contentScrollListener) {
      this.contentScrollListener();
      this.contentScrollListener = null;
    }
    if (this.mouseEnterListener) {
      this.mouseEnterListener();
      this.mouseEnterListener = null;
    }
    if (this.xBarMouseDownListener) {
      this.xBarMouseDownListener();
      this.xBarMouseDownListener = null;
    }
    if (this.yBarMouseDownListener) {
      this.yBarMouseDownListener();
      this.yBarMouseDownListener = null;
    }
  }
  onDestroy() {
    if (this.initialized) {
      this.unbindListeners();
    }
  }
  /**
   * Refreshes the position and size of the scrollbar.
   * @group Method
   */
  refresh() {
    this.moveBar();
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275ScrollPanel_BaseFactory;
    return function ScrollPanel_Factory(__ngFactoryType__) {
      return (\u0275ScrollPanel_BaseFactory || (\u0275ScrollPanel_BaseFactory = \u0275\u0275getInheritedFactory(_ScrollPanel)))(__ngFactoryType__ || _ScrollPanel);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _ScrollPanel,
    selectors: [["p-scroll-panel"], ["p-scrollPanel"], ["p-scrollpanel"]],
    contentQueries: function ScrollPanel_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c018, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contentTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function ScrollPanel_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c018, 5);
        \u0275\u0275viewQuery(_c115, 5);
        \u0275\u0275viewQuery(_c210, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contentViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.xBarViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.yBarViewChild = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function ScrollPanel_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      styleClass: "styleClass",
      step: [2, "step", "step", numberAttribute]
    },
    features: [\u0275\u0275ProvidersFeature([ScrollPanelStyle, {
      provide: SCROLLPANEL_INSTANCE,
      useExisting: _ScrollPanel
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _ScrollPanel
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    ngContentSelectors: _c39,
    decls: 9,
    vars: 22,
    consts: [["content", ""], ["xBar", ""], ["yBar", ""], [3, "pBind"], [3, "mouseenter", "scroll", "pBind"], [4, "ngTemplateOutlet"], ["tabindex", "0", "role", "scrollbar", 3, "mousedown", "keydown", "keyup", "focus", "blur", "pBind"], ["tabindex", "0", "role", "scrollbar", 3, "mousedown", "keydown", "keyup", "focus", "pBind"]],
    template: function ScrollPanel_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275projectionDef();
        \u0275\u0275elementStart(0, "div", 3)(1, "div", 4, 0);
        \u0275\u0275listener("mouseenter", function ScrollPanel_Template_div_mouseenter_1_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.moveBar());
        })("scroll", function ScrollPanel_Template_div_scroll_1_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onScroll($event));
        });
        \u0275\u0275conditionalCreate(3, ScrollPanel_Conditional_3_Template, 1, 0);
        \u0275\u0275template(4, ScrollPanel_ng_container_4_Template, 1, 0, "ng-container", 5);
        \u0275\u0275elementEnd()();
        \u0275\u0275elementStart(5, "div", 6, 1);
        \u0275\u0275listener("mousedown", function ScrollPanel_Template_div_mousedown_5_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onXBarMouseDown($event));
        })("keydown", function ScrollPanel_Template_div_keydown_5_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onKeyDown($event));
        })("keyup", function ScrollPanel_Template_div_keyup_5_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onKeyUp());
        })("focus", function ScrollPanel_Template_div_focus_5_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onFocus($event));
        })("blur", function ScrollPanel_Template_div_blur_5_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onBlur());
        });
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(7, "div", 7, 2);
        \u0275\u0275listener("mousedown", function ScrollPanel_Template_div_mousedown_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onYBarMouseDown($event));
        })("keydown", function ScrollPanel_Template_div_keydown_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onKeyDown($event));
        })("keyup", function ScrollPanel_Template_div_keyup_7_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onKeyUp());
        })("focus", function ScrollPanel_Template_div_focus_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onFocus($event));
        });
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cx("contentContainer"));
        \u0275\u0275property("pBind", ctx.ptm("contentContainer"));
        \u0275\u0275advance();
        \u0275\u0275classMap(ctx.cx("content"));
        \u0275\u0275property("pBind", ctx.ptm("content"));
        \u0275\u0275advance(2);
        \u0275\u0275conditional(!ctx.contentTemplate && !ctx._contentTemplate ? 3 : -1);
        \u0275\u0275advance();
        \u0275\u0275property("ngTemplateOutlet", ctx.contentTemplate || ctx._contentTemplate);
        \u0275\u0275advance();
        \u0275\u0275classMap(ctx.cx("barX"));
        \u0275\u0275property("pBind", ctx.ptm("barX"));
        \u0275\u0275attribute("aria-orientation", "horizontal")("aria-valuenow", ctx.lastScrollLeft)("aria-controls", ctx.contentId)("data-pc-group-section", "bar");
        \u0275\u0275advance(2);
        \u0275\u0275classMap(ctx.cx("barY"));
        \u0275\u0275property("pBind", ctx.ptm("barY"));
        \u0275\u0275attribute("aria-orientation", "vertical")("aria-valuenow", ctx.lastScrollTop)("aria-controls", ctx.contentId)("data-pc-group-section", "bar");
      }
    },
    dependencies: [CommonModule, NgTemplateOutlet, SharedModule, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollPanel, [{
    type: Component,
    args: [{
      selector: "p-scroll-panel, p-scrollPanel, p-scrollpanel",
      standalone: true,
      imports: [CommonModule, SharedModule, BindModule],
      template: `
        <div [pBind]="ptm('contentContainer')" [class]="cx('contentContainer')">
            <div #content [pBind]="ptm('content')" [class]="cx('content')" (mouseenter)="moveBar()" (scroll)="onScroll($event)">
                @if (!contentTemplate && !_contentTemplate) {
                    <ng-content></ng-content>
                }
                <ng-container *ngTemplateOutlet="contentTemplate || _contentTemplate"></ng-container>
            </div>
        </div>
        <div
            #xBar
            [pBind]="ptm('barX')"
            [class]="cx('barX')"
            tabindex="0"
            role="scrollbar"
            [attr.aria-orientation]="'horizontal'"
            [attr.aria-valuenow]="lastScrollLeft"
            [attr.aria-controls]="contentId"
            [attr.data-pc-group-section]="'bar'"
            (mousedown)="onXBarMouseDown($event)"
            (keydown)="onKeyDown($event)"
            (keyup)="onKeyUp()"
            (focus)="onFocus($event)"
            (blur)="onBlur()"
        ></div>
        <div
            #yBar
            [pBind]="ptm('barY')"
            [class]="cx('barY')"
            tabindex="0"
            role="scrollbar"
            [attr.aria-orientation]="'vertical'"
            [attr.aria-valuenow]="lastScrollTop"
            [attr.aria-controls]="contentId"
            (mousedown)="onYBarMouseDown($event)"
            (keydown)="onKeyDown($event)"
            (keyup)="onKeyUp()"
            (focus)="onFocus($event)"
            [attr.data-pc-group-section]="'bar'"
        ></div>
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [ScrollPanelStyle, {
        provide: SCROLLPANEL_INSTANCE,
        useExisting: ScrollPanel
      }, {
        provide: PARENT_INSTANCE,
        useExisting: ScrollPanel
      }],
      host: {
        "[class]": 'cn(cx("root"), styleClass)'
      },
      hostDirectives: [Bind]
    }]
  }], null, {
    styleClass: [{
      type: Input
    }],
    step: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    contentViewChild: [{
      type: ViewChild,
      args: ["content"]
    }],
    xBarViewChild: [{
      type: ViewChild,
      args: ["xBar"]
    }],
    yBarViewChild: [{
      type: ViewChild,
      args: ["yBar"]
    }],
    contentTemplate: [{
      type: ContentChild,
      args: ["content", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }]
  });
})();
var ScrollPanelModule = class _ScrollPanelModule {
  static \u0275fac = function ScrollPanelModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollPanelModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ScrollPanelModule,
    imports: [ScrollPanel, SharedModule, BindModule],
    exports: [ScrollPanel, SharedModule, BindModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [ScrollPanel, SharedModule, BindModule, SharedModule, BindModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollPanelModule, [{
    type: NgModule,
    args: [{
      imports: [ScrollPanel, SharedModule, BindModule],
      exports: [ScrollPanel, SharedModule, BindModule]
    }]
  }], null, null);
})();

// src/app/shared/components/icon-selector/icon-selector.component.ts
function IconSelectorComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "span", 15);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275attribute("aria-label", "Selected icon: " + ctx_r0.value());
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r0.value(), " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.value());
  }
}
function IconSelectorComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 2);
    \u0275\u0275text(1, "No icon selected");
    \u0275\u0275elementEnd();
  }
}
function IconSelectorComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-button", 16);
    \u0275\u0275listener("onClick", function IconSelectorComponent_Conditional_5_Template_p_button_onClick_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.clearSelection());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("outlined", true);
    \u0275\u0275attribute("aria-label", "Clear selected icon");
  }
}
function IconSelectorComponent_For_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 17);
    \u0275\u0275listener("click", function IconSelectorComponent_For_15_Template_button_click_0_listener() {
      const icon_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.selectIcon(icon_r4));
    });
    \u0275\u0275elementStart(1, "span", 18);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "span", 19);
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const icon_r4 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("selected", icon_r4 === ctx_r0.value());
    \u0275\u0275attribute("aria-label", "Select " + icon_r4 + " icon");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", icon_r4, " ");
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(icon_r4);
  }
}
function IconSelectorComponent_Conditional_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13);
    \u0275\u0275element(1, "span", 20);
    \u0275\u0275elementStart(2, "p");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1('No icons found matching "', ctx_r0.searchTerm(), '"');
  }
}
var MATERIAL_ICONS = [
  // Alert & Warning Icons
  "warning",
  "error",
  "info",
  "check_circle",
  "cancel",
  "help",
  "priority_high",
  "notification_important",
  "report_problem",
  "security",
  // Transportation & Vehicle Icons
  "directions_car",
  "local_shipping",
  "directions_bus",
  "motorcycle",
  "local_taxi",
  "airport_shuttle",
  "fire_truck",
  "emergency",
  // Location & Navigation
  "location_on",
  "gps_fixed",
  "place",
  "map",
  "navigation",
  "my_location",
  "location_off",
  "location_searching",
  // Time & Schedule
  "schedule",
  "access_time",
  "timer",
  "alarm",
  "today",
  "event",
  "history",
  "update",
  // Communication & Notifications
  "notifications",
  "notifications_active",
  "notifications_off",
  "email",
  "message",
  "phone",
  "chat",
  "announcement",
  // Status & Monitoring
  "visibility",
  "visibility_off",
  "monitor",
  "dashboard",
  "analytics",
  "trending_up",
  "trending_down",
  "speed",
  // Actions & Controls
  "play_arrow",
  "pause",
  "stop",
  "refresh",
  "sync",
  "power_settings_new",
  "settings",
  "tune",
  // General Purpose
  "home",
  "business",
  "person",
  "group",
  "folder",
  "description",
  "assignment",
  "bookmark",
  // Technical & System
  "memory",
  "storage",
  "wifi",
  "signal_cellular_alt",
  "battery_alert",
  "battery_full",
  "network_check",
  "router"
];
var IconSelectorComponent = class _IconSelectorComponent {
  // Input properties
  placeholder = input("Select an icon", ...ngDevMode ? [{ debugName: "placeholder" }] : []);
  disabled = input(false, ...ngDevMode ? [{ debugName: "disabled" }] : []);
  // Output events
  iconChange = output();
  // Internal state
  dialogVisible = signal(false, ...ngDevMode ? [{ debugName: "dialogVisible" }] : []);
  searchTerm = signal("", ...ngDevMode ? [{ debugName: "searchTerm" }] : []);
  value = signal(null, ...ngDevMode ? [{ debugName: "value" }] : []);
  // Available icons
  availableIcons = signal(MATERIAL_ICONS, ...ngDevMode ? [{ debugName: "availableIcons" }] : []);
  // Filtered icons based on search
  filteredIcons = computed(() => {
    const search = this.searchTerm().toLowerCase().trim();
    if (!search) {
      return this.availableIcons();
    }
    return this.availableIcons().filter((icon) => icon.toLowerCase().includes(search));
  }, ...ngDevMode ? [{ debugName: "filteredIcons" }] : []);
  // ControlValueAccessor implementation
  onChange = (_value) => {
  };
  onTouched = () => {
  };
  showDialog() {
    if (!this.disabled()) {
      this.dialogVisible.set(true);
      this.searchTerm.set("");
    }
  }
  selectIcon(icon) {
    this.value.set(icon);
    this.onChange(icon);
    this.onTouched();
    this.iconChange.emit(icon);
    this.dialogVisible.set(false);
  }
  clearSelection() {
    this.value.set(null);
    this.onChange(null);
    this.onTouched();
    this.iconChange.emit(null);
  }
  // ControlValueAccessor methods
  writeValue(value) {
    this.value.set(value);
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(_isDisabled) {
  }
  static \u0275fac = function IconSelectorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IconSelectorComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _IconSelectorComponent, selectors: [["app-icon-selector"]], inputs: { placeholder: [1, "placeholder"], disabled: [1, "disabled"] }, outputs: { iconChange: "iconChange" }, features: [\u0275\u0275ProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: _IconSelectorComponent,
      multi: true
    }
  ])], decls: 17, vars: 10, consts: [[1, "flex", "items-center", "gap-2"], [1, "flex", "items-center", "gap-2", "flex-1"], [1, "text-sm", "text-gray-500"], ["label", "Select Icon", "icon", "pi pi-search", "size", "small", 3, "onClick", "outlined"], ["icon", "pi pi-times", "severity", "secondary", "size", "small", 3, "outlined"], ["header", "Select Icon", "styleClass", "icon-selector-dialog", 3, "visibleChange", "visible", "modal", "dismissableMask"], [1, "flex", "flex-col", "h-full"], [1, "my-4"], ["pInputText", "", "placeholder", "Search icons...", 1, "w-full", 3, "ngModelChange", "ngModel"], [1, "pi", "pi-search"], ["styleClass", "icon-grid-scroll"], [1, "grid", "grid-cols-6", "sm:grid-cols-8", "md:grid-cols-10", "gap-3", "p-2"], ["type", "button", 1, "flex", "flex-col", "items-center", "p-3", "border", "rounded", "cursor-pointer", "hover:bg-primary", "transition-colors", "icon-item", "focus:outline-none", "focus:ring-2", "focus:ring-primary", 3, "selected"], [1, "text-center", "p-8", "text-gray-500", "search-no-results"], [1, "material-icons-outlined", "text-2xl"], [1, "text-sm", "text-gray-600"], ["icon", "pi pi-times", "severity", "secondary", "size", "small", 3, "onClick", "outlined"], ["type", "button", 1, "flex", "flex-col", "items-center", "p-3", "border", "rounded", "cursor-pointer", "hover:bg-primary", "transition-colors", "icon-item", "focus:outline-none", "focus:ring-2", "focus:ring-primary", 3, "click"], [1, "material-icons-outlined", "text-2xl", "mb-1"], [1, "text-xs", "text-center", "break-all"], [1, "pi", "pi-search", "text-4xl", "mb-4", "block"]], template: function IconSelectorComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
      \u0275\u0275conditionalCreate(2, IconSelectorComponent_Conditional_2_Template, 4, 3)(3, IconSelectorComponent_Conditional_3_Template, 2, 0, "span", 2);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "p-button", 3);
      \u0275\u0275listener("onClick", function IconSelectorComponent_Template_p_button_onClick_4_listener() {
        return ctx.showDialog();
      });
      \u0275\u0275elementEnd();
      \u0275\u0275conditionalCreate(5, IconSelectorComponent_Conditional_5_Template, 1, 2, "p-button", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "p-dialog", 5);
      \u0275\u0275twoWayListener("visibleChange", function IconSelectorComponent_Template_p_dialog_visibleChange_6_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.dialogVisible, $event) || (ctx.dialogVisible = $event);
        return $event;
      });
      \u0275\u0275elementStart(7, "div", 6)(8, "div", 7)(9, "p-iconfield")(10, "input", 8);
      \u0275\u0275listener("ngModelChange", function IconSelectorComponent_Template_input_ngModelChange_10_listener($event) {
        return ctx.searchTerm.set($event);
      });
      \u0275\u0275elementEnd();
      \u0275\u0275element(11, "p-inputicon", 9);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(12, "p-scrollPanel", 10)(13, "div", 11);
      \u0275\u0275repeaterCreate(14, IconSelectorComponent_For_15_Template, 5, 5, "button", 12, \u0275\u0275repeaterTrackByIdentity);
      \u0275\u0275elementEnd();
      \u0275\u0275conditionalCreate(16, IconSelectorComponent_Conditional_16_Template, 4, 1, "div", 13);
      \u0275\u0275elementEnd()()();
    }
    if (rf & 2) {
      \u0275\u0275advance(2);
      \u0275\u0275conditional(ctx.value() ? 2 : 3);
      \u0275\u0275advance(2);
      \u0275\u0275property("outlined", true);
      \u0275\u0275attribute("aria-label", "Open icon selector dialog");
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.value() ? 5 : -1);
      \u0275\u0275advance();
      \u0275\u0275twoWayProperty("visible", ctx.dialogVisible);
      \u0275\u0275property("modal", true)("dismissableMask", true);
      \u0275\u0275advance(4);
      \u0275\u0275property("ngModel", ctx.searchTerm());
      \u0275\u0275attribute("aria-label", "Search for icons");
      \u0275\u0275advance(4);
      \u0275\u0275repeater(ctx.filteredIcons());
      \u0275\u0275advance(2);
      \u0275\u0275conditional(ctx.filteredIcons().length === 0 ? 16 : -1);
    }
  }, dependencies: [
    CommonModule,
    FormsModule,
    DefaultValueAccessor,
    NgControlStatus,
    NgModel,
    ButtonModule,
    Button,
    DialogModule,
    Dialog,
    InputTextModule,
    InputText,
    ScrollPanelModule,
    ScrollPanel,
    IconField,
    InputIcon
  ], styles: ['\n\n[_nghost-%COMP%] {\n  display: block;\n}\n.material-icons-outlined[_ngcontent-%COMP%] {\n  font-variation-settings:\n    "FILL" 0,\n    "wght" 400,\n    "GRAD" 0,\n    "opsz" 24;\n}\n.icon-item[_ngcontent-%COMP%] {\n  transition: all 0.2s ease-in-out;\n}\n.icon-item[_ngcontent-%COMP%]:not(.selected):hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n  color: var(--color-primary-contrast);\n}\n.icon-item.selected[_ngcontent-%COMP%] {\n  border-color: var(--color-primary-contrast);\n  background-color: var(--color-primary-color);\n  color: var(--color-primary-contrast);\n}\n.search-no-results[_ngcontent-%COMP%] {\n  opacity: 0.7;\n}\n[_nghost-%COMP%]     .icon-selector-dialog {\n  width: 60vw;\n  height: 80vh;\n}\n[_nghost-%COMP%]     .icon-grid-scroll {\n  width: 100%;\n}\n/*# sourceMappingURL=icon-selector.component.css.map */'] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconSelectorComponent, [{
    type: Component,
    args: [{ selector: "app-icon-selector", imports: [
      CommonModule,
      FormsModule,
      ButtonModule,
      DialogModule,
      InputTextModule,
      ScrollPanelModule,
      IconField,
      InputIcon
    ], providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: IconSelectorComponent,
        multi: true
      }
    ], template: `<div class="flex items-center gap-2">
  <!-- Selected Icon Display -->
  <div class="flex items-center gap-2 flex-1">
    @if (value()) {
      <span
        class="material-icons-outlined text-2xl"
        [attr.aria-label]="'Selected icon: ' + value()"
      >
        {{ value() }}
      </span>
      <span class="text-sm text-gray-600">{{ value() }}</span>
    } @else {
      <span class="text-sm text-gray-500">No icon selected</span>
    }
  </div>

  <!-- Select Button -->
  <p-button
    label="Select Icon"
    icon="pi pi-search"
    [outlined]="true"
    size="small"
    (onClick)="showDialog()"
    [attr.aria-label]="'Open icon selector dialog'"
  />

  <!-- Clear Button -->
  @if (value()) {
    <p-button
      icon="pi pi-times"
      severity="secondary"
      [outlined]="true"
      size="small"
      (onClick)="clearSelection()"
      [attr.aria-label]="'Clear selected icon'"
    />
  }
</div>

<!-- Icon Selection Dialog -->
<p-dialog
  [(visible)]="dialogVisible"
  header="Select Icon"
  [modal]="true"
  styleClass="icon-selector-dialog"
  [dismissableMask]="true"
>
  <div class="flex flex-col h-full">
    <!-- Search Input -->
    <div class="my-4">
      <p-iconfield>
        <input
          pInputText
          [ngModel]="searchTerm()"
          (ngModelChange)="searchTerm.set($event)"
          placeholder="Search icons..."
          class="w-full"
          [attr.aria-label]="'Search for icons'"
        />
        <p-inputicon class="pi pi-search" />
      </p-iconfield>
    </div>

    <!-- Icons Grid -->
    <p-scrollPanel styleClass="icon-grid-scroll">
      <div class="grid grid-cols-6 sm:grid-cols-8 md:grid-cols-10 gap-3 p-2">
        @for (icon of filteredIcons(); track icon) {
          <button
            type="button"
            class="flex flex-col items-center p-3 border rounded cursor-pointer hover:bg-primary transition-colors icon-item focus:outline-none focus:ring-2 focus:ring-primary"
            [class.selected]="icon === value()"
            (click)="selectIcon(icon)"
            [attr.aria-label]="'Select ' + icon + ' icon'"
          >
            <span class="material-icons-outlined text-2xl mb-1">
              {{ icon }}
            </span>
            <span class="text-xs text-center break-all">{{ icon }}</span>
          </button>
        }
      </div>

      @if (filteredIcons().length === 0) {
        <div class="text-center p-8 text-gray-500 search-no-results">
          <span class="pi pi-search text-4xl mb-4 block"></span>
          <p>No icons found matching "{{ searchTerm() }}"</p>
        </div>
      }
    </p-scrollPanel>
  </div>
</p-dialog>
`, styles: ['/* src/app/shared/components/icon-selector/icon-selector.component.scss */\n:host {\n  display: block;\n}\n.material-icons-outlined {\n  font-variation-settings:\n    "FILL" 0,\n    "wght" 400,\n    "GRAD" 0,\n    "opsz" 24;\n}\n.icon-item {\n  transition: all 0.2s ease-in-out;\n}\n.icon-item:not(.selected):hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n  color: var(--color-primary-contrast);\n}\n.icon-item.selected {\n  border-color: var(--color-primary-contrast);\n  background-color: var(--color-primary-color);\n  color: var(--color-primary-contrast);\n}\n.search-no-results {\n  opacity: 0.7;\n}\n:host ::ng-deep .icon-selector-dialog {\n  width: 60vw;\n  height: 80vh;\n}\n:host ::ng-deep .icon-grid-scroll {\n  width: 100%;\n}\n/*# sourceMappingURL=icon-selector.component.css.map */\n'] }]
  }], null, { placeholder: [{ type: Input, args: [{ isSignal: true, alias: "placeholder", required: false }] }], disabled: [{ type: Input, args: [{ isSignal: true, alias: "disabled", required: false }] }], iconChange: [{ type: Output, args: ["iconChange"] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(IconSelectorComponent, { className: "IconSelectorComponent", filePath: "src/app/shared/components/icon-selector/icon-selector.component.ts", lineNumber: 133 });
})();

// src/app/shared/pipes/highlight.pipe.ts
var HighlightPipe = class _HighlightPipe {
  sanitizer = inject(DomSanitizer);
  transform(value, search) {
    if (!search || !value) {
      return value;
    }
    const escapedValue = this.escapeHtml(value);
    const escapedSearch = search.replaceAll(/[.*+?^${}()|[\]\\]/g, String.raw`\$&`);
    const re = new RegExp(`(${escapedSearch})`, "gi");
    const highlighted = escapedValue.replace(re, (match) => `<mark class="highlight-match">${match}</mark>`);
    const sanitized = this.sanitizer.sanitize(SecurityContext.HTML, highlighted);
    return sanitized ?? value;
  }
  escapeHtml(text) {
    const map2 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    return text.replaceAll(/[&<>"']/g, (m2) => map2[m2]);
  }
  static \u0275fac = function HighlightPipe_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HighlightPipe)();
  };
  static \u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "highlight", type: _HighlightPipe, pure: true });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighlightPipe, [{
    type: Pipe,
    args: [{
      name: "highlight"
    }]
  }], null, null);
})();

// src/app/shared/services/asset-grouping.service.ts
var AssetGroupingService = class _AssetGroupingService {
  clientDataService = inject(ClientDataService);
  entitiesService = inject(EntitiesService);
  authDataService = inject(AuthDataService);
  utilityService = inject(UtilityService);
  cacheService = inject(RequestCacheService);
  cache = {};
  globalClientId = this.clientDataService.getSelectedClient()?.id;
  buildFilterQuery(filter2) {
    return isDefined(filter2) ? `&name=*${this.utilityService.escapeRqlValue(filter2)}*` : "";
  }
  /**
   * Generic method to fetch and cache entities
   * @param entityType Type of entity to fetch ('costCentres', 'assetGroups', etc.)
   * @param clientId Client ID (owner ID)
   * @param fetchFn Function that returns a Promise with the API response
   * @param filter Optional filter string
   * @returns Promise of AssetGroupingItems
   */
  async getEntities(entityType, clientId, fetchFn, filter2) {
    const ownerId = clientId ?? this.globalClientId ?? "";
    const cacheKey = `${ownerId}/${entityType}`;
    const cachedItems = this.cache[cacheKey];
    if (isDefined(cachedItems)) {
      return cachedItems.items.map((x) => __spreadValues({}, x));
    }
    const result = await fetchFn(ownerId, filter2);
    result.items.sort((a, b2) => (a.name ?? "").localeCompare(b2.name ?? ""));
    this.cache[cacheKey] = {
      items: _AssetGroupingService.toAssetGroupingItems(result.items),
      count: result.count,
      limit: result.limit
    };
    if (isDefined(filter2) && entityType !== "costCentres" && entityType !== "assetGroups" && entityType !== "zoneGroups" && entityType !== "assetCategories") {
      return this.cache[cacheKey].items.filter((item) => item.name.toLowerCase().includes(filter2.toLowerCase()) === true);
    }
    return this.cache[cacheKey].items.map((x_1) => __spreadValues({}, x_1));
  }
  /**
   * Generic method to get entities as a tree
   * @param clientId Client ID
   * @param getItemsFn Function to get flat items
   * @param filter Optional filter string
   * @returns Promise of tree structure
   */
  async getEntitiesAsTree(clientId, getItemsFn, filter2) {
    const result = await getItemsFn(clientId, filter2);
    return _AssetGroupingService.toTree(result);
  }
  /**
   * Generic tree traversal utility that can be used for different tree operations
   * @param tree The tree structure to traverse
   * @param visitor Visitor function for each node
   * @returns Whether traversal was stopped early
   */
  traverseTree(tree, visitor) {
    const results = [];
    const recurse = (nodes) => {
      for (const node of nodes) {
        const visit = visitor(node);
        if (visit.collect !== void 0) {
          results.push(visit.collect);
        }
        if (isDefined(visit.stop)) {
          return true;
        }
        if (isDefined(node.children) && node.children.length > 0) {
          const shouldStop = recurse(node.children);
          if (shouldStop) {
            return true;
          }
        }
      }
      return false;
    };
    recurse(tree);
    return results;
  }
  static toTree(items) {
    const itemMap = /* @__PURE__ */ new Map();
    for (const item of items) {
      itemMap.set(item.id, __spreadProps(__spreadValues({}, item), {
        name: item.name,
        label: item.name,
        children: []
      }));
    }
    const rootItems = [];
    for (const item of items) {
      const treeItem = itemMap.get(item.id);
      if (isDefined(item.parent) && item.parent !== DEFAULT_SYSTEM_ID && itemMap.has(item.parent)) {
        const parentItem = itemMap.get(item.parent);
        if (isDefined(treeItem) && isDefined(parentItem?.children)) {
          parentItem.children.push(treeItem);
        }
      } else if (isDefined(treeItem)) {
        rootItems.push(treeItem);
      }
    }
    const sortChildren = (items2) => {
      items2.sort((a, b2) => a.name.localeCompare(b2.name));
      for (const item of items2) {
        if (isDefined(item.children) && item.children.length > 0) {
          sortChildren(item.children);
        }
      }
    };
    sortChildren(rootItems);
    return rootItems;
  }
  static toAssetGroupingItems(entities) {
    return entities.map((item) => ({
      id: item.id,
      name: item.name ?? "",
      parent: isDefined(item.parent) ? item.parent.id : DEFAULT_SYSTEM_ID,
      index: item.index ?? 0,
      contacts: item.contacts ?? [],
      data: item
    }));
  }
  static treeToComboValues(tree, startingDepth = 0) {
    const result = [];
    const recurseTree = (items, depth) => {
      if (isDefined(items)) {
        items.sort((a, b2) => a.name.localeCompare(b2.name));
        for (const item of items) {
          result.push({ key: item.id, value: item.name, indent: depth });
          if (isDefined(item.children) && item.children.length > 0) {
            recurseTree(item.children, depth + 1);
          }
        }
      }
    };
    recurseTree(tree, startingDepth);
    return result;
  }
  static createRootNode(clientId) {
    const data = {
      id: DEFAULT_SYSTEM_ID,
      name: "Root",
      parent: { id: null },
      contacts: [],
      owner: { id: clientId }
    };
    return {
      id: data.id,
      name: data.name,
      parent: null,
      data
    };
  }
  ngOnDestroy() {
    this.clear();
  }
  clear() {
    this.cache = {};
  }
  /**
   * Find a cost center in the cost center tree
   */
  findCCInCCTree(tree, costCentre) {
    if (isNullOrUndefined(costCentre)) {
      return [];
    }
    return this.traverseTree(tree, (node) => ({
      collect: node.id === costCentre.id ? node : void 0
    }));
  }
  /**
   * Filter cost centers using tree structure
   */
  getFilteredCostCentres(costCentreTree, costCentres) {
    const results = [];
    this.traverseTree(costCentreTree, (node) => {
      const costCentre = costCentres.find((x) => x.id === node.id);
      if (isDefined(costCentre)) {
        results.push(costCentre);
      }
      return {};
    });
    return results;
  }
  /**
   * Find a node in the tree by ID
   */
  findInTree(tree, id) {
    for (const node of tree) {
      if (node.id === id) {
        return node;
      }
      if (node.children && node.children.length > 0) {
        const found = this.findInTree(node.children, id);
        if (found) {
          return found;
        }
      }
    }
    return null;
  }
  getGroupResultInfo(clientId, type) {
    const { count, limit } = this.cache[`${clientId}/${type}`];
    return { count, limit };
  }
  getCostCentres(clientId, filter2) {
    return this.getEntities("costCentres", clientId, (ownerId, filter3) => firstValueFrom(this.entitiesService.listCostCentres(ownerId, 0, 1e3, "name", this.buildFilterQuery(filter3))), filter2);
  }
  getCostCentresAsTree(clientId, filter2) {
    return this.getEntitiesAsTree(clientId, this.getCostCentres.bind(this), filter2);
  }
  async getCostCentresAsTreeForUser(clientId, filter2) {
    const items = await this.getCostCentresAsTree(clientId, filter2);
    const costCenterId = this.authDataService.getUserProfile()?.costCentre?.id;
    if (isDefined(costCenterId)) {
      const item = this.findInTree(items, costCenterId);
      return [item].filter((x) => isDefined(x));
    }
    return items;
  }
  getAssetGroups(clientId, filter2) {
    return this.cacheService.getOrFetchAsync(`assetGroups-${clientId ?? this.globalClientId}-${filter2 ?? ""}`, () => this.getEntities("assetGroups", clientId, (ownerId, filter3) => firstValueFrom(this.entitiesService.listAssetGroups(ownerId, 0, 1e3, "name", this.buildFilterQuery(filter3))), filter2), 2 * 60 * 1e3);
  }
  getAssetGroupsAsTree(clientId, filter2) {
    return this.getEntitiesAsTree(clientId, this.getAssetGroups.bind(this), filter2);
  }
  getAssetCategories(clientId, filter2) {
    return this.cacheService.getOrFetchAsync(`assetCategories-${clientId ?? this.globalClientId}-${filter2 ?? ""}`, () => this.getEntities("assetCategories", clientId, (ownerId, filter3) => firstValueFrom(this.entitiesService.listAssetCategories(ownerId, 0, 1e3, "name", this.buildFilterQuery(filter3))), filter2), 5 * 60 * 1e3);
  }
  getAssetCategoriesAsTree(clientId, filter2) {
    return this.getEntitiesAsTree(clientId, this.getAssetCategories.bind(this), filter2);
  }
  async getAssetTypes(clientId, filter2) {
    return this.getEntities("assetTypes", clientId, async (ownerId) => firstValueFrom(this.entitiesService.listAssetTypes(ownerId)), filter2);
  }
  async getAssetTypesAsTree(clientId, filter2) {
    return this.getEntitiesAsTree(clientId, this.getAssetTypes.bind(this), filter2);
  }
  async getDeviceTypes(clientId, filter2) {
    return this.getEntities("deviceTypes", clientId, async (ownerId) => firstValueFrom(this.entitiesService.listDeviceTypes(ownerId)), filter2);
  }
  getDeviceTypesAsTree(clientId, filter2) {
    return this.getEntitiesAsTree(clientId, this.getDeviceTypes.bind(this), filter2);
  }
  getAssetTagTypes(clientId, _filter) {
    return this.getEntities("assetTagTypes", clientId, async (ownerId) => firstValueFrom(this.entitiesService.listAssetTagTypes(ownerId)));
  }
  getAssetTagTypesAsTree(clientId, filter2) {
    return this.getEntitiesAsTree(clientId, this.getAssetTagTypes.bind(this), filter2);
  }
  getZoneGroups(clientId, filter2) {
    return this.getEntities("zoneGroups", clientId, (ownerId, filter3) => firstValueFrom(this.entitiesService.listZoneGroups(ownerId, 0, 1e3, "name", this.buildFilterQuery(filter3))), filter2);
  }
  getZoneGroupsAsTree(clientId, filter2) {
    return this.getEntitiesAsTree(clientId, this.getZoneGroups.bind(this), filter2);
  }
  static \u0275fac = function AssetGroupingService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AssetGroupingService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _AssetGroupingService, factory: _AssetGroupingService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AssetGroupingService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/models/event-types.model.ts
var eventTypeMapping = {
  // Geocoding
  "GEOCODING.SPEED": {
    name: "Modify Speed Limit",
    action: "Modify speed limit"
  },
  // Geofence Events
  "ZONEEVENT.ENTER": { name: "Enter", action: "enters" },
  "ZONEEVENT.EXIT": { name: "Exit", action: "leaves" },
  "ZONEEVENT.RANGE_ENTER": { name: "In Range", action: "goes in range of" },
  "ZONEEVENT.RANGE_EXIT": {
    name: "Out of Range",
    action: "goes out of range of"
  },
  // Trip Events
  "ASSETACTIVATIONEVENT.ACTIVATE": { name: "Start", action: "starts a trip" },
  "ASSETACTIVATIONEVENT.DEACTIVATE": { name: "End", action: "ends a trip" },
  // Triggered Events
  "TRIGGEREDEVENT.PANIC": { name: "Panic", action: "triggers a Panic event" },
  "TRIGGEREDEVENT.HARSH_BRAKE": {
    name: "Harsh Brake",
    action: "triggers a Harsh Brake event"
  },
  "TRIGGEREDEVENT.HARSH_ACCEL": {
    name: "Harsh Accel",
    action: "triggers a Harsh Accel event"
  },
  "TRIGGEREDEVENT.POWER_LOW": {
    name: "Power Low",
    action: "triggers a Power Low event"
  },
  "TRIGGEREDEVENT.POWER_HIGH": {
    name: "Power High",
    action: "triggers a Power High event"
  },
  "TRIGGEREDEVENT.POWER_DISCONNECT": {
    name: "Power Disconnect",
    action: "triggers a Power Disconnect event"
  },
  "TRIGGEREDEVENT.POWER_RECONNECT": {
    name: "Power Reconnect",
    action: "triggers a Power Reconnect event"
  },
  "TRIGGEREDEVENT.BATTERY_LOW": {
    name: "Battery Low",
    action: "triggers a Battery Low event"
  },
  "TRIGGEREDEVENT.BATTERY_DISCONNECT": {
    name: "Battery Disconnect",
    action: "triggers a Battery Disconnect event"
  },
  "TRIGGEREDEVENT.BATTERY_RECONNECT": {
    name: "Battery Reconnect",
    action: "triggers a Battery Reconnect event"
  },
  "TRIGGEREDEVENT.BATTERY_ACTIVE": {
    name: "Battery Active",
    action: "triggers a Battery Active event"
  },
  "TRIGGEREDEVENT.GSM_SIGNAL_LOW": {
    name: "Gsm Signal Low",
    action: "triggers a Gsm Signal Low event"
  },
  "TRIGGEREDEVENT.GSM_ANTENNA_FAULT": {
    name: "Gsm Antenna Fault",
    action: "triggers a Gsm Antenna Fault event"
  },
  "TRIGGEREDEVENT.GSM_JAMMED": {
    name: "Gsm Jammed",
    action: "triggers a Gsm Jammed event"
  },
  "TRIGGEREDEVENT.GPS_FAILURE": {
    name: "Gps Failure",
    action: "triggers a Gps Failure event"
  },
  "TRIGGEREDEVENT.GPS_SIGNAL_LOW": {
    name: "Gps Signal Low",
    action: "triggers a Gps Signal Low event"
  },
  "TRIGGEREDEVENT.GPS_ANTENNA_FAULT": {
    name: "Gps Antenna Fault",
    action: "triggers a Gps Antenna Fault event"
  },
  "TRIGGEREDEVENT.GPS_JAMMED": {
    name: "Gps Jammed",
    action: "triggers a Gps Jammed event"
  },
  "TRIGGEREDEVENT.IMPACT": {
    name: "Impact",
    action: "triggers a Impact event"
  },
  "TRIGGEREDEVENT.UNAUTHORIZED_MOVEMENT": {
    name: "Unauthorized Movement",
    action: "triggers a Unauthorized Movement event"
  },
  "TRIGGEREDEVENT.TOWING": {
    name: "Towing",
    action: "triggers a Towing event"
  },
  "TRIGGEREDEVENT.OVER_RPM": {
    name: "Over Rpm",
    action: "triggers a Over Rpm event"
  },
  "TRIGGEREDEVENT.MOTION_START": {
    name: "Motion Start",
    action: "triggers a Motion Start event"
  },
  "TRIGGEREDEVENT.MOTION_END": {
    name: "Motion End",
    action: "triggers a Motion End event"
  },
  "TRIGGEREDEVENT.EXCESSIVE_STOP_START": {
    name: "Excessive Stop Start",
    action: "triggers a Excessive Stop Start event"
  },
  "TRIGGEREDEVENT.EXCESSIVE_STOP_END": {
    name: "Excessive Stop End",
    action: "triggers a Excessive Stop End event"
  },
  "TRIGGEREDEVENT.VOICE_CALL_STARTED": {
    name: "Voice Call Started",
    action: "triggers a Voice Call Started event"
  },
  "TRIGGEREDEVENT.VOICE_CALL_ENDED": {
    name: "Voice Call Ended",
    action: "triggers a Voice Call Ended event"
  },
  "TRIGGEREDEVENT.VOICE_CALLBACK": {
    name: "Voice Callback",
    action: "triggers a Voice Callback event"
  },
  "TRIGGEREDEVENT.ALARM_ACTIVE": {
    name: "Alarm Active",
    action: "triggers a Alarm Active event"
  },
  "TRIGGEREDEVENT.ALARM_ARMED": {
    name: "Alarm Armed",
    action: "triggers a Alarm Armed event"
  },
  "TRIGGEREDEVENT.ALARM_DISARMED": {
    name: "Alarm Disarmed",
    action: "triggers a Alarm Disarmed event"
  },
  "TRIGGEREDEVENT.CURFEW_VIOLATION": {
    name: "Curfew Violation",
    action: "triggers a Curfew Violation event"
  },
  "TRIGGEREDEVENT.HARSH_CORNER": {
    name: "Harsh Corner",
    action: "triggers a Harsh Corner event"
  },
  "TRIGGEREDEVENT.POWER_ON": {
    name: "Power On",
    action: "triggers a Power On event"
  },
  "TRIGGEREDEVENT.POWER_OFF": {
    name: "Power Off",
    action: "triggers a Power Off event"
  },
  "TRIGGEREDEVENT.ANALOG_RANGE": {
    name: "Analog Range",
    action: "triggers a Analog Range event"
  },
  "TRIGGEREDEVENT.ANALOG_JUMP": {
    name: "Analog Jump",
    action: "triggers a Analog Jump event"
  },
  "TRIGGEREDEVENT.TILT": { name: "Tilt", action: "triggers a Tilt event" },
  "TRIGGEREDEVENT.VIN_CHANGED": {
    name: "Vin Changed",
    action: "triggers a Vin Changed event"
  },
  // State Events
  "ASSETSTATECHANGEEVENT.CHANGE": { name: "State", action: "changes" },
  // Digital Events
  "DIGITALINPUTEVENT.ACTIVATE": { name: "Activate", action: "activates" },
  "DIGITALINPUTEVENT.DEACTIVATE": { name: "Deactivate", action: "deactivates" },
  // Value Events
  "VALUEINPUTEVENT.ACTIVATE": { name: "Activate", action: "activates" },
  "VALUEINPUTEVENT.DEACTIVATE": { name: "Deactivate", action: "deactivates" },
  // Analog/CAN Events
  "ANALOGINPUTEVENT.LOW": {
    name: "Low Range Violation",
    action: "exceeds low limit for"
  },
  "ANALOGINPUTEVENT.HIGH": {
    name: "High Range Violation",
    action: "exceeds high limit for"
  },
  "ANALOGINPUTEVENT.DROP": {
    name: "Sudden Drop",
    action: "experiences sudden drop in"
  },
  "ANALOGINPUTEVENT.JUMP": {
    name: "Sudden Jump",
    action: "experiences sudden jump in"
  },
  // Temperature Events
  "TEMPERATUREINPUTEVENT.OUT_RANGE": {
    name: "Range Violation",
    action: "exceeds min/max temperature for"
  },
  "TEMPERATUREINPUTEVENT.IN_RANGE": {
    name: "Range Return",
    action: "returns to temperature range for"
  },
  "TEMPERATUREINPUTEVENT.LOW": {
    name: "Low Range Violation",
    action: "exceeds low temperature for"
  },
  "TEMPERATUREINPUTEVENT.HIGH": {
    name: "High Range Violation",
    action: "exceeds high temperature for"
  },
  // Overspeed Events
  "OVERSPEEDEVENT.START": { name: "Start", action: "exceeds the speed limit" },
  "OVERSPEEDEVENT.BAND_END": {
    name: "Band",
    action: "exceeds the speed limit in the"
  },
  // Idle Events
  "EXCESSIVEIDLEEVENT.START": {
    name: "Excessive Idle",
    action: "idles for longer than the idling limit"
  },
  // Trip Violation Events
  "TRIPVIOLATIONEVENT.ACTIVE": {
    name: "Max Trip Time",
    action: "exceeds the trip time limit"
  },
  "TRIPVIOLATIONEVENT.INACTIVE": {
    name: "Max Trip Inactive Time",
    action: "exceeds the inactive trip time limit"
  },
  "TRIPVIOLATIONEVENT.DISTANCE": {
    name: "Max Trip Distance",
    action: "exceeds the trip distance limit"
  },
  // Reminder Events
  "REMINDEREVENT.ODO": {
    name: "Odometer Reminder",
    action: "triggers an odometer reminder"
  },
  "REMINDEREVENT.HOURS": {
    name: "Engine Hours Reminder",
    action: "triggers an engine hours reminder"
  },
  "REMINDEREVENT.TIME": {
    name: "Time Based Reminder",
    action: "triggers a time based reminder"
  },
  // Tag Events
  "TAGEVENT.GAINED": { name: "Regained", action: "gains a tag" },
  "TAGEVENT.LOST": { name: "Lost", action: "loses a tag" },
  "TAGEVENT.ALARM": {
    name: "Notification",
    action: "receives a tag notification"
  },
  // Text Message Events
  "TEXTMESSAGEEVENT.INCOMING": {
    name: "Text Message",
    action: "sends a text message"
  },
  // Geo Lock Events
  "GEOLOCKEVENT.VIOLATION": {
    name: "Geo Lock Violation",
    action: "violates a Geo Lock"
  },
  // Border Crossing Events
  "GEOBORDEREVENT.COUNTRY": {
    name: "Country",
    action: "crosses country borders"
  },
  "GEOBORDEREVENT.STATE": {
    name: "State/Province",
    action: "crosses state/province borders"
  },
  // Camera Events
  "CAMERAINPUTEVENT.VIDEO": { name: "Video", action: "creates a video" },
  // Fuel Events
  "FUELINGEVENT.TRANSACTION": {
    name: "Fuel Fill Up",
    action: "fills tank with fuel"
  }
};
var eventCategoryMapping = {
  GEOCODING: "Geocoding",
  ZONEEVENT: "Geofence",
  ASSETACTIVATIONEVENT: "Trip",
  TRIGGEREDEVENT: "Triggered Event",
  ASSETSTATECHANGEEVENT: "State",
  DIGITALINPUTEVENT: "Digital",
  VALUEINPUTEVENT: "Value",
  ANALOGINPUTEVENT: "Analog/CAN Violations",
  TEMPERATUREINPUTEVENT: "Temperature Violation",
  OVERSPEEDEVENT: "Overspeed",
  EXCESSIVEIDLEEVENT: "Excessive Idle",
  TRIPVIOLATIONEVENT: "Trip Limit",
  REMINDEREVENT: "Reminder",
  TAGEVENT: "Tag",
  TEXTMESSAGEEVENT: "Text Message",
  GEOLOCKEVENT: "Geo Lock Violation",
  GEOBORDEREVENT: "Border Crossing",
  CAMERAINPUTEVENT: "Camera",
  FUELINGEVENT: "Fuel"
};
function getEventTypeDisplayName(eventType, subType) {
  const key = `${eventType}.${subType}`;
  return eventTypeMapping[key]?.name || key;
}
function getEventTypeAction(eventType, subType) {
  const key = `${eventType}.${subType}`;
  return eventTypeMapping[key]?.action || key;
}
function getEventCategoryName(eventType) {
  return eventCategoryMapping[eventType] || eventType;
}

// src/app/shared/models/alerts-conditions.model.ts
var conditionTypeMapping = {
  TIME: {
    name: "Time Range",
    text: "time is {mode} {time1} and {time2} on {dow}",
    modes: {
      MODE_INSIDE: "between",
      MODE_OUTSIDE: "outside of"
    },
    fields: {
      TIME1: "start",
      TIME2: "end",
      DOW_0: "Sun",
      DOW_1: "Mon",
      DOW_2: "Tue",
      DOW_3: "Wed",
      DOW_4: "Thu",
      DOW_5: "Fri",
      DOW_6: "Sat"
    }
  },
  ZONE: {
    name: "Geofence",
    text: "current position is {mode} of {zone}",
    modes: {
      MODE_INSIDE: "inside",
      MODE_OUTSIDE: "outside"
    }
  },
  LINKED: {
    name: "Linked Asset",
    text: "current linked asset {mode} {asset}",
    modes: {
      MODE_IN: "is",
      MODE_OUT: "is not"
    }
  },
  ACTIVE: {
    name: "Ignition",
    text: "ignition is {state}",
    fields: {
      STATE_0: "Off",
      STATE_1: "On"
    }
  },
  SPEED: {
    name: "Speed",
    text: "speed is {mode} than {speed}",
    modes: {
      MODE_GREATER: "greater",
      MODE_LESS: "less"
    }
  },
  DIGITAL: {
    name: "Digital State",
    text: "digital {input} is {state}",
    fields: {
      STATE_0: "inactive",
      STATE_1: "active"
    }
  },
  STATE: {
    name: "Asset State",
    text: "state {profile} is {state}"
  },
  DISTANCE: {
    name: "Distance",
    text: "distance is {mode} than {distance}",
    modes: {
      MODE_GREATER: "greater",
      MODE_LESS: "less"
    }
  },
  DURATION: {
    name: "Duration",
    text: "duration is {mode} than {duration}",
    modes: {
      MODE_GREATER: "greater",
      MODE_LESS: "less"
    }
  },
  ROUTENUMBER: {
    name: "Road Route Number",
    text: "route number {mode} {value}",
    modes: {
      MODE_EQUALS: "equals",
      MODE_CONTAINS: "contains",
      MODE_STARTS: "starts with",
      MODE_ENDS: "ends with",
      MODE_NOT_EQUALS: "does not equal",
      MODE_NOT_CONTAINS: "does not contain",
      MODE_NOT_STARTS: "does not start with",
      MODE_NOT_ENDS: "does not end with"
    }
  },
  ROADNAME: {
    name: "Road Name",
    text: "road name {mode} {value}",
    modes: {
      MODE_EQUALS: "equals",
      MODE_CONTAINS: "contains",
      MODE_STARTS: "starts with",
      MODE_ENDS: "ends with",
      MODE_NOT_EQUALS: "does not equal",
      MODE_NOT_CONTAINS: "does not contain",
      MODE_NOT_STARTS: "does not start with",
      MODE_NOT_ENDS: "does not end with"
    }
  },
  BOUNDARY: {
    name: "Boundary",
    text: "{boundary} {mode} {value}",
    fields: {
      BOUNDARY_SUBURB: "suburb",
      BOUNDARY_TOWN: "town",
      BOUNDARY_STATE: "state/province",
      BOUNDARY_COUNTRY: "country"
    },
    modes: {
      MODE_EQUALS: "equals",
      MODE_CONTAINS: "contains",
      MODE_STARTS: "starts with",
      MODE_ENDS: "ends with",
      MODE_NOT_EQUALS: "does not equal",
      MODE_NOT_CONTAINS: "does not contain",
      MODE_NOT_STARTS: "does not start with",
      MODE_NOT_ENDS: "does not end with"
    }
  },
  SPEEDLIMIT: {
    name: "Speed Limit",
    text: "speed limit {mode} {speed}",
    modes: {
      MODE_GREATER: "is greater than",
      MODE_LESS: "is less than",
      MODE_EQUALS: "equals"
    }
  },
  CARRIAGEWAY: {
    name: "Carriageway",
    text: "road is a {mode} carriageway",
    modes: {
      MODE_SINGLE: "single",
      MODE_DUAL: "dual"
    }
  }
};
function getConditionTypeDisplayName(conditionType) {
  return conditionTypeMapping[conditionType]?.name || conditionType;
}

// src/app/core/services/api-schema.service.ts
var ApiSchemaService = class _ApiSchemaService {
  apiUrlService = inject(ApiUrlService);
  modernSchemaBackendUrl = environment.modernSchemaBackendUrl;
  schema = {
    SmsGatewayProvider: { typePropertyName: "smsgatewayproviderType" },
    EmailProvider: { typePropertyName: "emailproviderType" },
    ioType: { typePropertyName: "iotypeType" }
  };
  constructor() {
  }
  getTypePropertyNameInternal(entityName) {
    return this.schema[entityName]?.typePropertyName || "type";
  }
  // Public accessor for the type property name
  getEntityTypePropertyName(entityName) {
    return this.getTypePropertyNameInternal(entityName);
  }
  /**
   * Checks if the current API URL corresponds to the backend using the modern property schema.
   * (e.g., [Entity]Type instead of Type)
   *
   * @return {boolean} True if the modern schema is used, false otherwise.
   */
  usesModernSchema() {
    return this.apiUrlService.getCurrentApiUrl() === this.modernSchemaBackendUrl;
  }
  /**
   * Gets the correct property key for the 'type' field based on the active API schema.
   * @param entityName The name of the entity (e.g., 'SmsGatewayProvider', 'EmailProvider').
   * @returns The property key (e.g., 'smsgatewayproviderType' or 'type').
   */
  getTypePropertyKey(entityName) {
    if (this.usesModernSchema()) {
      return `${entityName.charAt(0).toLowerCase()}${entityName.slice(1)}Type`;
    }
    return "type";
  }
  /**
   * Gets the type object from an entity using the correct property key.
   * @param entity The entity object.
   * @param entityName The name of the entity.
   * @returns The type object or undefined.
   */
  getEntityType(entity, entityName) {
    const typePropertyName = this.getTypePropertyKey(entityName);
    if (typePropertyName in entity && typeof entity[typePropertyName] !== "undefined") {
      return entity[typePropertyName];
    }
    return null;
  }
  /**
   * Sets the type object on a payload using the correct property key.
   * @param payload The payload object to modify.
   * @param entityName The name of the entity.
   * @param value The value to set for the type property.
   */
  setEntityType(payload, entityName, value) {
    const typePropertyName = this.getTypePropertyNameInternal(entityName);
    payload[typePropertyName] = value;
  }
  static \u0275fac = function ApiSchemaService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ApiSchemaService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ApiSchemaService, factory: _ApiSchemaService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ApiSchemaService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// src/app/shared/services/event-filter.service.ts
var EventFilterService = class _EventFilterService {
  grouping = inject(AssetGroupingService);
  entitiesService = inject(EntitiesService);
  clientDataService = inject(ClientDataService);
  router = inject(Router);
  apiSchemaService = inject(ApiSchemaService);
  EVENT_CONDITIONS = {
    time: {
      mode: { type: "dropdown", values: ["inside", "outside"] },
      time1: { type: "time" },
      time2: { type: "time" },
      dow: { type: "checklist", values: ["0", "1", "2", "3", "4", "5", "6"] }
    },
    zone: {
      mode: { type: "dropdown", values: ["inside", "outside"] },
      zone: { type: "dropdown", values: () => this.getZoneSelectionTree() }
    },
    linked: {
      mode: { type: "dropdown", values: ["in", "out"] },
      asset: {
        type: "searchableTree",
        values: () => this.getAssetSelectionTree([
          "categories",
          "costcentres",
          "groups",
          "types"
        ])
      }
    },
    active: {
      state: { type: "dropdown", values: ["0", "1"] }
    },
    speed: {
      mode: { type: "dropdown", values: ["greater", "less"] },
      speed: { type: "speed" }
    },
    distance: {
      mode: { type: "dropdown", values: ["greater", "less"] },
      distance: { type: "distance" }
    },
    duration: {
      mode: { type: "dropdown", values: ["greater", "less"] },
      duration: { type: "duration" }
    },
    digital: {
      input: {
        type: "dropdown",
        values: () => this.getIoTargetList(["digital_input"]),
        linkedTo: "state"
      },
      state: {
        type: "dropdown",
        values: (data) => this.getIoValues(data)
      }
    },
    state: {
      profile: {
        type: "dropdown",
        values: () => this.getStateTargetList(),
        linkedTo: "state"
      },
      state: {
        type: "dropdown",
        values: (data) => this.getStateValues(data)
      }
    }
  };
  ACTION_EVENTS = {
    zoneevent: ["enter", "exit", "range_enter", "range_exit"],
    assetactivationevent: ["activate", "deactivate"],
    triggeredevent: [
      "alarm_active",
      "alarm_armed",
      "alarm_disarmed",
      "analog_jump",
      "analog_range",
      "battery_active",
      "battery_disconnect",
      "battery_low",
      "battery_reconnect",
      "curfew_violation",
      "excessive_stop_end",
      "excessive_stop_start",
      "gps_antenna_fault",
      "gps_failure",
      "gps_jammed",
      "gps_signal_low",
      "gsm_antenna_fault",
      "gsm_jammed",
      "gsm_signal_low",
      "harsh_accel",
      "harsh_brake",
      "harsh_corner",
      "impact",
      "motion_end",
      "motion_start",
      "over_rpm",
      "panic",
      "power_disconnect",
      "power_high",
      "power_low",
      "power_off",
      "power_on",
      "power_reconnect",
      "tilt",
      "towing",
      "unauthorized_movement",
      "vin_changed",
      "voice_call_ended",
      "voice_call_started",
      "voice_callback"
    ],
    assetstatechangeevent: ["change"],
    digitalinputevent: ["activate", "deactivate"],
    valueinputevent: ["activate"],
    analoginputevent: ["low", "high", "drop", "jump"],
    temperatureinputevent: ["out_range", "in_range", "low", "high"],
    overspeedevent: ["start", "band_end"],
    excessiveidleevent: ["start"],
    fuelingevent: ["transaction"],
    reminderevent: ["odo", "hours", "time"],
    tagevent: ["gained", "lost", "alarm"],
    textmessageevent: ["incoming"],
    geolockevent: ["violation"],
    geoborderevent: ["country", "state"],
    camerainputevent: ["video"]
  };
  ACTION_TARGETS = {
    zoneevent: "zones",
    assetstatechangeevent: "state",
    overspeedevent: {
      band_end: "overspeedband"
    },
    digitalinputevent: "digitals",
    valueinputevent: "values",
    analoginputevent: "analogs",
    temperatureinputevent: "temperatures"
  };
  static ALLOWED_ASSET_TYPE_NAMES = [
    "aircraft",
    "container",
    "driver",
    "fixed asset",
    "person",
    "site",
    "trailer",
    "vehicle",
    "car",
    "ship"
  ];
  getOwnerId() {
    let route = this.router.routerState.snapshot.root;
    while (route.firstChild) {
      route = route.firstChild;
    }
    let params = {};
    while (isDefined(route)) {
      params = __spreadValues(__spreadValues({}, route.params), params);
      route = route.parent;
    }
    return params["clientId"] ?? params["vendorId"] ?? params["distributorId"];
  }
  buildAssetSelectionTree(costCentres, assetTypes, assetGroups, assetCategories, allowedAssetTypes) {
    const nodes = [];
    const addAssetTypeGroups = (assetType) => {
      const assetTypeName = assetType.name;
      const anyDesc = `any ${assetTypeName}`;
      const node = {
        id: assetType.id,
        label: assetTypeName,
        children: [],
        data: {
          actorId: DEFAULT_SYSTEM_ID,
          actorSelectionType: "any",
          actorType: "asset",
          actorTypeId: assetType.id,
          actorTypeName: assetTypeName,
          text: anyDesc
        }
      };
      nodes.push(node);
      node.children = node.children ?? [];
      node.children.push({
        id: "any." + assetType.id,
        label: anyDesc,
        children: void 0,
        data: {
          actorId: DEFAULT_SYSTEM_ID,
          actorSelectionType: "any",
          actorType: "asset",
          actorTypeId: assetType.id,
          actorTypeName: assetTypeName,
          text: anyDesc
        }
      });
      if (costCentres.length > 0) {
        node.children.push({
          id: "costcentre." + assetType.id,
          label: "In Cost Centre",
          children: AssetGroupingService.toTree(costCentres.map((item) => {
            const desc = `any ${assetTypeName} in ${item.name}`;
            return __spreadProps(__spreadValues({}, item), {
              id: `costcentre.${assetType.id}.${item.id}`,
              label: item.name,
              data: {
                actorId: item.id,
                actorName: item.name,
                actorSelectionType: "accessGroup",
                actorType: "asset",
                actorTypeId: assetType.id,
                actorTypeName: assetTypeName,
                text: desc
              }
            });
          }))
        });
      }
      if (assetGroups.length > 0) {
        node.children.push({
          id: "group." + assetType.id,
          label: "In Group",
          children: AssetGroupingService.toTree(assetGroups.map((item) => {
            const desc = `any ${assetTypeName} in ${item.name}`;
            return __spreadProps(__spreadValues({}, item), {
              id: `group.${assetType.id}.${item.id}`,
              data: {
                actorId: item.id,
                actorName: item.name,
                actorSelectionType: "group",
                actorType: "asset",
                actorTypeId: assetType.id,
                actorTypeName: assetTypeName,
                text: desc
              }
            });
          }))
        });
      }
      if (assetCategories.length > 0) {
        node.children.push({
          id: "category." + assetType.id,
          label: "In Category",
          children: AssetGroupingService.toTree(assetCategories.map((item) => {
            const desc = `any ${assetTypeName} in ${item.name}`;
            return __spreadProps(__spreadValues({}, item), {
              id: `category.${assetType.id}.${item.id}`,
              data: {
                actorId: item.id,
                actorName: item.name,
                actorSelectionType: "category",
                actorType: "asset",
                actorTypeId: assetType.id,
                actorTypeName: assetTypeName,
                text: desc
              }
            });
          }))
        });
      }
    };
    if (allowedAssetTypes?.includes("asset") ?? false) {
      addAssetTypeGroups({
        id: DEFAULT_SYSTEM_ID,
        name: "Asset"
      });
    }
    assetTypes.sort((a, b2) => a.name.localeCompare(b2.name));
    for (const assetType of assetTypes) {
      if (isNullOrUndefined(allowedAssetTypes) || allowedAssetTypes.length === 0 || allowedAssetTypes.includes(assetType.name.toLowerCase())) {
        addAssetTypeGroups(assetType);
      }
    }
    return nodes;
  }
  async getAssetSelectionTree(groupTypes) {
    groupTypes = groupTypes ?? ["costcentres", "groups", "types", "categories"];
    const ownerId = this.getOwnerId();
    return Promise.all([
      groupTypes.includes("costcentres") ? this.grouping.getCostCentres(ownerId) : Promise.resolve([]),
      groupTypes.includes("types") ? this.grouping.getAssetTypes(ownerId) : Promise.resolve([]),
      groupTypes.includes("groups") ? this.grouping.getAssetGroups(ownerId) : Promise.resolve([]),
      groupTypes.includes("categories") ? this.grouping.getAssetCategories(ownerId) : Promise.resolve([])
    ]).then(([costCentres, assetTypes, assetGroups, assetCategories]) => {
      const filteredAssetTypes = assetTypes.filter((t) => isDefined(t?.name) && _EventFilterService.ALLOWED_ASSET_TYPE_NAMES.includes(t.name.trim().toLowerCase()));
      return this.buildAssetSelectionTree(costCentres, filteredAssetTypes, assetGroups, assetCategories);
    });
  }
  buildZoneSelectionTree(zoneGroups) {
    const nodes = [];
    for (const zoneType of ["location", "nogo", "keepin", "route"]) {
      const zoneTypeName = zoneType;
      const anyDesc = `any ${zoneTypeName}`;
      const node = {
        id: zoneType,
        label: zoneTypeName,
        children: [],
        data: {
          targetId: DEFAULT_SYSTEM_ID,
          targetSelectionType: "any",
          targetType: "zone",
          targetTypeId: zoneType,
          targetTypeName: zoneTypeName,
          text: anyDesc
        }
      };
      nodes.push(node);
      node.children = node.children ?? [];
      node.children.push({
        id: "any." + zoneType,
        label: anyDesc,
        children: void 0,
        data: {
          targetId: DEFAULT_SYSTEM_ID,
          targetSelectionType: "any",
          targetType: "zone",
          targetTypeId: zoneType,
          targetTypeName: zoneTypeName,
          text: anyDesc
        }
      });
      if (zoneGroups.length > 0) {
        node.children.push({
          id: "group." + zoneType,
          label: "In Group",
          children: AssetGroupingService.toTree(zoneGroups.map((item) => {
            const desc = `any ${zoneTypeName} in group ${item.name}`;
            return __spreadProps(__spreadValues({}, item), {
              id: `${zoneType}.${item.id}`,
              data: {
                targetId: item.id,
                targetName: item.name,
                targetSelectionType: "group",
                targetType: "zone",
                targetTypeId: zoneType,
                targetTypeName: zoneTypeName,
                text: desc
              }
            });
          }))
        });
      }
    }
    return nodes;
  }
  getZoneSelectionTree() {
    return this.grouping.getZoneGroups(this.getOwnerId()).then((zoneGroups) => {
      return this.buildZoneSelectionTree(zoneGroups);
    });
  }
  async getValueInputSelectionTree() {
    const ownerId = this.getOwnerId();
    const result = await firstValueFrom(this.entitiesService.listIoTypes(ownerId ?? "", true, 0, 300, "name", "state=active,type=value_input"));
    return result.items.map((item) => ({
      id: item.id,
      label: item.name ?? "",
      hasChildren: true,
      getChildren: async () => {
        const ioType = await firstValueFrom(this.entitiesService.getIoType(item.id));
        return [
          {
            id: "any." + item.id,
            label: "Any",
            data: {
              targetType: "value_input",
              targetTypeId: ioType.id,
              targetTypeName: ioType.name,
              targetSelectionType: "any",
              targetId: DEFAULT_SYSTEM_ID,
              targetName: "Any",
              text: ioType.name
            }
          },
          ...(ioType.lookups ?? []).map((lookup) => ({
            id: lookup.id,
            label: lookup.id + ": " + lookup.name,
            data: {
              targetType: "value_input",
              targetTypeId: ioType.id,
              targetTypeName: ioType.name,
              targetSelectionType: "specific",
              targetId: lookup.id,
              targetName: lookup.name,
              text: `${ioType.name} ${lookup.id} - ${lookup.name}`
            }
          }))
        ];
      }
    }));
  }
  getActionEventsTree() {
    const result = Object.keys(this.ACTION_EVENTS).map((eventClass) => {
      return {
        id: `event-${eventClass}`,
        label: getEventCategoryName(eventClass.toUpperCase()),
        children: this.ACTION_EVENTS[eventClass].map((eventType) => {
          let targetType = "";
          if (isObject(this.ACTION_TARGETS[eventClass])) {
            targetType = this.ACTION_TARGETS[eventClass][eventType];
          } else {
            targetType = this.ACTION_TARGETS[eventClass];
          }
          return {
            id: `event-${eventClass}-${eventType}`,
            label: getEventTypeDisplayName(eventClass.toUpperCase(), eventType.toUpperCase()),
            data: {
              eventClass,
              eventType,
              targetType,
              text: getEventTypeAction(eventClass.toUpperCase(), eventType.toUpperCase())
            }
          };
        }),
        selectable: false
      };
    });
    result.sort((a, b2) => a.label.localeCompare(b2.label));
    return result;
  }
  async getTargetNodes(targetType) {
    switch (targetType) {
      case "zones":
        return this.getZoneSelectionTree();
      case "digitals":
        return this.getIoTargetTree(["digital_input"]);
      case "analogs":
        return this.getIoTargetTree(["analog_input", "can_input"]);
      case "temperatures":
        return this.getIoTargetTree(["temperature_input"]);
      case "values":
        return this.getValueInputSelectionTree();
      case "state":
        return this.getStateTargetTree();
      case "overspeedband":
        return this.getOverspeedBandTargetTree();
    }
    return [];
  }
  async getIoTargetTree(types) {
    const ownerId = this.getOwnerId();
    const typePropertyName = this.apiSchemaService.getTypePropertyKey("iotype");
    const typeFilters = types.map((t) => `${typePropertyName}=${t}`).join("|");
    const type = types.length > 1 ? `(${typeFilters})` : typeFilters;
    const filter2 = type ? `state=active,${type}` : `state=active`;
    const result = await firstValueFrom(this.entitiesService.listIoTypes(ownerId ?? "", true, 0, 300, "name", filter2));
    return result.items.map((item) => ({
      id: item.id,
      label: item.name ?? "",
      data: {
        targetType: item.type,
        targetTypeId: item.type,
        targetTypeName: item.type,
        targetSelectionType: "specific",
        targetId: item.id,
        targetName: item.name,
        text: item.name
      }
    }));
  }
  async getIoTargetList(types) {
    const ownerId = this.getOwnerId();
    const typePropertyName = this.apiSchemaService.getTypePropertyKey("iotype");
    const typeFilters = types.map((t) => `${typePropertyName}=${t}`).join("|");
    const type = types.length > 1 ? `(${typeFilters})` : typeFilters;
    const filter2 = type ? `state=active,${type}` : `state=active`;
    const result = await firstValueFrom(this.entitiesService.listIoTypes(ownerId ?? "", true, 0, 300, "name", filter2));
    return result.items.map((item) => ({
      id: item.id,
      label: item.name ?? ""
    }));
  }
  async getIoValues(data) {
    if (isDefined(data?.input)) {
      try {
        const result = await firstValueFrom(this.entitiesService.getIoType(data.input));
        return [
          {
            id: "0",
            label: result?.text?.inactive ?? "inactive"
          },
          {
            id: "1",
            label: result?.text?.active ?? "active"
          }
        ];
      } catch {
        return [];
      }
    } else {
      return [];
    }
  }
  async getOverspeedBandTargetTree() {
    const ownerId = this.getOwnerId();
    const client = await firstValueFrom(this.clientDataService.fetchClientWithCache(ownerId ?? ""));
    const [vendorProfiles, clientProfiles] = await Promise.all([
      firstValueFrom(this.entitiesService.listOverspeedProfiles(client.owner.id, void 0, void 0, void 0, void 0, "state=active")),
      firstValueFrom(this.entitiesService.listOverspeedProfiles(client.id, void 0, void 0, void 0, void 0, "state=active"))
    ]);
    const items = [...vendorProfiles.items, ...clientProfiles.items].sort((a, b2) => (a.name ?? "").localeCompare(b2.name ?? ""));
    return items.map((item) => ({
      id: item.id,
      label: item.name ?? "",
      children: (item.items ?? []).map((band) => ({
        id: band.id,
        label: band.name,
        data: {
          targetType: "overspeedband",
          targetTypeId: item.id,
          targetTypeName: item.name,
          targetSelectionType: "specific",
          targetId: band.id,
          targetName: band.name,
          text: `${band.name} ${item.name} band`
        }
      }))
    }));
  }
  async getStateTargetTree() {
    const ownerId = this.getOwnerId();
    const result = await firstValueFrom(this.entitiesService.listAssetStateProfiles(ownerId ?? "", void 0, void 0, "name", "state=active"));
    return result.items.map((item) => ({
      id: item.id,
      label: item.name,
      children: item.items.map((state) => ({
        id: state.id,
        label: state.state,
        data: {
          targetType: "state",
          targetTypeId: item.id,
          targetTypeName: item.name,
          targetSelectionType: "specific",
          targetId: state.id,
          targetName: state.state,
          text: `${item.name} "${state.state} - ${state.name}"`
        }
      }))
    }));
  }
  async getStateTargetList() {
    const ownerId = this.getOwnerId();
    const result = await firstValueFrom(this.entitiesService.listAssetStateProfiles(ownerId ?? "", void 0, void 0, "name", "state=active"));
    return result.items.map((item) => ({
      id: item.id,
      label: item.name
    }));
  }
  async getStateValues(data) {
    if (isDefined(data?.profile)) {
      return firstValueFrom(this.entitiesService.getAssetStateProfile(data.profile)).then((result) => {
        return (result.items ?? []).map((item) => ({
          id: item.state,
          label: item.state
        }));
      }).catch(() => {
        return [];
      });
    } else {
      return [];
    }
  }
  getConditionsTree(action) {
    return Object.keys(this.EVENT_CONDITIONS).filter((key) => {
      switch (key) {
        case "distance":
          return action.eventClass === "fuelingevent" || action.eventClass === "overspeedevent" && action.eventType === "band_end";
        case "duration":
          return action.eventClass === "overspeedevent" && action.eventType === "band_end";
        default:
          return true;
      }
    }).map((key) => ({
      id: key,
      label: getConditionTypeDisplayName(key.toUpperCase()),
      data: {
        type: key,
        values: {},
        text: {}
      }
    }));
  }
  replacePlaceholders(template, data) {
    return template.replaceAll(/\{\{([^}]+)\}\}/g, (_m, key) => {
      const v2 = data[key.trim()];
      if (v2 === void 0 || v2 === null)
        return "";
      if (typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean") {
        return String(v2);
      }
      if (Array.isArray(v2)) {
        return v2.map((x) => typeof x === "string" || typeof x === "number" || typeof x === "boolean" ? String(x) : "").filter(Boolean).join(", ");
      }
      return "";
    });
  }
  isRecord(value) {
    return typeof value === "object" && value !== null;
  }
  getPrecomputedText(value) {
    const displayValue = value["display"];
    if (typeof displayValue === "string" && displayValue.trim() !== "") {
      return displayValue;
    }
    const textValue = value["text"];
    if (typeof textValue === "string" && textValue.trim() !== "") {
      return this.replacePlaceholders(textValue, value);
    }
    return void 0;
  }
  formatAction(value) {
    const pre = this.getPrecomputedText(value);
    if (pre !== void 0) {
      return pre;
    }
    const eventType = value["eventType"];
    if (typeof eventType === "string" && eventType.length > 0) {
      return eventType.replaceAll("_", " ");
    }
    const eventClass = value["eventClass"];
    if (typeof eventClass === "string" && eventClass.length > 0) {
      return eventClass.replaceAll("_", " ");
    }
    return "action";
  }
  formatActor(value) {
    const pre = this.getPrecomputedText(value);
    if (isDefined(pre)) {
      return pre;
    }
    const actorName = value["actorName"];
    const actorTypeName = value["actorTypeName"];
    const actorType = value["actorType"];
    if (isDefined(actorName)) {
      return actorName;
    }
    if (isDefined(actorTypeName)) {
      return actorTypeName;
    }
    if (isDefined(actorType)) {
      return actorType;
    }
    return "actor";
  }
  formatTarget(value) {
    const pre = this.getPrecomputedText(value);
    if (isDefined(pre)) {
      return pre;
    }
    const targetName = value["targetName"];
    const targetTypeName = value["targetTypeName"];
    const targetType = value["targetType"];
    if (isDefined(targetName) && targetName) {
      return targetName;
    }
    if (isDefined(targetTypeName) && targetTypeName) {
      return targetTypeName;
    }
    if (isDefined(targetType) && targetType) {
      return targetType;
    }
    return "target";
  }
  formatValueText(value, lookupType) {
    if (!value)
      return `[${lookupType}]`;
    switch (lookupType) {
      case "action":
        return this.formatAction(value);
      case "actor":
        return this.formatActor(value);
      case "target":
        return this.formatTarget(value);
      default:
        return `[${lookupType}]`;
    }
  }
  formatConditionText(conditionText) {
    if (typeof conditionText === "string") {
      return conditionText;
    }
    if (this.isRecord(conditionText)) {
      return Object.values(conditionText).filter((v2) => {
        if (Array.isArray(v2))
          return v2.length > 0;
        return isDefined(v2) && v2 !== "" && (typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean");
      }).map((v2) => Array.isArray(v2) ? v2.join(", ") : String(v2)).join(" ");
    }
    if (Array.isArray(conditionText)) {
      return conditionText.join(", ");
    }
    if (isDefined(conditionText) && (typeof conditionText === "string" || typeof conditionText === "number" || typeof conditionText === "boolean")) {
      return String(conditionText);
    }
    return "";
  }
  valueToText(value) {
    if (Array.isArray(value)) {
      return value.map((v2) => this.valueToText(v2)).filter(Boolean).join(", ");
    }
    if (this.isRecord(value)) {
      const o = value;
      const c2 = o["name"] ?? o["label"] ?? o["text"] ?? o["targetName"] ?? o["actorName"] ?? o["targetTypeName"] ?? o["actorTypeName"];
      if (isDefined(c2) && (typeof c2 === "string" || typeof c2 === "number" || typeof c2 === "boolean")) {
        return String(c2);
      }
      return "";
    }
    if (isDefined(value) && (typeof value === "string" || typeof value === "number" || typeof value === "boolean")) {
      return String(value);
    }
    return "";
  }
  mapDow(dow) {
    const names = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    let vals = [];
    if (Array.isArray(dow)) {
      vals = dow.map(String);
    } else if (typeof dow === "string") {
      vals = dow.split(",").map((s3) => s3.trim()).filter(Boolean);
    } else {
      return this.valueToText(dow);
    }
    return vals.map((s3) => {
      const idx = Number(s3);
      return Number.isFinite(idx) && idx >= 0 && idx <= 6 ? names[idx] : s3;
    }).join(", ");
  }
  renderCondition(type, text) {
    if (!this.isRecord(text)) {
      return this.formatConditionText(text);
    }
    const pre = this.getPrecomputedText(text);
    if (pre !== void 0) {
      return pre;
    }
    const conditionType = type.toLowerCase();
    switch (conditionType) {
      case "time":
        return this.renderTimeCondition(text);
      case "zone":
        return this.renderZoneCondition(text);
      case "linked":
        return this.renderLinkedCondition(text);
      case "active":
        return this.renderActiveCondition(text);
      case "speed":
        return this.renderSpeedCondition(text);
      case "distance":
        return this.renderDistanceCondition(text);
      case "duration":
        return this.renderDurationCondition(text);
      case "digital":
        return this.renderDigitalCondition(text);
      case "state":
        return this.renderStateCondition(text);
      default:
        return this.formatConditionText(text);
    }
  }
  renderTimeCondition(text) {
    const modeRaw = typeof text["mode"] === "string" ? text["mode"] : "";
    const mode = this.getModeText(modeRaw, "inside", "between", "outside", "outside of");
    const time1 = this.valueToText(text["time1"]);
    const time2 = this.valueToText(text["time2"]);
    const dow = this.mapDow(text["dow"]);
    const parts = [
      "time is",
      mode,
      time1 && time2 ? `${time1} and ${time2}` : time1 || time2 || "",
      dow ? `on ${dow}` : ""
    ].filter(Boolean);
    return parts.join(" ");
  }
  renderZoneCondition(text) {
    const modeRaw = typeof text["mode"] === "string" ? text["mode"] : "";
    const mode = this.getModeText(modeRaw, "inside", "inside", "outside", "outside");
    const zone = this.valueToText(text["zone"]);
    return `current position is ${mode} of ${zone}`;
  }
  renderLinkedCondition(text) {
    const modeRaw = typeof text["mode"] === "string" ? text["mode"] : "";
    const mode = this.getModeText(modeRaw, "in", "is", "out", "is not");
    const asset = this.valueToText(text["asset"]);
    return `current linked asset ${mode} ${asset}`;
  }
  renderActiveCondition(text) {
    const stateRaw = this.valueToText(text["state"]);
    const state = stateRaw === "0" ? "Off" : stateRaw === "1" ? "On" : stateRaw;
    return `ignition is ${state}`;
  }
  renderSpeedCondition(text) {
    const modeRaw = typeof text["mode"] === "string" ? text["mode"] : "";
    const mode = this.getComparisonMode(modeRaw);
    const speed = this.valueToText(text["speed"]);
    return `speed is ${mode} than ${speed}`;
  }
  renderDistanceCondition(text) {
    const modeRaw = typeof text["mode"] === "string" ? text["mode"] : "";
    const mode = this.getComparisonMode(modeRaw);
    const distance = this.valueToText(text["distance"]);
    return `distance is ${mode} than ${distance}`;
  }
  renderDurationCondition(text) {
    const modeRaw = typeof text["mode"] === "string" ? text["mode"] : "";
    const mode = this.getComparisonMode(modeRaw);
    const duration = this.valueToText(text["duration"]);
    return `duration is ${mode} than ${duration}`;
  }
  renderDigitalCondition(text) {
    const pre = this.getPrecomputedText(text);
    if (pre !== void 0) {
      return pre;
    }
    const input2 = this.valueToText(text["inputName"] ?? text["input"]);
    const stateRaw = this.valueToText(text["stateName"] ?? text["state"]);
    const state = stateRaw === "0" ? "inactive" : stateRaw === "1" ? "active" : stateRaw;
    return `digital ${input2} is ${state}`;
  }
  renderStateCondition(text) {
    const pre = this.getPrecomputedText(text);
    if (pre !== void 0) {
      return pre;
    }
    const profile = this.valueToText(text["profileName"] ?? text["profile"]);
    const state = this.valueToText(text["stateName"] ?? text["state"]);
    return `state ${profile} is ${state}`;
  }
  getModeText(modeRaw, firstCondition, firstResult, secondCondition, secondResult) {
    if (modeRaw === firstCondition) {
      return firstResult;
    } else if (modeRaw === secondCondition) {
      return secondResult;
    } else {
      return this.valueToText(modeRaw);
    }
  }
  getComparisonMode(modeRaw) {
    return modeRaw === "greater" ? "greater" : modeRaw === "less" ? "less" : this.valueToText(modeRaw);
  }
  formatConditions(conditions) {
    if (!conditions || conditions.length === 0)
      return "";
    return conditions.map((condition) => {
      const type = condition?.type;
      if (typeof type === "string" && type !== "null" && type.length > 0) {
        let t = this.renderCondition(type, condition?.text);
        if (t === "") {
          t = type;
        }
        return ` and (${t})`;
      }
      return "";
    }).join("");
  }
  getEventFilterText(filter2) {
    if (isNullOrUndefined(filter2)) {
      return "";
    }
    const filterObject = filter2;
    const actorRaw = filterObject["actor"];
    const actionRaw = filterObject["action"];
    const targetRaw = filterObject["target"];
    const actorVal = this.isRecord(actorRaw) ? actorRaw : void 0;
    const actionVal = this.isRecord(actionRaw) ? actionRaw : void 0;
    const targetVal = this.isRecord(targetRaw) ? targetRaw : void 0;
    const actorText = this.formatValueText(actorVal, "actor");
    const actionText = this.formatValueText(actionVal, "action");
    const targetText = this.formatValueText(targetVal, "target");
    let str = actorVal ? "When {actor} {action} {target}" : "{action} {target}";
    str = str.replace("{actor}", actorText).replace("{action}", actionText);
    const hasTarget = !!actionVal && typeof actionVal["targetType"] === "string" && actionVal["targetType"].length > 0;
    if (hasTarget) {
      str = str.replace("{target}", targetText);
    } else {
      str = str.replace(" {target}", "");
    }
    str += this.formatConditions(filter2.conditions);
    str += ".";
    return str;
  }
  static \u0275fac = function EventFilterService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EventFilterService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _EventFilterService, factory: _EventFilterService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventFilterService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/components/forms/event-filter-field/target-selector/target-selector.component.ts
function TargetSelectorComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 0);
    \u0275\u0275listener("click", function TargetSelectorComponent_Conditional_0_Template_span_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showTargetDropdown = true);
    })("keydown.enter", function TargetSelectorComponent_Conditional_0_Template_span_keydown_enter_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showTargetDropdown = true);
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "p-overlay", 1);
    \u0275\u0275twoWayListener("visibleChange", function TargetSelectorComponent_Conditional_0_Template_p_overlay_visibleChange_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.showTargetDropdown, $event) || (ctx_r1.showTargetDropdown = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementStart(3, "div", 2)(4, "p-select", 3);
    \u0275\u0275twoWayListener("ngModelChange", function TargetSelectorComponent_Conditional_0_Template_p_select_ngModelChange_4_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.target, $event) || (ctx_r1.target = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("onChange", function TargetSelectorComponent_Conditional_0_Template_p_select_onChange_4_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onTargetSelected());
    });
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    let tmp_1_0;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ((tmp_1_0 = ctx_r1.target()) == null ? null : tmp_1_0["label"]) || "target", " ");
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("visible", ctx_r1.showTargetDropdown);
    \u0275\u0275advance(2);
    \u0275\u0275property("options", ctx_r1.targets());
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.target);
    \u0275\u0275property("showClear", true);
  }
}
var TargetSelectorComponent = class _TargetSelectorComponent {
  targetType = input(void 0, ...ngDevMode ? [{ debugName: "targetType" }] : []);
  targets = input([], ...ngDevMode ? [{ debugName: "targets" }] : []);
  showTargetDropdown = false;
  target = model(void 0, ...ngDevMode ? [{ debugName: "target" }] : []);
  onTargetSelected() {
    this.showTargetDropdown = false;
  }
  static \u0275fac = function TargetSelectorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TargetSelectorComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _TargetSelectorComponent, selectors: [["app-target-selector"]], inputs: { targetType: [1, "targetType"], targets: [1, "targets"], target: [1, "target"] }, outputs: { target: "targetChange" }, decls: 1, vars: 1, consts: [[1, "underlined-field", "cursor-pointer", 3, "click", "keydown.enter"], ["appendTo", "body", 3, "visibleChange", "visible"], [1, "dropdown-panel", "p-3", "surface-card", "shadow-2", "border-round"], ["placeholder", "Select Target", "optionLabel", "label", 1, "w-full", "min-w-[200px]", 3, "ngModelChange", "onChange", "options", "ngModel", "showClear"]], template: function TargetSelectorComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275conditionalCreate(0, TargetSelectorComponent_Conditional_0_Template, 5, 5);
    }
    if (rf & 2) {
      \u0275\u0275conditional(ctx.targetType() ? 0 : -1);
    }
  }, dependencies: [CommonModule, FormsModule, NgControlStatus, NgModel, OverlayModule, Overlay, SelectModule, Select], styles: ["\n\n[_nghost-%COMP%] {\n  --p-treeselect-background: var(--p-tree-background) !important;\n}\n[_nghost-%COMP%]   .p-treeselect-label.p-placeholder[_ngcontent-%COMP%] {\n  color: var(--p-select-option-color);\n}\n/*# sourceMappingURL=target-selector.component.css.map */"], changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TargetSelectorComponent, [{
    type: Component,
    args: [{ selector: "app-target-selector", imports: [CommonModule, FormsModule, OverlayModule, SelectModule], changeDetection: ChangeDetectionStrategy.OnPush, template: `@if (targetType()) {
  <span
    class="underlined-field cursor-pointer"
    (click)="showTargetDropdown = true"
    (keydown.enter)="showTargetDropdown = true"
  >
    {{ target()?.['label'] || 'target' }}
  </span>
  <p-overlay [(visible)]="showTargetDropdown" appendTo="body">
    <div class="dropdown-panel p-3 surface-card shadow-2 border-round">
      <p-select
        [options]="targets()"
        [(ngModel)]="target"
        (onChange)="onTargetSelected()"
        placeholder="Select Target"
        optionLabel="label"
        [showClear]="true"
        class="w-full min-w-[200px]"
      ></p-select>
    </div>
  </p-overlay>
}
`, styles: ["/* src/app/shared/components/forms/event-filter-field/target-selector/target-selector.component.scss */\n:host {\n  --p-treeselect-background: var(--p-tree-background) !important;\n}\n:host .p-treeselect-label.p-placeholder {\n  color: var(--p-select-option-color);\n}\n/*# sourceMappingURL=target-selector.component.css.map */\n"] }]
  }], null, { targetType: [{ type: Input, args: [{ isSignal: true, alias: "targetType", required: false }] }], targets: [{ type: Input, args: [{ isSignal: true, alias: "targets", required: false }] }], target: [{ type: Input, args: [{ isSignal: true, alias: "target", required: false }] }, { type: Output, args: ["targetChange"] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(TargetSelectorComponent, { className: "TargetSelectorComponent", filePath: "src/app/shared/components/forms/event-filter-field/target-selector/target-selector.component.ts", lineNumber: 23 });
})();

// src/app/shared/components/forms/event-filter-field/condition-list/condition-list.component.ts
function ConditionListComponent_Conditional_1_For_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-button", 12);
    \u0275\u0275listener("onClick", function ConditionListComponent_Conditional_1_For_2_Conditional_5_Template_p_button_onClick_0_listener() {
      \u0275\u0275restoreView(_r7);
      const condition_r3 = \u0275\u0275nextContext().$implicit;
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.onConditionRemoved(condition_r3));
    });
    \u0275\u0275elementEnd();
  }
}
function ConditionListComponent_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 8)(1, "div", 9)(2, "div", 10);
    \u0275\u0275listener("click", function ConditionListComponent_Conditional_1_For_2_Template_div_click_2_listener() {
      const ctx_r1 = \u0275\u0275restoreView(_r1);
      const condition_r3 = ctx_r1.$implicit;
      const \u0275$index_6_r4 = ctx_r1.$index;
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.onConditionClicked(condition_r3, \u0275$index_6_r4));
    })("keydown.enter", function ConditionListComponent_Conditional_1_For_2_Template_div_keydown_enter_2_listener() {
      const ctx_r5 = \u0275\u0275restoreView(_r1);
      const condition_r3 = ctx_r5.$implicit;
      const \u0275$index_6_r4 = ctx_r5.$index;
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.onConditionClicked(condition_r3, \u0275$index_6_r4));
    });
    \u0275\u0275elementStart(3, "span");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
    \u0275\u0275conditionalCreate(5, ConditionListComponent_Conditional_1_For_2_Conditional_5_Template, 1, 0, "p-button", 11);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const condition_r3 = ctx.$implicit;
    const \u0275$index_6_r4 = ctx.$index;
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate2("", \u0275$index_6_r4 === 0 ? "If" : "And", " ", ctx_r4.displayConditionText(condition_r3));
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r4.canRemoveCondition() ? 5 : -1);
  }
}
function ConditionListComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275repeaterCreate(1, ConditionListComponent_Conditional_1_For_2_Template, 6, 3, "div", 8, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r4.conditions());
  }
}
var ConditionListComponent = class _ConditionListComponent {
  conditions = input([], ...ngDevMode ? [{ debugName: "conditions" }] : []);
  availableConditions = input([], ...ngDevMode ? [{ debugName: "availableConditions" }] : []);
  minConditions = input(0, ...ngDevMode ? [{ debugName: "minConditions" }] : []);
  editCondition = output();
  removeCondition = output();
  addCondition = output();
  showConditionDropdown = false;
  conditionFormControl = new FormControl(null);
  // Method to display human-readable condition text
  displayConditionText(condition) {
    if (isNullOrUndefined(condition))
      return "";
    if (isDefined(condition.text["display"])) {
      return condition.text["display"].trim();
    }
    let displayText = "";
    switch (condition.type) {
      case "speed": {
        const value = condition.values["value"] ?? "0";
        const unit = condition.values["unit"] ?? "mph";
        const operator = condition.values["operator"] ?? "gt";
        let operatorText = "equal to";
        if (operator === "gt") {
          operatorText = "greater than";
        } else if (operator === "lt") {
          operatorText = "less than";
        }
        displayText = `speed is ${operatorText} ${value} ${unit}`;
        break;
      }
      case "time": {
        const time = condition.values["time"] ?? "00:00";
        displayText = `time is ${time}`;
        break;
      }
      case "zone": {
        const zoneName = condition.values["zoneName"] ?? condition.text["zoneName"] ?? "unknown zone";
        displayText = `inside zone ${zoneName}`;
        break;
      }
      case "distance": {
        const value = condition.values["value"] ?? "0";
        const unit = condition.values["unit"] ?? "mi";
        displayText = `distance is ${value} ${unit}`;
        break;
      }
      case "duration": {
        const value = condition.values["value"] ?? "0";
        const unit = condition.values["unit"] ?? "seconds";
        displayText = `duration is ${value} ${unit}`;
        break;
      }
      case "days": {
        const days = condition.values["days"] ?? [];
        if (days.length > 0) {
          displayText = `on days: ${days.join(", ")}`;
        } else {
          displayText = "on all days";
        }
        break;
      }
      case "active": {
        displayText = "condition is active";
        break;
      }
      default:
        displayText = `condition of type ${condition.type}`;
    }
    return displayText;
  }
  onConditionClicked(condition, index) {
    this.editCondition.emit({ condition, index });
  }
  onConditionRemoved(condition) {
    if (this.conditions().length > this.minConditions()) {
      this.removeCondition.emit(condition);
    }
  }
  onConditionSelected(event) {
    if (isDefined(event?.node)) {
      this.addCondition.emit(event.node);
      this.showConditionDropdown = false;
      this.conditionFormControl.reset();
    }
  }
  canRemoveCondition() {
    return this.conditions().length > this.minConditions();
  }
  static \u0275fac = function ConditionListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ConditionListComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ConditionListComponent, selectors: [["app-condition-list"]], inputs: { conditions: [1, "conditions"], availableConditions: [1, "availableConditions"], minConditions: [1, "minConditions"] }, outputs: { editCondition: "editCondition", removeCondition: "removeCondition", addCondition: "addCondition" }, decls: 9, vars: 6, consts: [[1, "condition-list"], [1, "condition-items", "mb-3"], [1, "add-condition-section"], [1, "p-relative"], [1, "underlined-field", "cursor-pointer", 3, "click", "keydown.enter"], [3, "visibleChange", "visible", "appendTo"], [1, "p-0", "border-round"], ["placeholder", "Search condition types...", "selectionMode", "single", "appendTo", "body", 1, "w-full", "bg-(--p-tree-background)", "min-w-[200px]", 3, "onNodeSelect", "options", "formControl", "filter"], [1, "condition-item"], [1, "flex", "items-center", "px-3", "py-2", "rounded", "mb-2", "w-full", "justify-between", "condition-display"], ["pTooltip", "Click to edit condition", 1, "condition-text", "flex-grow-1", "cursor-pointer", 3, "click", "keydown.enter"], ["icon", "pi pi-times", "pTooltip", "Remove condition"], ["icon", "pi pi-times", "pTooltip", "Remove condition", 3, "onClick"]], template: function ConditionListComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275conditionalCreate(1, ConditionListComponent_Conditional_1_Template, 3, 0, "div", 1);
      \u0275\u0275elementStart(2, "div", 2)(3, "div", 3)(4, "span", 4);
      \u0275\u0275listener("click", function ConditionListComponent_Template_span_click_4_listener() {
        return ctx.showConditionDropdown = !ctx.showConditionDropdown;
      })("keydown.enter", function ConditionListComponent_Template_span_keydown_enter_4_listener() {
        return ctx.showConditionDropdown = !ctx.showConditionDropdown;
      });
      \u0275\u0275text(5, " and ");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(6, "p-overlay", 5);
      \u0275\u0275twoWayListener("visibleChange", function ConditionListComponent_Template_p_overlay_visibleChange_6_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.showConditionDropdown, $event) || (ctx.showConditionDropdown = $event);
        return $event;
      });
      \u0275\u0275elementStart(7, "div", 6)(8, "p-treeselect", 7);
      \u0275\u0275listener("onNodeSelect", function ConditionListComponent_Template_p_treeselect_onNodeSelect_8_listener($event) {
        return ctx.onConditionSelected($event);
      });
      \u0275\u0275elementEnd()()()()()();
    }
    if (rf & 2) {
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.conditions().length > 0 ? 1 : -1);
      \u0275\u0275advance(5);
      \u0275\u0275twoWayProperty("visible", ctx.showConditionDropdown);
      \u0275\u0275property("appendTo", "body");
      \u0275\u0275advance(2);
      \u0275\u0275property("options", ctx.availableConditions())("formControl", ctx.conditionFormControl)("filter", true);
    }
  }, dependencies: [
    CommonModule,
    FormsModule,
    NgControlStatus,
    ReactiveFormsModule,
    FormControlDirective,
    ButtonModule,
    Button,
    TreeSelectModule,
    TreeSelect,
    OverlayModule,
    Overlay,
    TooltipModule,
    Tooltip
  ], styles: ["\n\n.underlined-field[_ngcontent-%COMP%] {\n  color: green;\n  font-weight: 500;\n  padding: 0.25rem 0;\n}\n.underlined-field[_ngcontent-%COMP%]:hover {\n  text-decoration: underline;\n}\n.underlined-field.disabled-text[_ngcontent-%COMP%] {\n  color: #ccc;\n  cursor: not-allowed;\n}\n.underlined-field.disabled-text[_ngcontent-%COMP%]:hover {\n  color: #ccc;\n  text-decoration: underline;\n}\n.dropdown-panel[_ngcontent-%COMP%] {\n  min-width: 250px;\n}\n.condition-item[_ngcontent-%COMP%] {\n  display: flex;\n  justify-content: space-between;\n  padding-top: calc(var(--padding) / 2);\n}\n.condition-editor[_ngcontent-%COMP%]   .field[_ngcontent-%COMP%] {\n  margin-bottom: 1rem;\n}\n.condition-editor[_ngcontent-%COMP%]   .field[_ngcontent-%COMP%]   label[_ngcontent-%COMP%] {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n}\n.condition-editor[_ngcontent-%COMP%]   .field-checkbox[_ngcontent-%COMP%] {\n  margin-bottom: 0.5rem;\n}\n.condition-editor[_ngcontent-%COMP%]   .checklist[_ngcontent-%COMP%] {\n  max-height: 200px;\n  overflow-y: auto;\n  border: 1px solid #ced4da;\n  border-radius: 4px;\n  padding: 8px;\n}\n.condition-list[_ngcontent-%COMP%]   .condition-items[_ngcontent-%COMP%]   .condition-item[_ngcontent-%COMP%]   .condition-display[_ngcontent-%COMP%] {\n  border: 1px solid;\n  transition: all 0.2s;\n}\n.condition-list[_ngcontent-%COMP%]   .condition-items[_ngcontent-%COMP%]   .condition-item[_ngcontent-%COMP%]   .condition-display[_ngcontent-%COMP%]:hover {\n  box-shadow: 0 0 0 0.2rem rgba(63, 81, 181, 0.1);\n}\n.condition-list[_ngcontent-%COMP%]   .condition-items[_ngcontent-%COMP%]   .condition-item[_ngcontent-%COMP%]   .condition-display[_ngcontent-%COMP%]   .condition-text[_ngcontent-%COMP%] {\n  line-height: 1.5;\n}\n.condition-list[_ngcontent-%COMP%]   .empty-conditions[_ngcontent-%COMP%] {\n  border-style: dashed;\n  color: #6c757d;\n}\n.condition-list[_ngcontent-%COMP%]   .add-condition-section[_ngcontent-%COMP%] {\n  margin-top: 0.5rem;\n}\n.condition-list[_ngcontent-%COMP%]   .condition-dropdown[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%] {\n  font-size: 1rem;\n  margin-top: 0;\n}\n.p-error[_ngcontent-%COMP%] {\n  font-size: 0.875rem;\n}\n[_nghost-%COMP%] {\n  --p-treeselect-background: var(--p-tree-background) !important;\n}\n/*# sourceMappingURL=condition-list.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConditionListComponent, [{
    type: Component,
    args: [{ selector: "app-condition-list", imports: [
      CommonModule,
      FormsModule,
      ReactiveFormsModule,
      ButtonModule,
      TreeSelectModule,
      OverlayModule,
      TooltipModule
    ], template: `<div class="condition-list">
  <!-- List of current conditions -->
  @if (conditions().length > 0) {
    <div class="condition-items mb-3">
      @for (condition of conditions(); track $index; let i = $index) {
        <div class="condition-item">
          <div
            class="flex items-center px-3 py-2 rounded mb-2 w-full justify-between condition-display"
          >
            <div
              class="condition-text flex-grow-1 cursor-pointer"
              (click)="onConditionClicked(condition, i)"
              (keydown.enter)="onConditionClicked(condition, i)"
              pTooltip="Click to edit condition"
            >
              <span
                >{{ i === 0 ? 'If' : 'And' }}
                {{ displayConditionText(condition) }}</span
              >
            </div>
            @if (canRemoveCondition()) {
              <p-button
                icon="pi pi-times"
                (onClick)="onConditionRemoved(condition)"
                pTooltip="Remove condition"
              ></p-button>
            }
          </div>
        </div>
      }
    </div>
  }

  <!-- Add condition dropdown -->
  <div class="add-condition-section">
    <div class="p-relative">
      <span
        class="underlined-field cursor-pointer"
        (click)="showConditionDropdown = !showConditionDropdown"
        (keydown.enter)="showConditionDropdown = !showConditionDropdown"
      >
        and
      </span>

      <p-overlay [(visible)]="showConditionDropdown" [appendTo]="'body'">
        <div class="p-0 border-round">
          <p-treeselect
            [options]="availableConditions()"
            placeholder="Search condition types..."
            [formControl]="conditionFormControl"
            selectionMode="single"
            appendTo="body"
            [filter]="true"
            (onNodeSelect)="onConditionSelected($event)"
            class="w-full bg-(--p-tree-background) min-w-[200px]"
          ></p-treeselect>
        </div>
      </p-overlay>
    </div>
  </div>
</div>
`, styles: ["/* src/app/shared/components/forms/event-filter-field/condition-list/condition-list.component.scss */\n.underlined-field {\n  color: green;\n  font-weight: 500;\n  padding: 0.25rem 0;\n}\n.underlined-field:hover {\n  text-decoration: underline;\n}\n.underlined-field.disabled-text {\n  color: #ccc;\n  cursor: not-allowed;\n}\n.underlined-field.disabled-text:hover {\n  color: #ccc;\n  text-decoration: underline;\n}\n.dropdown-panel {\n  min-width: 250px;\n}\n.condition-item {\n  display: flex;\n  justify-content: space-between;\n  padding-top: calc(var(--padding) / 2);\n}\n.condition-editor .field {\n  margin-bottom: 1rem;\n}\n.condition-editor .field label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n}\n.condition-editor .field-checkbox {\n  margin-bottom: 0.5rem;\n}\n.condition-editor .checklist {\n  max-height: 200px;\n  overflow-y: auto;\n  border: 1px solid #ced4da;\n  border-radius: 4px;\n  padding: 8px;\n}\n.condition-list .condition-items .condition-item .condition-display {\n  border: 1px solid;\n  transition: all 0.2s;\n}\n.condition-list .condition-items .condition-item .condition-display:hover {\n  box-shadow: 0 0 0 0.2rem rgba(63, 81, 181, 0.1);\n}\n.condition-list .condition-items .condition-item .condition-display .condition-text {\n  line-height: 1.5;\n}\n.condition-list .empty-conditions {\n  border-style: dashed;\n  color: #6c757d;\n}\n.condition-list .add-condition-section {\n  margin-top: 0.5rem;\n}\n.condition-list .condition-dropdown h3 {\n  font-size: 1rem;\n  margin-top: 0;\n}\n.p-error {\n  font-size: 0.875rem;\n}\n:host {\n  --p-treeselect-background: var(--p-tree-background) !important;\n}\n/*# sourceMappingURL=condition-list.component.css.map */\n"] }]
  }], null, { conditions: [{ type: Input, args: [{ isSignal: true, alias: "conditions", required: false }] }], availableConditions: [{ type: Input, args: [{ isSignal: true, alias: "availableConditions", required: false }] }], minConditions: [{ type: Input, args: [{ isSignal: true, alias: "minConditions", required: false }] }], editCondition: [{ type: Output, args: ["editCondition"] }], removeCondition: [{ type: Output, args: ["removeCondition"] }], addCondition: [{ type: Output, args: ["addCondition"] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ConditionListComponent, { className: "ConditionListComponent", filePath: "src/app/shared/components/forms/event-filter-field/condition-list/condition-list.component.ts", lineNumber: 29 });
})();

// src/app/shared/components/searchable-tree/searchable-tree.component.ts
var _c019 = ["searchInput"];
var _c116 = ["treePanel"];
var _c211 = (a0) => ({ "p-disabled": a0 });
var _c310 = (a0) => ({ "cursor-pointer": a0 });
function SearchableTreeComponent_Conditional_4_Conditional_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13);
    \u0275\u0275element(1, "i", 14);
    \u0275\u0275elementEnd();
  }
}
function SearchableTreeComponent_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 8)(1, "div", 3)(2, "input", 12, 1);
    \u0275\u0275twoWayListener("ngModelChange", function SearchableTreeComponent_Conditional_4_Conditional_2_Template_input_ngModelChange_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r2.searchValue, $event) || (ctx_r2.searchValue = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function SearchableTreeComponent_Conditional_4_Conditional_2_Template_input_ngModelChange_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onSearchInput($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(4, SearchableTreeComponent_Conditional_4_Conditional_2_Conditional_4_Template, 2, 0, "div", 13);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275property("placeholder", ctx_r2.searchPlaceholder);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.searchValue);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r2.isSearching ? 4 : -1);
  }
}
function SearchableTreeComponent_Conditional_4_Conditional_3_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 17);
    \u0275\u0275listener("click", function SearchableTreeComponent_Conditional_4_Conditional_3_For_3_Template_li_click_0_listener() {
      const result_r6 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.onSearchResultSelect(result_r6));
    })("keydown.enter", function SearchableTreeComponent_Conditional_4_Conditional_3_For_3_Template_li_keydown_enter_0_listener() {
      const result_r6 = \u0275\u0275restoreView(_r5).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.onSearchResultSelect(result_r6));
    });
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const result_r6 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(result_r6.value);
  }
}
function SearchableTreeComponent_Conditional_4_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 9)(1, "ul", 15);
    \u0275\u0275repeaterCreate(2, SearchableTreeComponent_Conditional_4_Conditional_3_For_3_Template, 3, 1, "li", 16, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r2.searchNodes);
  }
}
function SearchableTreeComponent_Conditional_4_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 10)(1, "p-tree", 18);
    \u0275\u0275listener("onNodeSelect", function SearchableTreeComponent_Conditional_4_Conditional_4_Template_p_tree_onNodeSelect_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onNodeSelect($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r2.nodes)("emptyMessage", "No data available");
  }
}
function SearchableTreeComponent_Conditional_4_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275text(1, "No data available");
    \u0275\u0275elementEnd();
  }
}
function SearchableTreeComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-overlay", 6);
    \u0275\u0275twoWayListener("visibleChange", function SearchableTreeComponent_Conditional_4_Template_p_overlay_visibleChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r2.showDropdown, $event) || (ctx_r2.showDropdown = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementStart(1, "div", 7);
    \u0275\u0275conditionalCreate(2, SearchableTreeComponent_Conditional_4_Conditional_2_Template, 5, 3, "div", 8);
    \u0275\u0275conditionalCreate(3, SearchableTreeComponent_Conditional_4_Conditional_3_Template, 4, 0, "div", 9);
    \u0275\u0275conditionalCreate(4, SearchableTreeComponent_Conditional_4_Conditional_4_Template, 2, 2, "div", 10);
    \u0275\u0275conditionalCreate(5, SearchableTreeComponent_Conditional_4_Conditional_5_Template, 2, 0, "div", 11);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    const treePanel_r8 = \u0275\u0275reference(1);
    \u0275\u0275styleProp("--trigger-w", (treePanel_r8 == null ? null : treePanel_r8.offsetWidth) || 250, "px");
    \u0275\u0275twoWayProperty("visible", ctx_r2.showDropdown);
    \u0275\u0275property("appendTo", "body");
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r2.searchEnabled ? 2 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r2.searchNodes.length > 0 ? 3 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r2.nodes.length > 0 ? 4 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r2.searchNodes.length === 0 && ctx_r2.nodes.length === 0 ? 5 : -1);
  }
}
var SearchableTreeComponent = class _SearchableTreeComponent {
  treeData = [];
  searchEnabled = true;
  searchPlaceholder = "Search...";
  valueField = "name";
  childrenField = "children";
  idField = "id";
  expandedByDefault = false;
  debounceTime = 300;
  clientId;
  entityType;
  displayField = "label";
  disabled = false;
  nodeSelected = new EventEmitter();
  searchChanged = new EventEmitter();
  searchInput;
  treePanel;
  nodes = [];
  searchValue = "";
  displayValue = "";
  searchNodes = [];
  flattenedNodes = [];
  isSearching = false;
  showDropdown = false;
  // Control value accessor properties
  onChange = () => {
  };
  onTouched = () => {
  };
  innerValue = null;
  searchSubject = new Subject();
  destroyRef = inject(DestroyRef);
  entitiesService = inject(EntitiesService);
  cdr = inject(ChangeDetectorRef);
  constructor() {
  }
  ngOnInit() {
    this.transformData();
    this.setupSearchDebounce();
    this.updateDisplayValueFromSelection();
    document.addEventListener("click", this.onDocumentClick.bind(this));
  }
  ngOnChanges(changes) {
    if (isDefined(changes["treeData"])) {
      this.transformData();
    }
    if (isDefined(changes["selectedNodeKey"])) {
      this.updateDisplayValueFromSelection();
    }
  }
  ngOnDestroy() {
    document.removeEventListener("click", this.onDocumentClick.bind(this));
  }
  // ControlValueAccessor implementation
  writeValue(value) {
    if (value !== this.innerValue) {
      this.innerValue = value;
      if (isDefined(value)) {
        if (typeof value === "object" && value !== null) {
          this.selectedNodeKey = value[this.idField] ?? null;
        } else {
          this.selectedNodeKey = value;
        }
        this.updateDisplayValueFromSelection();
      } else {
        this.selectedNodeKey = null;
        this.displayValue = "";
      }
      this.cdr.markForCheck();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cdr.markForCheck();
  }
  // Our component's public properties
  selectedNodeKey = null;
  onDocumentClick(event) {
    if (this.showDropdown && isNullOrUndefined(this.treePanel?.nativeElement?.contains(event.target)) && isNullOrUndefined(this.searchInput?.nativeElement?.contains(event.target))) {
      this.closeDropdown();
      this.cdr.markForCheck();
    }
  }
  updateDisplayValueFromSelection() {
    if (isDefined(this.selectedNodeKey)) {
      const selectedNode = this.findNodeById(this.selectedNodeKey);
      if (selectedNode) {
        this.displayValue = selectedNode.label ?? "";
        this.cdr.markForCheck();
      } else if (typeof this.innerValue === "object" && this.innerValue !== null) {
        this.displayValue = this.innerValue[this.displayField] ?? this.innerValue[this.valueField] ?? "";
      }
    }
  }
  findNodeById(id) {
    const findNode = (nodes) => {
      for (const node of nodes) {
        if (node.key === id) {
          return node;
        }
        if (node.children) {
          const foundNode = findNode(node.children);
          if (foundNode)
            return foundNode;
        }
      }
      return null;
    };
    return findNode(this.nodes);
  }
  setupSearchDebounce() {
    this.searchSubject.pipe(debounceTime(this.debounceTime), distinctUntilChanged(), takeUntilDestroyed(this.destroyRef), switchMap((searchTerm) => {
      if (!searchTerm || searchTerm.length < 2) {
        this.isSearching = false;
        this.searchNodes = [];
        this.cdr.markForCheck();
        return of([]);
      }
      this.isSearching = true;
      this.cdr.markForCheck();
      if (isDefined(this.entityType) && isDefined(this.clientId)) {
        return this.performApiSearch(searchTerm);
      } else {
        return of(this.performLocalSearch(searchTerm));
      }
    })).subscribe({
      next: (results) => {
        this.searchNodes = results;
        this.isSearching = false;
        this.searchChanged.emit(this.searchValue);
        this.cdr.markForCheck();
      },
      error: (error) => {
        console.error("Error during search:", error);
        this.isSearching = false;
        this.searchNodes = [];
        this.cdr.markForCheck();
      }
    });
  }
  onSearchInput(value) {
    this.searchValue = value;
    this.searchSubject.next(value);
  }
  toggleDropdown(event) {
    if (this.disabled)
      return;
    event.stopPropagation();
    this.showDropdown = !this.showDropdown;
    if (this.showDropdown && isDefined(this.searchInput)) {
      setTimeout(() => {
        this.searchInput.nativeElement.focus();
      });
    }
    this.onTouched();
    this.cdr.markForCheck();
  }
  closeDropdown() {
    this.showDropdown = false;
    this.searchValue = "";
    this.searchNodes = [];
  }
  performLocalSearch(searchTerm) {
    if (!searchTerm.trim()) {
      return [];
    }
    const term = searchTerm.toLowerCase().trim();
    return this.flattenedNodes.filter((node) => node.value.toLowerCase().includes(term));
  }
  performApiSearch(searchTerm) {
    if (isNullOrUndefined(this.clientId)) {
      return of([]);
    }
    const trimmedSearchTerm = searchTerm.trim();
    if (trimmedSearchTerm.length === 0) {
      return of([]);
    }
    const filter2 = `name=*${trimmedSearchTerm}*&state=active`;
    const limit = 10;
    switch (this.entityType) {
      case "asset":
        return this.entitiesService.listAssets(this.clientId, 0, limit, "name:asc", filter2).pipe(switchMap((response) => {
          if (isNullOrUndefined(response.items))
            return of([]);
          return of(response.items.map((item) => ({
            id: item.id,
            value: item.name || "Unnamed Asset",
            data: __spreadProps(__spreadValues({}, item), {
              text: `${item.assetType?.name ?? "Asset"} "${item.name ?? "Unnamed"}"`,
              actorId: item.id,
              actorName: item.name,
              actorSelectionType: "specific",
              actorType: "asset",
              actorTypeId: item.assetType?.id,
              actorTypeName: item.assetType?.name ?? "Asset"
            })
          })));
        }));
      case "zone":
        return this.entitiesService.listZones(this.clientId, 0, limit, "name:asc", filter2).pipe(switchMap((response) => {
          if (isNullOrUndefined(response.items))
            return of([]);
          return of(response.items.map((item) => ({
            id: item.id,
            value: item.name ?? "Unnamed Zone",
            data: __spreadProps(__spreadValues({}, item), {
              text: `${item.zoneType ?? "Zone"} "${item.name ?? "Unnamed"}"`,
              targetId: item.id,
              targetName: item.name,
              targetSelectionType: "specific",
              targetType: "zone",
              targetTypeId: item.zoneType,
              targetTypeName: item.zoneType ?? "Zone"
            })
          })));
        }));
      case "device":
        return this.entitiesService.listDevices(this.clientId, 0, limit, "name:asc", filter2).pipe(switchMap((response) => {
          if (isNullOrUndefined(response.items))
            return of([]);
          return of(response.items.map((item) => ({
            id: item.id,
            value: item.name ?? "Unnamed Device",
            data: __spreadProps(__spreadValues({}, item), {
              text: `${item.deviceType?.name ?? "Device"} "${item.name ?? "Unnamed"}"`,
              deviceId: item.id,
              deviceName: item.name
            })
          })));
        }));
      default:
        return of(this.performLocalSearch(searchTerm));
    }
  }
  transformData() {
    if (!Array.isArray(this.treeData) || !this.treeData.length) {
      this.nodes = [];
      this.flattenedNodes = [];
      return;
    }
    this.nodes = this.mapDataToTreeNodes(this.treeData);
    this.flattenedNodes = this.flattenTreeData(this.treeData);
  }
  mapDataToTreeNodes(data) {
    if (!Array.isArray(data))
      return [];
    return data.map((item) => {
      const node = {
        key: item[this.idField],
        label: item[this.displayField] ?? item[this.valueField],
        data: item,
        expanded: this.expandedByDefault
      };
      const children = item[this.childrenField];
      if (Array.isArray(children) && children.length > 0) {
        node.children = this.mapDataToTreeNodes(children);
      }
      return node;
    });
  }
  flattenTreeData(data) {
    if (!Array.isArray(data))
      return [];
    let result = [];
    for (const item of data) {
      if (isDefined(item)) {
        result.push({
          id: item[this.idField],
          value: item[this.displayField] ?? item[this.valueField],
          data: item
        });
        const children = item[this.childrenField];
        if (Array.isArray(children) && children.length > 0) {
          result = [...result, ...this.flattenTreeData(children)];
        }
      }
    }
    return result;
  }
  onNodeSelect(event) {
    if (isDefined(event?.node?.data)) {
      this.displayValue = event.node.label ?? "";
      this.selectedNodeKey = event.node.key;
      this.innerValue = event.node.data;
      this.onChange(this.innerValue);
      this.onTouched();
      this.nodeSelected.emit(event.node.data);
      this.closeDropdown();
      this.cdr.markForCheck();
    }
  }
  onSearchResultSelect(result) {
    if (isNullOrUndefined(result))
      return;
    this.displayValue = result.value;
    this.selectedNodeKey = result.id;
    this.innerValue = result.data;
    this.onChange(this.innerValue);
    this.onTouched();
    this.nodeSelected.emit(result.data);
    this.closeDropdown();
    this.cdr.markForCheck();
  }
  static \u0275fac = function SearchableTreeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SearchableTreeComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _SearchableTreeComponent, selectors: [["app-searchable-tree"]], viewQuery: function SearchableTreeComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c019, 5);
      \u0275\u0275viewQuery(_c116, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.searchInput = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.treePanel = _t.first);
    }
  }, inputs: { treeData: "treeData", searchEnabled: "searchEnabled", searchPlaceholder: "searchPlaceholder", valueField: "valueField", childrenField: "childrenField", idField: "idField", expandedByDefault: "expandedByDefault", debounceTime: "debounceTime", clientId: "clientId", entityType: "entityType", displayField: "displayField", disabled: "disabled" }, outputs: { nodeSelected: "nodeSelected", searchChanged: "searchChanged" }, features: [\u0275\u0275ProvidersFeature([
    {
      provide: NG_VALUE_ACCESSOR,
      // eslint-disable-next-line @angular-eslint/no-forward-ref
      useExisting: forwardRef(() => _SearchableTreeComponent),
      multi: true
    }
  ]), \u0275\u0275NgOnChangesFeature], decls: 5, vars: 9, consts: [["treePanel", ""], ["searchInput", ""], [1, "searchable-tree-container", 3, "ngClass"], [1, "p-inputgroup"], ["type", "text", "pInputText", "", "readonly", "", 1, "p-inputtext", "p-component", "w-full", 3, "click", "disabled", "value", "ngClass"], [1, "z-[10000]", "min-w-[250px]", "searchable-tree-overlay", 3, "visible", "appendTo", "--trigger-w"], [1, "z-[10000]", "min-w-[250px]", "searchable-tree-overlay", 3, "visibleChange", "visible", "appendTo"], [1, "tree-dropdown", "p-2", "border-round", "shadow-2"], [1, "search-input-container", "mb-2"], [1, "search-results", "mb-2"], [1, "tree-view-container", "border", "shadow-md"], [1, "p-2", "text-center"], ["type", "text", "pInputText", "", 1, "p-inputtext", "p-component", "w-full", 3, "ngModelChange", "placeholder", "ngModel"], [1, "p-progress-spinner"], [1, "pi", "pi-spinner", "animate-spin"], [1, "list-none", "p-0", "m-0", "p-tree", "border", "shadow-md"], [1, "p-2", "cursor-pointer", "hover:surface-hover", "transition-colors", "transition-duration-150", "border-round"], [1, "p-2", "cursor-pointer", "hover:surface-hover", "transition-colors", "transition-duration-150", "border-round", 3, "click", "keydown.enter"], ["selectionMode", "single", 1, "w-full", 3, "onNodeSelect", "value", "emptyMessage"]], template: function SearchableTreeComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = \u0275\u0275getCurrentView();
      \u0275\u0275elementStart(0, "div", 2, 0)(2, "div", 3)(3, "input", 4);
      \u0275\u0275listener("click", function SearchableTreeComponent_Template_input_click_3_listener($event) {
        \u0275\u0275restoreView(_r1);
        return \u0275\u0275resetView(ctx.toggleDropdown($event));
      });
      \u0275\u0275elementEnd()();
      \u0275\u0275conditionalCreate(4, SearchableTreeComponent_Conditional_4_Template, 6, 8, "p-overlay", 5);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(5, _c211, ctx.disabled));
      \u0275\u0275advance(3);
      \u0275\u0275property("disabled", ctx.disabled)("value", ctx.displayValue)("ngClass", \u0275\u0275pureFunction1(7, _c310, !ctx.disabled));
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.showDropdown ? 4 : -1);
    }
  }, dependencies: [
    CommonModule,
    NgClass,
    FormsModule,
    DefaultValueAccessor,
    NgControlStatus,
    NgModel,
    TreeModule,
    Tree,
    InputTextModule,
    InputText,
    ButtonModule,
    TreeSelectModule,
    OverlayModule,
    Overlay
  ], styles: ["\n\n[_nghost-%COMP%] {\n  display: block;\n  position: relative;\n  --p-treeselect-background: var(--p-tree-background) !important;\n}\n.searchable-tree-container[_ngcontent-%COMP%] {\n  width: 100%;\n  position: relative;\n}\n.searchable-tree-container[_ngcontent-%COMP%]   .search-input-container[_ngcontent-%COMP%] {\n  position: relative;\n}\n.searchable-tree-container[_ngcontent-%COMP%]   .search-input-container[_ngcontent-%COMP%]   .p-progress-spinner[_ngcontent-%COMP%] {\n  position: absolute;\n  right: 48px;\n  top: 50%;\n  transform: translateY(-50%);\n  z-index: 2;\n}\n.searchable-tree-container[_ngcontent-%COMP%]   .tree-dropdown[_ngcontent-%COMP%] {\n  position: absolute;\n  width: 100%;\n  min-width: 250px;\n  z-index: 100;\n  max-height: 350px;\n  overflow-y: auto;\n  margin-top: 4px;\n  cursor: default;\n  background: var(--p-select-overlay-background);\n  color: var(--p-select-overlay-color);\n  border: 1px solid var(--p-select-overlay-border-color);\n  border-radius: var(--p-select-overlay-border-radius);\n  box-shadow: var(--p-select-overlay-shadow);\n}\n.searchable-tree-container[_ngcontent-%COMP%]   .search-results[_ngcontent-%COMP%] {\n  margin-top: 0.25rem;\n}\n.searchable-tree-container[_ngcontent-%COMP%]   .search-results[_ngcontent-%COMP%]   li[_ngcontent-%COMP%] {\n  border-radius: 4px;\n}\n[_nghost-%COMP%]     .p-treeselect {\n  width: 100%;\n}\n[_nghost-%COMP%]     .p-treeselect .p-treeselect-label {\n  padding: 0.5rem 0.75rem;\n}\n[_nghost-%COMP%]     .p-tree {\n  border: none;\n  padding: 0.25rem;\n}\n.max-h-15rem[_ngcontent-%COMP%] {\n  max-height: 15rem;\n}\n.animate-spin[_ngcontent-%COMP%] {\n  animation: _ngcontent-%COMP%_spin 1s linear infinite;\n}\n@keyframes _ngcontent-%COMP%_spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n/*# sourceMappingURL=searchable-tree.component.css.map */"], changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SearchableTreeComponent, [{
    type: Component,
    args: [{ selector: "app-searchable-tree", imports: [
      CommonModule,
      FormsModule,
      TreeModule,
      InputTextModule,
      ButtonModule,
      TreeSelectModule,
      OverlayModule
    ], changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: NG_VALUE_ACCESSOR,
        // eslint-disable-next-line @angular-eslint/no-forward-ref
        useExisting: forwardRef(() => SearchableTreeComponent),
        multi: true
      }
    ], template: `<div
  class="searchable-tree-container"
  #treePanel
  [ngClass]="{ 'p-disabled': disabled }"
>
  <!-- Main input that triggers dropdown -->
  <div class="p-inputgroup">
    <input
      type="text"
      pInputText
      readonly
      [disabled]="disabled"
      [value]="displayValue"
      (click)="toggleDropdown($event)"
      class="p-inputtext p-component w-full"
      [ngClass]="{ 'cursor-pointer': !disabled }"
    />
  </div>

  <!-- Dropdown panel -->
  @if (showDropdown) {
    <!-- eslint-disable-next-line @angular-eslint/template/no-inline-styles -->
    <p-overlay
      [(visible)]="showDropdown"
      [appendTo]="'body'"
      class="z-[10000] min-w-[250px] searchable-tree-overlay"
      [style.--trigger-w.px]="treePanel?.offsetWidth || 250"
    >
      <div class="tree-dropdown p-2 border-round shadow-2">
        <!-- Search input -->
        @if (searchEnabled) {
          <div class="search-input-container mb-2">
            <div class="p-inputgroup">
              <input
                #searchInput
                type="text"
                pInputText
                [placeholder]="searchPlaceholder"
                [(ngModel)]="searchValue"
                (ngModelChange)="onSearchInput($event)"
                class="p-inputtext p-component w-full"
              />
              @if (isSearching) {
                <div class="p-progress-spinner">
                  <i class="pi pi-spinner animate-spin"></i>
                </div>
              }
            </div>
          </div>
        }
        <!-- Search results -->
        @if (searchNodes.length > 0) {
          <div class="search-results mb-2">
            <ul class="list-none p-0 m-0 p-tree border shadow-md">
              @for (result of searchNodes; track result) {
                <li
                  class="p-2 cursor-pointer hover:surface-hover transition-colors transition-duration-150 border-round"
                  (click)="onSearchResultSelect(result)"
                  (keydown.enter)="onSearchResultSelect(result)"
                >
                  <span>{{ result.value }}</span>
                </li>
              }
            </ul>
          </div>
        }
        <!-- Tree view -->
        @if (nodes.length > 0) {
          <div class="tree-view-container border shadow-md">
            <p-tree
              [value]="nodes"
              selectionMode="single"
              (onNodeSelect)="onNodeSelect($event)"
              class="w-full"
              [emptyMessage]="'No data available'"
            ></p-tree>
          </div>
        }
        <!-- Empty state -->
        @if (searchNodes.length === 0 && nodes.length === 0) {
          <div class="p-2 text-center">No data available</div>
        }
      </div>
    </p-overlay>
  }
</div>
`, styles: ["/* src/app/shared/components/searchable-tree/searchable-tree.component.scss */\n:host {\n  display: block;\n  position: relative;\n  --p-treeselect-background: var(--p-tree-background) !important;\n}\n.searchable-tree-container {\n  width: 100%;\n  position: relative;\n}\n.searchable-tree-container .search-input-container {\n  position: relative;\n}\n.searchable-tree-container .search-input-container .p-progress-spinner {\n  position: absolute;\n  right: 48px;\n  top: 50%;\n  transform: translateY(-50%);\n  z-index: 2;\n}\n.searchable-tree-container .tree-dropdown {\n  position: absolute;\n  width: 100%;\n  min-width: 250px;\n  z-index: 100;\n  max-height: 350px;\n  overflow-y: auto;\n  margin-top: 4px;\n  cursor: default;\n  background: var(--p-select-overlay-background);\n  color: var(--p-select-overlay-color);\n  border: 1px solid var(--p-select-overlay-border-color);\n  border-radius: var(--p-select-overlay-border-radius);\n  box-shadow: var(--p-select-overlay-shadow);\n}\n.searchable-tree-container .search-results {\n  margin-top: 0.25rem;\n}\n.searchable-tree-container .search-results li {\n  border-radius: 4px;\n}\n:host ::ng-deep .p-treeselect {\n  width: 100%;\n}\n:host ::ng-deep .p-treeselect .p-treeselect-label {\n  padding: 0.5rem 0.75rem;\n}\n:host ::ng-deep .p-tree {\n  border: none;\n  padding: 0.25rem;\n}\n.max-h-15rem {\n  max-height: 15rem;\n}\n.animate-spin {\n  animation: spin 1s linear infinite;\n}\n@keyframes spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n/*# sourceMappingURL=searchable-tree.component.css.map */\n"] }]
  }], () => [], { treeData: [{
    type: Input
  }], searchEnabled: [{
    type: Input
  }], searchPlaceholder: [{
    type: Input
  }], valueField: [{
    type: Input
  }], childrenField: [{
    type: Input
  }], idField: [{
    type: Input
  }], expandedByDefault: [{
    type: Input
  }], debounceTime: [{
    type: Input
  }], clientId: [{
    type: Input
  }], entityType: [{
    type: Input
  }], displayField: [{
    type: Input
  }], disabled: [{
    type: Input
  }], nodeSelected: [{
    type: Output
  }], searchChanged: [{
    type: Output
  }], searchInput: [{
    type: ViewChild,
    args: ["searchInput"]
  }], treePanel: [{
    type: ViewChild,
    args: ["treePanel"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(SearchableTreeComponent, { className: "SearchableTreeComponent", filePath: "src/app/shared/components/searchable-tree/searchable-tree.component.ts", lineNumber: 73 });
})();

// src/app/shared/services/event-filter-condition.service.ts
var import_lodash = __toESM(require_lodash());
var EventFilterConditionService = class _EventFilterConditionService {
  eventFilterService = inject(EventFilterService);
  conditionPartsCache = /* @__PURE__ */ new Map();
  zoneOptions = signal([], ...ngDevMode ? [{ debugName: "zoneOptions" }] : []);
  digitalInputOptions = signal([], ...ngDevMode ? [{ debugName: "digitalInputOptions" }] : []);
  digitalStateOptions = signal([], ...ngDevMode ? [{ debugName: "digitalStateOptions" }] : []);
  stateProfileOptions = signal([], ...ngDevMode ? [{ debugName: "stateProfileOptions" }] : []);
  stateValueOptions = signal([], ...ngDevMode ? [{ debugName: "stateValueOptions" }] : []);
  linkedAssetOptions = signal([], ...ngDevMode ? [{ debugName: "linkedAssetOptions" }] : []);
  async initializeConditionParts(condition) {
    if (condition.type === "zone") {
      const currentZoneOptions = this.zoneOptions();
      if ((0, import_lodash.isEmpty)(currentZoneOptions) || currentZoneOptions.length === 0) {
        this.eventFilterService.getZoneSelectionTree().then((nodes) => {
          this.zoneOptions.set(nodes);
          this.updateOptionsInCache(condition, "zone", "zone");
        }).catch(() => {
          this.zoneOptions.set([]);
        });
      } else {
        this.updateOptionsInCache(condition, "zone", "zone");
      }
    }
    if (condition.type === "digital") {
      await this.loadDigitalInputOptions(condition);
      await this.loadDigitalStateOptions(condition);
    }
    if (condition.type === "state") {
      await this.loadStateProfileOptions(condition);
    }
    if (condition.type === "linked") {
      await this.loadLinkedAssetOptions(condition);
    }
  }
  updateOptionsInCache(condition, key, conditionType) {
    const cacheKey = `${condition.type}-${condition.id}`;
    const cachedParts = this.conditionPartsCache.get(cacheKey);
    if (!cachedParts)
      return;
    const part = cachedParts.find((p2) => p2.key === key);
    if (!isDefined(part))
      return;
    const optionsKey = `${conditionType}-${key}`;
    switch (optionsKey) {
      case "zone-zone":
        part.options = this.zoneOptions();
        break;
      case "digital-input":
        part.options = this.digitalInputOptions();
        break;
      case "digital-state":
        part.options = this.digitalStateOptions();
        break;
      case "state-profile":
        part.options = this.stateProfileOptions();
        break;
      case "state-state":
        part.options = this.stateValueOptions();
        break;
      case "linked-asset":
        part.options = this.linkedAssetOptions();
        break;
    }
  }
  async loadDigitalInputOptions(condition) {
    try {
      const conditionDef = this.eventFilterService.EVENT_CONDITIONS["digital"];
      const inputFieldDef = conditionDef["input"];
      if (typeof inputFieldDef.values === "function") {
        const inputOptions = await inputFieldDef.values();
        const transformedOptions = inputOptions.map((opt) => ({
          label: opt.label,
          value: opt.id
        }));
        this.digitalInputOptions.set(transformedOptions);
        this.updateOptionsInCache(condition, "input", "digital");
        if (isDefined(condition.values["input"])) {
          await this.loadDigitalStateOptions(condition);
        }
      }
    } catch (error) {
      console.error("Error loading digital input options:", error);
      this.digitalInputOptions.set([]);
    }
  }
  async loadDigitalStateOptions(condition) {
    try {
      const inputId = condition.values["input"];
      if (!isDefined(inputId) || inputId === "") {
        this.digitalStateOptions.set([]);
        return;
      }
      const conditionDef = this.eventFilterService.EVENT_CONDITIONS["digital"];
      const stateFieldDef = conditionDef["state"];
      if (typeof stateFieldDef.values === "function") {
        const stateOptions = await stateFieldDef.values({ input: inputId });
        const transformedOptions = stateOptions.map((opt) => ({
          label: opt.label,
          value: opt.id
        }));
        this.digitalStateOptions.set(transformedOptions);
        this.updateOptionsInCache(condition, "state", "digital");
      }
    } catch (error) {
      console.error("Error loading digital state options:", error);
      this.digitalStateOptions.set([]);
    }
  }
  async loadStateProfileOptions(condition) {
    try {
      const conditionDef = this.eventFilterService.EVENT_CONDITIONS["state"];
      const profileFieldDef = conditionDef["profile"];
      if (typeof profileFieldDef.values === "function") {
        const profileOptions = await profileFieldDef.values();
        const transformedOptions = profileOptions.map((opt) => ({
          label: opt.label,
          value: opt.id
        }));
        this.stateProfileOptions.set(transformedOptions);
        this.updateOptionsInCache(condition, "profile", "state");
        if (isDefined(condition.values["profile"])) {
          await this.loadStateValues(condition);
        }
      }
    } catch (error) {
      console.error("Error loading state profile options:", error);
      this.stateProfileOptions.set([]);
    }
  }
  async loadStateValues(condition) {
    try {
      const conditionDef = this.eventFilterService.EVENT_CONDITIONS["state"];
      const stateFieldDef = conditionDef["state"];
      if (typeof stateFieldDef.values === "function") {
        const stateOptions = await stateFieldDef.values({
          profile: condition.values["profile"]
        });
        const transformedOptions = stateOptions.map((opt) => ({
          label: opt.label,
          value: opt.id
        }));
        this.stateValueOptions.set(transformedOptions);
        this.updateOptionsInCache(condition, "state", "state");
      }
    } catch (error) {
      console.error("Error loading state values:", error);
      this.stateValueOptions.set([]);
    }
  }
  async loadLinkedAssetOptions(condition) {
    try {
      const conditionDef = this.eventFilterService.EVENT_CONDITIONS["linked"];
      const assetFieldDef = conditionDef["asset"];
      if (typeof assetFieldDef.values === "function") {
        const assetOptions = await assetFieldDef.values();
        this.linkedAssetOptions.set(assetOptions);
        this.updateOptionsInCache(condition, "asset", "linked");
      }
    } catch (error) {
      console.error("Error loading linked asset options:", error);
      this.linkedAssetOptions.set([]);
    }
  }
  // Public method to handle when a field value changes (for linked fields)
  async onConditionFieldChange(condition, fieldKey) {
    if (condition.type === "state" && fieldKey === "profile") {
      await this.loadStateValues(condition);
    } else if (condition.type === "digital" && fieldKey === "input") {
      await this.loadDigitalStateOptions(condition);
    }
    return this.getConditionParts(condition);
  }
  updateSpeedConditionText(condition) {
    const value = condition.values["value"] ?? "0";
    const unit = condition.values["unit"] ?? "mph";
    const operator = condition.values["operator"] ?? "gt";
    let operatorText = "equal to";
    if (operator === "gt") {
      operatorText = "greater than";
    } else if (operator === "lt") {
      operatorText = "less than";
    }
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `speed is ${operatorText} ${value} ${unit}`,
      value: `${value}`,
      unit,
      operator: operatorText,
      speed: `${value} ${unit}`
    });
  }
  updateTimeConditionText(condition) {
    const mode = condition.values["mode"] ?? "inside";
    const time1 = condition.values["time1"] ?? "00:00";
    const time2 = condition.values["time2"] ?? "23:59";
    const dow = condition.values["dow"] ?? [];
    const modeText = mode === "inside" ? "between" : "outside of";
    let dowText = "";
    if (isDefined(dow) && dow.length > 0) {
      const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      const selectedDays = dow.map((d) => dayNames[Number.parseInt(d)]);
      dowText = ` on ${selectedDays.join(", ")}`;
    }
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `time is ${modeText} ${time1} and ${time2}${dowText}`,
      mode: modeText,
      time1,
      time2,
      dow
    });
  }
  updateZoneConditionText(condition) {
    const mode = condition.values["mode"] ?? "inside";
    const zoneName = condition.values["zoneName"] ?? "unknown zone";
    const zoneId = condition.values["zoneId"] ?? "";
    const modeText = mode === "inside" ? "inside" : "outside";
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `current position is ${modeText} of ${zoneName}`,
      mode: modeText,
      zoneName,
      zoneId
    });
  }
  updateLinkedConditionText(condition) {
    const mode = condition.values["mode"] ?? "in";
    const assetName = condition.values["assetName"] ?? condition.values["asset"]?.label ?? "unknown asset";
    const assetId = condition.values["assetId"] ?? "";
    const modeText = mode === "in" ? "is" : "is not";
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `current linked asset ${modeText} ${assetName}`,
      mode: modeText,
      assetName,
      assetId
    });
  }
  updateActiveConditionText(condition) {
    const state = condition.values["state"] ?? "1";
    const stateText = state === "1" ? "On" : "Off";
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `ignition is ${stateText}`,
      state: stateText
    });
  }
  updateDigitalConditionText(condition) {
    const input2 = condition.values["input"] ?? "";
    const inputName = condition.values["inputName"] ?? this.digitalInputOptions().find((opt) => opt.value === input2)?.label ?? "unknown input";
    const state = condition.values["state"] ?? "1";
    const stateName = condition.values["stateName"] ?? this.digitalStateOptions().find((opt) => opt.value === state)?.label ?? (state === "1" ? "active" : "inactive");
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `digital ${inputName} is ${stateName}`,
      input: input2,
      inputName,
      state,
      stateName
    });
  }
  updateStateConditionText(condition) {
    const profile = condition.values["profile"] ?? "";
    const profileName = condition.values["profileName"] ?? this.stateProfileOptions().find((opt) => opt.value === profile)?.label ?? "unknown profile";
    const state = condition.values["state"] ?? "";
    const stateName = condition.values["stateName"] ?? "state";
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `state ${profileName} is ${stateName}`,
      profile,
      profileName,
      state,
      stateName
    });
  }
  updateDistanceConditionText(condition) {
    const mode = condition.values["mode"] ?? "greater";
    const distance = condition.values["distance"] ?? "0";
    const unit = condition.values["unit"] ?? "mi";
    const modeText = mode === "greater" ? "greater than" : "less than";
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `distance is ${modeText} ${distance} ${unit}`,
      mode: modeText,
      distance: `${distance}`,
      unit
    });
  }
  updateDurationConditionText(condition) {
    const mode = condition.values["mode"] ?? "greater";
    const duration = condition.values["duration"] ?? "0";
    const unit = condition.values["unit"] ?? "minutes";
    const modeText = mode === "greater" ? "greater than" : "less than";
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `duration is ${modeText} ${duration} ${unit}`,
      mode: modeText,
      duration: `${duration}`,
      unit
    });
  }
  updateRouteNumberConditionText(condition) {
    const mode = condition.values["mode"] ?? "equals";
    const value = condition.values["value"] ?? "";
    const modeText = this.getComparisonModeText(mode);
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `route number ${modeText} ${value}`,
      mode: modeText,
      value
    });
  }
  updateRoadNameConditionText(condition) {
    const mode = condition.values["mode"] ?? "equals";
    const value = condition.values["value"] ?? "";
    const modeText = this.getComparisonModeText(mode);
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `road name ${modeText} ${value}`,
      mode: modeText,
      value
    });
  }
  updateBoundaryConditionText(condition) {
    const boundary = condition.values["boundary"] ?? "suburb";
    const mode = condition.values["mode"] ?? "equals";
    const value = condition.values["value"] ?? "";
    const boundaryText = this.getBoundaryText(boundary);
    const modeText = this.getComparisonModeText(mode);
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `${boundaryText} ${modeText} ${value}`,
      boundary: boundaryText,
      mode: modeText,
      value
    });
  }
  updateSpeedLimitConditionText(condition) {
    const mode = condition.values["mode"] ?? "greater";
    const speed = condition.values["speed"] ?? "0";
    const unit = condition.values["unit"] ?? "mph";
    let modeText;
    switch (mode) {
      case "greater":
        modeText = "is greater than";
        break;
      case "less":
        modeText = "is less than";
        break;
      case "equals":
        modeText = "equals";
        break;
      default:
        modeText = "is greater than";
    }
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `speed limit ${modeText} ${speed} ${unit}`,
      mode: modeText,
      speed: `${speed}`,
      unit
    });
  }
  updateCarriagewayConditionText(condition) {
    const mode = condition.values["mode"] ?? "single";
    const modeText = mode === "single" ? "single" : "dual";
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: `road is a ${modeText} carriageway`,
      mode: modeText
    });
  }
  updateDaysConditionText(condition) {
    const days = condition.values["days"] ?? [];
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: days.length > 0 ? `on days: ${days.join(", ")}` : "on all days",
      days
    });
  }
  updateDefaultConditionText(condition) {
    const parts = this.getConditionParts(condition);
    const textParts = [];
    for (const part of parts) {
      if (isDefined(condition.values[part.key])) {
        if (part.type === "dropdown") {
          const option = part.options?.find((opt) => opt.value === condition.values[part.key]);
          if (isDefined(option)) {
            textParts.push(`${part.label}: ${option.label}`);
          }
        } else if (part.type === "checklist" && Array.isArray(condition.values[part.key])) {
          if (condition.values[part.key].length > 0) {
            textParts.push(`${part.label}: ${condition.values[part.key].join(", ")}`);
          }
        } else {
          textParts.push(`${part.label}: ${condition.values[part.key]}`);
        }
      }
    }
    condition.text = __spreadProps(__spreadValues({}, condition.text), {
      display: textParts.join(", ")
    });
  }
  // Helper functions to further reduce complexity
  getComparisonModeText(mode) {
    switch (mode) {
      case "equals":
        return "equals";
      case "contains":
        return "contains";
      case "starts":
        return "starts with";
      case "ends":
        return "ends with";
      case "not_equals":
        return "does not equal";
      case "not_contains":
        return "does not contain";
      case "not_starts":
        return "does not start with";
      case "not_ends":
        return "does not end with";
      default:
        return "equals";
    }
  }
  getBoundaryText(boundary) {
    switch (boundary) {
      case "suburb":
        return "suburb";
      case "town":
        return "town";
      case "state":
        return "state/province";
      case "country":
        return "country";
      default:
        return "suburb";
    }
  }
  updateConditionText(condition) {
    switch (condition.type) {
      case "speed":
        this.updateSpeedConditionText(condition);
        break;
      case "time":
        this.updateTimeConditionText(condition);
        break;
      case "zone":
        this.updateZoneConditionText(condition);
        break;
      case "linked":
        this.updateLinkedConditionText(condition);
        break;
      case "active":
        this.updateActiveConditionText(condition);
        break;
      case "digital":
        this.updateDigitalConditionText(condition);
        break;
      case "state":
        this.updateStateConditionText(condition);
        break;
      case "distance":
        this.updateDistanceConditionText(condition);
        break;
      case "duration":
        this.updateDurationConditionText(condition);
        break;
      case "routenumber":
        this.updateRouteNumberConditionText(condition);
        break;
      case "roadname":
        this.updateRoadNameConditionText(condition);
        break;
      case "boundary":
        this.updateBoundaryConditionText(condition);
        break;
      case "speedlimit":
        this.updateSpeedLimitConditionText(condition);
        break;
      case "carriageway":
        this.updateCarriagewayConditionText(condition);
        break;
      case "days":
        this.updateDaysConditionText(condition);
        break;
      default:
        this.updateDefaultConditionText(condition);
    }
  }
  getConditionParts(condition) {
    if (isNullOrUndefined(condition))
      return [];
    const cacheKey = `${condition.type}-${condition.id}`;
    if (this.conditionPartsCache.has(cacheKey)) {
      return this.conditionPartsCache.get(cacheKey) ?? [];
    }
    const parts = [];
    switch (condition.type) {
      case "speed":
        parts.push({
          key: "value",
          label: "Speed Value",
          type: "number",
          value: condition.values["value"] ?? 0,
          required: true
        }, {
          key: "operator",
          label: "Operator",
          type: "dropdown",
          options: [
            { label: "Greater than", value: "gt" },
            { label: "Less than", value: "lt" },
            { label: "Equal to", value: "eq" }
          ],
          value: condition.values["operator"] ?? "gt",
          required: true
        }, {
          key: "unit",
          label: "Unit",
          type: "dropdown",
          options: [
            { label: "MPH", value: "mph" },
            { label: "KPH", value: "kph" }
          ],
          value: condition.values["unit"] ?? "mph",
          required: true
        });
        break;
      case "time":
        parts.push({
          key: "mode",
          label: "Mode",
          type: "dropdown",
          options: [
            { label: "Between", value: "inside" },
            { label: "Outside of", value: "outside" }
          ],
          value: condition.values["mode"] ?? "inside",
          required: true
        }, {
          key: "time1",
          label: "Start Time",
          type: "time",
          value: condition.values["time1"] ?? "00:00",
          required: true
        }, {
          key: "time2",
          label: "End Time",
          type: "time",
          value: condition.values["time2"] ?? "23:59",
          required: true
        }, {
          key: "dow",
          label: "Days of Week",
          type: "checklist",
          options: [
            { label: "Sun", value: "0" },
            { label: "Mon", value: "1" },
            { label: "Tue", value: "2" },
            { label: "Wed", value: "3" },
            { label: "Thu", value: "4" },
            { label: "Fri", value: "5" },
            { label: "Sat", value: "6" }
          ],
          value: condition.values["dow"] ?? [],
          required: false
        });
        break;
      case "zone":
        parts.push({
          key: "mode",
          label: "Mode",
          type: "dropdown",
          options: [
            { label: "Inside", value: "inside" },
            { label: "Outside", value: "outside" }
          ],
          value: condition.values["mode"] ?? "inside",
          required: true
        }, {
          key: "zone",
          label: "Geofence",
          type: "searchableTree",
          options: this.zoneOptions(),
          value: condition.values["zone"] ?? "",
          required: true
        });
        this.conditionPartsCache.set(cacheKey, parts);
        break;
      case "linked":
        parts.push({
          key: "mode",
          label: "Mode",
          type: "dropdown",
          options: [
            { label: "Is", value: "in" },
            { label: "Is Not", value: "out" }
          ],
          value: condition.values["mode"] ?? "in",
          required: true
        }, {
          key: "asset",
          label: "Asset",
          type: "searchableTree",
          options: this.linkedAssetOptions(),
          value: condition.values["asset"] ?? "",
          required: true
        });
        this.conditionPartsCache.set(cacheKey, parts);
        break;
      case "active":
        parts.push({
          key: "state",
          label: "State",
          type: "dropdown",
          options: [
            { label: "On", value: "1" },
            { label: "Off", value: "0" }
          ],
          value: condition.values["state"] ?? "1",
          required: true
        });
        break;
      case "digital":
        parts.push({
          key: "input",
          label: "Input",
          type: "dropdown",
          options: this.digitalInputOptions(),
          value: condition.values["input"] ?? "",
          required: true
        }, {
          key: "state",
          label: "State",
          type: "dropdown",
          options: this.digitalStateOptions(),
          value: condition.values["state"] ?? "1",
          required: true
        });
        this.conditionPartsCache.set(cacheKey, parts);
        break;
      case "state":
        parts.push({
          key: "profile",
          label: "Profile",
          type: "dropdown",
          options: this.stateProfileOptions(),
          value: condition.values["profile"] ?? "",
          required: true
        }, {
          key: "state",
          label: "State",
          type: "dropdown",
          options: this.stateValueOptions(),
          value: condition.values["state"] ?? "",
          required: true
        });
        this.conditionPartsCache.set(cacheKey, parts);
        break;
      case "distance":
        parts.push({
          key: "mode",
          label: "Mode",
          type: "dropdown",
          options: [
            { label: "Greater than", value: "greater" },
            { label: "Less than", value: "less" }
          ],
          value: condition.values["mode"] ?? "greater",
          required: true
        }, {
          key: "distance",
          label: "Distance",
          type: "number",
          value: condition.values["distance"] ?? 0,
          required: true
        }, {
          key: "unit",
          label: "Unit",
          type: "dropdown",
          options: [
            { label: "Miles", value: "mi" },
            { label: "Kilometers", value: "km" },
            { label: "Meters", value: "m" }
          ],
          value: condition.values["unit"] ?? "mi",
          required: true
        });
        break;
      case "duration":
        parts.push({
          key: "mode",
          label: "Mode",
          type: "dropdown",
          options: [
            { label: "Greater than", value: "greater" },
            { label: "Less than", value: "less" }
          ],
          value: condition.values["mode"] ?? "greater",
          required: true
        }, {
          key: "duration",
          label: "Duration",
          type: "number",
          value: condition.values["duration"] ?? 0,
          required: true
        }, {
          key: "unit",
          label: "Unit",
          type: "dropdown",
          options: [
            { label: "Seconds", value: "seconds" },
            { label: "Minutes", value: "minutes" },
            { label: "Hours", value: "hours" }
          ],
          value: condition.values["unit"] ?? "minutes",
          required: true
        });
        break;
      case "routenumber":
      case "roadname":
        parts.push({
          key: "mode",
          label: "Mode",
          type: "dropdown",
          options: [
            { label: "Equals", value: "equals" },
            { label: "Contains", value: "contains" },
            { label: "Starts with", value: "starts" },
            { label: "Ends with", value: "ends" },
            { label: "Does not equal", value: "not_equals" },
            { label: "Does not contain", value: "not_contains" },
            { label: "Does not start with", value: "not_starts" },
            { label: "Does not end with", value: "not_ends" }
          ],
          value: condition.values["mode"] ?? "equals",
          required: true
        }, {
          key: "value",
          label: condition.type === "routenumber" ? "Route Number" : "Road Name",
          type: "text",
          value: condition.values["value"] ?? "",
          required: true
        });
        break;
      case "boundary":
        parts.push({
          key: "boundary",
          label: "Boundary Type",
          type: "dropdown",
          options: [
            { label: "Suburb", value: "suburb" },
            { label: "Town", value: "town" },
            { label: "State/Province", value: "state" },
            { label: "Country", value: "country" }
          ],
          value: condition.values["boundary"] ?? "suburb",
          required: true
        }, {
          key: "mode",
          label: "Mode",
          type: "dropdown",
          options: [
            { label: "Equals", value: "equals" },
            { label: "Contains", value: "contains" },
            { label: "Starts with", value: "starts" },
            { label: "Ends with", value: "ends" },
            { label: "Does not equal", value: "not_equals" },
            { label: "Does not contain", value: "not_contains" },
            { label: "Does not start with", value: "not_starts" },
            { label: "Does not end with", value: "not_ends" }
          ],
          value: condition.values["mode"] ?? "equals",
          required: true
        }, {
          key: "value",
          label: "Value",
          type: "text",
          value: condition.values["value"] ?? "",
          required: true
        });
        break;
      case "speedlimit":
        parts.push({
          key: "mode",
          label: "Mode",
          type: "dropdown",
          options: [
            { label: "Is greater than", value: "greater" },
            { label: "Is less than", value: "less" },
            { label: "Equals", value: "equals" }
          ],
          value: condition.values["mode"] ?? "greater",
          required: true
        }, {
          key: "speed",
          label: "Speed",
          type: "number",
          value: condition.values["speed"] ?? 0,
          required: true
        }, {
          key: "unit",
          label: "Unit",
          type: "dropdown",
          options: [
            { label: "MPH", value: "mph" },
            { label: "KPH", value: "kph" }
          ],
          value: condition.values["unit"] ?? "mph",
          required: true
        });
        break;
      case "carriageway":
        parts.push({
          key: "mode",
          label: "Mode",
          type: "dropdown",
          options: [
            { label: "Single", value: "single" },
            { label: "Dual", value: "dual" }
          ],
          value: condition.values["mode"] ?? "single",
          required: true
        });
        break;
      default:
        if (isDefined(condition.values)) {
          for (const key of Object.keys(condition.values)) {
            if (key === "id" || key === "type")
              continue;
            const valueType = typeof condition.values[key];
            parts.push({
              key,
              label: key.charAt(0).toUpperCase() + key.slice(1),
              type: valueType === "number" ? "number" : "text",
              value: condition.values[key] ?? "",
              required: true
            });
          }
        }
    }
    return parts;
  }
  static \u0275fac = function EventFilterConditionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EventFilterConditionService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _EventFilterConditionService, factory: _EventFilterConditionService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventFilterConditionService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/components/forms/event-filter-field/condition-editor/condition-editor.component.ts
var _c020 = () => [];
var _forTrack02 = ($index, $item) => $item.key;
var _forTrack1 = ($index, $item) => $item.value;
function ConditionEditorComponent_Conditional_1_For_4_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 13);
    \u0275\u0275twoWayListener("ngModelChange", function ConditionEditorComponent_Conditional_1_For_4_Case_4_Template_input_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const part_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r2.condition().values[part_r2.key], $event) || (ctx_r2.condition().values[part_r2.key] = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const part_r2 = ctx_r3.$implicit;
    const \u0275$index_9_r5 = ctx_r3.$index;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", "part-" + \u0275$index_9_r5);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.condition().values[part_r2.key]);
  }
}
function ConditionEditorComponent_Conditional_1_For_4_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 14);
    \u0275\u0275twoWayListener("ngModelChange", function ConditionEditorComponent_Conditional_1_For_4_Case_5_Template_input_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const part_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r2.condition().values[part_r2.key], $event) || (ctx_r2.condition().values[part_r2.key] = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const part_r2 = ctx_r3.$implicit;
    const \u0275$index_9_r5 = ctx_r3.$index;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", "part-" + \u0275$index_9_r5);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.condition().values[part_r2.key]);
  }
}
function ConditionEditorComponent_Conditional_1_For_4_Case_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-inputnumber", 15);
    \u0275\u0275twoWayListener("ngModelChange", function ConditionEditorComponent_Conditional_1_For_4_Case_6_Template_p_inputnumber_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const part_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r2.condition().values[part_r2.key], $event) || (ctx_r2.condition().values[part_r2.key] = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const part_r2 = ctx_r3.$implicit;
    const \u0275$index_9_r5 = ctx_r3.$index;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", "part-" + \u0275$index_9_r5);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.condition().values[part_r2.key]);
    \u0275\u0275property("min", 0)("showButtons", true);
  }
}
function ConditionEditorComponent_Conditional_1_For_4_Case_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-select", 16);
    \u0275\u0275twoWayListener("ngModelChange", function ConditionEditorComponent_Conditional_1_For_4_Case_7_Template_p_select_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const part_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r2.condition().values[part_r2.key], $event) || (ctx_r2.condition().values[part_r2.key] = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function ConditionEditorComponent_Conditional_1_For_4_Case_7_Template_p_select_ngModelChange_0_listener() {
      \u0275\u0275restoreView(_r8);
      const part_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onFieldChange(part_r2.key));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const part_r2 = ctx_r3.$implicit;
    const \u0275$index_9_r5 = ctx_r3.$index;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", "part-" + \u0275$index_9_r5)("options", part_r2.options);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.condition().values[part_r2.key]);
    \u0275\u0275property("showClear", !part_r2.required);
  }
}
function ConditionEditorComponent_Conditional_1_For_4_Case_8_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 17)(1, "p-checkbox", 18);
    \u0275\u0275twoWayListener("ngModelChange", function ConditionEditorComponent_Conditional_1_For_4_Case_8_For_1_Template_p_checkbox_ngModelChange_1_listener($event) {
      \u0275\u0275restoreView(_r9);
      const part_r2 = \u0275\u0275nextContext(2).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r2.condition().values[part_r2.key], $event) || (ctx_r2.condition().values[part_r2.key] = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "label", 19);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const option_r10 = ctx.$implicit;
    const part_r2 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("name", "checklist-" + part_r2.key)("value", option_r10.value);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.condition().values[part_r2.key]);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(option_r10.label);
  }
}
function ConditionEditorComponent_Conditional_1_For_4_Case_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, ConditionEditorComponent_Conditional_1_For_4_Case_8_For_1_Template, 4, 4, "div", 17, _forTrack1);
  }
  if (rf & 2) {
    const part_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275repeater(part_r2.options);
  }
}
function ConditionEditorComponent_Conditional_1_For_4_Case_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-searchable-tree", 20);
    \u0275\u0275twoWayListener("ngModelChange", function ConditionEditorComponent_Conditional_1_For_4_Case_9_Template_app_searchable_tree_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const part_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r2.condition().values[part_r2.key], $event) || (ctx_r2.condition().values[part_r2.key] = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("nodeSelected", function ConditionEditorComponent_Conditional_1_For_4_Case_9_Template_app_searchable_tree_nodeSelected_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const part_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onSearchableTreeNodeSelected($event, part_r2.key));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_15_0;
    const part_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.condition().values[part_r2.key]);
    \u0275\u0275property("searchEnabled", true)("clientId", (tmp_15_0 = ctx_r2.clientDataService.getSelectedClient()) == null ? null : tmp_15_0.id)("entityType", part_r2.key)("searchPlaceholder", "Search " + part_r2.label + "...")("treeData", part_r2.options ?? \u0275\u0275pureFunction0(6, _c020));
  }
}
function ConditionEditorComponent_Conditional_1_For_4_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "small", 12);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const part_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(part_r2.hint);
  }
}
function ConditionEditorComponent_Conditional_1_For_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4)(1, "label", 5);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 6);
    \u0275\u0275conditionalCreate(4, ConditionEditorComponent_Conditional_1_For_4_Case_4_Template, 1, 2, "input", 7)(5, ConditionEditorComponent_Conditional_1_For_4_Case_5_Template, 1, 2, "input", 8)(6, ConditionEditorComponent_Conditional_1_For_4_Case_6_Template, 1, 4, "p-inputnumber", 9)(7, ConditionEditorComponent_Conditional_1_For_4_Case_7_Template, 1, 4, "p-select", 10)(8, ConditionEditorComponent_Conditional_1_For_4_Case_8_Template, 2, 0)(9, ConditionEditorComponent_Conditional_1_For_4_Case_9_Template, 1, 7, "app-searchable-tree", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(10, ConditionEditorComponent_Conditional_1_For_4_Conditional_10_Template, 2, 1, "small", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_14_0;
    const part_r2 = ctx.$implicit;
    const \u0275$index_9_r5 = ctx.$index;
    \u0275\u0275advance();
    \u0275\u0275property("for", "part-" + \u0275$index_9_r5);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(part_r2.label);
    \u0275\u0275advance(2);
    \u0275\u0275conditional((tmp_14_0 = part_r2.type) === "text" ? 4 : tmp_14_0 === "time" ? 5 : tmp_14_0 === "number" ? 6 : tmp_14_0 === "dropdown" ? 7 : tmp_14_0 === "checklist" ? 8 : tmp_14_0 === "searchableTree" ? 9 : -1);
    \u0275\u0275advance(6);
    \u0275\u0275conditional(part_r2.hint ? 10 : -1);
  }
}
function ConditionEditorComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1)(1, "h3", 3);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(3, ConditionEditorComponent_Conditional_1_For_4_Template, 11, 4, "div", 4, _forTrack02);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r2.getConditionTitle(ctx_r2.condition()));
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r2.getConditionParts(ctx_r2.condition()));
  }
}
function ConditionEditorComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-button", 21);
    \u0275\u0275listener("onClick", function ConditionEditorComponent_ng_template_2_Template_p_button_onClick_0_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onCancel());
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(1, "p-button", 22);
    \u0275\u0275listener("onClick", function ConditionEditorComponent_ng_template_2_Template_p_button_onClick_1_listener() {
      \u0275\u0275restoreView(_r12);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onSave());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("disabled", !ctx_r2.isConditionValid());
  }
}
var ConditionEditorComponent = class _ConditionEditorComponent {
  visible = model(false, ...ngDevMode ? [{ debugName: "visible" }] : []);
  condition = input(null, ...ngDevMode ? [{ debugName: "condition" }] : []);
  clientDataService = inject(ClientDataService);
  eventFilterConditionService = inject(EventFilterConditionService);
  cdr = inject(ChangeDetectorRef);
  saved = output();
  cancelled = output();
  ngOnInit() {
    const currentCondition = this.condition();
    if (isDefined(currentCondition)) {
      const parts = this.eventFilterConditionService.getConditionParts(currentCondition);
      for (const part of parts) {
        if (part.type === "checklist" && !Array.isArray(currentCondition.values[part.key])) {
          currentCondition.values[part.key] = [];
        }
      }
      void this.eventFilterConditionService.initializeConditionParts(currentCondition).then(() => {
        this.cdr.detectChanges();
      });
    }
  }
  constructor() {
    effect(async () => {
      const currentCondition = this.condition();
      if (isDefined(currentCondition)) {
        const parts = this.eventFilterConditionService.getConditionParts(currentCondition);
        for (const part of parts) {
          if (part.type === "checklist" && !Array.isArray(currentCondition.values[part.key])) {
            currentCondition.values[part.key] = [];
          }
        }
        await this.eventFilterConditionService.initializeConditionParts(currentCondition);
        this.cdr.detectChanges();
      }
    });
  }
  getConditionTitle(condition) {
    switch (condition.type) {
      case "speed":
        return "Speed Condition";
      case "time":
        return "Time Condition";
      case "zone":
        return "Zone Condition";
      case "distance":
        return "Distance Condition";
      case "duration":
        return "Duration Condition";
      case "days":
        return "Days of Week Condition";
      default:
        return `${condition.type.charAt(0).toUpperCase() + condition.type.slice(1)} Condition`;
    }
  }
  getConditionParts(condition) {
    return this.eventFilterConditionService.getConditionParts(condition);
  }
  isConditionValid() {
    const condition = this.condition();
    if (isNullOrUndefined(condition))
      return false;
    const parts = this.getConditionParts(condition);
    return parts.every((part) => {
      if (isDefined(part.required) && part.required === false)
        return true;
      if (part.type === "checklist" && Array.isArray(condition.values[part.key])) {
        return true;
      }
      return isDefined(condition.values[part.key]) && condition.values[part.key] !== "" && condition.values[part.key] !== null;
    });
  }
  onSave() {
    const condition = this.condition();
    if (isDefined(condition) && this.isConditionValid()) {
      this.eventFilterConditionService.updateConditionText(condition);
      this.saved.emit(condition);
    }
  }
  onVisibilityChange(isVisible) {
    if (!isVisible) {
      this.visible.set(false);
      this.onCancel();
    }
  }
  onCancel() {
    this.cancelled.emit();
  }
  async onSearchableTreeNodeSelected(node, fieldKey) {
    const condition = this.condition();
    if (isNullOrUndefined(condition))
      return;
    switch (fieldKey) {
      case "zone":
        condition.values["zoneId"] = node["id"] ?? node["targetId"];
        condition.values["zoneName"] = node["name"] ?? node["targetName"];
        break;
      case "asset":
        condition.values["assetId"] = node["id"] ?? node["actorId"];
        condition.values["assetName"] = node["name"] ?? node["actorName"];
        break;
      case "input":
        condition.values["inputName"] = node["name"] ?? node["text"];
        break;
    }
  }
  // Add method to handle field changes for linked dropdowns
  async onFieldChange(fieldKey) {
    const condition = this.condition();
    if (isDefined(condition)) {
      await this.eventFilterConditionService.onConditionFieldChange(condition, fieldKey);
      this.cdr.detectChanges();
    }
  }
  static \u0275fac = function ConditionEditorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ConditionEditorComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ConditionEditorComponent, selectors: [["app-condition-editor"]], inputs: { visible: [1, "visible"], condition: [1, "condition"] }, outputs: { visible: "visibleChange", saved: "saved", cancelled: "cancelled" }, decls: 3, vars: 4, consts: [["header", "Edit Condition", "styleClass", "w-[70vw] h-auto max-w-[800px]", "appendTo", "body", 3, "onHide", "visibleChange", "visible", "modal", "dismissableMask"], [1, "condition-editor", "p-3"], ["pTemplate", "footer"], [1, "mb-4"], [1, "mb-4", "field"], [1, "font-medium", 3, "for"], [1, "mt-1"], ["pInputText", "", 1, "w-full", 3, "id", "ngModel"], ["pInputText", "", "type", "time", 1, "w-full", 3, "id", "ngModel"], [1, "w-full", 3, "id", "ngModel", "min", "showButtons"], ["optionLabel", "label", "optionValue", "value", "placeholder", "Select an option", "appendTo", "body", 1, "w-full", 3, "id", "options", "ngModel", "showClear"], [3, "ngModel", "searchEnabled", "clientId", "entityType", "searchPlaceholder", "treeData"], [1, "text-secondary", "mt-1", "d-block"], ["pInputText", "", 1, "w-full", 3, "ngModelChange", "id", "ngModel"], ["pInputText", "", "type", "time", 1, "w-full", 3, "ngModelChange", "id", "ngModel"], [1, "w-full", 3, "ngModelChange", "id", "ngModel", "min", "showButtons"], ["optionLabel", "label", "optionValue", "value", "placeholder", "Select an option", "appendTo", "body", 1, "w-full", 3, "ngModelChange", "id", "options", "ngModel", "showClear"], [1, "flex", "items-center", "gap-1", "my-2"], ["inputId", "ny", 3, "ngModelChange", "name", "value", "ngModel"], ["for", "ny", 1, "font-medium"], [3, "ngModelChange", "nodeSelected", "ngModel", "searchEnabled", "clientId", "entityType", "searchPlaceholder", "treeData"], ["label", "Cancel", "icon", "pi pi-times", "severity", "secondary", 1, "p-button-text", 3, "onClick"], ["label", "Save", "icon", "pi pi-check", 3, "onClick", "disabled"]], template: function ConditionEditorComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "p-dialog", 0);
      \u0275\u0275listener("onHide", function ConditionEditorComponent_Template_p_dialog_onHide_0_listener() {
        return ctx.onCancel();
      })("visibleChange", function ConditionEditorComponent_Template_p_dialog_visibleChange_0_listener($event) {
        return ctx.onVisibilityChange($event);
      });
      \u0275\u0275conditionalCreate(1, ConditionEditorComponent_Conditional_1_Template, 5, 1, "div", 1);
      \u0275\u0275template(2, ConditionEditorComponent_ng_template_2_Template, 2, 1, "ng-template", 2);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275property("visible", ctx.visible())("modal", true)("dismissableMask", false);
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.condition() ? 1 : -1);
    }
  }, dependencies: [
    CommonModule,
    FormsModule,
    DefaultValueAccessor,
    NgControlStatus,
    NgModel,
    DialogModule,
    Dialog,
    PrimeTemplate,
    ButtonModule,
    Button,
    InputTextModule,
    InputText,
    InputNumberModule,
    InputNumber,
    SelectModule,
    Select,
    CheckboxModule,
    Checkbox,
    SearchableTreeComponent,
    DatePickerModule
  ], styles: ["\n\n.condition-editor[_ngcontent-%COMP%]   .checklist[_ngcontent-%COMP%] {\n  max-height: 200px;\n  overflow-y: auto;\n  border-radius: 4px;\n  padding: 8px;\n}\n.condition-editor[_ngcontent-%COMP%]   h3[_ngcontent-%COMP%] {\n  margin-top: 0;\n  margin-bottom: 1rem;\n  font-size: 1.25rem;\n}\n/*# sourceMappingURL=condition-editor.component.css.map */"], changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConditionEditorComponent, [{
    type: Component,
    args: [{ selector: "app-condition-editor", imports: [
      CommonModule,
      FormsModule,
      DialogModule,
      ButtonModule,
      InputTextModule,
      InputNumberModule,
      SelectModule,
      CheckboxModule,
      SearchableTreeComponent,
      DatePickerModule
    ], changeDetection: ChangeDetectionStrategy.OnPush, template: `<p-dialog
  [visible]="visible()"
  header="Edit Condition"
  [modal]="true"
  [dismissableMask]="false"
  (onHide)="onCancel()"
  (visibleChange)="onVisibilityChange($event)"
  styleClass="w-[70vw] h-auto max-w-[800px]"
  appendTo="body"
>
  @if (condition()) {
    <div class="condition-editor p-3">
      <h3 class="mb-4">{{ getConditionTitle(condition()!) }}</h3>

      <!-- Dynamic form based on condition type -->
      @for (
        part of getConditionParts(condition());
        track part.key;
        let i = $index
      ) {
        <div class="mb-4 field">
          <label class="font-medium" [for]="'part-' + i">{{
            part.label
          }}</label>

          <div class="mt-1">
            @switch (part.type) {
              <!-- Text input -->
              @case ('text') {
                <input
                  pInputText
                  [id]="'part-' + i"
                  [(ngModel)]="condition()!.values[part.key]"
                  class="w-full"
                />
              }

              <!-- Time input -->
              @case ('time') {
                <input
                  pInputText
                  type="time"
                  [id]="'part-' + i"
                  [(ngModel)]="condition()!.values[part.key]"
                  class="w-full"
                />
              }

              <!-- Number input -->
              @case ('number') {
                <p-inputnumber
                  [id]="'part-' + i"
                  [(ngModel)]="condition()!.values[part.key]"
                  [min]="0"
                  [showButtons]="true"
                  class="w-full"
                />
              }

              <!-- Dropdown selection -->
              @case ('dropdown') {
                <p-select
                  [id]="'part-' + i"
                  [options]="part.options"
                  [(ngModel)]="condition()!.values[part.key]"
                  (ngModelChange)="onFieldChange(part.key)"
                  optionLabel="label"
                  optionValue="value"
                  placeholder="Select an option"
                  [showClear]="!part.required"
                  class="w-full"
                  appendTo="body"
                />
              }

              <!-- Checklist -->
              @case ('checklist') {
                @for (option of part.options; track option.value) {
                  <div class="flex items-center gap-1 my-2">
                    <p-checkbox
                      inputId="ny"
                      [name]="'checklist-' + part.key"
                      [value]="option.value"
                      [(ngModel)]="condition()!.values[part.key]"
                    ></p-checkbox>
                    <label class="font-medium" for="ny">{{
                      option.label
                    }}</label>
                  </div>
                }
              }

              @case ('searchableTree') {
                <app-searchable-tree
                  [(ngModel)]="condition()!.values[part.key]"
                  [searchEnabled]="true"
                  [clientId]="clientDataService.getSelectedClient()?.id"
                  [entityType]="part.key"
                  [searchPlaceholder]="'Search ' + part.label + '...'"
                  [treeData]="part.options ?? []"
                  (nodeSelected)="
                    onSearchableTreeNodeSelected($event, part.key)
                  "
                ></app-searchable-tree>
              }
            }
          </div>

          @if (part.hint) {
            <small class="text-secondary mt-1 d-block">{{ part.hint }}</small>
          }
        </div>
      }
    </div>
  }
  <ng-template pTemplate="footer">
    <p-button
      class="p-button-text"
      label="Cancel"
      icon="pi pi-times"
      severity="secondary"
      (onClick)="onCancel()"
    ></p-button>
    <p-button
      label="Save"
      icon="pi pi-check"
      [disabled]="!isConditionValid()"
      (onClick)="onSave()"
    ></p-button>
  </ng-template>
</p-dialog>
`, styles: ["/* src/app/shared/components/forms/event-filter-field/condition-editor/condition-editor.component.scss */\n.condition-editor .checklist {\n  max-height: 200px;\n  overflow-y: auto;\n  border-radius: 4px;\n  padding: 8px;\n}\n.condition-editor h3 {\n  margin-top: 0;\n  margin-bottom: 1rem;\n  font-size: 1.25rem;\n}\n/*# sourceMappingURL=condition-editor.component.css.map */\n"] }]
  }], () => [], { visible: [{ type: Input, args: [{ isSignal: true, alias: "visible", required: false }] }, { type: Output, args: ["visibleChange"] }], condition: [{ type: Input, args: [{ isSignal: true, alias: "condition", required: false }] }], saved: [{ type: Output, args: ["saved"] }], cancelled: [{ type: Output, args: ["cancelled"] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ConditionEditorComponent, { className: "ConditionEditorComponent", filePath: "src/app/shared/components/forms/event-filter-field/condition-editor/condition-editor.component.ts", lineNumber: 46 });
})();

// src/app/shared/components/forms/event-filter-field/actor-selector/actor-selector.component.ts
function ActorSelectorComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 5);
    \u0275\u0275text(1, "When");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "span", 1);
    \u0275\u0275listener("click", function ActorSelectorComponent_Conditional_1_Template_span_click_2_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showActorDropdown = true);
    })("keydown.enter", function ActorSelectorComponent_Conditional_1_Template_span_keydown_enter_2_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.showActorDropdown = true);
    });
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "p-overlay", 2);
    \u0275\u0275twoWayListener("visibleChange", function ActorSelectorComponent_Conditional_1_Template_p_overlay_visibleChange_4_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.showActorDropdown, $event) || (ctx_r1.showActorDropdown = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementStart(5, "div", 6)(6, "p-treeselect", 7);
    \u0275\u0275twoWayListener("ngModelChange", function ActorSelectorComponent_Conditional_1_Template_p_treeselect_ngModelChange_6_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r1.actor, $event) || (ctx_r1.actor = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("onNodeSelect", function ActorSelectorComponent_Conditional_1_Template_p_treeselect_onNodeSelect_6_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onActorSelected());
    });
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    let tmp_1_0;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", ((tmp_1_0 = ctx_r1.actor()) == null ? null : tmp_1_0.data == null ? null : tmp_1_0.data["text"]) || "actor", " ");
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("visible", ctx_r1.showActorDropdown);
    \u0275\u0275advance(2);
    \u0275\u0275property("options", ctx_r1.actorNodes())("filter", true)("filterInputAutoFocus", true);
    \u0275\u0275twoWayProperty("ngModel", ctx_r1.actor);
    \u0275\u0275property("showClear", true);
  }
}
var ActorSelectorComponent = class _ActorSelectorComponent {
  actorNodes = input([], ...ngDevMode ? [{ debugName: "actorNodes" }] : []);
  actionNodes = input([], ...ngDevMode ? [{ debugName: "actionNodes" }] : []);
  requireActorBeforeAction = input(true, ...ngDevMode ? [{ debugName: "requireActorBeforeAction" }] : []);
  actorId = input(void 0, ...ngDevMode ? [{ debugName: "actorId" }] : []);
  actionId = input(void 0, ...ngDevMode ? [{ debugName: "actionId" }] : []);
  actor = model(void 0, ...ngDevMode ? [{ debugName: "actor" }] : []);
  action = model(void 0, ...ngDevMode ? [{ debugName: "action" }] : []);
  showActorDropdown = false;
  showActionDropdown = false;
  constructor() {
    effect(() => {
      const actorIdValue = this.actorId();
      const actionIdValue = this.actionId();
      if (isDefined(actorIdValue) && this.actorNodes()?.length > 0) {
        const matchedActor = this.findActorNodeById(this.actorNodes(), actorIdValue);
        if (isDefined(matchedActor) && matchedActor !== this.actor()) {
          this.actor.set(matchedActor);
        }
      }
      if (isDefined(actionIdValue) && this.actionNodes()?.length) {
        const matchedAction = this.findActionNodeById(this.actionNodes(), actionIdValue);
        if (isDefined(matchedAction) && matchedAction !== this.action()) {
          this.action.set(matchedAction);
        }
      }
    });
  }
  onActorSelected() {
    this.showActorDropdown = false;
  }
  onActionSelected() {
    this.showActionDropdown = false;
  }
  handleActionClick() {
    if (this.requireActorBeforeAction() && this.actorNodes().length > 0 && isNullOrUndefined(this.actor())) {
      return;
    }
    this.showActionDropdown = true;
  }
  findActorNodeById(nodes, id) {
    if (isNullOrUndefined(nodes) || !id)
      return void 0;
    for (const node of nodes) {
      if (node.id === id || node.data?.actorId === id) {
        return node;
      }
      if (isDefined(node.children)) {
        const found = this.findActorNodeById(node.children, id);
        if (found)
          return found;
      }
    }
    return void 0;
  }
  findActionNodeById(nodes, id) {
    if (isNullOrUndefined(nodes) || !id)
      return void 0;
    for (const node of nodes) {
      if (node.id === id || node.data?.eventType === id) {
        return node;
      }
      if (isDefined(node.children)) {
        const found = this.findActionNodeById(node.children, id);
        if (found)
          return found;
      }
    }
    return void 0;
  }
  static \u0275fac = function ActorSelectorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ActorSelectorComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ActorSelectorComponent, selectors: [["app-actor-selector"]], inputs: { actorNodes: [1, "actorNodes"], actionNodes: [1, "actionNodes"], requireActorBeforeAction: [1, "requireActorBeforeAction"], actorId: [1, "actorId"], actionId: [1, "actionId"], actor: [1, "actor"], action: [1, "action"] }, outputs: { actor: "actorChange", action: "actionChange" }, decls: 7, vars: 8, consts: [[1, "filter-header"], [1, "underlined-field", "cursor-pointer", "mr-2", 3, "click", "keydown.enter"], ["appendTo", "body", 3, "visibleChange", "visible"], [1, "dropdown-panel", "p-0", "surface-card", "shadow-2", "border-round"], ["placeholder", "Select Action", "optionLabel", "name", "styleClass", "w-full bg-(--p-tree-background) min-w-[200px]", 3, "ngModelChange", "onNodeSelect", "options", "ngModel", "showClear"], [1, "filter-text"], [1, "p-0", "border-round"], ["placeholder", "Select Actor", 1, "w-full", "tree-select-background", "min-w-[200px]", 3, "ngModelChange", "onNodeSelect", "options", "filter", "filterInputAutoFocus", "ngModel", "showClear"]], template: function ActorSelectorComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0);
      \u0275\u0275conditionalCreate(1, ActorSelectorComponent_Conditional_1_Template, 7, 7);
      \u0275\u0275elementStart(2, "span", 1);
      \u0275\u0275listener("click", function ActorSelectorComponent_Template_span_click_2_listener() {
        return ctx.handleActionClick();
      })("keydown.enter", function ActorSelectorComponent_Template_span_keydown_enter_2_listener() {
        return ctx.handleActionClick();
      });
      \u0275\u0275text(3);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(4, "p-overlay", 2);
      \u0275\u0275twoWayListener("visibleChange", function ActorSelectorComponent_Template_p_overlay_visibleChange_4_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.showActionDropdown, $event) || (ctx.showActionDropdown = $event);
        return $event;
      });
      \u0275\u0275elementStart(5, "div", 3)(6, "p-treeselect", 4);
      \u0275\u0275twoWayListener("ngModelChange", function ActorSelectorComponent_Template_p_treeselect_ngModelChange_6_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.action, $event) || (ctx.action = $event);
        return $event;
      });
      \u0275\u0275listener("onNodeSelect", function ActorSelectorComponent_Template_p_treeselect_onNodeSelect_6_listener() {
        return ctx.onActionSelected();
      });
      \u0275\u0275elementEnd()()()();
    }
    if (rf & 2) {
      let tmp_2_0;
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.actorNodes().length > 0 || ctx.requireActorBeforeAction() ? 1 : -1);
      \u0275\u0275advance();
      \u0275\u0275classProp("disabled-text", !ctx.actor() && ctx.requireActorBeforeAction() && ctx.actorNodes().length > 0);
      \u0275\u0275advance();
      \u0275\u0275textInterpolate1(" ", ((tmp_2_0 = ctx.action()) == null ? null : tmp_2_0.data == null ? null : tmp_2_0.data["text"]) || "action", " ");
      \u0275\u0275advance();
      \u0275\u0275twoWayProperty("visible", ctx.showActionDropdown);
      \u0275\u0275advance(2);
      \u0275\u0275property("options", ctx.actionNodes());
      \u0275\u0275twoWayProperty("ngModel", ctx.action);
      \u0275\u0275property("showClear", true);
    }
  }, dependencies: [CommonModule, FormsModule, NgControlStatus, NgModel, TreeSelectModule, TreeSelect, OverlayModule, Overlay], styles: ["\n\n[_nghost-%COMP%] {\n  --p-treeselect-background: var(--p-tree-background) !important;\n}\n[_nghost-%COMP%]   .p-treeselect-label.p-placeholder[_ngcontent-%COMP%] {\n  color: var(--p-select-option-color);\n}\n/*# sourceMappingURL=actor-selector.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActorSelectorComponent, [{
    type: Component,
    args: [{ selector: "app-actor-selector", imports: [CommonModule, FormsModule, TreeSelectModule, OverlayModule], template: `<div class="filter-header">
  <!-- Actor Selection - Only show if there are actor nodes or if actor is required -->
  @if (actorNodes().length > 0 || requireActorBeforeAction()) {
    <span class="filter-text">When</span>
    <span
      class="underlined-field cursor-pointer mr-2"
      (click)="showActorDropdown = true"
      (keydown.enter)="showActorDropdown = true"
    >
      {{ actor()?.data?.['text'] || 'actor' }}
    </span>
    <p-overlay [(visible)]="showActorDropdown" appendTo="body">
      <div class="p-0 border-round">
        <p-treeselect
          [options]="actorNodes()"
          [filter]="true"
          [filterInputAutoFocus]="true"
          [(ngModel)]="actor"
          (onNodeSelect)="onActorSelected()"
          placeholder="Select Actor"
          [showClear]="true"
          class="w-full tree-select-background min-w-[200px]"
        ></p-treeselect>
      </div>
    </p-overlay>
  }

  <!-- Action Selection -->
  <span
    class="underlined-field cursor-pointer mr-2"
    [class.disabled-text]="
      !actor() && requireActorBeforeAction() && actorNodes().length > 0
    "
    (click)="handleActionClick()"
    (keydown.enter)="handleActionClick()"
  >
    {{ action()?.data?.['text'] || 'action' }}
  </span>
  <p-overlay [(visible)]="showActionDropdown" appendTo="body">
    <div class="dropdown-panel p-0 surface-card shadow-2 border-round">
      <p-treeselect
        [options]="actionNodes()"
        [(ngModel)]="action"
        (onNodeSelect)="onActionSelected()"
        placeholder="Select Action"
        optionLabel="name"
        [showClear]="true"
        styleClass="w-full bg-(--p-tree-background) min-w-[200px]"
      ></p-treeselect>
    </div>
  </p-overlay>
</div>
`, styles: ["/* src/app/shared/components/forms/event-filter-field/actor-selector/actor-selector.component.scss */\n:host {\n  --p-treeselect-background: var(--p-tree-background) !important;\n}\n:host .p-treeselect-label.p-placeholder {\n  color: var(--p-select-option-color);\n}\n/*# sourceMappingURL=actor-selector.component.css.map */\n"] }]
  }], () => [], { actorNodes: [{ type: Input, args: [{ isSignal: true, alias: "actorNodes", required: false }] }], actionNodes: [{ type: Input, args: [{ isSignal: true, alias: "actionNodes", required: false }] }], requireActorBeforeAction: [{ type: Input, args: [{ isSignal: true, alias: "requireActorBeforeAction", required: false }] }], actorId: [{ type: Input, args: [{ isSignal: true, alias: "actorId", required: false }] }], actionId: [{ type: Input, args: [{ isSignal: true, alias: "actionId", required: false }] }], actor: [{ type: Input, args: [{ isSignal: true, alias: "actor", required: false }] }, { type: Output, args: ["actorChange"] }], action: [{ type: Input, args: [{ isSignal: true, alias: "action", required: false }] }, { type: Output, args: ["actionChange"] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ActorSelectorComponent, { className: "ActorSelectorComponent", filePath: "src/app/shared/components/forms/event-filter-field/actor-selector/actor-selector.component.ts", lineNumber: 19 });
})();

// src/app/shared/components/forms/event-filter-field/event-filter-field/event-filter-field.component.ts
var import_lodash2 = __toESM(require_lodash());
var _c021 = ["actorDropdown"];
var _c117 = ["actionDropdown"];
var _c213 = ["targetDropdown"];
var _c311 = ["conditionDropdown"];
function EventFilterFieldComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-condition-list", 6);
    \u0275\u0275listener("editCondition", function EventFilterFieldComponent_Conditional_4_Template_app_condition_list_editCondition_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onEditCondition($event));
    })("removeCondition", function EventFilterFieldComponent_Conditional_4_Template_app_condition_list_removeCondition_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onRemoveCondition($event));
    })("addCondition", function EventFilterFieldComponent_Conditional_4_Template_app_condition_list_addCondition_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onAddCondition($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("conditions", ctx_r1.value().conditions)("availableConditions", ctx_r1.availableConditions())("minConditions", ctx_r1.minConditions());
  }
}
function provideEventFilterFieldValueAccessor() {
  return {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line @angular-eslint/no-forward-ref
    useExisting: forwardRef(() => EventFilterFieldComponent),
    multi: true
  };
}
var EventFilterFieldComponent = class _EventFilterFieldComponent {
  cdr = inject(ChangeDetectorRef);
  id = input(...ngDevMode ? [void 0, { debugName: "id" }] : []);
  required = input(false, ...ngDevMode ? [{ debugName: "required" }] : []);
  groupTypes = input([], ...ngDevMode ? [{ debugName: "groupTypes" }] : []);
  targetNodes = signal([], ...ngDevMode ? [{ debugName: "targetNodes" }] : []);
  filterService = input(inject(EventFilterService), ...ngDevMode ? [{ debugName: "filterService" }] : []);
  // Configuration inputs with defaults matching current behavior
  minConditions = input(0, ...ngDevMode ? [{ debugName: "minConditions" }] : []);
  requireActorBeforeAction = input(false, ...ngDevMode ? [{ debugName: "requireActorBeforeAction" }] : []);
  requireActionForConditions = input(true, ...ngDevMode ? [{ debugName: "requireActionForConditions" }] : []);
  actorNodes = signal([], ...ngDevMode ? [{ debugName: "actorNodes" }] : []);
  actionNodes = signal([], ...ngDevMode ? [{ debugName: "actionNodes" }] : []);
  availableConditions = signal([], ...ngDevMode ? [{ debugName: "availableConditions" }] : []);
  eventFilterConditionService = inject(EventFilterConditionService);
  value = signal({ conditions: [] }, ...ngDevMode ? [{ debugName: "value" }] : []);
  get actor() {
    return this.value().actor;
  }
  set actor(newValue) {
    this.value.update((val) => __spreadProps(__spreadValues({}, val), { actor: newValue }));
    this.onEventFilterChange(this.transformFilterItemForOutput(this.value()));
    this.updateAvailableConditions();
  }
  get action() {
    return this.value().action;
  }
  set action(newValue) {
    this.value.update((val) => __spreadProps(__spreadValues({}, val), { action: newValue }));
    this.onEventFilterChange(this.transformFilterItemForOutput(this.value()));
    this.updateAvailableConditions();
    this.updateTargetNodes();
  }
  get target() {
    return this.value().target;
  }
  set target(newValue) {
    this.value.update((val) => __spreadProps(__spreadValues({}, val), { target: newValue }));
    this.onEventFilterChange(this.transformFilterItemForOutput(this.value()));
  }
  // Editor state
  selectedCondition = null;
  selectedConditionIndex = -1;
  showConditionEditor = false;
  // Access dropdown components
  actorDropdown;
  actionDropdown;
  targetDropdown;
  conditionDropdown;
  conditionEditor;
  touched = false;
  onEventFilterChange = () => {
  };
  onTouch = () => {
  };
  constructor() {
    effect(() => {
      const _actor = this.value().actor;
      const _action = this.value().action;
      if (isDefined(_action)) {
        this.updateAvailableConditions();
      }
    });
  }
  ngOnInit() {
    this.updateAvailableConditions();
    this.loadAllNodes().catch(() => {
    });
  }
  transformFilterItemForOutput(value) {
    if (isNullOrUndefined(value))
      return null;
    return {
      actor: value.actor,
      action: value.action,
      target: value.target,
      conditions: value.conditions?.map((condition) => __spreadValues({}, condition))
    };
  }
  async loadAllNodes() {
    try {
      const [assetTree, actionTree] = await Promise.all([
        this.filterService().getAssetSelectionTree(this.groupTypes()),
        Promise.resolve(this.filterService().getActionEventsTree())
      ]);
      this.actorNodes.set(assetTree);
      this.actionNodes.set(actionTree);
      this.cdr.markForCheck();
    } catch (error) {
      console.error("Error loading nodes:", error);
      this.actorNodes.set([]);
      this.actionNodes.set([]);
    }
  }
  transformIncomingValue(value) {
    const transformField = (fieldValue) => {
      if (!isDefined(fieldValue)) {
        return void 0;
      }
      if (typeof fieldValue !== "object" || fieldValue === null || isNullOrUndefined(fieldValue["data"]) && isNullOrUndefined(fieldValue["key"])) {
        return { data: fieldValue };
      }
      return fieldValue;
    };
    return {
      actor: transformField(value.actor),
      action: transformField(value.action),
      target: transformField(value.target),
      conditions: value.conditions ?? []
    };
  }
  // Helper to find a node by its key in a tree structure (recursive)
  findNodeById(nodes, key) {
    if (isNullOrUndefined(key) || isNullOrUndefined(nodes) || nodes.length === 0)
      return void 0;
    for (const node of nodes) {
      if (node.id === key)
        return node;
      if (isDefined(node.children) && node.children.length > 0) {
        const foundInChildren = this.findNodeById(node.children, key);
        if (foundInChildren)
          return foundInChildren;
      }
    }
    return void 0;
  }
  // Helper to generate the key from actor data
  generateActorKeyFromData(actorData) {
    if (isNullOrUndefined(actorData))
      return void 0;
    const actorSelectionType = actorData.actorSelectionType ?? "";
    const actorTypeId = actorData.actorTypeId;
    const actorId = actorData.actorId;
    if (actorSelectionType === "any" && isDefined(actorTypeId)) {
      return `any.${actorTypeId}`;
    } else if (["costcentre", "group", "category"].includes(actorSelectionType) && isDefined(actorTypeId) && isDefined(actorId)) {
      return `${actorSelectionType}.${actorTypeId}.${actorId}`;
    }
    return actorData.actorId;
  }
  // Helper to generate the key from action data
  generateActionKeyFromData(actionData) {
    if (isNullOrUndefined(actionData))
      return void 0;
    const eventClass = actionData.eventClass;
    const eventType = actionData.eventType;
    if (isDefined(eventClass) && isDefined(eventType)) {
      return `event-${eventClass}-${eventType}`;
    } else if (isDefined(eventClass)) {
      return `event-${eventClass}`;
    }
    return void 0;
  }
  // Helper to generate key from target data (example, adjust if target key generation is different)
  generateTargetKeyFromData(targetData) {
    if (isNullOrUndefined(targetData))
      return void 0;
    return targetData.targetId;
  }
  writeValue(value) {
    if (isDefined(value)) {
      const initialTransformedValue = this.transformIncomingValue(value);
      if (isDefined(initialTransformedValue.conditions) && initialTransformedValue.conditions.length > 0) {
        for (const condition of initialTransformedValue.conditions) {
          this.eventFilterConditionService.initializeConditionParts(condition).catch(() => {
          });
        }
      }
      this.loadAllNodes().then(async () => {
        let finalActorNode = void 0;
        if (isDefined(initialTransformedValue.actor?.data)) {
          const actorKey = this.generateActorKeyFromData(initialTransformedValue?.actor?.data);
          finalActorNode = this.findNodeById(this.actorNodes(), actorKey);
        }
        let finalActionNode = void 0;
        if (isDefined(initialTransformedValue?.action?.data)) {
          const actionKey = this.generateActionKeyFromData(initialTransformedValue?.action?.data);
          finalActionNode = this.findNodeById(this.actionNodes(), actionKey);
        }
        let finalTargetNode = void 0;
        if (isDefined(initialTransformedValue.target?.data) && isDefined(initialTransformedValue.action?.data?.targetType)) {
          await this.filterService().getTargetNodes(initialTransformedValue.action.data.targetType).then((nodes) => {
            this.targetNodes.set(nodes);
          }).catch(() => {
          });
          const targetKey = this.generateTargetKeyFromData(initialTransformedValue?.target?.data);
          finalTargetNode = this.findNodeById(this.targetNodes(), targetKey);
        }
        this.value.set({
          actor: finalActorNode,
          action: finalActionNode,
          target: finalTargetNode,
          conditions: initialTransformedValue.conditions ?? []
        });
        if (isDefined(this.value().action)) {
          this.updateAvailableConditions();
        }
        this.cdr.markForCheck();
      }).catch((error) => {
        console.error("Error loading nodes or processing value in writeValue:", error);
        this.value.set(initialTransformedValue);
        this.cdr.markForCheck();
      });
    } else {
      this.value.set({
        actor: void 0,
        action: void 0,
        target: void 0,
        conditions: []
      });
      this.cdr.markForCheck();
    }
  }
  registerOnChange(fn) {
    this.onEventFilterChange = (value) => {
      const transformedValue = this.transformFilterItemForOutput(value);
      fn(transformedValue);
    };
  }
  registerOnTouched(fn) {
    this.onTouch = fn;
  }
  setDisabledState(_isDisabled) {
  }
  /**
   * Constructs the proper actor ID based on the filter value
   */
  getActorNodeId() {
    const actor = this.value()?.actor;
    if (isNullOrUndefined(actor))
      return void 0;
    const actorSelectionType = actor?.data?.actorSelectionType ?? "";
    const actorTypeId = actor?.data?.actorTypeId;
    const actorId = actor?.data?.actorId;
    if (actorSelectionType === "any" && isDefined(actorTypeId)) {
      return `any.${actorTypeId}`;
    } else if (["costcentre", "group", "category"].includes(actorSelectionType) && isDefined(actorTypeId) && isDefined(actorId)) {
      return `${actorSelectionType}.${actorTypeId}.${actorId}`;
    }
    return actor?.data?.actorId;
  }
  /**
   * Constructs the proper action ID based on the filter value
   */
  getActionNodeId() {
    const actionNode = this.value()?.action;
    if (isNullOrUndefined(actionNode) || isNullOrUndefined(actionNode.data))
      return void 0;
    return actionNode.key ?? this.generateActionKeyFromData(actionNode.data);
  }
  canShowConditions() {
    if (this.requireActorBeforeAction() && isNullOrUndefined(this.actor)) {
      return false;
    }
    if (this.requireActionForConditions() && isNullOrUndefined(this.action)) {
      return false;
    }
    return true;
  }
  updateAvailableConditions() {
    if (isDefined(this.action?.data)) {
      this.availableConditions.set(this.filterService().getConditionsTree(this.action.data));
      this.cdr.markForCheck();
    } else {
      this.availableConditions.set([]);
      this.cdr.markForCheck();
    }
  }
  updateTargetNodes() {
    if (isDefined(this.action?.data?.targetType)) {
      this.filterService().getTargetNodes(this.action?.data?.targetType).then((nodes) => {
        this.targetNodes.set(nodes);
        this.cdr.markForCheck();
      }).catch(() => {
      });
    }
  }
  // Handle condition add from condition list
  onAddCondition(node) {
    if (isNullOrUndefined(node?.data))
      return;
    const newCondition = {
      id: node.data.id ?? Date.now().toString(),
      type: node.data.type,
      text: { display: "" },
      values: {}
    };
    this.selectedCondition = (0, import_lodash2.cloneDeep)(newCondition);
    this.selectedConditionIndex = -1;
    this.showConditionEditor = true;
    this.touched = true;
    this.cdr.markForCheck();
  }
  onEditCondition(data) {
    this.selectedCondition = (0, import_lodash2.cloneDeep)(data.condition);
    this.selectedConditionIndex = data.index;
    this.showConditionEditor = true;
    this.cdr.markForCheck();
  }
  onSaveCondition(condition) {
    if (this.selectedConditionIndex >= 0) {
      const updatedConditions = [...this.value().conditions];
      updatedConditions[this.selectedConditionIndex] = condition;
      this.value.update((current) => __spreadProps(__spreadValues({}, current), {
        conditions: updatedConditions
      }));
    } else {
      this.value.update((current) => __spreadProps(__spreadValues({}, current), {
        conditions: [...current.conditions, condition]
      }));
    }
    this.touched = true;
    this.onEventFilterChange(this.value());
    this.closeConditionEditor();
  }
  onRemoveCondition(condition) {
    const updatedConditions = this.value().conditions.filter((c2) => c2 !== condition);
    this.value.update((current) => __spreadProps(__spreadValues({}, current), {
      conditions: updatedConditions
    }));
    this.touched = true;
    this.onEventFilterChange(this.value());
    this.cdr.markForCheck();
  }
  closeConditionEditor() {
    this.selectedCondition = null;
    this.selectedConditionIndex = -1;
    this.showConditionEditor = false;
    this.cdr.markForCheck();
  }
  isValid() {
    const filter2 = this.value();
    if (this.requireActorBeforeAction() && isNullOrUndefined(filter2.actor)) {
      return false;
    }
    if (isNullOrUndefined(filter2.action)) {
      return false;
    }
    if (isDefined(filter2.action?.data?.targetType) && isNullOrUndefined(filter2.target)) {
      return false;
    }
    if (filter2.conditions.length < this.minConditions()) {
      return false;
    }
    const allConditionsValid = filter2.conditions.every((condition) => {
      const hasRequiredValues = Object.keys(condition.values).length > 0;
      return hasRequiredValues && isDefined(condition.type);
    });
    return allConditionsValid;
  }
  static \u0275fac = function EventFilterFieldComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EventFilterFieldComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _EventFilterFieldComponent, selectors: [["app-event-filter-field"]], viewQuery: function EventFilterFieldComponent_Query(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275viewQuery(_c021, 5);
      \u0275\u0275viewQuery(_c117, 5);
      \u0275\u0275viewQuery(_c213, 5);
      \u0275\u0275viewQuery(_c311, 5);
      \u0275\u0275viewQuery(ConditionEditorComponent, 5);
    }
    if (rf & 2) {
      let _t;
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.actorDropdown = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.actionDropdown = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.targetDropdown = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.conditionDropdown = _t.first);
      \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.conditionEditor = _t.first);
    }
  }, inputs: { id: [1, "id"], required: [1, "required"], groupTypes: [1, "groupTypes"], filterService: [1, "filterService"], minConditions: [1, "minConditions"], requireActorBeforeAction: [1, "requireActorBeforeAction"], requireActionForConditions: [1, "requireActionForConditions"] }, features: [\u0275\u0275ProvidersFeature([provideEventFilterFieldValueAccessor()])], decls: 6, vars: 13, consts: [[1, "event-filter-field", "p-3", "border", "border-gray-300", "rounded"], [1, "mb-3"], [3, "actorChange", "actionChange", "actorNodes", "actionNodes", "requireActorBeforeAction", "actorId", "actionId", "actor", "action"], [3, "targetChange", "targetType", "targets", "target"], [3, "conditions", "availableConditions", "minConditions"], [3, "visibleChange", "saved", "cancelled", "visible", "condition"], [3, "editCondition", "removeCondition", "addCondition", "conditions", "availableConditions", "minConditions"]], template: function EventFilterFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "div", 0)(1, "div", 1)(2, "app-actor-selector", 2);
      \u0275\u0275twoWayListener("actorChange", function EventFilterFieldComponent_Template_app_actor_selector_actorChange_2_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.actor, $event) || (ctx.actor = $event);
        return $event;
      })("actionChange", function EventFilterFieldComponent_Template_app_actor_selector_actionChange_2_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.action, $event) || (ctx.action = $event);
        return $event;
      });
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "app-target-selector", 3);
      \u0275\u0275twoWayListener("targetChange", function EventFilterFieldComponent_Template_app_target_selector_targetChange_3_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.target, $event) || (ctx.target = $event);
        return $event;
      });
      \u0275\u0275elementEnd()();
      \u0275\u0275conditionalCreate(4, EventFilterFieldComponent_Conditional_4_Template, 1, 3, "app-condition-list", 4);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(5, "app-condition-editor", 5);
      \u0275\u0275twoWayListener("visibleChange", function EventFilterFieldComponent_Template_app_condition_editor_visibleChange_5_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.showConditionEditor, $event) || (ctx.showConditionEditor = $event);
        return $event;
      });
      \u0275\u0275listener("saved", function EventFilterFieldComponent_Template_app_condition_editor_saved_5_listener($event) {
        return ctx.onSaveCondition($event);
      })("cancelled", function EventFilterFieldComponent_Template_app_condition_editor_cancelled_5_listener() {
        return ctx.closeConditionEditor();
      });
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      let tmp_7_0;
      \u0275\u0275advance(2);
      \u0275\u0275property("actorNodes", ctx.actorNodes())("actionNodes", ctx.actionNodes())("requireActorBeforeAction", ctx.requireActorBeforeAction())("actorId", ctx.getActorNodeId())("actionId", ctx.getActionNodeId());
      \u0275\u0275twoWayProperty("actor", ctx.actor)("action", ctx.action);
      \u0275\u0275advance();
      \u0275\u0275property("targetType", (tmp_7_0 = ctx.value().action) == null ? null : tmp_7_0.data == null ? null : tmp_7_0.data.targetType)("targets", ctx.targetNodes());
      \u0275\u0275twoWayProperty("target", ctx.target);
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.canShowConditions() ? 4 : -1);
      \u0275\u0275advance();
      \u0275\u0275twoWayProperty("visible", ctx.showConditionEditor);
      \u0275\u0275property("condition", ctx.selectedCondition);
    }
  }, dependencies: [
    CommonModule,
    FormsModule,
    ReactiveFormsModule,
    ButtonModule,
    InputTextModule,
    SelectModule,
    ActorSelectorComponent,
    TargetSelectorComponent,
    ConditionListComponent,
    ConditionEditorComponent
  ], styles: ["\n\n.underlined-field[_ngcontent-%COMP%] {\n  text-decoration: underline;\n  color: var(--color-primary-color, #2196f3);\n  font-weight: 500;\n  padding: 0.25rem 0;\n}\n.underlined-field[_ngcontent-%COMP%]:hover {\n  color: var(--primary-600, #1e88e5);\n}\n.underlined-field.disabled-text[_ngcontent-%COMP%] {\n  color: #ccc;\n  cursor: not-allowed;\n}\n.underlined-field.disabled-text[_ngcontent-%COMP%]:hover {\n  color: #ccc;\n  text-decoration: underline;\n}\n.dropdown-panel[_ngcontent-%COMP%] {\n  min-width: 250px;\n}\n.condition-item[_ngcontent-%COMP%] {\n  background-color: #f8f9fa;\n  border-radius: 4px;\n}\n.condition-item[_ngcontent-%COMP%]:hover {\n  background-color: #e9ecef;\n}\n.condition-item[_ngcontent-%COMP%]   .condition-text[_ngcontent-%COMP%] {\n  padding: 8px;\n  flex: 1;\n}\n.condition-item[_ngcontent-%COMP%]   .condition-text[_ngcontent-%COMP%]:hover {\n  text-decoration: underline;\n}\n.condition-editor[_ngcontent-%COMP%]   .field[_ngcontent-%COMP%] {\n  margin-bottom: 1rem;\n}\n.condition-editor[_ngcontent-%COMP%]   .field[_ngcontent-%COMP%]   label[_ngcontent-%COMP%] {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n}\n.condition-editor[_ngcontent-%COMP%]   .field-checkbox[_ngcontent-%COMP%] {\n  margin-bottom: 0.5rem;\n}\n.condition-editor[_ngcontent-%COMP%]   .checklist[_ngcontent-%COMP%] {\n  max-height: 200px;\n  overflow-y: auto;\n  border: 1px solid #ced4da;\n  border-radius: 4px;\n  padding: 8px;\n}\n.p-error[_ngcontent-%COMP%] {\n  font-size: 0.875rem;\n}\n.event-filter-field[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%] {\n  margin-bottom: 1rem;\n}\n.event-filter-field[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]:last-child {\n  margin-bottom: 0;\n}\n.event-filter-field[_ngcontent-%COMP%]   .filter-section[_ngcontent-%COMP%]   .section-title[_ngcontent-%COMP%] {\n  font-weight: 500;\n  margin-bottom: 0.5rem;\n}\n.event-filter-field[_ngcontent-%COMP%]   .actor-action-section[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n}\n@media (min-width: 768px) {\n  .event-filter-field[_ngcontent-%COMP%]   .actor-action-section[_ngcontent-%COMP%] {\n    flex-direction: row;\n    align-items: center;\n  }\n  .event-filter-field[_ngcontent-%COMP%]   .actor-action-section[_ngcontent-%COMP%]   .filter-item[_ngcontent-%COMP%] {\n    flex: 1;\n  }\n}\n.event-filter-field[_ngcontent-%COMP%]   .conditions-section[_ngcontent-%COMP%] {\n  margin-top: 1rem;\n  padding-top: 1rem;\n}\n.event-filter-field.invalid[_ngcontent-%COMP%] {\n  border-color: #f44336;\n}\n.event-filter-field.invalid[_ngcontent-%COMP%]   .error-message[_ngcontent-%COMP%] {\n  color: #f44336;\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}\n/*# sourceMappingURL=event-filter-field.component.css.map */"], changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventFilterFieldComponent, [{
    type: Component,
    args: [{ selector: "app-event-filter-field", imports: [
      CommonModule,
      FormsModule,
      ReactiveFormsModule,
      ButtonModule,
      InputTextModule,
      SelectModule,
      ActorSelectorComponent,
      TargetSelectorComponent,
      ConditionListComponent,
      ConditionEditorComponent
    ], changeDetection: ChangeDetectionStrategy.OnPush, providers: [provideEventFilterFieldValueAccessor()], template: '<div class="event-filter-field p-3 border border-gray-300 rounded">\n  <!-- Actor/Action Selector Component -->\n  <div class="mb-3">\n    <app-actor-selector\n      [actorNodes]="actorNodes()"\n      [actionNodes]="actionNodes()"\n      [requireActorBeforeAction]="requireActorBeforeAction()"\n      [actorId]="getActorNodeId()"\n      [actionId]="getActionNodeId()"\n      [(actor)]="actor"\n      [(action)]="action"\n    ></app-actor-selector>\n\n    <!-- Target Selector Component -->\n    <app-target-selector\n      [targetType]="value().action?.data?.targetType"\n      [targets]="targetNodes()"\n      [(target)]="target"\n    ></app-target-selector>\n  </div>\n\n  <!-- Condition List Component - Show Only If Actor and Action (if required) are selected -->\n  @if (canShowConditions()) {\n    <app-condition-list\n      [conditions]="value().conditions"\n      [availableConditions]="availableConditions()"\n      [minConditions]="minConditions()"\n      (editCondition)="onEditCondition($event)"\n      (removeCondition)="onRemoveCondition($event)"\n      (addCondition)="onAddCondition($event)"\n    ></app-condition-list>\n  }\n</div>\n\n<!-- Condition Editor Component -->\n<app-condition-editor\n  [(visible)]="showConditionEditor"\n  [condition]="selectedCondition"\n  (saved)="onSaveCondition($event)"\n  (cancelled)="closeConditionEditor()"\n></app-condition-editor>\n', styles: ["/* src/app/shared/components/forms/event-filter-field/event-filter-field/event-filter-field.component.scss */\n.underlined-field {\n  text-decoration: underline;\n  color: var(--color-primary-color, #2196f3);\n  font-weight: 500;\n  padding: 0.25rem 0;\n}\n.underlined-field:hover {\n  color: var(--primary-600, #1e88e5);\n}\n.underlined-field.disabled-text {\n  color: #ccc;\n  cursor: not-allowed;\n}\n.underlined-field.disabled-text:hover {\n  color: #ccc;\n  text-decoration: underline;\n}\n.dropdown-panel {\n  min-width: 250px;\n}\n.condition-item {\n  background-color: #f8f9fa;\n  border-radius: 4px;\n}\n.condition-item:hover {\n  background-color: #e9ecef;\n}\n.condition-item .condition-text {\n  padding: 8px;\n  flex: 1;\n}\n.condition-item .condition-text:hover {\n  text-decoration: underline;\n}\n.condition-editor .field {\n  margin-bottom: 1rem;\n}\n.condition-editor .field label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n}\n.condition-editor .field-checkbox {\n  margin-bottom: 0.5rem;\n}\n.condition-editor .checklist {\n  max-height: 200px;\n  overflow-y: auto;\n  border: 1px solid #ced4da;\n  border-radius: 4px;\n  padding: 8px;\n}\n.p-error {\n  font-size: 0.875rem;\n}\n.event-filter-field .filter-section {\n  margin-bottom: 1rem;\n}\n.event-filter-field .filter-section:last-child {\n  margin-bottom: 0;\n}\n.event-filter-field .filter-section .section-title {\n  font-weight: 500;\n  margin-bottom: 0.5rem;\n}\n.event-filter-field .actor-action-section {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n}\n@media (min-width: 768px) {\n  .event-filter-field .actor-action-section {\n    flex-direction: row;\n    align-items: center;\n  }\n  .event-filter-field .actor-action-section .filter-item {\n    flex: 1;\n  }\n}\n.event-filter-field .conditions-section {\n  margin-top: 1rem;\n  padding-top: 1rem;\n}\n.event-filter-field.invalid {\n  border-color: #f44336;\n}\n.event-filter-field.invalid .error-message {\n  color: #f44336;\n  font-size: 0.875rem;\n  margin-top: 0.25rem;\n}\n/*# sourceMappingURL=event-filter-field.component.css.map */\n"] }]
  }], () => [], { id: [{ type: Input, args: [{ isSignal: true, alias: "id", required: false }] }], required: [{ type: Input, args: [{ isSignal: true, alias: "required", required: false }] }], groupTypes: [{ type: Input, args: [{ isSignal: true, alias: "groupTypes", required: false }] }], filterService: [{ type: Input, args: [{ isSignal: true, alias: "filterService", required: false }] }], minConditions: [{ type: Input, args: [{ isSignal: true, alias: "minConditions", required: false }] }], requireActorBeforeAction: [{ type: Input, args: [{ isSignal: true, alias: "requireActorBeforeAction", required: false }] }], requireActionForConditions: [{ type: Input, args: [{ isSignal: true, alias: "requireActionForConditions", required: false }] }], actorDropdown: [{
    type: ViewChild,
    args: ["actorDropdown"]
  }], actionDropdown: [{
    type: ViewChild,
    args: ["actionDropdown"]
  }], targetDropdown: [{
    type: ViewChild,
    args: ["targetDropdown"]
  }], conditionDropdown: [{
    type: ViewChild,
    args: ["conditionDropdown"]
  }], conditionEditor: [{
    type: ViewChild,
    args: [ConditionEditorComponent]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(EventFilterFieldComponent, { className: "EventFilterFieldComponent", filePath: "src/app/shared/components/forms/event-filter-field/event-filter-field/event-filter-field.component.ts", lineNumber: 72 });
})();

// src/app/shared/services/asset-filter.service.ts
var AssetFilterService = class _AssetFilterService {
  assetsCache = {};
  entities = inject(EntitiesService);
  grouping = inject(AssetGroupingService);
  filterService = inject(EventFilterService);
  clearCache() {
    this.assetsCache = {};
  }
  async fetchAsset(id) {
    try {
      return await firstValueFrom(this.entities.getAsset(id));
    } catch {
      return null;
    }
  }
  async getAssets(ownerId, limit, filter2 = "") {
    const safeOwner = ownerId || "";
    const key = `${safeOwner}:${filter2}:${limit}`;
    if (!(key in this.assetsCache)) {
      this.assetsCache[key] = firstValueFrom(this.entities.listAssets(safeOwner, 0, limit, "name:asc", `owner.id=${safeOwner}&state=active${filter2 ? "&name=*" + encodeURIComponent(filter2) + "*" : ""}`)).then((res) => {
        const truncated = typeof res?.count === "number" && res.count > limit ? { limit, count: res.count } : void 0;
        return { items: Array.isArray(res?.items) ? res.items : [], truncated };
      });
    }
    return this.assetsCache[key];
  }
  async buildGroupTree(params) {
    try {
      const { ownerId, allowedAssetTypes = [], excludeCategories = false } = params;
      const [costCentres, assetTypes, assetGroups, assetCategories] = await Promise.all([
        this.grouping.getCostCentres(ownerId),
        this.grouping.getAssetTypes(ownerId),
        this.grouping.getAssetGroups(ownerId),
        excludeCategories ? Promise.resolve([]) : this.grouping.getAssetCategories(ownerId)
      ]);
      const filteredAssetTypes = assetTypes.filter((t) => isDefined(t?.name) && (!allowedAssetTypes?.length || allowedAssetTypes.includes(t.name.toLowerCase())));
      return this.filterService.buildAssetSelectionTree(costCentres, filteredAssetTypes, assetGroups, assetCategories, allowedAssetTypes);
    } catch (e) {
      console.error("Failed to build group tree", e);
      return [];
    }
  }
  flattenGroupNodes(nodes) {
    const result = [];
    const walk = (n) => {
      n.forEach((node) => {
        if (node.data) {
          result.push({
            id: node.id,
            name: node.data.text ?? node.label,
            filter: node.data
          });
        }
        if (Array.isArray(node.children) && node.children.length) {
          walk(node.children);
        }
      });
    };
    walk(nodes);
    return result;
  }
  toAssetFilter(a) {
    const assetAny = a;
    const assetTypeObj = assetAny.assetType;
    const assetTypeName = assetTypeObj?.name ?? "Asset";
    return {
      actorId: a.id,
      actorName: a.name ?? a.id,
      actorSelectionType: "specific",
      actorType: "asset",
      actorTypeId: assetTypeObj?.id ?? "",
      actorTypeName: assetTypeName,
      text: `${assetTypeName} "${a.name}"`
    };
  }
  createSpecificFromTag(tag) {
    return tag.filter ?? {
      actorId: tag.id,
      actorSelectionType: "specific",
      actorType: "asset",
      actorTypeId: "",
      actorTypeName: "Asset",
      text: tag.name
    };
  }
  async search(term, params) {
    const clean = term.trim();
    if (!clean)
      return [];
    const { ownerId, multi, groupTreeNodes, selectedIds } = params;
    const [assetRes, groups] = await Promise.all([
      this.getAssets(ownerId, 10, clean),
      multi ? Promise.resolve(this.flattenGroupNodes(groupTreeNodes)) : Promise.resolve([])
    ]);
    const groupMatches = groups.filter((g) => g.name.toLowerCase().includes(clean.toLowerCase()));
    const assetMatches = assetRes.items.map((a) => ({
      id: a.id,
      name: a.name ?? a.id,
      filter: this.toAssetFilter(a)
    }));
    return [...assetMatches, ...groupMatches].filter((x) => !selectedIds.includes(x.id));
  }
  static \u0275fac = function AssetFilterService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AssetFilterService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _AssetFilterService, factory: _AssetFilterService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AssetFilterService, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();

// src/app/shared/components/forms/asset-filter-field/asset-filter-field.component.ts
var _c022 = () => ({ standalone: true });
var _c118 = () => ({ width: "100%" });
var _c214 = (a0, a1) => ({ "pi-plus": a0, "pi-chevron-down": a1 });
var _forTrack03 = ($index, $item) => $item.id || $item.name;
function AssetFilterFieldComponent_Conditional_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 12)(1, "span", 13);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "p-button", 14);
    \u0275\u0275listener("onClick", function AssetFilterFieldComponent_Conditional_4_For_2_Template_p_button_onClick_3_listener() {
      const item_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.removeTag(item_r2));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("title", item_r2.name);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r2.name);
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r2.isDisabled);
    \u0275\u0275attribute("aria-label", "Remove " + item_r2.name);
  }
}
function AssetFilterFieldComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 3);
    \u0275\u0275repeaterCreate(1, AssetFilterFieldComponent_Conditional_4_For_2_Template, 4, 4, "li", 12, _forTrack03);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r2.selectedItems);
  }
}
function AssetFilterFieldComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r4.name);
  }
}
function AssetFilterFieldComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-button", 16);
    \u0275\u0275listener("onClick", function AssetFilterFieldComponent_Conditional_10_Template_p_button_onClick_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.clearSingle());
    });
    \u0275\u0275element(1, "i", 17);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("disabled", ctx_r2.isDisabled);
  }
}
function AssetFilterFieldComponent_Conditional_12_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 20)(1, "p-tree", 23);
    \u0275\u0275listener("onNodeSelect", function AssetFilterFieldComponent_Conditional_12_Conditional_9_Template_p_tree_onNodeSelect_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onTreeNodeSelect($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r2.assetTreeNodes);
  }
}
function AssetFilterFieldComponent_Conditional_12_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275text(1, "No assets available");
    \u0275\u0275elementEnd();
  }
}
function AssetFilterFieldComponent_Conditional_12_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 20)(1, "p-tree", 23);
    \u0275\u0275listener("onNodeSelect", function AssetFilterFieldComponent_Conditional_12_Conditional_12_Template_p_tree_onNodeSelect_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onTreeNodeSelect($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r2.groupTreeNodes);
  }
}
function AssetFilterFieldComponent_Conditional_12_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275text(1, "No groups");
    \u0275\u0275elementEnd();
  }
}
function AssetFilterFieldComponent_Conditional_12_Conditional_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 22);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate2(" Showing ", ctx_r2.truncatedList.limit, " of ", ctx_r2.truncatedList.count, " items. Type more characters to narrow results.. ");
  }
}
function AssetFilterFieldComponent_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11)(1, "p-tabs", 18)(2, "p-tablist")(3, "p-tab", 18);
    \u0275\u0275text(4, "Assets");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "p-tab", 19);
    \u0275\u0275text(6, "Groups");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "p-tabpanels")(8, "p-tabpanel", 18);
    \u0275\u0275conditionalCreate(9, AssetFilterFieldComponent_Conditional_12_Conditional_9_Template, 2, 1, "div", 20)(10, AssetFilterFieldComponent_Conditional_12_Conditional_10_Template, 2, 0, "div", 21);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "p-tabpanel", 19);
    \u0275\u0275conditionalCreate(12, AssetFilterFieldComponent_Conditional_12_Conditional_12_Template, 2, 1, "div", 20)(13, AssetFilterFieldComponent_Conditional_12_Conditional_13_Template, 2, 0, "div", 21);
    \u0275\u0275elementEnd()()();
    \u0275\u0275conditionalCreate(14, AssetFilterFieldComponent_Conditional_12_Conditional_14_Template, 2, 2, "div", 22);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(9);
    \u0275\u0275conditional(ctx_r2.assetTreeNodes.length ? 9 : 10);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(ctx_r2.groupTreeNodes.length ? 12 : 13);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r2.truncatedList ? 14 : -1);
  }
}
function AssetFilterFieldComponent_Conditional_13_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 20)(1, "p-tree", 23);
    \u0275\u0275listener("onNodeSelect", function AssetFilterFieldComponent_Conditional_13_Conditional_1_Template_p_tree_onNodeSelect_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onTreeNodeSelect($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r2.assetTreeNodes);
  }
}
function AssetFilterFieldComponent_Conditional_13_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275text(1, "No assets");
    \u0275\u0275elementEnd();
  }
}
function AssetFilterFieldComponent_Conditional_13_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 22);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate2(" Showing ", ctx_r2.truncatedList.limit, " of ", ctx_r2.truncatedList.count, " items. Refine search. ");
  }
}
function AssetFilterFieldComponent_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275conditionalCreate(1, AssetFilterFieldComponent_Conditional_13_Conditional_1_Template, 2, 1, "div", 20)(2, AssetFilterFieldComponent_Conditional_13_Conditional_2_Template, 2, 0, "div", 21);
    \u0275\u0275conditionalCreate(3, AssetFilterFieldComponent_Conditional_13_Conditional_3_Template, 2, 2, "div", 22);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r2.assetTreeNodes.length ? 1 : 2);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r2.truncatedList ? 3 : -1);
  }
}
function provideAssetFilterFieldValueAccessor() {
  return {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line @angular-eslint/no-forward-ref
    useExisting: forwardRef(() => AssetFilterFieldComponent),
    multi: true
  };
}
var AssetFilterFieldComponent = class _AssetFilterFieldComponent {
  // Configurable Inputs
  multi = input(true, ...ngDevMode ? [{ debugName: "multi" }] : []);
  // if false -> single select
  required = input(false, ...ngDevMode ? [{ debugName: "required" }] : []);
  readonly = input(false, ...ngDevMode ? [{ debugName: "readonly" }] : []);
  // Add readonly input
  allowedAssetTypes = input([], ...ngDevMode ? [{ debugName: "allowedAssetTypes" }] : []);
  excludeCategories = input(false, ...ngDevMode ? [{ debugName: "excludeCategories" }] : []);
  placeholder = input("Enter asset or vehicle name...", ...ngDevMode ? [{ debugName: "placeholder" }] : []);
  // Provide ability to pass initial ownerId (optional override)
  ownerId = input(void 0, ...ngDevMode ? [{ debugName: "ownerId" }] : []);
  // State
  touched = false;
  dirty = false;
  loading = false;
  showPopup = false;
  truncatedList = null;
  // Tag data
  selectedItems = [];
  autoCompleteItems = [];
  assetTreeNodes = [];
  groupTreeNodes = [];
  searchTerm = "";
  searchInput = "";
  // internal resolved owner id (either from input or client selection)
  resolvedOwnerId;
  onChange = () => {
  };
  onTouched = () => {
  };
  internalValue = { mode: "multi", value: [] };
  entities = inject(EntitiesService);
  assetFilterSvc = inject(AssetFilterService);
  cdr = inject(ChangeDetectorRef);
  host = inject(ElementRef);
  constructor() {
    effect(() => {
      const ownerIdValue = this.ownerId();
      this.resolvedOwnerId = ownerIdValue !== void 0 && ownerIdValue !== null && ownerIdValue.trim() !== "" ? ownerIdValue : void 0;
      if (this.resolvedOwnerId !== void 0 && this.resolvedOwnerId !== null && this.resolvedOwnerId.trim() !== "") {
        void this.initForMode();
      }
    });
  }
  ngOnInit() {
    const ownerIdValue = this.ownerId();
    this.resolvedOwnerId = ownerIdValue !== void 0 && ownerIdValue !== null && ownerIdValue.trim() !== "" ? ownerIdValue : void 0;
    void this.initForMode();
  }
  // Control Value Accessor
  writeValue(extValue) {
    if (!isDefined(extValue)) {
      this.internalValue = this.multi() ? { mode: "multi", value: [] } : { mode: "single", value: null };
      this.selectedItems = [];
      this.cdr.markForCheck();
      return;
    }
    if (this.multi()) {
      if (Array.isArray(extValue)) {
        const typed = extValue;
        this.internalValue = { mode: "multi", value: typed };
        this.selectedItems = typed.map((x) => ({
          id: x.actorId,
          name: x.text ?? x.actorName ?? x.actorId,
          filter: x
        }));
      }
    } else {
      const id = typeof extValue === "string" && extValue.length ? extValue : null;
      this.internalValue = { mode: "single", value: id };
      if (id !== null) {
        void this.fetchAsset(id).then((asset) => {
          if (asset) {
            this.selectedItems = [
              { id: asset.id, name: asset.name ?? asset.id, filter: null }
            ];
            this.cdr.markForCheck();
          }
        });
      } else {
        this.selectedItems = [];
      }
    }
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(_isDisabled) {
  }
  // Initialization logic depending on mode
  async initForMode() {
    if (this.resolvedOwnerId === void 0 || this.resolvedOwnerId === null || this.resolvedOwnerId === "") {
      return;
    }
    if (this.multi()) {
      this.groupTreeNodes = await this.assetFilterSvc.buildGroupTree({
        ownerId: this.resolvedOwnerId,
        allowedAssetTypes: this.allowedAssetTypes(),
        excludeCategories: this.excludeCategories()
      });
    }
    await this.loadInitialAssets();
  }
  async loadInitialAssets() {
    this.loading = true;
    try {
      const res = await this.assetFilterSvc.getAssets(this.resolvedOwnerId ?? "", 100);
      if (res.truncated) {
        this.truncatedList = res.truncated;
      }
      const assets = res.items;
      this.assetTreeNodes = assets.map((a) => ({
        id: a.id,
        label: a.name ?? a.id,
        data: this.assetFilterSvc.toAssetFilter(a)
      }));
    } finally {
      this.loading = false;
      this.cdr.markForCheck();
    }
  }
  // Searching / autocomplete
  async onSearch(term) {
    term = (term || "").trim();
    if (!term) {
      this.autoCompleteItems = [];
      return;
    }
    this.loading = true;
    try {
      this.autoCompleteItems = await this.assetFilterSvc.search(term, {
        ownerId: this.resolvedOwnerId ?? "",
        multi: this.multi(),
        groupTreeNodes: this.groupTreeNodes,
        selectedIds: this.selectedItems.map((x) => x.id)
      });
    } catch {
      this.autoCompleteItems = [];
    } finally {
      this.loading = false;
      this.cdr.markForCheck();
    }
  }
  addTag(item) {
    if (!this.multi()) {
      this.selectedItems = [item];
    } else if (isNullOrUndefined(this.selectedItems.find((x) => x.id === item.id))) {
      this.selectedItems = [...this.selectedItems, item];
    }
    this.updateExternalValue();
  }
  removeTag(item) {
    this.selectedItems = this.selectedItems.filter((x) => x.id !== item.id);
    this.updateExternalValue();
  }
  onTreeNodeSelect(event) {
    let node;
    if (typeof event === "object" && event !== null && "node" in event) {
      node = event.node;
    } else {
      node = event;
    }
    if (!node?.data) {
      return;
    }
    const data = node.data;
    const tag = {
      id: node.id,
      name: data.text ?? node.label,
      filter: data
    };
    this.addTag(tag);
    if (!this.multi()) {
      this.showPopup = false;
    }
  }
  clearSingle() {
    if (this.multi())
      return;
    this.selectedItems = [];
    this.updateExternalValue();
  }
  updateExternalValue() {
    this.dirty = true;
    if (this.multi()) {
      const filters = this.selectedItems.map((x) => x.filter ?? this.assetFilterSvc.createSpecificFromTag(x));
      this.internalValue = { mode: "multi", value: filters };
      this.onChange(filters);
    } else {
      const id = this.selectedItems[0]?.id ?? null;
      this.internalValue = { mode: "single", value: id };
      this.onChange(id);
    }
    this.cdr.markForCheck();
  }
  // Utilities
  async fetchAsset(id) {
    try {
      const asset = await firstValueFrom(this.entities.getAsset(id));
      return asset;
    } catch {
      return null;
    }
  }
  // Autocomplete wrapper for PrimeNG event
  onAutoComplete(event) {
    this.searchTerm = event.query;
    void this.onSearch(event.query);
  }
  onAutoItemSelected(event) {
    const item = event.value;
    if (item !== null && item !== void 0) {
      this.addTag(item);
    }
    this.searchInput = "";
    this.autoCompleteItems = [];
  }
  // Validation state for host form integration
  get invalid() {
    return this.required() && this.touched && (this.multi() ? this.selectedItems.length === 0 : !this.selectedItems.length);
  }
  // Check if the component should be disabled due to missing ownerId or explicit disabled input
  get isDisabled() {
    return this.readonly() || this.resolvedOwnerId === void 0 || this.resolvedOwnerId === null || this.resolvedOwnerId.trim() === "";
  }
  // Mark touched when focusing inside
  onFocusIn() {
    this.touched = true;
  }
  // Close popup when clicking outside component
  onDocClick(ev) {
    if (!this.showPopup)
      return;
    const target = ev.target;
    if (!(target instanceof HTMLElement))
      return;
    const insideHost = this.host.nativeElement.contains(target);
    const insideOverlay = !!target.closest(".af-popup");
    if (insideHost === false && insideOverlay === false) {
      this.showPopup = false;
      this.cdr.markForCheck();
    }
  }
  static \u0275fac = function AssetFilterFieldComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AssetFilterFieldComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AssetFilterFieldComponent, selectors: [["app-asset-filter-field"]], hostBindings: function AssetFilterFieldComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("focusin", function AssetFilterFieldComponent_focusin_HostBindingHandler() {
        return ctx.onFocusIn();
      })("click", function AssetFilterFieldComponent_click_HostBindingHandler($event) {
        return ctx.onDocClick($event);
      }, \u0275\u0275resolveDocument);
    }
  }, inputs: { multi: [1, "multi"], required: [1, "required"], readonly: [1, "readonly"], allowedAssetTypes: [1, "allowedAssetTypes"], excludeCategories: [1, "excludeCategories"], placeholder: [1, "placeholder"], ownerId: [1, "ownerId"] }, features: [\u0275\u0275ProvidersFeature([provideAssetFilterFieldValueAccessor()])], decls: 14, vars: 25, consts: [[1, "asset-filter-field", "w-full"], [1, "sr-only"], [1, "input-wrapper"], ["aria-label", "Selected items", 1, "tags"], [1, "ac-row"], ["field", "name", "inputId", "asset-filter-autocomplete", 1, "ac", "flex-grow", 3, "ngModelChange", "completeMethod", "onSelect", "ngModel", "ngModelOptions", "suggestions", "forceSelection", "placeholder", "multiple", "dropdown", "minLength", "appendTo", "readonly", "inputStyle"], ["pTemplate", "item"], ["type", "button", "aria-label", "Toggle selector", "severity", "primary", 1, "btn-icon", "toggle", 3, "onClick", "disabled"], [1, "pi", 3, "ngClass"], ["type", "button", "aria-label", "Clear selection", 1, "btn-icon", "clear", 3, "disabled"], ["appendTo", "body", 3, "visibleChange", "onHide", "visible"], [1, "popup", "af-popup"], [1, "tag", "pill"], [1, "tag-label", 3, "title"], ["icon", "pi pi-times", 3, "onClick", "disabled"], [1, "ac-item"], ["type", "button", "aria-label", "Clear selection", 1, "btn-icon", "clear", 3, "onClick", "disabled"], [1, "pi", "pi-times"], ["value", "0"], ["value", "1"], [1, "tree-wrapper"], [1, "muted", "px-2", "py-1"], [1, "footer"], ["selectionMode", "single", 3, "onNodeSelect", "value"]], template: function AssetFilterFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "fieldset", 0)(1, "legend", 1);
      \u0275\u0275text(2, "Asset Filter");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "div", 2);
      \u0275\u0275conditionalCreate(4, AssetFilterFieldComponent_Conditional_4_Template, 3, 0, "ul", 3);
      \u0275\u0275elementStart(5, "div", 4)(6, "p-autoComplete", 5);
      \u0275\u0275twoWayListener("ngModelChange", function AssetFilterFieldComponent_Template_p_autoComplete_ngModelChange_6_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.searchInput, $event) || (ctx.searchInput = $event);
        return $event;
      });
      \u0275\u0275listener("completeMethod", function AssetFilterFieldComponent_Template_p_autoComplete_completeMethod_6_listener($event) {
        return ctx.onAutoComplete($event);
      })("onSelect", function AssetFilterFieldComponent_Template_p_autoComplete_onSelect_6_listener($event) {
        return ctx.onAutoItemSelected($event);
      });
      \u0275\u0275template(7, AssetFilterFieldComponent_ng_template_7_Template, 2, 1, "ng-template", 6);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(8, "p-button", 7);
      \u0275\u0275listener("onClick", function AssetFilterFieldComponent_Template_p_button_onClick_8_listener() {
        return ctx.showPopup = !ctx.showPopup;
      });
      \u0275\u0275element(9, "i", 8);
      \u0275\u0275elementEnd();
      \u0275\u0275conditionalCreate(10, AssetFilterFieldComponent_Conditional_10_Template, 2, 1, "p-button", 9);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(11, "p-overlay", 10);
      \u0275\u0275twoWayListener("visibleChange", function AssetFilterFieldComponent_Template_p_overlay_visibleChange_11_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.showPopup, $event) || (ctx.showPopup = $event);
        return $event;
      });
      \u0275\u0275listener("onHide", function AssetFilterFieldComponent_Template_p_overlay_onHide_11_listener() {
        return ctx.showPopup = false;
      });
      \u0275\u0275conditionalCreate(12, AssetFilterFieldComponent_Conditional_12_Template, 15, 3, "div", 11);
      \u0275\u0275conditionalCreate(13, AssetFilterFieldComponent_Conditional_13_Template, 4, 2, "div", 11);
      \u0275\u0275elementEnd()();
    }
    if (rf & 2) {
      \u0275\u0275classProp("disabled", ctx.isDisabled);
      \u0275\u0275advance(4);
      \u0275\u0275conditional(ctx.selectedItems.length ? 4 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275twoWayProperty("ngModel", ctx.searchInput);
      \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(20, _c022))("suggestions", ctx.autoCompleteItems)("forceSelection", false)("placeholder", ctx.placeholder())("multiple", false)("dropdown", false)("minLength", 2)("appendTo", "body")("readonly", ctx.isDisabled || !ctx.multi() && ctx.selectedItems.length === 1)("inputStyle", \u0275\u0275pureFunction0(21, _c118));
      \u0275\u0275advance(2);
      \u0275\u0275property("disabled", ctx.isDisabled);
      \u0275\u0275advance();
      \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(22, _c214, ctx.multi(), !ctx.multi()));
      \u0275\u0275advance();
      \u0275\u0275conditional(!ctx.multi() && ctx.selectedItems.length ? 10 : -1);
      \u0275\u0275advance();
      \u0275\u0275twoWayProperty("visible", ctx.showPopup);
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.multi() ? 12 : -1);
      \u0275\u0275advance();
      \u0275\u0275conditional(!ctx.multi() ? 13 : -1);
    }
  }, dependencies: [CommonModule, NgClass, FormsModule, NgControlStatus, NgModel, AutoCompleteModule, AutoComplete, PrimeTemplate, ButtonModule, Button, OverlayModule, Overlay, TreeModule, Tree, TabsModule, Tabs, TabPanels, TabPanel, TabList, Tab, InputTextModule], styles: ["\n\n.asset-filter-field[_ngcontent-%COMP%]   .input-wrapper[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n  width: 100%;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .ac-row[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: stretch;\n  width: 100%;\n  gap: 0.25rem;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .ac-row[_ngcontent-%COMP%]   .p-autocomplete[_ngcontent-%COMP%], \n.asset-filter-field[_ngcontent-%COMP%]   .ac-row[_ngcontent-%COMP%]   .p-autocomplete[_ngcontent-%COMP%]   .p-inputtext[_ngcontent-%COMP%] {\n  width: 100%;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .btn-icon.toggle[_ngcontent-%COMP%], \n.asset-filter-field[_ngcontent-%COMP%]   .btn-icon.clear[_ngcontent-%COMP%] {\n  flex: 0 0 auto;\n  height: 2.5rem;\n  width: 2.5rem;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 0.375rem;\n  cursor: pointer;\n  transition: background 0.15s ease, color 0.15s ease;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .tags[_ngcontent-%COMP%] {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.4rem;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .tag.pill[_ngcontent-%COMP%] {\n  display: inline-flex;\n  align-items: center;\n  max-width: 100%;\n  font-size: 0.75rem;\n  line-height: 1;\n  padding: 0.4rem 0.55rem 0.4rem 0.6rem;\n  border-radius: 9999px;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);\n  position: relative;\n  transition: background 0.15s ease;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .tag-label[_ngcontent-%COMP%] {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 12rem;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%] {\n  background: transparent;\n  color: #ffffff;\n  border: none;\n  margin-left: 0.4rem;\n  cursor: pointer;\n  font-size: 0.85rem;\n  line-height: 1;\n  padding: 0;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%]:hover {\n  color: #fef3c7;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .popup.af-popup[_ngcontent-%COMP%] {\n  min-width: 420px;\n  max-width: 560px;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav {\n  background: transparent;\n  border-bottom: 1px solid #e5e7eb;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-tabview-nav-link {\n  background: transparent;\n  border: none;\n  border-bottom: 2px solid transparent;\n  color: #6b7280;\n  font-weight: 500;\n  padding: 0.75rem 1rem;\n  transition: all 0.2s ease;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-tabview-nav-link:not(.p-disabled):focus {\n  box-shadow: none;\n  outline: 2px solid #3b82f6;\n  outline-offset: -2px;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-tabview-nav-link:hover {\n  background: rgba(59, 130, 246, 0.05);\n  color: #3b82f6;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-highlight .p-tabview-nav-link {\n  background: transparent;\n  border-bottom-color: #3b82f6;\n  color: #3b82f6;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-panels {\n  background: transparent;\n  padding: 1rem 0 0 0;\n  border: none;\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-inputtext:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-autocomplete-panel {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item {\n  padding: 0;\n  border: none;\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item:hover {\n  background: #f3f4f6;\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item.p-highlight {\n  background: #eff6ff;\n  color: #1e40af;\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-label:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-header {\n  background: #f9fafb;\n  border-bottom: 1px solid #e5e7eb;\n  padding: 0.75rem;\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-inputtext {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  padding: 0.5rem 0.75rem;\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-inputtext:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item {\n  padding: 0.5rem 0.75rem;\n  border: none;\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item:hover {\n  background: #f3f4f6;\n}\n.asset-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item.p-highlight {\n  background: #eff6ff;\n  color: #1e40af;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .selected-asset-tag[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      135deg,\n      #3b82f6 0%,\n      #1d4ed8 100%);\n}\n.asset-filter-field[_ngcontent-%COMP%]   .selected-asset-tag[_ngcontent-%COMP%]:hover {\n  background:\n    linear-gradient(\n      135deg,\n      #2563eb 0%,\n      #1e40af 100%);\n}\n.asset-filter-field[_ngcontent-%COMP%]   .selected-asset-tag[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover {\n  background: rgba(255, 255, 255, 0.2);\n}\n.asset-filter-field[_ngcontent-%COMP%]   .clear-button[_ngcontent-%COMP%] {\n  transition: all 0.2s ease;\n}\n.asset-filter-field[_ngcontent-%COMP%]   .clear-button[_ngcontent-%COMP%]:hover {\n  background: #fef2f2;\n  border-color: #fca5a5;\n  color: #dc2626;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n}\n.asset-filter-field[_ngcontent-%COMP%]   .clear-button[_ngcontent-%COMP%]:active {\n  transform: translateY(0);\n}\n.asset-filter-field.disabled[_ngcontent-%COMP%] {\n  opacity: 0.6;\n}\n.asset-filter-field.disabled[_ngcontent-%COMP%]   .btn-icon.toggle[_ngcontent-%COMP%], \n.asset-filter-field.disabled[_ngcontent-%COMP%]   .btn-icon.clear[_ngcontent-%COMP%] {\n  cursor: not-allowed;\n  background: #f9fafb;\n  color: #9ca3af;\n}\n.asset-filter-field.disabled[_ngcontent-%COMP%]   .btn-icon.toggle[_ngcontent-%COMP%]:hover, \n.asset-filter-field.disabled[_ngcontent-%COMP%]   .btn-icon.clear[_ngcontent-%COMP%]:hover {\n  background: #f9fafb;\n  color: #9ca3af;\n}\n.asset-filter-field.disabled[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%] {\n  cursor: not-allowed;\n}\n.asset-filter-field.disabled[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%]:hover {\n  color: #ffffff;\n}\n.asset-filter-field.disabled[_ngcontent-%COMP%]     .p-autocomplete .p-inputtext {\n  background: #f9fafb;\n  color: #9ca3af;\n  cursor: not-allowed;\n}\n.asset-filter-field.disabled[_ngcontent-%COMP%]     .p-autocomplete .p-inputtext:focus {\n  border-color: #d1d5db;\n  box-shadow: none;\n}\n@media (max-width: 768px) {\n  .asset-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-tabview-nav-link {\n    padding: 0.5rem 0.75rem;\n    font-size: 0.875rem;\n  }\n}\n/*# sourceMappingURL=asset-filter-field.component.css.map */"], changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AssetFilterFieldComponent, [{
    type: Component,
    args: [{ selector: "app-asset-filter-field", imports: [
      CommonModule,
      FormsModule,
      AutoCompleteModule,
      ButtonModule,
      OverlayModule,
      TreeModule,
      TabsModule,
      InputTextModule
    ], changeDetection: ChangeDetectionStrategy.OnPush, providers: [provideAssetFilterFieldValueAccessor()], template: `<fieldset class="asset-filter-field w-full" [class.disabled]="isDisabled">
  <legend class="sr-only">Asset Filter</legend>
  <div class="input-wrapper">
    <!-- Selected pills -->
    @if (selectedItems.length) {
      <ul class="tags" aria-label="Selected items">
        @for (item of selectedItems; track item.id || item.name) {
          <li class="tag pill">
            <span class="tag-label" [title]="item.name">{{ item.name }}</span>
            <p-button
              (onClick)="removeTag(item)"
              [attr.aria-label]="'Remove ' + item.name"
              [disabled]="isDisabled"
              icon="pi pi-times"
            />
          </li>
        }
      </ul>
    }
    <div class="ac-row">
      <!-- Autocomplete input -->
      <p-autoComplete
        class="ac flex-grow"
        [(ngModel)]="searchInput"
        [ngModelOptions]="{ standalone: true }"
        [suggestions]="autoCompleteItems"
        (completeMethod)="onAutoComplete($event)"
        (onSelect)="onAutoItemSelected($event)"
        field="name"
        [forceSelection]="false"
        [placeholder]="placeholder()"
        [multiple]="false"
        [dropdown]="false"
        [minLength]="2"
        [appendTo]="'body'"
        inputId="asset-filter-autocomplete"
        [readonly]="isDisabled || (!multi() && selectedItems.length === 1)"
        [inputStyle]="{ width: '100%' }"
      >
        <ng-template let-item pTemplate="item">
          <div class="ac-item">{{ item.name }}</div>
        </ng-template>
      </p-autoComplete>
      <!-- Add / caret button -->
      <p-button
        type="button"
        class="btn-icon toggle"
        (onClick)="showPopup = !showPopup"
        [disabled]="isDisabled"
        aria-label="Toggle selector"
        severity="primary"
      >
        <i
          class="pi"
          [ngClass]="{ 'pi-plus': multi(), 'pi-chevron-down': !multi() }"
        ></i>
      </p-button>
      @if (!multi() && selectedItems.length) {
        <p-button
          type="button"
          class="btn-icon clear"
          (onClick)="clearSingle()"
          [disabled]="isDisabled"
          aria-label="Clear selection"
        >
          <i class="pi pi-times"></i>
        </p-button>
      }
    </div>
  </div>

  <!-- Popup -->
  <p-overlay
    [(visible)]="showPopup"
    appendTo="body"
    (onHide)="showPopup = false"
  >
    @if (multi()) {
      <div class="popup af-popup">
        <p-tabs value="0">
          <p-tablist>
            <p-tab value="0">Assets</p-tab>
            <p-tab value="1">Groups</p-tab>
          </p-tablist>
          <p-tabpanels>
            <p-tabpanel value="0">
              @if (assetTreeNodes.length) {
                <div class="tree-wrapper">
                  <p-tree
                    [value]="assetTreeNodes"
                    selectionMode="single"
                    (onNodeSelect)="onTreeNodeSelect($event)"
                  ></p-tree>
                </div>
              } @else {
                <div class="muted px-2 py-1">No assets available</div>
              }
            </p-tabpanel>
            <p-tabpanel value="1">
              @if (groupTreeNodes.length) {
                <div class="tree-wrapper">
                  <p-tree
                    [value]="groupTreeNodes"
                    selectionMode="single"
                    (onNodeSelect)="onTreeNodeSelect($event)"
                  ></p-tree>
                </div>
              } @else {
                <div class="muted px-2 py-1">No groups</div>
              }
            </p-tabpanel>
          </p-tabpanels>
        </p-tabs>
        @if (truncatedList) {
          <div class="footer">
            Showing {{ truncatedList.limit }} of
            {{ truncatedList.count }} items. Type more characters to narrow
            results..
          </div>
        }
      </div>
    }
    @if (!multi()) {
      <div class="popup af-popup">
        @if (assetTreeNodes.length) {
          <div class="tree-wrapper">
            <p-tree
              [value]="assetTreeNodes"
              selectionMode="single"
              (onNodeSelect)="onTreeNodeSelect($event)"
            ></p-tree>
          </div>
        } @else {
          <div class="muted px-2 py-1">No assets</div>
        }
        @if (truncatedList) {
          <div class="footer">
            Showing {{ truncatedList.limit }} of
            {{ truncatedList.count }} items. Refine search.
          </div>
        }
      </div>
    }
  </p-overlay>
</fieldset>
`, styles: ["/* src/app/shared/components/forms/asset-filter-field/asset-filter-field.component.scss */\n.asset-filter-field .input-wrapper {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n  width: 100%;\n}\n.asset-filter-field .ac-row {\n  display: flex;\n  align-items: stretch;\n  width: 100%;\n  gap: 0.25rem;\n}\n.asset-filter-field .ac-row .p-autocomplete,\n.asset-filter-field .ac-row .p-autocomplete .p-inputtext {\n  width: 100%;\n}\n.asset-filter-field .btn-icon.toggle,\n.asset-filter-field .btn-icon.clear {\n  flex: 0 0 auto;\n  height: 2.5rem;\n  width: 2.5rem;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 0.375rem;\n  cursor: pointer;\n  transition: background 0.15s ease, color 0.15s ease;\n}\n.asset-filter-field .tags {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.4rem;\n}\n.asset-filter-field .tag.pill {\n  display: inline-flex;\n  align-items: center;\n  max-width: 100%;\n  font-size: 0.75rem;\n  line-height: 1;\n  padding: 0.4rem 0.55rem 0.4rem 0.6rem;\n  border-radius: 9999px;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);\n  position: relative;\n  transition: background 0.15s ease;\n}\n.asset-filter-field .tag-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 12rem;\n}\n.asset-filter-field .tag-remove {\n  background: transparent;\n  color: #ffffff;\n  border: none;\n  margin-left: 0.4rem;\n  cursor: pointer;\n  font-size: 0.85rem;\n  line-height: 1;\n  padding: 0;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n}\n.asset-filter-field .tag-remove:hover {\n  color: #fef3c7;\n}\n.asset-filter-field .popup.af-popup {\n  min-width: 420px;\n  max-width: 560px;\n}\n.asset-filter-field .custom-tabview ::ng-deep .p-tabview-nav {\n  background: transparent;\n  border-bottom: 1px solid #e5e7eb;\n}\n.asset-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-tabview-nav-link {\n  background: transparent;\n  border: none;\n  border-bottom: 2px solid transparent;\n  color: #6b7280;\n  font-weight: 500;\n  padding: 0.75rem 1rem;\n  transition: all 0.2s ease;\n}\n.asset-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-tabview-nav-link:not(.p-disabled):focus {\n  box-shadow: none;\n  outline: 2px solid #3b82f6;\n  outline-offset: -2px;\n}\n.asset-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-tabview-nav-link:hover {\n  background: rgba(59, 130, 246, 0.05);\n  color: #3b82f6;\n}\n.asset-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-highlight .p-tabview-nav-link {\n  background: transparent;\n  border-bottom-color: #3b82f6;\n  color: #3b82f6;\n}\n.asset-filter-field .custom-tabview ::ng-deep .p-tabview-panels {\n  background: transparent;\n  padding: 1rem 0 0 0;\n  border: none;\n}\n.asset-filter-field ::ng-deep .p-autocomplete .p-inputtext:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.asset-filter-field ::ng-deep .p-autocomplete .p-autocomplete-panel {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n}\n.asset-filter-field ::ng-deep .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item {\n  padding: 0;\n  border: none;\n}\n.asset-filter-field ::ng-deep .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item:hover {\n  background: #f3f4f6;\n}\n.asset-filter-field ::ng-deep .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item.p-highlight {\n  background: #eff6ff;\n  color: #1e40af;\n}\n.asset-filter-field ::ng-deep .p-multiselect .p-multiselect-label:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.asset-filter-field ::ng-deep .p-multiselect .p-multiselect-panel {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n}\n.asset-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-header {\n  background: #f9fafb;\n  border-bottom: 1px solid #e5e7eb;\n  padding: 0.75rem;\n}\n.asset-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-inputtext {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  padding: 0.5rem 0.75rem;\n}\n.asset-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-inputtext:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.asset-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item {\n  padding: 0.5rem 0.75rem;\n  border: none;\n}\n.asset-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item:hover {\n  background: #f3f4f6;\n}\n.asset-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item.p-highlight {\n  background: #eff6ff;\n  color: #1e40af;\n}\n.asset-filter-field .selected-asset-tag {\n  background:\n    linear-gradient(\n      135deg,\n      #3b82f6 0%,\n      #1d4ed8 100%);\n}\n.asset-filter-field .selected-asset-tag:hover {\n  background:\n    linear-gradient(\n      135deg,\n      #2563eb 0%,\n      #1e40af 100%);\n}\n.asset-filter-field .selected-asset-tag button:hover {\n  background: rgba(255, 255, 255, 0.2);\n}\n.asset-filter-field .clear-button {\n  transition: all 0.2s ease;\n}\n.asset-filter-field .clear-button:hover {\n  background: #fef2f2;\n  border-color: #fca5a5;\n  color: #dc2626;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n}\n.asset-filter-field .clear-button:active {\n  transform: translateY(0);\n}\n.asset-filter-field.disabled {\n  opacity: 0.6;\n}\n.asset-filter-field.disabled .btn-icon.toggle,\n.asset-filter-field.disabled .btn-icon.clear {\n  cursor: not-allowed;\n  background: #f9fafb;\n  color: #9ca3af;\n}\n.asset-filter-field.disabled .btn-icon.toggle:hover,\n.asset-filter-field.disabled .btn-icon.clear:hover {\n  background: #f9fafb;\n  color: #9ca3af;\n}\n.asset-filter-field.disabled .tag-remove {\n  cursor: not-allowed;\n}\n.asset-filter-field.disabled .tag-remove:hover {\n  color: #ffffff;\n}\n.asset-filter-field.disabled ::ng-deep .p-autocomplete .p-inputtext {\n  background: #f9fafb;\n  color: #9ca3af;\n  cursor: not-allowed;\n}\n.asset-filter-field.disabled ::ng-deep .p-autocomplete .p-inputtext:focus {\n  border-color: #d1d5db;\n  box-shadow: none;\n}\n@media (max-width: 768px) {\n  .asset-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-tabview-nav-link {\n    padding: 0.5rem 0.75rem;\n    font-size: 0.875rem;\n  }\n}\n/*# sourceMappingURL=asset-filter-field.component.css.map */\n"] }]
  }], () => [], { multi: [{ type: Input, args: [{ isSignal: true, alias: "multi", required: false }] }], required: [{ type: Input, args: [{ isSignal: true, alias: "required", required: false }] }], readonly: [{ type: Input, args: [{ isSignal: true, alias: "readonly", required: false }] }], allowedAssetTypes: [{ type: Input, args: [{ isSignal: true, alias: "allowedAssetTypes", required: false }] }], excludeCategories: [{ type: Input, args: [{ isSignal: true, alias: "excludeCategories", required: false }] }], placeholder: [{ type: Input, args: [{ isSignal: true, alias: "placeholder", required: false }] }], ownerId: [{ type: Input, args: [{ isSignal: true, alias: "ownerId", required: false }] }], onFocusIn: [{
    type: HostListener,
    args: ["focusin"]
  }], onDocClick: [{
    type: HostListener,
    args: ["document:click", ["$event"]]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AssetFilterFieldComponent, { className: "AssetFilterFieldComponent", filePath: "src/app/shared/components/forms/asset-filter-field/asset-filter-field.component.ts", lineNumber: 73 });
})();

// src/app/shared/services/zone-filter.service.ts
var ZoneFilterService = class _ZoneFilterService {
  zonesCache = {};
  entities = inject(EntitiesService);
  grouping = inject(AssetGroupingService);
  filterService = inject(EventFilterService);
  clearCache() {
    this.zonesCache = {};
  }
  async fetchZone(id) {
    try {
      return await firstValueFrom(this.entities.getZone(id));
    } catch {
      return null;
    }
  }
  async getZones(ownerId, limit, filter2 = "") {
    const safeOwner = ownerId || "";
    const key = `${safeOwner}:${filter2}:${limit}`;
    if (!(key in this.zonesCache)) {
      this.zonesCache[key] = firstValueFrom(this.entities.listZones(safeOwner, 0, limit, "name:asc", `owner.id=${safeOwner}&state=active${filter2 ? "&name=*" + encodeURIComponent(filter2) + "*" : ""}`)).then((res) => {
        const truncated = typeof res?.count === "number" && res.count > limit ? { limit, count: res.count } : void 0;
        return { items: Array.isArray(res?.items) ? res.items : [], truncated };
      });
    }
    return this.zonesCache[key];
  }
  async buildGroupTree(params) {
    try {
      const { ownerId } = params;
      const treeItems = await this.grouping.getZoneGroupsAsTree(ownerId);
      const mapTree = (items) => {
        return items.map((item) => ({
          id: item.id,
          label: item.name,
          data: {
            actorId: item.id,
            actorName: item.name,
            actorSelectionType: "group",
            actorType: "zone",
            actorTypeId: "",
            actorTypeName: "Zone Group",
            text: item.name
          },
          children: Array.isArray(item.children) ? mapTree(item.children) : []
        }));
      };
      return mapTree(treeItems);
    } catch (e) {
      console.error("Failed to build group tree", e);
      return [];
    }
  }
  flattenGroupNodes(nodes) {
    const result = [];
    const walk = (n) => {
      for (const node of n) {
        if (node.data) {
          result.push({
            id: node.id,
            name: node.data.text ?? node.label,
            filter: node.data
          });
        }
        if (Array.isArray(node.children) && node.children.length) {
          walk(node.children);
        }
      }
    };
    walk(nodes);
    return result;
  }
  toZoneFilter(z2) {
    return {
      actorId: z2.id,
      actorName: z2.name ?? z2.id,
      actorSelectionType: "specific",
      actorType: "zone",
      actorTypeId: "",
      // Zones don't usually have a type like assets do
      actorTypeName: "Zone",
      text: `Zone "${z2.name}"`,
      zoneType: z2.zoneType
    };
  }
  createSpecificFromTag(tag) {
    return tag.filter ?? {
      actorId: tag.id,
      actorSelectionType: "specific",
      actorType: "zone",
      actorTypeId: "",
      actorTypeName: "Zone",
      text: tag.name
    };
  }
  async search(term, params) {
    const clean = term.trim();
    if (!clean)
      return [];
    const { ownerId, multi, groupTreeNodes, selectedIds } = params;
    const [zoneRes, groups] = await Promise.all([
      this.getZones(ownerId, 10, clean),
      multi ? Promise.resolve(this.flattenGroupNodes(groupTreeNodes)) : Promise.resolve([])
    ]);
    const groupMatches = groups.filter((g) => g.name.toLowerCase().includes(clean.toLowerCase()));
    const zoneMatches = zoneRes.items.map((z2) => ({
      id: z2.id,
      name: z2.name ?? z2.id,
      filter: this.toZoneFilter(z2)
    }));
    return [...zoneMatches, ...groupMatches].filter((x) => !selectedIds.includes(x.id));
  }
  static \u0275fac = function ZoneFilterService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ZoneFilterService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ZoneFilterService, factory: _ZoneFilterService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneFilterService, [{
    type: Injectable,
    args: [{ providedIn: "root" }]
  }], null, null);
})();

// src/app/shared/components/forms/zone-filter-field/zone-filter-field.component.ts
var _c023 = () => ({ standalone: true });
var _c119 = () => ({ width: "100%" });
var _c215 = (a0, a1) => ({ "pi-plus": a0, "pi-chevron-down": a1 });
var _forTrack04 = ($index, $item) => $item.id || $item.name;
function ZoneFilterFieldComponent_Conditional_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 13)(1, "span", 14);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "p-button", 15);
    \u0275\u0275listener("onClick", function ZoneFilterFieldComponent_Conditional_4_For_2_Template_p_button_onClick_3_listener() {
      const item_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.removeTag(item_r2));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("title", item_r2.name);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r2.name);
    \u0275\u0275advance();
    \u0275\u0275property("disabled", ctx_r2.isDisabled);
    \u0275\u0275attribute("aria-label", "Remove " + item_r2.name);
  }
}
function ZoneFilterFieldComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", 3);
    \u0275\u0275repeaterCreate(1, ZoneFilterFieldComponent_Conditional_4_For_2_Template, 4, 4, "li", 13, _forTrack04);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r2.selectedItems());
  }
}
function ZoneFilterFieldComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r4.name);
  }
}
function ZoneFilterFieldComponent_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-button", 17);
    \u0275\u0275listener("onClick", function ZoneFilterFieldComponent_Conditional_10_Template_p_button_onClick_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.clearSingle());
    });
    \u0275\u0275element(1, "i", 18);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("disabled", ctx_r2.isDisabled);
  }
}
function ZoneFilterFieldComponent_Conditional_12_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 21)(1, "p-tree", 24);
    \u0275\u0275listener("onNodeSelect", function ZoneFilterFieldComponent_Conditional_12_Conditional_9_Template_p_tree_onNodeSelect_1_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onTreeNodeSelect($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r2.zoneTreeNodes);
  }
}
function ZoneFilterFieldComponent_Conditional_12_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 22);
    \u0275\u0275text(1, "No zones available");
    \u0275\u0275elementEnd();
  }
}
function ZoneFilterFieldComponent_Conditional_12_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 21)(1, "p-tree", 24);
    \u0275\u0275listener("onNodeSelect", function ZoneFilterFieldComponent_Conditional_12_Conditional_12_Template_p_tree_onNodeSelect_1_listener($event) {
      \u0275\u0275restoreView(_r7);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onTreeNodeSelect($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r2.groupTreeNodes);
  }
}
function ZoneFilterFieldComponent_Conditional_12_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 22);
    \u0275\u0275text(1, "No groups");
    \u0275\u0275elementEnd();
  }
}
function ZoneFilterFieldComponent_Conditional_12_Conditional_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 23);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate2(" Showing ", ctx_r2.truncatedList.limit, " of ", ctx_r2.truncatedList.count, " items. Type more characters to narrow results.. ");
  }
}
function ZoneFilterFieldComponent_Conditional_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11)(1, "p-tabs", 19)(2, "p-tablist")(3, "p-tab", 19);
    \u0275\u0275text(4, "Zones");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "p-tab", 20);
    \u0275\u0275text(6, "Groups");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "p-tabpanels")(8, "p-tabpanel", 19);
    \u0275\u0275conditionalCreate(9, ZoneFilterFieldComponent_Conditional_12_Conditional_9_Template, 2, 1, "div", 21)(10, ZoneFilterFieldComponent_Conditional_12_Conditional_10_Template, 2, 0, "div", 22);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "p-tabpanel", 20);
    \u0275\u0275conditionalCreate(12, ZoneFilterFieldComponent_Conditional_12_Conditional_12_Template, 2, 1, "div", 21)(13, ZoneFilterFieldComponent_Conditional_12_Conditional_13_Template, 2, 0, "div", 22);
    \u0275\u0275elementEnd()()();
    \u0275\u0275conditionalCreate(14, ZoneFilterFieldComponent_Conditional_12_Conditional_14_Template, 2, 2, "div", 23);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(9);
    \u0275\u0275conditional(ctx_r2.zoneTreeNodes.length ? 9 : 10);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(ctx_r2.groupTreeNodes.length ? 12 : 13);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r2.truncatedList ? 14 : -1);
  }
}
function ZoneFilterFieldComponent_Conditional_13_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 21)(1, "p-tree", 24);
    \u0275\u0275listener("onNodeSelect", function ZoneFilterFieldComponent_Conditional_13_Conditional_1_Template_p_tree_onNodeSelect_1_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onTreeNodeSelect($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r2.zoneTreeNodes);
  }
}
function ZoneFilterFieldComponent_Conditional_13_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 22);
    \u0275\u0275text(1, "No zones");
    \u0275\u0275elementEnd();
  }
}
function ZoneFilterFieldComponent_Conditional_13_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 23);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate2(" Showing ", ctx_r2.truncatedList.limit, " of ", ctx_r2.truncatedList.count, " items. Refine search. ");
  }
}
function ZoneFilterFieldComponent_Conditional_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11);
    \u0275\u0275conditionalCreate(1, ZoneFilterFieldComponent_Conditional_13_Conditional_1_Template, 2, 1, "div", 21)(2, ZoneFilterFieldComponent_Conditional_13_Conditional_2_Template, 2, 0, "div", 22);
    \u0275\u0275conditionalCreate(3, ZoneFilterFieldComponent_Conditional_13_Conditional_3_Template, 2, 2, "div", 23);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r2.zoneTreeNodes.length ? 1 : 2);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r2.truncatedList ? 3 : -1);
  }
}
function ZoneFilterFieldComponent_Conditional_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 12)(1, "div");
    \u0275\u0275text(2, "This field is required");
    \u0275\u0275elementEnd()();
  }
}
function provideZoneFilterFieldValueAccessor() {
  return {
    provide: NG_VALUE_ACCESSOR,
    // eslint-disable-next-line @angular-eslint/no-forward-ref
    useExisting: forwardRef(() => ZoneFilterFieldComponent),
    multi: true
  };
}
var ZoneFilterFieldComponent = class _ZoneFilterFieldComponent {
  // Configurable Inputs
  multi = input(true, ...ngDevMode ? [{ debugName: "multi" }] : []);
  // if false -> single select
  required = input(false, ...ngDevMode ? [{ debugName: "required" }] : []);
  readonly = input(false, ...ngDevMode ? [{ debugName: "readonly" }] : []);
  // Add readonly input
  placeholder = input("Enter zone name...", ...ngDevMode ? [{ debugName: "placeholder" }] : []);
  // Provide ability to pass initial ownerId (optional override)
  ownerId = input(void 0, ...ngDevMode ? [{ debugName: "ownerId" }] : []);
  // State
  touched = false;
  dirty = false;
  loading = false;
  showPopup = false;
  truncatedList = null;
  // Tag data
  selectedItems = signal([], ...ngDevMode ? [{ debugName: "selectedItems" }] : []);
  autoCompleteItems = [];
  zoneTreeNodes = [];
  groupTreeNodes = [];
  searchTerm = "";
  searchInput = "";
  // internal resolved owner id (either from input or client selection)
  resolvedOwnerId;
  onChange = () => {
  };
  onTouched = () => {
  };
  internalValue = { mode: "multi", value: [] };
  entities = inject(EntitiesService);
  zoneFilterSvc = inject(ZoneFilterService);
  cdr = inject(ChangeDetectorRef);
  host = inject(ElementRef);
  constructor() {
    effect(() => {
      const ownerIdValue = this.ownerId();
      this.resolvedOwnerId = ownerIdValue !== void 0 && ownerIdValue !== null && ownerIdValue.trim() !== "" ? ownerIdValue : void 0;
      if (this.resolvedOwnerId !== void 0 && this.resolvedOwnerId !== null && this.resolvedOwnerId.trim() !== "") {
        void this.initForMode();
      }
    });
  }
  ngOnInit() {
    const ownerIdValue = this.ownerId();
    this.resolvedOwnerId = ownerIdValue !== void 0 && ownerIdValue !== null && ownerIdValue.trim() !== "" ? ownerIdValue : void 0;
    void this.initForMode();
  }
  // Control Value Accessor
  writeValue(extValue) {
    if (!isDefined(extValue)) {
      this.internalValue = this.multi() ? { mode: "multi", value: [] } : { mode: "single", value: null };
      this.selectedItems.set([]);
      this.cdr.markForCheck();
      return;
    }
    if (this.multi()) {
      if (Array.isArray(extValue)) {
        const typed = extValue;
        this.internalValue = { mode: "multi", value: typed };
        this.selectedItems.set(typed.map((x) => ({
          id: x.actorId,
          name: x.text ?? x.actorName ?? x.actorId,
          filter: x
        })));
      }
    } else {
      const id = typeof extValue === "string" && extValue.length ? extValue : null;
      this.internalValue = { mode: "single", value: id };
      if (id === null) {
        this.selectedItems.set([]);
      } else {
        void this.fetchZone(id).then((zone) => {
          if (zone) {
            this.selectedItems.set([
              { id: zone.id, name: zone.name ?? zone.id, filter: null }
            ]);
            this.cdr.markForCheck();
          }
        });
      }
    }
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(_isDisabled) {
  }
  // Initialization logic depending on mode
  async initForMode() {
    if (this.resolvedOwnerId === void 0 || this.resolvedOwnerId === null || this.resolvedOwnerId === "") {
      return;
    }
    if (this.multi()) {
      this.groupTreeNodes = await this.zoneFilterSvc.buildGroupTree({
        ownerId: this.resolvedOwnerId
      });
    }
    await this.loadInitialZones();
  }
  async loadInitialZones() {
    this.loading = true;
    try {
      const res = await this.zoneFilterSvc.getZones(this.resolvedOwnerId ?? "", 100);
      if (res.truncated) {
        this.truncatedList = res.truncated;
      }
      const zones = res.items;
      this.zoneTreeNodes = zones.map((z2) => ({
        id: z2.id,
        label: z2.name ?? z2.id,
        data: this.zoneFilterSvc.toZoneFilter(z2)
      }));
    } finally {
      this.loading = false;
      this.cdr.markForCheck();
    }
  }
  // Searching / autocomplete
  async onSearch(term) {
    term = (term || "").trim();
    if (!term) {
      this.autoCompleteItems = [];
      return;
    }
    this.loading = true;
    this.dirty = true;
    try {
      this.autoCompleteItems = await this.zoneFilterSvc.search(term, {
        ownerId: this.resolvedOwnerId ?? "",
        multi: this.multi(),
        groupTreeNodes: this.groupTreeNodes,
        selectedIds: this.selectedItems().map((x) => x.id)
      });
    } catch {
      this.autoCompleteItems = [];
    } finally {
      this.loading = false;
      this.cdr.markForCheck();
    }
  }
  addTag(item) {
    if (!this.multi()) {
      this.selectedItems.set([item]);
    } else if (isNullOrUndefined(this.selectedItems().find((x) => x.id === item.id))) {
      this.selectedItems.update((tags) => [...tags, item]);
    }
    this.updateExternalValue();
  }
  removeTag(item) {
    this.selectedItems.update((items) => {
      const idx = items.findIndex((x) => x.id === item.id);
      if (idx > -1) {
        return [...items.slice(0, idx), ...items.slice(idx + 1)];
      }
      return items;
    });
    this.updateExternalValue();
  }
  onTreeNodeSelect(event) {
    this.dirty = true;
    let node;
    if (typeof event === "object" && event !== null && "node" in event) {
      node = event.node;
    } else {
      node = event;
    }
    if (!node?.data) {
      return;
    }
    const data = node.data;
    const tag = {
      id: node.id,
      name: data.text ?? node.label,
      filter: data
    };
    if (!this.selectedItems().some((x) => x.id === tag.id)) {
      this.addTag(tag);
    }
    this.showPopup = false;
  }
  clearSingle() {
    if (this.multi())
      return;
    this.selectedItems.set([]);
    this.updateExternalValue();
  }
  updateExternalValue() {
    this.dirty = true;
    this.touched = true;
    if (this.multi()) {
      const filters = this.selectedItems().map((x) => x.filter ?? this.zoneFilterSvc.createSpecificFromTag(x));
      this.internalValue = { mode: "multi", value: filters };
      this.onChange(filters);
    } else {
      const id = this.selectedItems()[0]?.id ?? null;
      this.internalValue = { mode: "single", value: id };
      this.onChange(id);
    }
    this.cdr.markForCheck();
  }
  // Utilities
  async fetchZone(id) {
    try {
      const zone = await firstValueFrom(this.entities.getZone(id));
      return zone;
    } catch {
      return null;
    }
  }
  // Autocomplete wrapper for PrimeNG event
  onAutoComplete(event) {
    this.searchTerm = event.query;
    void this.onSearch(event.query);
  }
  onAutoItemSelected(event) {
    const item = event.value;
    if (item !== null && item !== void 0) {
      this.addTag(item);
    }
    this.searchInput = "";
    this.autoCompleteItems = [];
  }
  // Validation state for host form integration
  get invalid() {
    return this.required() && this.touched && (this.multi() ? this.selectedItems().length === 0 : !this.selectedItems().length);
  }
  // Validation method similar to sample component
  validate() {
    this.touched = true;
    this.dirty = true;
    this.cdr.markForCheck();
    return !this.required() || this.selectedItems().length > 0;
  }
  // Check if the component should be disabled due to missing ownerId or explicit disabled input
  get isDisabled() {
    return this.readonly() || this.resolvedOwnerId === void 0 || this.resolvedOwnerId === null || this.resolvedOwnerId.trim() === "";
  }
  // Mark touched when focusing inside
  onFocusIn() {
    this.touched = true;
  }
  // Close popup when clicking outside component
  onDocClick(ev) {
    if (!this.showPopup)
      return;
    const target = ev.target;
    if (!(target instanceof HTMLElement))
      return;
    const insideHost = this.host.nativeElement.contains(target);
    const insideOverlay = !!target.closest(".af-popup");
    if (insideHost === false && insideOverlay === false) {
      this.showPopup = false;
      this.cdr.markForCheck();
    }
  }
  static \u0275fac = function ZoneFilterFieldComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ZoneFilterFieldComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _ZoneFilterFieldComponent, selectors: [["app-zone-filter-field"]], hostBindings: function ZoneFilterFieldComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275listener("focusin", function ZoneFilterFieldComponent_focusin_HostBindingHandler() {
        return ctx.onFocusIn();
      })("click", function ZoneFilterFieldComponent_click_HostBindingHandler($event) {
        return ctx.onDocClick($event);
      }, \u0275\u0275resolveDocument);
    }
  }, inputs: { multi: [1, "multi"], required: [1, "required"], readonly: [1, "readonly"], placeholder: [1, "placeholder"], ownerId: [1, "ownerId"] }, features: [\u0275\u0275ProvidersFeature([provideZoneFilterFieldValueAccessor()])], decls: 15, vars: 26, consts: [[1, "zone-filter-field", "w-full"], [1, "sr-only"], [1, "input-wrapper"], ["aria-label", "Selected items", 1, "tags"], [1, "ac-row"], ["field", "name", "inputId", "zone-filter-autocomplete", 1, "ac", "flex-grow", 3, "ngModelChange", "completeMethod", "onSelect", "ngModel", "ngModelOptions", "suggestions", "forceSelection", "placeholder", "multiple", "dropdown", "minLength", "appendTo", "readonly", "inputStyle"], ["pTemplate", "item"], ["type", "button", "aria-label", "Toggle selector", "severity", "primary", 1, "btn-icon", "toggle", 3, "onClick", "disabled"], [1, "pi", 3, "ngClass"], ["type", "button", "aria-label", "Clear selection", 1, "btn-icon", "clear", 3, "disabled"], ["appendTo", "body", 3, "visibleChange", "onHide", "visible"], [1, "popup", "af-popup"], [1, "invalid-feedback", "d-block"], [1, "tag", "pill"], [1, "tag-label", 3, "title"], ["icon", "pi pi-times", 3, "onClick", "disabled"], [1, "ac-item"], ["type", "button", "aria-label", "Clear selection", 1, "btn-icon", "clear", 3, "onClick", "disabled"], [1, "pi", "pi-times"], ["value", "0"], ["value", "1"], [1, "tree-wrapper"], [1, "muted", "px-2", "py-1"], [1, "footer"], ["selectionMode", "single", 3, "onNodeSelect", "value"]], template: function ZoneFilterFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275elementStart(0, "fieldset", 0)(1, "legend", 1);
      \u0275\u0275text(2, "Zone Filter");
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(3, "div", 2);
      \u0275\u0275conditionalCreate(4, ZoneFilterFieldComponent_Conditional_4_Template, 3, 0, "ul", 3);
      \u0275\u0275elementStart(5, "div", 4)(6, "p-autoComplete", 5);
      \u0275\u0275twoWayListener("ngModelChange", function ZoneFilterFieldComponent_Template_p_autoComplete_ngModelChange_6_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.searchInput, $event) || (ctx.searchInput = $event);
        return $event;
      });
      \u0275\u0275listener("completeMethod", function ZoneFilterFieldComponent_Template_p_autoComplete_completeMethod_6_listener($event) {
        return ctx.onAutoComplete($event);
      })("onSelect", function ZoneFilterFieldComponent_Template_p_autoComplete_onSelect_6_listener($event) {
        return ctx.onAutoItemSelected($event);
      });
      \u0275\u0275template(7, ZoneFilterFieldComponent_ng_template_7_Template, 2, 1, "ng-template", 6);
      \u0275\u0275elementEnd();
      \u0275\u0275elementStart(8, "p-button", 7);
      \u0275\u0275listener("onClick", function ZoneFilterFieldComponent_Template_p_button_onClick_8_listener() {
        return ctx.showPopup = !ctx.showPopup;
      });
      \u0275\u0275element(9, "i", 8);
      \u0275\u0275elementEnd();
      \u0275\u0275conditionalCreate(10, ZoneFilterFieldComponent_Conditional_10_Template, 2, 1, "p-button", 9);
      \u0275\u0275elementEnd()();
      \u0275\u0275elementStart(11, "p-overlay", 10);
      \u0275\u0275twoWayListener("visibleChange", function ZoneFilterFieldComponent_Template_p_overlay_visibleChange_11_listener($event) {
        \u0275\u0275twoWayBindingSet(ctx.showPopup, $event) || (ctx.showPopup = $event);
        return $event;
      });
      \u0275\u0275listener("onHide", function ZoneFilterFieldComponent_Template_p_overlay_onHide_11_listener() {
        return ctx.showPopup = false;
      });
      \u0275\u0275conditionalCreate(12, ZoneFilterFieldComponent_Conditional_12_Template, 15, 3, "div", 11);
      \u0275\u0275conditionalCreate(13, ZoneFilterFieldComponent_Conditional_13_Template, 4, 2, "div", 11);
      \u0275\u0275elementEnd();
      \u0275\u0275conditionalCreate(14, ZoneFilterFieldComponent_Conditional_14_Template, 3, 0, "div", 12);
      \u0275\u0275elementEnd();
    }
    if (rf & 2) {
      \u0275\u0275classProp("disabled", ctx.isDisabled);
      \u0275\u0275advance(4);
      \u0275\u0275conditional(ctx.selectedItems().length ? 4 : -1);
      \u0275\u0275advance(2);
      \u0275\u0275twoWayProperty("ngModel", ctx.searchInput);
      \u0275\u0275property("ngModelOptions", \u0275\u0275pureFunction0(21, _c023))("suggestions", ctx.autoCompleteItems)("forceSelection", false)("placeholder", ctx.placeholder())("multiple", false)("dropdown", false)("minLength", 2)("appendTo", "body")("readonly", ctx.isDisabled || !ctx.multi() && ctx.selectedItems().length === 1)("inputStyle", \u0275\u0275pureFunction0(22, _c119));
      \u0275\u0275advance(2);
      \u0275\u0275property("disabled", ctx.isDisabled);
      \u0275\u0275advance();
      \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(23, _c215, ctx.multi(), !ctx.multi()));
      \u0275\u0275advance();
      \u0275\u0275conditional(!ctx.multi() && ctx.selectedItems().length ? 10 : -1);
      \u0275\u0275advance();
      \u0275\u0275twoWayProperty("visible", ctx.showPopup);
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.multi() ? 12 : -1);
      \u0275\u0275advance();
      \u0275\u0275conditional(!ctx.multi() ? 13 : -1);
      \u0275\u0275advance();
      \u0275\u0275conditional(ctx.required() && ctx.dirty && ctx.touched && ctx.selectedItems().length === 0 ? 14 : -1);
    }
  }, dependencies: [CommonModule, NgClass, FormsModule, NgControlStatus, NgModel, AutoCompleteModule, AutoComplete, PrimeTemplate, ButtonModule, Button, OverlayModule, Overlay, TreeModule, Tree, TabsModule, Tabs, TabPanels, TabPanel, TabList, Tab, InputTextModule], styles: ["\n\n.zone-filter-field[_ngcontent-%COMP%]   .input-wrapper[_ngcontent-%COMP%] {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n  width: 100%;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .ac-row[_ngcontent-%COMP%] {\n  display: flex;\n  align-items: stretch;\n  width: 100%;\n  gap: 0.25rem;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .ac-row[_ngcontent-%COMP%]   .p-autocomplete[_ngcontent-%COMP%], \n.zone-filter-field[_ngcontent-%COMP%]   .ac-row[_ngcontent-%COMP%]   .p-autocomplete[_ngcontent-%COMP%]   .p-inputtext[_ngcontent-%COMP%] {\n  width: 100%;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .btn-icon.toggle[_ngcontent-%COMP%], \n.zone-filter-field[_ngcontent-%COMP%]   .btn-icon.clear[_ngcontent-%COMP%] {\n  flex: 0 0 auto;\n  height: 2.5rem;\n  width: 2.5rem;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 0.375rem;\n  cursor: pointer;\n  transition: background 0.15s ease, color 0.15s ease;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .tags[_ngcontent-%COMP%] {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.4rem;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .tag.pill[_ngcontent-%COMP%] {\n  display: inline-flex;\n  align-items: center;\n  max-width: 100%;\n  font-size: 0.75rem;\n  line-height: 1;\n  padding: 0.4rem 0.55rem 0.4rem 0.6rem;\n  border-radius: 9999px;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);\n  position: relative;\n  transition: background 0.15s ease;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .tag-label[_ngcontent-%COMP%] {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 12rem;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%] {\n  background: transparent;\n  color: #ffffff;\n  border: none;\n  margin-left: 0.4rem;\n  cursor: pointer;\n  font-size: 0.85rem;\n  line-height: 1;\n  padding: 0;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%]:hover {\n  color: #fef3c7;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .popup.af-popup[_ngcontent-%COMP%] {\n  min-width: 420px;\n  max-width: 560px;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav {\n  background: transparent;\n  border-bottom: 1px solid #e5e7eb;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-tabview-nav-link {\n  background: transparent;\n  border: none;\n  border-bottom: 2px solid transparent;\n  color: #6b7280;\n  font-weight: 500;\n  padding: 0.75rem 1rem;\n  transition: all 0.2s ease;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-tabview-nav-link:not(.p-disabled):focus {\n  box-shadow: none;\n  outline: 2px solid #3b82f6;\n  outline-offset: -2px;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-tabview-nav-link:hover {\n  background: rgba(59, 130, 246, 0.05);\n  color: #3b82f6;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-highlight .p-tabview-nav-link {\n  background: transparent;\n  border-bottom-color: #3b82f6;\n  color: #3b82f6;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-panels {\n  background: transparent;\n  padding: 1rem 0 0 0;\n  border: none;\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-inputtext:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-autocomplete-panel {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item {\n  padding: 0;\n  border: none;\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item:hover {\n  background: #f3f4f6;\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item.p-highlight {\n  background: #eff6ff;\n  color: #1e40af;\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-label:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-header {\n  background: #f9fafb;\n  border-bottom: 1px solid #e5e7eb;\n  padding: 0.75rem;\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-inputtext {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  padding: 0.5rem 0.75rem;\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-inputtext:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item {\n  padding: 0.5rem 0.75rem;\n  border: none;\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item:hover {\n  background: #f3f4f6;\n}\n.zone-filter-field[_ngcontent-%COMP%]     .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item.p-highlight {\n  background: #eff6ff;\n  color: #1e40af;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .selected-zone-tag[_ngcontent-%COMP%] {\n  background:\n    linear-gradient(\n      135deg,\n      #3b82f6 0%,\n      #1d4ed8 100%);\n}\n.zone-filter-field[_ngcontent-%COMP%]   .selected-zone-tag[_ngcontent-%COMP%]:hover {\n  background:\n    linear-gradient(\n      135deg,\n      #2563eb 0%,\n      #1e40af 100%);\n}\n.zone-filter-field[_ngcontent-%COMP%]   .selected-zone-tag[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover {\n  background: rgba(255, 255, 255, 0.2);\n}\n.zone-filter-field[_ngcontent-%COMP%]   .clear-button[_ngcontent-%COMP%] {\n  transition: all 0.2s ease;\n}\n.zone-filter-field[_ngcontent-%COMP%]   .clear-button[_ngcontent-%COMP%]:hover {\n  background: #fef2f2;\n  border-color: #fca5a5;\n  color: #dc2626;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n}\n.zone-filter-field[_ngcontent-%COMP%]   .clear-button[_ngcontent-%COMP%]:active {\n  transform: translateY(0);\n}\n.zone-filter-field.disabled[_ngcontent-%COMP%] {\n  opacity: 0.6;\n}\n.zone-filter-field.disabled[_ngcontent-%COMP%]   .btn-icon.toggle[_ngcontent-%COMP%], \n.zone-filter-field.disabled[_ngcontent-%COMP%]   .btn-icon.clear[_ngcontent-%COMP%] {\n  cursor: not-allowed;\n  background: #f9fafb;\n  color: #9ca3af;\n}\n.zone-filter-field.disabled[_ngcontent-%COMP%]   .btn-icon.toggle[_ngcontent-%COMP%]:hover, \n.zone-filter-field.disabled[_ngcontent-%COMP%]   .btn-icon.clear[_ngcontent-%COMP%]:hover {\n  background: #f9fafb;\n  color: #9ca3af;\n}\n.zone-filter-field.disabled[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%] {\n  cursor: not-allowed;\n}\n.zone-filter-field.disabled[_ngcontent-%COMP%]   .tag-remove[_ngcontent-%COMP%]:hover {\n  color: #ffffff;\n}\n.zone-filter-field.disabled[_ngcontent-%COMP%]     .p-autocomplete .p-inputtext {\n  background: #f9fafb;\n  color: #9ca3af;\n  cursor: not-allowed;\n}\n.zone-filter-field.disabled[_ngcontent-%COMP%]     .p-autocomplete .p-inputtext:focus {\n  border-color: #d1d5db;\n  box-shadow: none;\n}\n@media (max-width: 768px) {\n  .zone-filter-field[_ngcontent-%COMP%]   .custom-tabview[_ngcontent-%COMP%]     .p-tabview-nav .p-tabview-nav-link {\n    padding: 0.5rem 0.75rem;\n    font-size: 0.875rem;\n  }\n}\n/*# sourceMappingURL=zone-filter-field.component.css.map */"], changeDetection: 0 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ZoneFilterFieldComponent, [{
    type: Component,
    args: [{ selector: "app-zone-filter-field", imports: [
      CommonModule,
      FormsModule,
      AutoCompleteModule,
      ButtonModule,
      OverlayModule,
      TreeModule,
      TabsModule,
      InputTextModule
    ], changeDetection: ChangeDetectionStrategy.OnPush, providers: [provideZoneFilterFieldValueAccessor()], template: `<fieldset class="zone-filter-field w-full" [class.disabled]="isDisabled">
  <legend class="sr-only">Zone Filter</legend>
  <div class="input-wrapper">
    <!-- Selected pills -->
    @if (selectedItems().length) {
      <ul class="tags" aria-label="Selected items">
        @for (item of selectedItems(); track item.id || item.name) {
          <li class="tag pill">
            <span class="tag-label" [title]="item.name">{{ item.name }}</span>
            <p-button
              (onClick)="removeTag(item)"
              [attr.aria-label]="'Remove ' + item.name"
              [disabled]="isDisabled"
              icon="pi pi-times"
            />
          </li>
        }
      </ul>
    }
    <div class="ac-row">
      <!-- Autocomplete input -->
      <p-autoComplete
        class="ac flex-grow"
        [(ngModel)]="searchInput"
        [ngModelOptions]="{ standalone: true }"
        [suggestions]="autoCompleteItems"
        (completeMethod)="onAutoComplete($event)"
        (onSelect)="onAutoItemSelected($event)"
        field="name"
        [forceSelection]="false"
        [placeholder]="placeholder()"
        [multiple]="false"
        [dropdown]="false"
        [minLength]="2"
        [appendTo]="'body'"
        inputId="zone-filter-autocomplete"
        [readonly]="isDisabled || (!multi() && selectedItems().length === 1)"
        [inputStyle]="{ width: '100%' }"
      >
        <ng-template let-item pTemplate="item">
          <div class="ac-item">{{ item.name }}</div>
        </ng-template>
      </p-autoComplete>
      <!-- Add / caret button -->
      <p-button
        type="button"
        class="btn-icon toggle"
        (onClick)="showPopup = !showPopup"
        [disabled]="isDisabled"
        aria-label="Toggle selector"
        severity="primary"
      >
        <i
          class="pi"
          [ngClass]="{ 'pi-plus': multi(), 'pi-chevron-down': !multi() }"
        ></i>
      </p-button>
      @if (!multi() && selectedItems().length) {
        <p-button
          type="button"
          class="btn-icon clear"
          (onClick)="clearSingle()"
          [disabled]="isDisabled"
          aria-label="Clear selection"
        >
          <i class="pi pi-times"></i>
        </p-button>
      }
    </div>
  </div>

  <!-- Popup -->
  <p-overlay
    [(visible)]="showPopup"
    appendTo="body"
    (onHide)="showPopup = false"
  >
    @if (multi()) {
      <div class="popup af-popup">
        <p-tabs value="0">
          <p-tablist>
            <p-tab value="0">Zones</p-tab>
            <p-tab value="1">Groups</p-tab>
          </p-tablist>
          <p-tabpanels>
            <p-tabpanel value="0">
              @if (zoneTreeNodes.length) {
                <div class="tree-wrapper">
                  <p-tree
                    [value]="zoneTreeNodes"
                    selectionMode="single"
                    (onNodeSelect)="onTreeNodeSelect($event)"
                  ></p-tree>
                </div>
              } @else {
                <div class="muted px-2 py-1">No zones available</div>
              }
            </p-tabpanel>
            <p-tabpanel value="1">
              @if (groupTreeNodes.length) {
                <div class="tree-wrapper">
                  <p-tree
                    [value]="groupTreeNodes"
                    selectionMode="single"
                    (onNodeSelect)="onTreeNodeSelect($event)"
                  ></p-tree>
                </div>
              } @else {
                <div class="muted px-2 py-1">No groups</div>
              }
            </p-tabpanel>
          </p-tabpanels>
        </p-tabs>
        @if (truncatedList) {
          <div class="footer">
            Showing {{ truncatedList.limit }} of
            {{ truncatedList.count }} items. Type more characters to narrow
            results..
          </div>
        }
      </div>
    }
    @if (!multi()) {
      <div class="popup af-popup">
        @if (zoneTreeNodes.length) {
          <div class="tree-wrapper">
            <p-tree
              [value]="zoneTreeNodes"
              selectionMode="single"
              (onNodeSelect)="onTreeNodeSelect($event)"
            ></p-tree>
          </div>
        } @else {
          <div class="muted px-2 py-1">No zones</div>
        }
        @if (truncatedList) {
          <div class="footer">
            Showing {{ truncatedList.limit }} of
            {{ truncatedList.count }} items. Refine search.
          </div>
        }
      </div>
    }
  </p-overlay>

  <!-- Error display like sample component -->
  @if (required() && dirty && touched && selectedItems().length === 0) {
    <div class="invalid-feedback d-block">
      <div>This field is required</div>
    </div>
  }
</fieldset>
`, styles: ["/* src/app/shared/components/forms/zone-filter-field/zone-filter-field.component.scss */\n.zone-filter-field .input-wrapper {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n  width: 100%;\n}\n.zone-filter-field .ac-row {\n  display: flex;\n  align-items: stretch;\n  width: 100%;\n  gap: 0.25rem;\n}\n.zone-filter-field .ac-row .p-autocomplete,\n.zone-filter-field .ac-row .p-autocomplete .p-inputtext {\n  width: 100%;\n}\n.zone-filter-field .btn-icon.toggle,\n.zone-filter-field .btn-icon.clear {\n  flex: 0 0 auto;\n  height: 2.5rem;\n  width: 2.5rem;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: 0.375rem;\n  cursor: pointer;\n  transition: background 0.15s ease, color 0.15s ease;\n}\n.zone-filter-field .tags {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.4rem;\n}\n.zone-filter-field .tag.pill {\n  display: inline-flex;\n  align-items: center;\n  max-width: 100%;\n  font-size: 0.75rem;\n  line-height: 1;\n  padding: 0.4rem 0.55rem 0.4rem 0.6rem;\n  border-radius: 9999px;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);\n  position: relative;\n  transition: background 0.15s ease;\n}\n.zone-filter-field .tag-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 12rem;\n}\n.zone-filter-field .tag-remove {\n  background: transparent;\n  color: #ffffff;\n  border: none;\n  margin-left: 0.4rem;\n  cursor: pointer;\n  font-size: 0.85rem;\n  line-height: 1;\n  padding: 0;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n}\n.zone-filter-field .tag-remove:hover {\n  color: #fef3c7;\n}\n.zone-filter-field .popup.af-popup {\n  min-width: 420px;\n  max-width: 560px;\n}\n.zone-filter-field .custom-tabview ::ng-deep .p-tabview-nav {\n  background: transparent;\n  border-bottom: 1px solid #e5e7eb;\n}\n.zone-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-tabview-nav-link {\n  background: transparent;\n  border: none;\n  border-bottom: 2px solid transparent;\n  color: #6b7280;\n  font-weight: 500;\n  padding: 0.75rem 1rem;\n  transition: all 0.2s ease;\n}\n.zone-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-tabview-nav-link:not(.p-disabled):focus {\n  box-shadow: none;\n  outline: 2px solid #3b82f6;\n  outline-offset: -2px;\n}\n.zone-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-tabview-nav-link:hover {\n  background: rgba(59, 130, 246, 0.05);\n  color: #3b82f6;\n}\n.zone-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-highlight .p-tabview-nav-link {\n  background: transparent;\n  border-bottom-color: #3b82f6;\n  color: #3b82f6;\n}\n.zone-filter-field .custom-tabview ::ng-deep .p-tabview-panels {\n  background: transparent;\n  padding: 1rem 0 0 0;\n  border: none;\n}\n.zone-filter-field ::ng-deep .p-autocomplete .p-inputtext:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.zone-filter-field ::ng-deep .p-autocomplete .p-autocomplete-panel {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n}\n.zone-filter-field ::ng-deep .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item {\n  padding: 0;\n  border: none;\n}\n.zone-filter-field ::ng-deep .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item:hover {\n  background: #f3f4f6;\n}\n.zone-filter-field ::ng-deep .p-autocomplete .p-autocomplete-panel .p-autocomplete-items .p-autocomplete-item.p-highlight {\n  background: #eff6ff;\n  color: #1e40af;\n}\n.zone-filter-field ::ng-deep .p-multiselect .p-multiselect-label:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.zone-filter-field ::ng-deep .p-multiselect .p-multiselect-panel {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n}\n.zone-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-header {\n  background: #f9fafb;\n  border-bottom: 1px solid #e5e7eb;\n  padding: 0.75rem;\n}\n.zone-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-inputtext {\n  border: 1px solid #d1d5db;\n  border-radius: 0.375rem;\n  padding: 0.5rem 0.75rem;\n}\n.zone-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-header .p-multiselect-filter-container .p-inputtext:focus {\n  border-color: #3b82f6;\n  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);\n}\n.zone-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item {\n  padding: 0.5rem 0.75rem;\n  border: none;\n}\n.zone-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item:hover {\n  background: #f3f4f6;\n}\n.zone-filter-field ::ng-deep .p-multiselect .p-multiselect-panel .p-multiselect-items .p-multiselect-item.p-highlight {\n  background: #eff6ff;\n  color: #1e40af;\n}\n.zone-filter-field .selected-zone-tag {\n  background:\n    linear-gradient(\n      135deg,\n      #3b82f6 0%,\n      #1d4ed8 100%);\n}\n.zone-filter-field .selected-zone-tag:hover {\n  background:\n    linear-gradient(\n      135deg,\n      #2563eb 0%,\n      #1e40af 100%);\n}\n.zone-filter-field .selected-zone-tag button:hover {\n  background: rgba(255, 255, 255, 0.2);\n}\n.zone-filter-field .clear-button {\n  transition: all 0.2s ease;\n}\n.zone-filter-field .clear-button:hover {\n  background: #fef2f2;\n  border-color: #fca5a5;\n  color: #dc2626;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n}\n.zone-filter-field .clear-button:active {\n  transform: translateY(0);\n}\n.zone-filter-field.disabled {\n  opacity: 0.6;\n}\n.zone-filter-field.disabled .btn-icon.toggle,\n.zone-filter-field.disabled .btn-icon.clear {\n  cursor: not-allowed;\n  background: #f9fafb;\n  color: #9ca3af;\n}\n.zone-filter-field.disabled .btn-icon.toggle:hover,\n.zone-filter-field.disabled .btn-icon.clear:hover {\n  background: #f9fafb;\n  color: #9ca3af;\n}\n.zone-filter-field.disabled .tag-remove {\n  cursor: not-allowed;\n}\n.zone-filter-field.disabled .tag-remove:hover {\n  color: #ffffff;\n}\n.zone-filter-field.disabled ::ng-deep .p-autocomplete .p-inputtext {\n  background: #f9fafb;\n  color: #9ca3af;\n  cursor: not-allowed;\n}\n.zone-filter-field.disabled ::ng-deep .p-autocomplete .p-inputtext:focus {\n  border-color: #d1d5db;\n  box-shadow: none;\n}\n@media (max-width: 768px) {\n  .zone-filter-field .custom-tabview ::ng-deep .p-tabview-nav .p-tabview-nav-link {\n    padding: 0.5rem 0.75rem;\n    font-size: 0.875rem;\n  }\n}\n/*# sourceMappingURL=zone-filter-field.component.css.map */\n"] }]
  }], () => [], { multi: [{ type: Input, args: [{ isSignal: true, alias: "multi", required: false }] }], required: [{ type: Input, args: [{ isSignal: true, alias: "required", required: false }] }], readonly: [{ type: Input, args: [{ isSignal: true, alias: "readonly", required: false }] }], placeholder: [{ type: Input, args: [{ isSignal: true, alias: "placeholder", required: false }] }], ownerId: [{ type: Input, args: [{ isSignal: true, alias: "ownerId", required: false }] }], onFocusIn: [{
    type: HostListener,
    args: ["focusin"]
  }], onDocClick: [{
    type: HostListener,
    args: ["document:click", ["$event"]]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(ZoneFilterFieldComponent, { className: "ZoneFilterFieldComponent", filePath: "src/app/shared/components/forms/zone-filter-field/zone-filter-field.component.ts", lineNumber: 75 });
})();

// node_modules/@primeuix/styles/dist/tieredmenu/index.mjs
var style18 = "\n    .p-tieredmenu {\n        background: dt('tieredmenu.background');\n        color: dt('tieredmenu.color');\n        border: 1px solid dt('tieredmenu.border.color');\n        border-radius: dt('tieredmenu.border.radius');\n        min-width: 12.5rem;\n    }\n    \n\n    .p-tieredmenu-root-list,\n    .p-tieredmenu-submenu {\n        margin: 0;\n        padding: dt('tieredmenu.list.padding');\n        list-style: none;\n        outline: 0 none;\n        display: flex;\n        flex-direction: column;\n        gap: dt('tieredmenu.list.gap');\n    }\n\n    .p-tieredmenu-submenu {\n        position: absolute;\n        min-width: 100%;\n        z-index: 1;\n        background: dt('tieredmenu.background');\n        color: dt('tieredmenu.color');\n        border: 1px solid dt('tieredmenu.border.color');\n        border-radius: dt('tieredmenu.border.radius');\n        box-shadow: dt('tieredmenu.shadow');\n    }\n\n    .p-tieredmenu-item {\n        position: relative;\n    }\n\n    .p-tieredmenu-item-content {\n        transition:\n            background dt('tieredmenu.transition.duration'),\n            color dt('tieredmenu.transition.duration');\n        border-radius: dt('tieredmenu.item.border.radius');\n        color: dt('tieredmenu.item.color');\n    }\n\n    .p-tieredmenu-item-link {\n        cursor: pointer;\n        display: flex;\n        align-items: center;\n        text-decoration: none;\n        overflow: hidden;\n        position: relative;\n        color: inherit;\n        padding: dt('tieredmenu.item.padding');\n        gap: dt('tieredmenu.item.gap');\n        user-select: none;\n        outline: 0 none;\n    }\n\n    .p-tieredmenu-item-label {\n        line-height: 1;\n    }\n\n    .p-tieredmenu-item-icon {\n        color: dt('tieredmenu.item.icon.color');\n    }\n\n    .p-tieredmenu-submenu-icon {\n        color: dt('tieredmenu.submenu.icon.color');\n        margin-left: auto;\n        font-size: dt('tieredmenu.submenu.icon.size');\n        width: dt('tieredmenu.submenu.icon.size');\n        height: dt('tieredmenu.submenu.icon.size');\n    }\n\n    .p-tieredmenu-submenu-icon:dir(rtl) {\n        margin-left: 0;\n        margin-right: auto;\n    }\n\n    .p-tieredmenu-item.p-focus > .p-tieredmenu-item-content {\n        color: dt('tieredmenu.item.focus.color');\n        background: dt('tieredmenu.item.focus.background');\n    }\n\n    .p-tieredmenu-item.p-focus > .p-tieredmenu-item-content .p-tieredmenu-item-icon {\n        color: dt('tieredmenu.item.icon.focus.color');\n    }\n\n    .p-tieredmenu-item.p-focus > .p-tieredmenu-item-content .p-tieredmenu-submenu-icon {\n        color: dt('tieredmenu.submenu.icon.focus.color');\n    }\n\n    .p-tieredmenu-item:not(.p-disabled) > .p-tieredmenu-item-content:hover {\n        color: dt('tieredmenu.item.focus.color');\n        background: dt('tieredmenu.item.focus.background');\n    }\n\n    .p-tieredmenu-item:not(.p-disabled) > .p-tieredmenu-item-content:hover .p-tieredmenu-item-icon {\n        color: dt('tieredmenu.item.icon.focus.color');\n    }\n\n    .p-tieredmenu-item:not(.p-disabled) > .p-tieredmenu-item-content:hover .p-tieredmenu-submenu-icon {\n        color: dt('tieredmenu.submenu.icon.focus.color');\n    }\n\n    .p-tieredmenu-item-active > .p-tieredmenu-item-content {\n        color: dt('tieredmenu.item.active.color');\n        background: dt('tieredmenu.item.active.background');\n    }\n\n    .p-tieredmenu-item-active > .p-tieredmenu-item-content .p-tieredmenu-item-icon {\n        color: dt('tieredmenu.item.icon.active.color');\n    }\n\n    .p-tieredmenu-item-active > .p-tieredmenu-item-content .p-tieredmenu-submenu-icon {\n        color: dt('tieredmenu.submenu.icon.active.color');\n    }\n\n    .p-tieredmenu-separator {\n        border-block-start: 1px solid dt('tieredmenu.separator.border.color');\n    }\n\n    .p-tieredmenu-overlay {\n        box-shadow: dt('tieredmenu.shadow');\n        will-change: transform;\n    }\n\n    .p-tieredmenu-mobile .p-tieredmenu-submenu {\n        position: static;\n        box-shadow: none;\n        border: 0 none;\n        padding-inline-start: dt('tieredmenu.submenu.mobile.indent');\n        padding-inline-end: 0;\n    }\n\n    .p-tieredmenu-mobile .p-tieredmenu-submenu:dir(rtl) {\n        padding-inline-start: 0;\n        padding-inline-end: dt('tieredmenu.submenu.mobile.indent');\n    }\n\n    .p-tieredmenu-mobile .p-tieredmenu-submenu-icon {\n        transition: transform 0.2s;\n        transform: rotate(90deg);\n    }\n\n    .p-tieredmenu-mobile .p-tieredmenu-item-active > .p-tieredmenu-item-content .p-tieredmenu-submenu-icon {\n        transform: rotate(-90deg);\n    }\n";

// node_modules/primeng/fesm2022/primeng-tieredmenu.mjs
var _c024 = ["sublist"];
var _c120 = (a0) => ({
  processedItem: a0
});
var _c216 = () => ({
  exact: false
});
var _c312 = (a0, a1) => ({
  $implicit: a0,
  hasSubmenu: a1
});
function TieredMenuSub_Conditional_0_ng_template_2_li_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "li", 8);
  }
  if (rf & 2) {
    const processedItem_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275styleMap(ctx_r1.getItemProp(processedItem_r3, "style"));
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("separator"), ctx_r1.getItemProp(processedItem_r3, "class"), ctx_r1.getItemProp(processedItem_r3, "styleClass")));
    \u0275\u0275property("pBind", ctx_r1._ptm("separator"));
    \u0275\u0275attribute("id", ctx_r1.getItemId(processedItem_r3));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 19);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(4);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemIcon"), ctx_r1.getItemProp(processedItem_r3, "icon"), ctx_r1.getItemProp(processedItem_r3, "iconClass")));
    \u0275\u0275property("ngStyle", ctx_r1.getItemProp(processedItem_r3, "iconStyle"))("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "itemIcon"));
    \u0275\u0275attribute("tabindex", -1);
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 19);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(4);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemLabel"), ctx_r1.getItemProp(processedItem_r3, "labelClass")));
    \u0275\u0275property("ngStyle", ctx_r1.getItemProp(processedItem_r3, "labelStyle"))("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "itemLabel"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getItemLabel(processedItem_r3), " ");
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 20);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(4);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemLabel"), ctx_r1.getItemProp(processedItem_r3, "labelClass")));
    \u0275\u0275property("ngStyle", ctx_r1.getItemProp(processedItem_r3, "labelStyle"))("innerHTML", ctx_r1.getItemLabel(processedItem_r3), \u0275\u0275sanitizeHtml)("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "itemLabel"));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const processedItem_r3 = \u0275\u0275nextContext(4).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemBadge"), ctx_r1.getItemProp(processedItem_r3, "badgeStyleClass")));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.getItemProp(processedItem_r3, "badge"));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_container_6__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 23);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(5);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cx("submenuIcon"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "submenuIcon"));
    \u0275\u0275attribute("aria-hidden", true);
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_container_6_2_ng_template_0_Template(rf, ctx) {
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_container_6_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_container_6_2_ng_template_0_Template, 0, 0, "ng-template", 24);
  }
  if (rf & 2) {
    \u0275\u0275ariaProperty("aria-hidden", true);
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_container_6__svg_svg_1_Template, 1, 4, "svg", 21)(2, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_container_6_2_Template, 1, 1, null, 22);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(6);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.tieredMenu.submenuIconTemplate && !ctx_r1.tieredMenu._submenuIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.tieredMenu.submenuIconTemplate || ctx_r1.tieredMenu._submenuIconTemplate);
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 15);
    \u0275\u0275template(1, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_span_1_Template, 1, 5, "span", 16)(2, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_span_2_Template, 2, 5, "span", 17)(3, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_template_3_Template, 1, 5, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(5, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_span_5_Template, 2, 3, "span", 18)(6, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_ng_container_6_Template, 3, 2, "ng-container", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const htmlLabel_r7 = \u0275\u0275reference(4);
    const ctx_r4 = \u0275\u0275nextContext(3);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemLink"), ctx_r1.getItemProp(processedItem_r3, "linkClass")));
    \u0275\u0275property("target", ctx_r1.getItemProp(processedItem_r3, "target"))("ngStyle", ctx_r1.getItemProp(processedItem_r3, "linkStyle"))("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "itemLink"));
    \u0275\u0275attribute("href", ctx_r1.getItemProp(processedItem_r3, "url"), \u0275\u0275sanitizeUrl)("data-automationid", ctx_r1.getItemProp(processedItem_r3, "automationId"))("title", ctx_r1.getItemProp(processedItem_r3, "title"))("tabindex", -1);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getItemProp(processedItem_r3, "icon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getItemProp(processedItem_r3, "escape"))("ngIfElse", htmlLabel_r7);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r1.getItemProp(processedItem_r3, "badge"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isItemGroup(processedItem_r3));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 19);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(4);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemIcon"), ctx_r1.getItemProp(processedItem_r3, "icon"), ctx_r1.getItemProp(processedItem_r3, "iconClass")));
    \u0275\u0275property("ngStyle", ctx_r1.getItemProp(processedItem_r3, "iconStyle"))("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "itemIcon"));
    \u0275\u0275attribute("aria-hidden", true)("tabindex", -1);
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 19);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(4);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemLabel"), ctx_r1.getItemProp(processedItem_r3, "labelClass")));
    \u0275\u0275property("ngStyle", ctx_r1.getItemProp(processedItem_r3, "labelStyle"))("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "itemLabel"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.getItemLabel(processedItem_r3), " ");
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 20);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(4);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemLabel"), ctx_r1.getItemProp(processedItem_r3, "labelClass")));
    \u0275\u0275property("ngStyle", ctx_r1.getItemProp(processedItem_r3, "labelStyle"))("innerHTML", ctx_r1.getItemLabel(processedItem_r3), \u0275\u0275sanitizeHtml)("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "itemLabel"));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_span_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const processedItem_r3 = \u0275\u0275nextContext(4).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemBadge"), ctx_r1.getItemProp(processedItem_r3, "badgeStyleClass")));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.getItemProp(processedItem_r3, "badge"));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_container_6__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 23);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(5);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cx("submenuIcon"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "submenuIcon"));
    \u0275\u0275attribute("aria-hidden", true);
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_container_6_2_ng_template_0_Template(rf, ctx) {
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_container_6_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_container_6_2_ng_template_0_Template, 0, 0, "ng-template", 24);
  }
  if (rf & 2) {
    \u0275\u0275ariaProperty("aria-hidden", true);
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_container_6__svg_svg_1_Template, 1, 4, "svg", 21)(2, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_container_6_2_Template, 1, 1, null, 22);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(6);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.tieredMenu.submenuIconTemplate && !ctx_r1.tieredMenu._submenuIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.tieredMenu.submenuIconTemplate || ctx_r1.tieredMenu._submenuIconTemplate);
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 25);
    \u0275\u0275template(1, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_span_1_Template, 1, 6, "span", 16)(2, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_span_2_Template, 2, 5, "span", 17)(3, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_template_3_Template, 1, 5, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(5, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_span_5_Template, 2, 3, "span", 18)(6, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_ng_container_6_Template, 3, 2, "ng-container", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const htmlLabel_r8 = \u0275\u0275reference(4);
    const ctx_r4 = \u0275\u0275nextContext(3);
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("itemLink"), ctx_r1.getItemProp(processedItem_r3, "linkClass")));
    \u0275\u0275property("routerLink", ctx_r1.getItemProp(processedItem_r3, "routerLink"))("queryParams", ctx_r1.getItemProp(processedItem_r3, "queryParams"))("routerLinkActive", "p-tieredmenu-item-link-active")("routerLinkActiveOptions", ctx_r1.getItemProp(processedItem_r3, "routerLinkActiveOptions") || \u0275\u0275pureFunction0(23, _c216))("target", ctx_r1.getItemProp(processedItem_r3, "target"))("ngStyle", ctx_r1.getItemProp(processedItem_r3, "linkStyle"))("fragment", ctx_r1.getItemProp(processedItem_r3, "fragment"))("queryParamsHandling", ctx_r1.getItemProp(processedItem_r3, "queryParamsHandling"))("preserveFragment", ctx_r1.getItemProp(processedItem_r3, "preserveFragment"))("skipLocationChange", ctx_r1.getItemProp(processedItem_r3, "skipLocationChange"))("replaceUrl", ctx_r1.getItemProp(processedItem_r3, "replaceUrl"))("state", ctx_r1.getItemProp(processedItem_r3, "state"))("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "itemLink"));
    \u0275\u0275attribute("data-automationid", ctx_r1.getItemProp(processedItem_r3, "automationId"))("title", ctx_r1.getItemProp(processedItem_r3, "title"))("tabindex", -1);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getItemProp(processedItem_r3, "icon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getItemProp(processedItem_r3, "escape"))("ngIfElse", htmlLabel_r8);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngIf", ctx_r1.getItemProp(processedItem_r3, "badge"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isItemGroup(processedItem_r3));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_1_Template, 7, 14, "a", 13)(2, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_a_2_Template, 7, 24, "a", 14);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const processedItem_r3 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.getItemProp(processedItem_r3, "routerLink"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.getItemProp(processedItem_r3, "routerLink"));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_4_1_ng_template_0_Template(rf, ctx) {
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_4_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_4_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_4_1_Template, 1, 0, null, 26);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const processedItem_r3 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.itemTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c312, processedItem_r3.item, ctx_r1.getItemProp(processedItem_r3, "items")));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_p_tieredmenusub_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-tieredmenusub", 27);
    \u0275\u0275listener("itemClick", function TieredMenuSub_Conditional_0_ng_template_2_li_1_p_tieredmenusub_5_Template_p_tieredmenusub_itemClick_0_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.itemClick.emit($event));
    })("itemMouseEnter", function TieredMenuSub_Conditional_0_ng_template_2_li_1_p_tieredmenusub_5_Template_p_tieredmenusub_itemMouseEnter_0_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r1 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r1.onItemMouseEnter($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const processedItem_r3 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("items", processedItem_r3.items)("itemTemplate", ctx_r1.itemTemplate)("autoDisplay", ctx_r1.autoDisplay)("menuId", ctx_r1.menuId)("visible", ctx_r1.isItemActive(processedItem_r3) && ctx_r1.isItemGroup(processedItem_r3))("activeItemPath", ctx_r1.activeItemPath())("focusedItemId", ctx_r1.focusedItemId)("ariaLabelledBy", ctx_r1.getItemId(processedItem_r3))("level", ctx_r1.level + 1)("pt", ctx_r1.pt())("motionOptions", ctx_r1.motionOptions)("unstyled", ctx_r1.unstyled());
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 9, 1)(2, "div", 10);
    \u0275\u0275listener("click", function TieredMenuSub_Conditional_0_ng_template_2_li_1_Template_div_click_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const processedItem_r3 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onItemClick($event, processedItem_r3));
    })("mouseenter", function TieredMenuSub_Conditional_0_ng_template_2_li_1_Template_div_mouseenter_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const processedItem_r3 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.onItemMouseEnter({
        $event,
        processedItem: processedItem_r3
      }));
    });
    \u0275\u0275template(3, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_3_Template, 3, 2, "ng-container", 11)(4, TieredMenuSub_Conditional_0_ng_template_2_li_1_ng_container_4_Template, 2, 5, "ng-container", 11);
    \u0275\u0275elementEnd();
    \u0275\u0275template(5, TieredMenuSub_Conditional_0_ng_template_2_li_1_p_tieredmenusub_5_Template, 1, 12, "p-tieredmenusub", 12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    const processedItem_r3 = ctx_r4.$implicit;
    const index_r6 = ctx_r4.index;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("item", \u0275\u0275pureFunction1(22, _c120, processedItem_r3)), ctx_r1.getItemProp(processedItem_r3, "styleClass")));
    \u0275\u0275property("ngStyle", ctx_r1.getItemProp(processedItem_r3, "style"))("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "item"))("tooltipOptions", ctx_r1.getItemProp(processedItem_r3, "tooltipOptions"))("pTooltipUnstyled", ctx_r1.unstyled());
    \u0275\u0275attribute("id", ctx_r1.getItemId(processedItem_r3))("data-p-highlight", ctx_r1.isItemActive(processedItem_r3))("data-p-focused", ctx_r1.isItemFocused(processedItem_r3))("data-p-disabled", ctx_r1.isItemDisabled(processedItem_r3))("aria-label", ctx_r1.getItemLabel(processedItem_r3))("aria-disabled", ctx_r1.isItemDisabled(processedItem_r3) || void 0)("aria-haspopup", ctx_r1.isItemGroup(processedItem_r3) && !ctx_r1.getItemProp(processedItem_r3, "to") ? "menu" : void 0)("aria-expanded", ctx_r1.isItemGroup(processedItem_r3) ? ctx_r1.isItemActive(processedItem_r3) : void 0)("aria-setsize", ctx_r1.getAriaSetSize())("aria-posinset", ctx_r1.getAriaPosInset(index_r6));
    \u0275\u0275advance(2);
    \u0275\u0275classMap(ctx_r1.cx("itemContent"));
    \u0275\u0275property("pBind", ctx_r1.getPTOptions(processedItem_r3, index_r6, "itemContent"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r1.itemTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.itemTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isItemVisible(processedItem_r3) && ctx_r1.isItemGroup(processedItem_r3));
  }
}
function TieredMenuSub_Conditional_0_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, TieredMenuSub_Conditional_0_ng_template_2_li_0_Template, 1, 6, "li", 6)(1, TieredMenuSub_Conditional_0_ng_template_2_li_1_Template, 6, 24, "li", 7);
  }
  if (rf & 2) {
    const processedItem_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngIf", ctx_r1.isItemVisible(processedItem_r3) && ctx_r1.getItemProp(processedItem_r3, "separator"));
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", ctx_r1.isItemVisible(processedItem_r3) && !ctx_r1.getItemProp(processedItem_r3, "separator"));
  }
}
function TieredMenuSub_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "ul", 4, 0);
    \u0275\u0275listener("keydown", function TieredMenuSub_Conditional_0_Template_ul_keydown_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.menuKeydown.emit($event));
    })("focus", function TieredMenuSub_Conditional_0_Template_ul_focus_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.menuFocus.emit($event));
    })("blur", function TieredMenuSub_Conditional_0_Template_ul_blur_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.menuBlur.emit($event));
    })("pMotionOnBeforeEnter", function TieredMenuSub_Conditional_0_Template_ul_pMotionOnBeforeEnter_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBeforeEnter($event));
    })("pMotionOnAfterLeave", function TieredMenuSub_Conditional_0_Template_ul_pMotionOnAfterLeave_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onAfterLeave());
    });
    \u0275\u0275template(2, TieredMenuSub_Conditional_0_ng_template_2_Template, 2, 2, "ng-template", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(ctx_r1.inlineStyles);
    \u0275\u0275classMap(ctx_r1.root ? ctx_r1.cx("rootList") : ctx_r1.cx("submenu"));
    \u0275\u0275property("id", ctx_r1.menuId + "_list")("tabindex", ctx_r1.tabindex)("pBind", ctx_r1._ptm(ctx_r1.root ? "rootList" : "submenu"))("pMotion", ctx_r1.root ? true : ctx_r1.visible)("pMotionDisabled", ctx_r1.root)("pMotionAppear", true)("pMotionName", "p-anchored-overlay")("pMotionOptions", ctx_r1.motionOptions);
    \u0275\u0275attribute("aria-label", ctx_r1.ariaLabel)("aria-labelledBy", ctx_r1.ariaLabelledBy)("aria-activedescendant", ctx_r1.focusedItemId)("aria-orientation", "vertical");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngForOf", ctx_r1.items);
  }
}
var _c48 = ["submenuicon"];
var _c58 = ["item"];
var _c67 = ["rootmenu"];
var _c77 = ["container"];
function TieredMenu_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 3, 0);
    \u0275\u0275listener("click", function TieredMenu_Conditional_0_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onOverlayClick($event));
    })("pMotionOnBeforeEnter", function TieredMenu_Conditional_0_Template_div_pMotionOnBeforeEnter_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onOverlayBeforeEnter($event));
    })("pMotionOnAfterEnter", function TieredMenu_Conditional_0_Template_div_pMotionOnAfterEnter_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onOverlayAfterEnter());
    })("pMotionOnAfterLeave", function TieredMenu_Conditional_0_Template_div_pMotionOnAfterLeave_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onOverlayAfterLeave());
    });
    \u0275\u0275elementStart(2, "p-tieredMenuSub", 4, 1);
    \u0275\u0275listener("itemClick", function TieredMenu_Conditional_0_Template_p_tieredMenuSub_itemClick_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onItemClick($event));
    })("menuFocus", function TieredMenu_Conditional_0_Template_p_tieredMenuSub_menuFocus_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onMenuFocus($event));
    })("menuBlur", function TieredMenu_Conditional_0_Template_p_tieredMenuSub_menuBlur_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onMenuBlur($event));
    })("menuKeydown", function TieredMenu_Conditional_0_Template_p_tieredMenuSub_menuKeydown_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onKeyDown($event));
    })("itemMouseEnter", function TieredMenu_Conditional_0_Template_p_tieredMenuSub_itemMouseEnter_2_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onItemMouseEnter($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r1.cn(ctx_r1.cx("root"), ctx_r1.styleClass));
    \u0275\u0275property("id", ctx_r1.id)("ngStyle", ctx_r1.style)("pBind", ctx_r1.ptm("root"))("pMotion", ctx_r1.visible || !ctx_r1.popup)("pMotionName", "p-anchored-overlay")("pMotionAppear", true)("pMotionDisabled", !ctx_r1.popup)("pMotionOptions", ctx_r1.computedMotionOptions());
    \u0275\u0275advance(2);
    \u0275\u0275property("root", true)("visible", true)("items", ctx_r1.processedItems)("itemTemplate", ctx_r1.itemTemplate || ctx_r1._itemTemplate)("menuId", ctx_r1.id)("tabindex", !ctx_r1.disabled ? ctx_r1.tabindex : -1)("ariaLabel", ctx_r1.ariaLabel)("ariaLabelledBy", ctx_r1.ariaLabelledBy)("baseZIndex", ctx_r1.baseZIndex)("autoZIndex", ctx_r1.autoZIndex)("autoDisplay", ctx_r1.autoDisplay)("popup", ctx_r1.popup)("focusedItemId", ctx_r1.focused ? ctx_r1.focusedItemId : void 0)("activeItemPath", ctx_r1.activeItemPath())("pt", ctx_r1.pt())("unstyled", ctx_r1.unstyled())("motionOptions", ctx_r1.computedMotionOptions());
  }
}
var inlineStyles4 = {
  submenu: ({
    instance,
    processedItem
  }) => ({
    display: instance.isItemActive(processedItem) ? "flex" : "none"
  })
};
var classes13 = {
  root: ({
    instance
  }) => ["p-tieredmenu p-component", {
    "p-tieredmenu-overlay": instance.popup,
    "p-tieredmenu-mobile": instance.queryMatches()
  }],
  start: "p-tieredmenu-start",
  rootList: "p-tieredmenu-root-list",
  item: ({
    instance,
    processedItem
  }) => ["p-tieredmenu-item", {
    "p-tieredmenu-item-active": instance.isItemActive(processedItem),
    "p-focus": instance.isItemFocused(processedItem),
    "p-disabled": instance.isItemDisabled(processedItem)
  }],
  itemContent: "p-tieredmenu-item-content",
  itemLink: "p-tieredmenu-item-link",
  itemIcon: "p-tieredmenu-item-icon",
  itemLabel: "p-tieredmenu-item-label",
  itemBadge: "p-menuitem-badge",
  submenuIcon: "p-tieredmenu-submenu-icon",
  submenu: "p-tieredmenu-submenu",
  separator: "p-tieredmenu-separator",
  end: "p-tieredmenu-end"
};
var TieredMenuStyle = class _TieredMenuStyle extends BaseStyle {
  name = "tieredmenu";
  style = style18;
  classes = classes13;
  inlineStyles = inlineStyles4;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275TieredMenuStyle_BaseFactory;
    return function TieredMenuStyle_Factory(__ngFactoryType__) {
      return (\u0275TieredMenuStyle_BaseFactory || (\u0275TieredMenuStyle_BaseFactory = \u0275\u0275getInheritedFactory(_TieredMenuStyle)))(__ngFactoryType__ || _TieredMenuStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TieredMenuStyle,
    factory: _TieredMenuStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TieredMenuStyle, [{
    type: Injectable
  }], null, null);
})();
var TieredMenuClasses;
(function(TieredMenuClasses2) {
  TieredMenuClasses2["root"] = "p-tieredmenu";
  TieredMenuClasses2["start"] = "p-tieredmenu-start";
  TieredMenuClasses2["rootList"] = "p-tieredmenu-root-list";
  TieredMenuClasses2["item"] = "p-tieredmenu-item";
  TieredMenuClasses2["itemContent"] = "p-tieredmenu-item-content";
  TieredMenuClasses2["itemLink"] = "p-tieredmenu-item-link";
  TieredMenuClasses2["itemIcon"] = "p-tieredmenu-item-icon";
  TieredMenuClasses2["itemLabel"] = "p-tieredmenu-item-label";
  TieredMenuClasses2["submenuIcon"] = "p-tieredmenu-submenu-icon";
  TieredMenuClasses2["submenu"] = "p-tieredmenu-submenu";
  TieredMenuClasses2["separator"] = "p-tieredmenu-separator";
  TieredMenuClasses2["end"] = "p-tieredmenu-end";
})(TieredMenuClasses || (TieredMenuClasses = {}));
var TIEREDMENU_INSTANCE = new InjectionToken("TIEREDMENU_INSTANCE");
var TIEREDMENUSUB_INSTANCE = new InjectionToken("TIEREDMENUSUB_INSTANCE");
var TieredMenuSub = class _TieredMenuSub extends BaseComponent {
  el;
  renderer;
  tieredMenu;
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (this._visible || this.root) {
      this.render.set(true);
    }
  }
  items;
  itemTemplate;
  root = false;
  autoDisplay;
  autoZIndex = true;
  baseZIndex = 0;
  popup;
  menuId;
  ariaLabel;
  ariaLabelledBy;
  level = 0;
  focusedItemId;
  activeItemPath = input([], ...ngDevMode ? [{
    debugName: "activeItemPath"
  }] : []);
  motionOptions;
  tabindex = 0;
  inlineStyles;
  itemClick = new EventEmitter();
  itemMouseEnter = new EventEmitter();
  menuFocus = new EventEmitter();
  menuBlur = new EventEmitter();
  menuKeydown = new EventEmitter();
  sublistViewChild;
  render = signal(false, ...ngDevMode ? [{
    debugName: "render"
  }] : []);
  _componentStyle = inject(TieredMenuStyle);
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  $pcTieredMenu = inject(TIEREDMENU_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  $pcTieredMenuSub = inject(TIEREDMENUSUB_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  _visible = false;
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  constructor(el, renderer, tieredMenu) {
    super();
    this.el = el;
    this.renderer = renderer;
    this.tieredMenu = tieredMenu;
  }
  positionSubmenu(sublist) {
    if (isPlatformBrowser(this.tieredMenu.platformId)) {
      if (sublist) {
        zt(sublist, this.level);
      }
    }
  }
  getItemProp(processedItem, name, params = null) {
    return processedItem && processedItem.item ? m(processedItem.item[name], params) : void 0;
  }
  getItemId(processedItem) {
    return processedItem.item?.id ?? `${this.menuId}_${processedItem.key}`;
  }
  getItemKey(processedItem) {
    return this.getItemId(processedItem);
  }
  getItemLabel(processedItem) {
    return this.getItemProp(processedItem, "label");
  }
  getAriaSetSize() {
    return this.items.filter((processedItem) => this.isItemVisible(processedItem) && !this.getItemProp(processedItem, "separator")).length;
  }
  getAriaPosInset(index) {
    return index - this.items.slice(0, index).filter((processedItem) => {
      const isItemVisible = this.isItemVisible(processedItem);
      const isVisibleSeparator = isItemVisible && this.getItemProp(processedItem, "separator");
      return !isItemVisible || isVisibleSeparator;
    }).length + 1;
  }
  isItemVisible(processedItem) {
    return this.getItemProp(processedItem, "visible") !== false;
  }
  isItemActive(processedItem) {
    if (this.activeItemPath()) {
      return this.activeItemPath().some((path) => path.key === processedItem.key);
    }
    return false;
  }
  isItemDisabled(processedItem) {
    return this.getItemProp(processedItem, "disabled");
  }
  isItemFocused(processedItem) {
    return this.focusedItemId === this.getItemId(processedItem);
  }
  isItemGroup(processedItem) {
    return s(processedItem.items);
  }
  // TODO: will be removed later. Helper method to get PT from parent ContextMenu if available, otherwise use own PT
  _ptm(section, options) {
    return this.$pcTieredMenu ? this.$pcTieredMenu.ptm(section, options) : this.ptm(section, options);
  }
  getPTOptions(processedItem, index, key) {
    return this._ptm(key, {
      context: {
        item: processedItem.item,
        index,
        active: this.isItemActive(processedItem),
        focused: this.isItemFocused(processedItem),
        disabled: this.isItemDisabled(processedItem)
      }
    });
  }
  onItemMouseEnter(param) {
    if (this.autoDisplay) {
      const {
        event,
        processedItem
      } = param;
      this.itemMouseEnter.emit({
        originalEvent: event,
        processedItem
      });
    }
  }
  onItemClick(event, processedItem) {
    this.getItemProp(processedItem, "command", {
      originalEvent: event,
      item: processedItem.item
    });
    this.itemClick.emit({
      originalEvent: event,
      processedItem,
      isFocus: true
    });
  }
  onBeforeEnter(event) {
    this.positionSubmenu(event.element);
  }
  onAfterLeave() {
    this.render.set(false);
  }
  static \u0275fac = function TieredMenuSub_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TieredMenuSub)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(forwardRef(() => TieredMenu)));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _TieredMenuSub,
    selectors: [["p-tieredMenuSub"], ["p-tieredmenusub"]],
    viewQuery: function TieredMenuSub_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c024, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.sublistViewChild = _t.first);
      }
    },
    inputs: {
      visible: "visible",
      items: "items",
      itemTemplate: "itemTemplate",
      root: [2, "root", "root", booleanAttribute],
      autoDisplay: [2, "autoDisplay", "autoDisplay", booleanAttribute],
      autoZIndex: [2, "autoZIndex", "autoZIndex", booleanAttribute],
      baseZIndex: [2, "baseZIndex", "baseZIndex", numberAttribute],
      popup: [2, "popup", "popup", booleanAttribute],
      menuId: "menuId",
      ariaLabel: "ariaLabel",
      ariaLabelledBy: "ariaLabelledBy",
      level: [2, "level", "level", numberAttribute],
      focusedItemId: "focusedItemId",
      activeItemPath: [1, "activeItemPath"],
      motionOptions: "motionOptions",
      tabindex: [2, "tabindex", "tabindex", numberAttribute],
      inlineStyles: "inlineStyles"
    },
    outputs: {
      itemClick: "itemClick",
      itemMouseEnter: "itemMouseEnter",
      menuFocus: "menuFocus",
      menuBlur: "menuBlur",
      menuKeydown: "menuKeydown"
    },
    features: [\u0275\u0275ProvidersFeature([{
      provide: TIEREDMENUSUB_INSTANCE,
      useExisting: forwardRef(() => _TieredMenuSub)
    }, {
      provide: PARENT_INSTANCE,
      useExisting: forwardRef(() => _TieredMenuSub)
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["sublist", ""], ["listItem", ""], ["htmlLabel", ""], ["role", "menu", 3, "class", "id", "tabindex", "pBind", "style", "pMotion", "pMotionDisabled", "pMotionAppear", "pMotionName", "pMotionOptions"], ["role", "menu", 3, "keydown", "focus", "blur", "pMotionOnBeforeEnter", "pMotionOnAfterLeave", "id", "tabindex", "pBind", "pMotion", "pMotionDisabled", "pMotionAppear", "pMotionName", "pMotionOptions"], ["ngFor", "", 3, "ngForOf"], ["role", "separator", 3, "style", "class", "pBind", 4, "ngIf"], ["role", "menuitem", "pTooltip", "", 3, "ngStyle", "class", "pBind", "tooltipOptions", "pTooltipUnstyled", 4, "ngIf"], ["role", "separator", 3, "pBind"], ["role", "menuitem", "pTooltip", "", 3, "ngStyle", "pBind", "tooltipOptions", "pTooltipUnstyled"], [3, "click", "mouseenter", "pBind"], [4, "ngIf"], [3, "items", "itemTemplate", "autoDisplay", "menuId", "visible", "activeItemPath", "focusedItemId", "ariaLabelledBy", "level", "pt", "motionOptions", "unstyled", "itemClick", "itemMouseEnter", 4, "ngIf"], ["pRipple", "", 3, "target", "class", "ngStyle", "pBind", 4, "ngIf"], ["pRipple", "", 3, "routerLink", "queryParams", "routerLinkActive", "routerLinkActiveOptions", "target", "class", "ngStyle", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "pBind", 4, "ngIf"], ["pRipple", "", 3, "target", "ngStyle", "pBind"], [3, "class", "ngStyle", "pBind", 4, "ngIf"], [3, "class", "ngStyle", "pBind", 4, "ngIf", "ngIfElse"], [3, "class", 4, "ngIf"], [3, "ngStyle", "pBind"], [3, "ngStyle", "innerHTML", "pBind"], ["data-p-icon", "angle-right", 3, "class", "pBind", 4, "ngIf"], [4, "ngTemplateOutlet"], ["data-p-icon", "angle-right", 3, "pBind"], [3, "aria-hidden"], ["pRipple", "", 3, "routerLink", "queryParams", "routerLinkActive", "routerLinkActiveOptions", "target", "ngStyle", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "pBind"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "itemClick", "itemMouseEnter", "items", "itemTemplate", "autoDisplay", "menuId", "visible", "activeItemPath", "focusedItemId", "ariaLabelledBy", "level", "pt", "motionOptions", "unstyled"]],
    template: function TieredMenuSub_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275conditionalCreate(0, TieredMenuSub_Conditional_0_Template, 3, 17, "ul", 3);
      }
      if (rf & 2) {
        \u0275\u0275conditional(ctx.render() ? 0 : -1);
      }
    },
    dependencies: [_TieredMenuSub, CommonModule, NgForOf, NgIf, NgTemplateOutlet, NgStyle, RouterModule, RouterLink, RouterLinkActive, Ripple, TooltipModule, Tooltip, Bind, AngleRightIcon, SharedModule, BindModule, MotionModule, MotionDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TieredMenuSub, [{
    type: Component,
    args: [{
      selector: "p-tieredMenuSub, p-tieredmenusub",
      standalone: true,
      imports: [CommonModule, RouterModule, Ripple, TooltipModule, AngleRightIcon, SharedModule, BindModule, MotionModule],
      template: `
        @if (render()) {
            <ul
                #sublist
                role="menu"
                [class]="root ? cx('rootList') : cx('submenu')"
                [id]="menuId + '_list'"
                [tabindex]="tabindex"
                [attr.aria-label]="ariaLabel"
                [attr.aria-labelledBy]="ariaLabelledBy"
                [attr.aria-activedescendant]="focusedItemId"
                [attr.aria-orientation]="'vertical'"
                [pBind]="_ptm(root ? 'rootList' : 'submenu')"
                (keydown)="menuKeydown.emit($event)"
                (focus)="menuFocus.emit($event)"
                (blur)="menuBlur.emit($event)"
                [style]="inlineStyles"
                [pMotion]="root ? true : visible"
                [pMotionDisabled]="root"
                [pMotionAppear]="true"
                [pMotionName]="'p-anchored-overlay'"
                [pMotionOptions]="motionOptions"
                (pMotionOnBeforeEnter)="onBeforeEnter($event)"
                (pMotionOnAfterLeave)="onAfterLeave()"
            >
                <ng-template ngFor let-processedItem [ngForOf]="items" let-index="index">
                    <li
                        *ngIf="isItemVisible(processedItem) && getItemProp(processedItem, 'separator')"
                        [attr.id]="getItemId(processedItem)"
                        [style]="getItemProp(processedItem, 'style')"
                        [class]="cn(cx('separator'), getItemProp(processedItem, 'class'), getItemProp(processedItem, 'styleClass'))"
                        role="separator"
                        [pBind]="_ptm('separator')"
                    ></li>
                    <li
                        #listItem
                        *ngIf="isItemVisible(processedItem) && !getItemProp(processedItem, 'separator')"
                        role="menuitem"
                        [attr.id]="getItemId(processedItem)"
                        [attr.data-p-highlight]="isItemActive(processedItem)"
                        [attr.data-p-focused]="isItemFocused(processedItem)"
                        [attr.data-p-disabled]="isItemDisabled(processedItem)"
                        [attr.aria-label]="getItemLabel(processedItem)"
                        [attr.aria-disabled]="isItemDisabled(processedItem) || undefined"
                        [attr.aria-haspopup]="isItemGroup(processedItem) && !getItemProp(processedItem, 'to') ? 'menu' : undefined"
                        [attr.aria-expanded]="isItemGroup(processedItem) ? isItemActive(processedItem) : undefined"
                        [attr.aria-setsize]="getAriaSetSize()"
                        [attr.aria-posinset]="getAriaPosInset(index)"
                        [ngStyle]="getItemProp(processedItem, 'style')"
                        [class]="cn(cx('item', { processedItem }), getItemProp(processedItem, 'styleClass'))"
                        [pBind]="getPTOptions(processedItem, index, 'item')"
                        pTooltip
                        [tooltipOptions]="getItemProp(processedItem, 'tooltipOptions')"
                        [pTooltipUnstyled]="unstyled()"
                    >
                        <div [class]="cx('itemContent')" [pBind]="getPTOptions(processedItem, index, 'itemContent')" (click)="onItemClick($event, processedItem)" (mouseenter)="onItemMouseEnter({ $event, processedItem })">
                            <ng-container *ngIf="!itemTemplate">
                                <a
                                    *ngIf="!getItemProp(processedItem, 'routerLink')"
                                    [attr.href]="getItemProp(processedItem, 'url')"
                                    [attr.data-automationid]="getItemProp(processedItem, 'automationId')"
                                    [attr.title]="getItemProp(processedItem, 'title')"
                                    [target]="getItemProp(processedItem, 'target')"
                                    [class]="cn(cx('itemLink'), getItemProp(processedItem, 'linkClass'))"
                                    [ngStyle]="getItemProp(processedItem, 'linkStyle')"
                                    [attr.tabindex]="-1"
                                    [pBind]="getPTOptions(processedItem, index, 'itemLink')"
                                    pRipple
                                >
                                    <span
                                        *ngIf="getItemProp(processedItem, 'icon')"
                                        [class]="cn(cx('itemIcon'), getItemProp(processedItem, 'icon'), getItemProp(processedItem, 'iconClass'))"
                                        [ngStyle]="getItemProp(processedItem, 'iconStyle')"
                                        [pBind]="getPTOptions(processedItem, index, 'itemIcon')"
                                        [attr.tabindex]="-1"
                                    >
                                    </span>
                                    <span
                                        *ngIf="getItemProp(processedItem, 'escape'); else htmlLabel"
                                        [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                        [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                        [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                    >
                                        {{ getItemLabel(processedItem) }}
                                    </span>
                                    <ng-template #htmlLabel>
                                        <span
                                            [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                            [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                            [innerHTML]="getItemLabel(processedItem)"
                                            [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                        ></span>
                                    </ng-template>
                                    <span *ngIf="getItemProp(processedItem, 'badge')" [class]="cn(cx('itemBadge'), getItemProp(processedItem, 'badgeStyleClass'))">{{ getItemProp(processedItem, 'badge') }}</span>

                                    <ng-container *ngIf="isItemGroup(processedItem)">
                                        <svg
                                            data-p-icon="angle-right"
                                            *ngIf="!tieredMenu.submenuIconTemplate && !tieredMenu._submenuIconTemplate"
                                            [class]="cx('submenuIcon')"
                                            [pBind]="getPTOptions(processedItem, index, 'submenuIcon')"
                                            [attr.aria-hidden]="true"
                                        />
                                        <ng-template *ngTemplateOutlet="tieredMenu.submenuIconTemplate || tieredMenu._submenuIconTemplate" [attr.aria-hidden]="true"></ng-template>
                                    </ng-container>
                                </a>
                                <a
                                    *ngIf="getItemProp(processedItem, 'routerLink')"
                                    [routerLink]="getItemProp(processedItem, 'routerLink')"
                                    [attr.data-automationid]="getItemProp(processedItem, 'automationId')"
                                    [attr.title]="getItemProp(processedItem, 'title')"
                                    [attr.tabindex]="-1"
                                    [queryParams]="getItemProp(processedItem, 'queryParams')"
                                    [routerLinkActive]="'p-tieredmenu-item-link-active'"
                                    [routerLinkActiveOptions]="getItemProp(processedItem, 'routerLinkActiveOptions') || { exact: false }"
                                    [target]="getItemProp(processedItem, 'target')"
                                    [class]="cn(cx('itemLink'), getItemProp(processedItem, 'linkClass'))"
                                    [ngStyle]="getItemProp(processedItem, 'linkStyle')"
                                    [fragment]="getItemProp(processedItem, 'fragment')"
                                    [queryParamsHandling]="getItemProp(processedItem, 'queryParamsHandling')"
                                    [preserveFragment]="getItemProp(processedItem, 'preserveFragment')"
                                    [skipLocationChange]="getItemProp(processedItem, 'skipLocationChange')"
                                    [replaceUrl]="getItemProp(processedItem, 'replaceUrl')"
                                    [state]="getItemProp(processedItem, 'state')"
                                    [pBind]="getPTOptions(processedItem, index, 'itemLink')"
                                    pRipple
                                >
                                    <span
                                        *ngIf="getItemProp(processedItem, 'icon')"
                                        [class]="cn(cx('itemIcon'), getItemProp(processedItem, 'icon'), getItemProp(processedItem, 'iconClass'))"
                                        [ngStyle]="getItemProp(processedItem, 'iconStyle')"
                                        [pBind]="getPTOptions(processedItem, index, 'itemIcon')"
                                        [attr.aria-hidden]="true"
                                        [attr.tabindex]="-1"
                                    >
                                    </span>
                                    <span
                                        *ngIf="getItemProp(processedItem, 'escape'); else htmlLabel"
                                        [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                        [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                        [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                    >
                                        {{ getItemLabel(processedItem) }}
                                    </span>
                                    <ng-template #htmlLabel>
                                        <span
                                            [class]="cn(cx('itemLabel'), getItemProp(processedItem, 'labelClass'))"
                                            [ngStyle]="getItemProp(processedItem, 'labelStyle')"
                                            [innerHTML]="getItemLabel(processedItem)"
                                            [pBind]="getPTOptions(processedItem, index, 'itemLabel')"
                                        ></span>
                                    </ng-template>
                                    <span *ngIf="getItemProp(processedItem, 'badge')" [class]="cn(cx('itemBadge'), getItemProp(processedItem, 'badgeStyleClass'))">{{ getItemProp(processedItem, 'badge') }}</span>

                                    <ng-container *ngIf="isItemGroup(processedItem)">
                                        <svg
                                            data-p-icon="angle-right"
                                            *ngIf="!tieredMenu.submenuIconTemplate && !tieredMenu._submenuIconTemplate"
                                            [class]="cx('submenuIcon')"
                                            [pBind]="getPTOptions(processedItem, index, 'submenuIcon')"
                                            [attr.aria-hidden]="true"
                                        />
                                        <ng-template *ngTemplateOutlet="tieredMenu.submenuIconTemplate || tieredMenu._submenuIconTemplate" [attr.aria-hidden]="true"></ng-template>
                                    </ng-container>
                                </a>
                            </ng-container>
                            <ng-container *ngIf="itemTemplate">
                                <ng-template *ngTemplateOutlet="itemTemplate; context: { $implicit: processedItem.item, hasSubmenu: getItemProp(processedItem, 'items') }"></ng-template>
                            </ng-container>
                        </div>

                        <p-tieredmenusub
                            *ngIf="isItemVisible(processedItem) && isItemGroup(processedItem)"
                            [items]="processedItem.items"
                            [itemTemplate]="itemTemplate"
                            [autoDisplay]="autoDisplay"
                            [menuId]="menuId"
                            [visible]="isItemActive(processedItem) && isItemGroup(processedItem)"
                            [activeItemPath]="activeItemPath()"
                            [focusedItemId]="focusedItemId"
                            [ariaLabelledBy]="getItemId(processedItem)"
                            [level]="level + 1"
                            (itemClick)="itemClick.emit($event)"
                            (itemMouseEnter)="onItemMouseEnter($event)"
                            [pt]="pt()"
                            [motionOptions]="motionOptions"
                            [unstyled]="unstyled()"
                        ></p-tieredmenusub>
                    </li>
                </ng-template>
            </ul>
        }
    `,
      encapsulation: ViewEncapsulation.None,
      providers: [{
        provide: TIEREDMENUSUB_INSTANCE,
        useExisting: forwardRef(() => TieredMenuSub)
      }, {
        provide: PARENT_INSTANCE,
        useExisting: forwardRef(() => TieredMenuSub)
      }],
      hostDirectives: [Bind]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: TieredMenu,
    decorators: [{
      type: Inject,
      args: [forwardRef(() => TieredMenu)]
    }]
  }], {
    visible: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    root: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    autoDisplay: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    autoZIndex: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    baseZIndex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    popup: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    menuId: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    level: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    focusedItemId: [{
      type: Input
    }],
    activeItemPath: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "activeItemPath",
        required: false
      }]
    }],
    motionOptions: [{
      type: Input
    }],
    tabindex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    inlineStyles: [{
      type: Input
    }],
    itemClick: [{
      type: Output
    }],
    itemMouseEnter: [{
      type: Output
    }],
    menuFocus: [{
      type: Output
    }],
    menuBlur: [{
      type: Output
    }],
    menuKeydown: [{
      type: Output
    }],
    sublistViewChild: [{
      type: ViewChild,
      args: ["sublist"]
    }]
  });
})();
var TieredMenu = class _TieredMenu extends BaseComponent {
  overlayService;
  /**
   * An array of menuitems.
   * @group Props
   */
  set model(value) {
    this._model = value;
    this._processedItems = this.createProcessedItems(this._model || []);
  }
  get model() {
    return this._model;
  }
  /**
   * Defines if menu would displayed as a popup.
   * @group Props
   */
  popup;
  /**
   * Inline style of the component.
   * @group Props
   */
  style;
  /**
   * Style class of the component.
   * @group Props
   */
  styleClass;
  /**
   * The breakpoint to define the maximum width boundary.
   * @group Props
   */
  breakpoint = "960px";
  /**
   * Whether to automatically manage layering.
   * @group Props
   */
  autoZIndex = true;
  /**
   * Base zIndex value to use in layering.
   * @group Props
   */
  baseZIndex = 0;
  /**
   * Whether to show a root submenu on mouse over.
   * @defaultValue true
   * @group Props
   */
  autoDisplay = true;
  /**
   * Transition options of the show animation.
   * @group Props
   * @deprecated since v21.0.0, use `motionOptions` instead.
   */
  showTransitionOptions = ".12s cubic-bezier(0, 0, 0.2, 1)";
  /**
   * Transition options of the hide animation.
   * @group Props
   * @deprecated since v21.0.0, use `motionOptions` instead.
   */
  hideTransitionOptions = ".1s linear";
  /**
   * Current id state as a string.
   * @group Props
   */
  id;
  /**
   * Defines a string value that labels an interactive element.
   * @group Props
   */
  ariaLabel;
  /**
   * Identifier of the underlying input element.
   * @group Props
   */
  ariaLabelledBy;
  /**
   * When present, it specifies that the component should be disabled.
   * @group Props
   */
  disabled = false;
  /**
   * Index of the element in tabbing order.
   * @group Props
   */
  tabindex = 0;
  /**
   * Target element to attach the overlay, valid values are "body" or a local ng-template variable of another element (note: use binding with brackets for template variables, e.g. [appendTo]="mydiv" for a div element having #mydiv as variable name).
   * @defaultValue 'self'
   * @group Props
   */
  appendTo = input(void 0, ...ngDevMode ? [{
    debugName: "appendTo"
  }] : []);
  /**
   * The motion options.
   * @group Props
   */
  motionOptions = input(void 0, ...ngDevMode ? [{
    debugName: "motionOptions"
  }] : []);
  computedMotionOptions = computed(() => {
    return __spreadValues(__spreadValues({}, this.ptm("motion")), this.motionOptions());
  }, ...ngDevMode ? [{
    debugName: "computedMotionOptions"
  }] : []);
  /**
   * Callback to invoke when overlay menu is shown.
   * @group Emits
   */
  onShow = new EventEmitter();
  /**
   * Callback to invoke when overlay menu is hidden.
   * @group Emits
   */
  onHide = new EventEmitter();
  rootmenu;
  containerViewChild;
  /**
   * Custom submenu icon template.
   * @group Templates
   */
  submenuIconTemplate;
  /**
   * Custom item template.
   * @param {TieredMenuItemTemplateContext} context - item context.
   * @see {@link TieredMenuItemTemplateContext}
   * @group Templates
   */
  itemTemplate;
  templates;
  $appendTo = computed(() => this.appendTo() || this.config.overlayAppendTo(), ...ngDevMode ? [{
    debugName: "$appendTo"
  }] : []);
  render = signal(false, ...ngDevMode ? [{
    debugName: "render"
  }] : []);
  container;
  outsideClickListener;
  resizeListener;
  scrollHandler;
  target;
  relatedTarget;
  visible;
  dirty = false;
  focused = false;
  activeItemPath = signal([], ...ngDevMode ? [{
    debugName: "activeItemPath"
  }] : []);
  number = signal(0, ...ngDevMode ? [{
    debugName: "number"
  }] : []);
  focusedItemInfo = signal({
    index: -1,
    level: 0,
    parentKey: "",
    item: null
  }, ...ngDevMode ? [{
    debugName: "focusedItemInfo"
  }] : []);
  searchValue = "";
  searchTimeout;
  _processedItems;
  _model;
  _componentStyle = inject(TieredMenuStyle);
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  matchMediaListener;
  query;
  queryMatches = signal(false, ...ngDevMode ? [{
    debugName: "queryMatches"
  }] : []);
  _submenuIconTemplate;
  _itemTemplate;
  get visibleItems() {
    const processedItem = this.activeItemPath().find((p2) => p2.key === this.focusedItemInfo().parentKey);
    return processedItem ? processedItem.items : this.processedItems;
  }
  get processedItems() {
    if (!this._processedItems || !this._processedItems.length) {
      this._processedItems = this.createProcessedItems(this.model || []);
    }
    return this._processedItems;
  }
  get focusedItemId() {
    const focusedItemInfo = this.focusedItemInfo();
    return focusedItemInfo.item?.id ? focusedItemInfo.item.id : focusedItemInfo.index !== -1 ? `${this.id}${s(focusedItemInfo.parentKey) ? "_" + focusedItemInfo.parentKey : ""}_${focusedItemInfo.index}` : null;
  }
  constructor(overlayService) {
    super();
    this.overlayService = overlayService;
    effect(() => {
      const path = this.activeItemPath();
      if (s(path)) {
        this.bindOutsideClickListener();
        this.bindResizeListener();
      } else {
        this.unbindOutsideClickListener();
        this.unbindResizeListener();
      }
    });
  }
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  onInit() {
    this.bindMatchMediaListener();
    this.id = this.id || s2("pn_id_");
  }
  onAfterContentInit() {
    this.templates?.forEach((item) => {
      switch (item.getType()) {
        case "submenuicon":
          this._submenuIconTemplate = item.template;
          break;
        case "item":
          this._itemTemplate = item.template;
          break;
        default:
          this._itemTemplate = item.template;
          break;
      }
    });
  }
  bindMatchMediaListener() {
    if (isPlatformBrowser(this.platformId)) {
      if (!this.matchMediaListener) {
        const query = window.matchMedia(`(max-width: ${this.breakpoint})`);
        this.query = query;
        this.queryMatches.set(query.matches);
        this.matchMediaListener = () => {
          this.queryMatches.set(query.matches);
        };
        query.addEventListener("change", this.matchMediaListener);
      }
    }
  }
  unbindMatchMediaListener() {
    if (this.matchMediaListener) {
      this.query.removeEventListener("change", this.matchMediaListener);
      this.matchMediaListener = null;
    }
  }
  createProcessedItems(items, level = 0, parent = {}, parentKey = "") {
    const processedItems = [];
    items && items.forEach((item, index) => {
      const key = (parentKey !== "" ? parentKey + "_" : "") + index;
      const newItem = {
        item,
        index,
        level,
        key,
        parent,
        parentKey
      };
      newItem["items"] = this.createProcessedItems(item.items, level + 1, newItem, key);
      processedItems.push(newItem);
    });
    return processedItems;
  }
  getItemProp(item, name) {
    return item ? m(item[name]) : void 0;
  }
  getProccessedItemLabel(processedItem) {
    return processedItem ? this.getItemLabel(processedItem.item) : void 0;
  }
  getItemLabel(item) {
    return this.getItemProp(item, "label");
  }
  isProcessedItemGroup(processedItem) {
    return processedItem && s(processedItem.items);
  }
  isSelected(processedItem) {
    return this.activeItemPath().some((p2) => p2.key === processedItem.key);
  }
  isValidSelectedItem(processedItem) {
    return this.isValidItem(processedItem) && this.isSelected(processedItem);
  }
  isValidItem(processedItem) {
    return !!processedItem && !this.isItemDisabled(processedItem.item) && !this.isItemSeparator(processedItem.item) && this.isItemVisible(processedItem.item);
  }
  isItemDisabled(item) {
    return this.getItemProp(item, "disabled");
  }
  isItemVisible(item) {
    return this.getItemProp(item, "visible") !== false;
  }
  isItemSeparator(item) {
    return this.getItemProp(item, "separator");
  }
  isItemMatched(processedItem) {
    return this.isValidItem(processedItem) && this.getProccessedItemLabel(processedItem).toLocaleLowerCase().startsWith(this.searchValue.toLocaleLowerCase());
  }
  isProccessedItemGroup(processedItem) {
    return processedItem && s(processedItem.items);
  }
  onOverlayClick(event) {
    if (this.popup) {
      this.overlayService.add({
        originalEvent: event,
        target: this.el.nativeElement
      });
    }
  }
  onItemClick(event) {
    const {
      originalEvent,
      processedItem
    } = event;
    const grouped = this.isProcessedItemGroup(processedItem);
    const root = l(processedItem.parent);
    const selected = this.isSelected(processedItem);
    if (selected) {
      const {
        index,
        key,
        level,
        parentKey,
        item
      } = processedItem;
      this.activeItemPath.set(this.activeItemPath().filter((p2) => key !== p2.key && key.startsWith(p2.key)));
      this.focusedItemInfo.set({
        index,
        level,
        parentKey,
        item
      });
      this.dirty = true;
      bt(this.rootmenu?.sublistViewChild?.nativeElement);
    } else {
      if (grouped) {
        this.onItemChange(event);
      } else {
        const rootProcessedItem = root ? processedItem : this.activeItemPath().find((p2) => p2.parentKey === "");
        this.hide(originalEvent);
        this.changeFocusedItemIndex(originalEvent, rootProcessedItem?.index ?? -1);
        bt(this.rootmenu?.sublistViewChild?.nativeElement);
      }
    }
  }
  onItemMouseEnter(event) {
    if (!Yt()) {
      if (this.dirty) {
        this.onItemChange(event, "hover");
      }
    } else {
      this.onItemChange({
        event,
        processedItem: event.processedItem,
        focus: this.autoDisplay
      }, "hover");
    }
  }
  onKeyDown(event) {
    const metaKey = event.metaKey || event.ctrlKey;
    switch (event.code) {
      case "ArrowDown":
        this.onArrowDownKey(event);
        break;
      case "ArrowUp":
        this.onArrowUpKey(event);
        break;
      case "ArrowLeft":
        this.onArrowLeftKey(event);
        break;
      case "ArrowRight":
        this.onArrowRightKey(event);
        break;
      case "Home":
        this.onHomeKey(event);
        break;
      case "End":
        this.onEndKey(event);
        break;
      case "Space":
        this.onSpaceKey(event);
        break;
      case "Enter":
        this.onEnterKey(event);
        break;
      case "Escape":
        this.onEscapeKey(event);
        break;
      case "Tab":
        this.onTabKey(event);
        break;
      case "PageDown":
      case "PageUp":
      case "Backspace":
      case "ShiftLeft":
      case "ShiftRight":
        break;
      default:
        if (!metaKey && J(event.key)) {
          this.searchItems(event, event.key);
        }
        break;
    }
  }
  onArrowDownKey(event) {
    const itemIndex = this.focusedItemInfo().index !== -1 ? this.findNextItemIndex(this.focusedItemInfo().index) : this.findFirstFocusedItemIndex();
    this.changeFocusedItemIndex(event, itemIndex);
    event.preventDefault();
  }
  onArrowRightKey(event) {
    const processedItem = this.visibleItems[this.focusedItemInfo().index];
    const grouped = this.isProccessedItemGroup(processedItem);
    const item = processedItem?.item;
    if (grouped) {
      this.onItemChange({
        originalEvent: event,
        processedItem
      });
      this.focusedItemInfo.set({
        index: -1,
        parentKey: processedItem.key,
        item
      });
      this.searchValue = "";
      this.onArrowDownKey(event);
    }
    event.preventDefault();
  }
  onArrowUpKey(event) {
    if (event.altKey) {
      if (this.focusedItemInfo().index !== -1) {
        const processedItem = this.visibleItems[this.focusedItemInfo().index];
        const grouped = this.isProccessedItemGroup(processedItem);
        !grouped && this.onItemChange({
          originalEvent: event,
          processedItem
        });
      }
      this.popup && this.hide(event, true);
      event.preventDefault();
    } else {
      const itemIndex = this.focusedItemInfo().index !== -1 ? this.findPrevItemIndex(this.focusedItemInfo().index) : this.findLastFocusedItemIndex();
      this.changeFocusedItemIndex(event, itemIndex);
      event.preventDefault();
    }
  }
  onArrowLeftKey(event) {
    const processedItem = this.visibleItems[this.focusedItemInfo().index];
    if (!processedItem) {
      event.preventDefault();
      return;
    }
    const parentItem = this.activeItemPath().find((p2) => p2.key === processedItem.parentKey);
    const root = l(processedItem.parent);
    if (!root) {
      this.focusedItemInfo.set({
        index: -1,
        parentKey: parentItem ? parentItem.parentKey : "",
        item: processedItem.item
      });
      this.searchValue = "";
      this.onArrowDownKey(event);
    }
    const activeItemPath = this.activeItemPath().filter((p2) => p2.parentKey !== this.focusedItemInfo().parentKey);
    this.activeItemPath.set(activeItemPath);
    event.preventDefault();
  }
  onHomeKey(event) {
    this.changeFocusedItemIndex(event, this.findFirstItemIndex());
    event.preventDefault();
  }
  onEndKey(event) {
    this.changeFocusedItemIndex(event, this.findLastItemIndex());
    event.preventDefault();
  }
  onSpaceKey(event) {
    this.onEnterKey(event);
  }
  onEscapeKey(event) {
    this.hide(event, true);
    this.focusedItemInfo().index = this.findFirstFocusedItemIndex();
    event.preventDefault();
  }
  onTabKey(event) {
    if (this.focusedItemInfo().index !== -1) {
      const processedItem = this.visibleItems[this.focusedItemInfo().index];
      const grouped = this.isProccessedItemGroup(processedItem);
      !grouped && this.onItemChange({
        originalEvent: event,
        processedItem
      });
    }
    this.hide();
  }
  onEnterKey(event) {
    if (this.focusedItemInfo().index !== -1) {
      const element = z(this.rootmenu?.el?.nativeElement, `li[id="${`${this.focusedItemId}`}"]`);
      const anchorElement = element && (z(element, '[data-pc-section="itemlink"]') || z(element, "a,button"));
      anchorElement ? anchorElement.click() : element && element.click();
      if (!this.popup) {
        const processedItem = this.visibleItems[this.focusedItemInfo().index];
        const grouped = this.isProccessedItemGroup(processedItem);
        !grouped && (this.focusedItemInfo().index = this.findFirstFocusedItemIndex());
      }
    }
    event.preventDefault();
  }
  onItemChange(event, type) {
    const {
      processedItem,
      isFocus
    } = event;
    if (l(processedItem)) return;
    const {
      index,
      key,
      level,
      parentKey,
      items,
      item
    } = processedItem;
    const grouped = s(items);
    const activeItemPath = this.activeItemPath().filter((p2) => p2.parentKey !== parentKey && p2.parentKey !== key);
    grouped && activeItemPath.push(processedItem);
    this.focusedItemInfo.set({
      index,
      level,
      parentKey,
      item
    });
    grouped && (this.dirty = true);
    isFocus && bt(this.rootmenu?.sublistViewChild?.nativeElement);
    if (type === "hover" && this.queryMatches()) {
      return;
    }
    this.activeItemPath.set(activeItemPath);
  }
  onMenuFocus(event) {
    this.focused = true;
    if (this.focusedItemInfo().index === -1 && !this.popup) {
    }
  }
  onMenuBlur(event) {
    this.focused = false;
    this.focusedItemInfo.set({
      index: -1,
      level: 0,
      parentKey: "",
      item: null
    });
    this.searchValue = "";
    this.dirty = false;
  }
  onOverlayBeforeEnter(event) {
    if (this.popup) {
      this.container = event.element;
      S(this.container, {
        position: "absolute"
      });
      this.moveOnTop();
      this.onShow.emit({});
      this.$attrSelector && this.container?.setAttribute(this.$attrSelector, "");
      this.appendOverlay();
      this.alignOverlay();
    }
  }
  onOverlayAfterEnter() {
    if (this.popup) {
      this.bindOutsideClickListener();
      this.bindResizeListener();
      this.bindScrollListener();
      this.scrollInView();
    }
    bt(this.rootmenu?.sublistViewChild?.nativeElement);
  }
  onOverlayAfterLeave() {
    this.restoreOverlayAppend();
    this.onOverlayHide();
    this.render.set(false);
    this.onHide.emit({});
  }
  relativeAlign = false;
  alignOverlay() {
    if (this.container && this.target) {
      if (this.relativeAlign) I(this.container, this.target);
      else D(this.container, this.target);
      const targetWidth = v(this.target);
      if (targetWidth > v(this.container)) {
        this.container.style.minWidth = v(this.target) + "px";
      }
    }
  }
  appendOverlay() {
    if (this.$appendTo() && this.$appendTo() !== "self") {
      if (this.$appendTo() === "body") {
        ut(this.document.body, this.container);
      } else {
        ut(this.$appendTo(), this.container);
      }
    }
  }
  restoreOverlayAppend() {
    if (this.container && this.$appendTo() !== "self") {
      ut(this.el.nativeElement, this.container);
    }
  }
  moveOnTop() {
    if (this.autoZIndex) {
      zindexutils.set("menu", this.container, this.baseZIndex + this.config.zIndex.menu);
    }
  }
  /**
   * Hides the popup menu.
   * @group Method
   */
  hide(event, isFocus) {
    if (this.popup) {
      this.onHide.emit({});
      this.visible = false;
    }
    this.activeItemPath.set([]);
    this.focusedItemInfo.set({
      index: -1,
      level: 0,
      parentKey: ""
    });
    isFocus && bt(this.relatedTarget || this.target || this.rootmenu?.sublistViewChild?.nativeElement);
    this.dirty = false;
  }
  /**
   * Toggles the visibility of the popup menu.
   * @param {Event} event - Browser event.
   * @group Method
   */
  toggle(event) {
    this.visible ? this.hide(event, true) : this.show(event);
  }
  /**
   * Displays the popup menu.
   * @param {Event} even - Browser event.
   * @group Method
   */
  show(event, isFocus) {
    if (this.popup) {
      this.visible = true;
      this.target = this.target || event.currentTarget;
      this.relatedTarget = event.relatedTarget || null;
      this.relativeAlign = event?.relativeAlign || null;
    }
    this.render.set(true);
    this.focusedItemInfo.set({
      index: -1,
      level: 0,
      parentKey: ""
    });
    isFocus && bt(this.rootmenu?.sublistViewChild?.nativeElement);
    this.cd.markForCheck();
  }
  searchItems(event, char) {
    this.searchValue = (this.searchValue || "") + char;
    let itemIndex = -1;
    let matched = false;
    if (this.focusedItemInfo().index !== -1) {
      itemIndex = this.visibleItems.slice(this.focusedItemInfo().index).findIndex((processedItem) => this.isItemMatched(processedItem));
      itemIndex = itemIndex === -1 ? this.visibleItems.slice(0, this.focusedItemInfo().index).findIndex((processedItem) => this.isItemMatched(processedItem)) : itemIndex + this.focusedItemInfo().index;
    } else {
      itemIndex = this.visibleItems.findIndex((processedItem) => this.isItemMatched(processedItem));
    }
    if (itemIndex !== -1) {
      matched = true;
    }
    if (itemIndex === -1 && this.focusedItemInfo().index === -1) {
      itemIndex = this.findFirstFocusedItemIndex();
    }
    if (itemIndex !== -1) {
      this.changeFocusedItemIndex(event, itemIndex);
    }
    if (this.searchTimeout) {
      clearTimeout(this.searchTimeout);
    }
    this.searchTimeout = setTimeout(() => {
      this.searchValue = "";
      this.searchTimeout = null;
    }, 500);
    return matched;
  }
  findLastFocusedItemIndex() {
    const selectedIndex = this.findSelectedItemIndex();
    return selectedIndex < 0 ? this.findLastItemIndex() : selectedIndex;
  }
  findLastItemIndex() {
    return M(this.visibleItems, (processedItem) => this.isValidItem(processedItem));
  }
  findPrevItemIndex(index) {
    const matchedItemIndex = index > 0 ? M(this.visibleItems.slice(0, index), (processedItem) => this.isValidItem(processedItem)) : -1;
    return matchedItemIndex > -1 ? matchedItemIndex : index;
  }
  findNextItemIndex(index) {
    const matchedItemIndex = index < this.visibleItems.length - 1 ? this.visibleItems.slice(index + 1).findIndex((processedItem) => this.isValidItem(processedItem)) : -1;
    return matchedItemIndex > -1 ? matchedItemIndex + index + 1 : index;
  }
  findFirstFocusedItemIndex() {
    const selectedIndex = this.findSelectedItemIndex();
    return selectedIndex < 0 ? this.findFirstItemIndex() : selectedIndex;
  }
  findFirstItemIndex() {
    return this.visibleItems.findIndex((processedItem) => this.isValidItem(processedItem));
  }
  findSelectedItemIndex() {
    return this.visibleItems.findIndex((processedItem) => this.isValidSelectedItem(processedItem));
  }
  changeFocusedItemIndex(event, index) {
    if (this.focusedItemInfo().index !== index) {
      const focusedItemInfo = this.focusedItemInfo();
      this.focusedItemInfo.set(__spreadProps(__spreadValues({}, focusedItemInfo), {
        item: this.visibleItems[index].item,
        index
      }));
      this.scrollInView();
    }
  }
  scrollInView(index = -1) {
    const id = index !== -1 ? `${this.id}_${index}` : this.focusedItemId;
    const element = z(this.rootmenu?.el?.nativeElement, `li[id="${id}"]`);
    if (element) {
      element.scrollIntoView && element.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  }
  bindScrollListener() {
    if (!this.scrollHandler) {
      this.scrollHandler = new ConnectedOverlayScrollHandler(this.target, (event) => {
        if (this.visible) {
          this.hide(event, true);
        }
      });
    }
    this.scrollHandler.bindScrollListener();
  }
  unbindScrollListener() {
    if (this.scrollHandler) {
      this.scrollHandler.unbindScrollListener();
      this.scrollHandler = null;
    }
  }
  bindResizeListener() {
    if (isPlatformBrowser(this.platformId)) {
      if (!this.resizeListener) {
        this.resizeListener = this.renderer.listen(this.document.defaultView, "resize", (event) => {
          if (!Yt()) {
            this.hide(event, true);
          }
        });
      }
    }
  }
  bindOutsideClickListener() {
    if (isPlatformBrowser(this.platformId)) {
      if (!this.outsideClickListener) {
        this.outsideClickListener = this.renderer.listen(this.document, "click", (event) => {
          const isOutsideContainer = this.containerViewChild && !this.containerViewChild.nativeElement.contains(event.target);
          const isOutsideTarget = this.popup ? !(this.target && (this.target === event.target || this.target.contains(event.target))) : true;
          if (isOutsideContainer && isOutsideTarget) {
            this.hide();
          }
        });
      }
    }
  }
  unbindOutsideClickListener() {
    if (this.outsideClickListener) {
      document.removeEventListener("click", this.outsideClickListener);
      this.outsideClickListener = null;
    }
  }
  unbindResizeListener() {
    if (this.resizeListener) {
      this.resizeListener();
      this.resizeListener = null;
    }
  }
  onOverlayHide() {
    this.unbindOutsideClickListener();
    this.unbindResizeListener();
    this.unbindScrollListener();
    if (!this.cd.destroyed) {
      this.target = null;
    }
    if (this.container && this.autoZIndex) {
      zindexutils.clear(this.container);
    }
  }
  onDestroy() {
    if (this.popup) {
      if (this.scrollHandler) {
        this.scrollHandler.destroy();
        this.scrollHandler = null;
      }
      this.restoreOverlayAppend();
      this.onOverlayHide();
    }
    this.unbindMatchMediaListener();
  }
  static \u0275fac = function TieredMenu_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TieredMenu)(\u0275\u0275directiveInject(OverlayService));
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _TieredMenu,
    selectors: [["p-tieredMenu"], ["p-tieredmenu"], ["p-tiered-menu"]],
    contentQueries: function TieredMenu_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c48, 4);
        \u0275\u0275contentQuery(dirIndex, _c58, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.submenuIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.itemTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function TieredMenu_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c67, 5);
        \u0275\u0275viewQuery(_c77, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.rootmenu = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.containerViewChild = _t.first);
      }
    },
    inputs: {
      model: "model",
      popup: [2, "popup", "popup", booleanAttribute],
      style: "style",
      styleClass: "styleClass",
      breakpoint: "breakpoint",
      autoZIndex: [2, "autoZIndex", "autoZIndex", booleanAttribute],
      baseZIndex: [2, "baseZIndex", "baseZIndex", numberAttribute],
      autoDisplay: [2, "autoDisplay", "autoDisplay", booleanAttribute],
      showTransitionOptions: "showTransitionOptions",
      hideTransitionOptions: "hideTransitionOptions",
      id: "id",
      ariaLabel: "ariaLabel",
      ariaLabelledBy: "ariaLabelledBy",
      disabled: [2, "disabled", "disabled", booleanAttribute],
      tabindex: [2, "tabindex", "tabindex", numberAttribute],
      appendTo: [1, "appendTo"],
      motionOptions: [1, "motionOptions"]
    },
    outputs: {
      onShow: "onShow",
      onHide: "onHide"
    },
    features: [\u0275\u0275ProvidersFeature([TieredMenuStyle, {
      provide: TIEREDMENU_INSTANCE,
      useExisting: _TieredMenu
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _TieredMenu
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["container", ""], ["rootmenu", ""], [3, "id", "class", "ngStyle", "pBind", "pMotion", "pMotionName", "pMotionAppear", "pMotionDisabled", "pMotionOptions"], [3, "click", "pMotionOnBeforeEnter", "pMotionOnAfterEnter", "pMotionOnAfterLeave", "id", "ngStyle", "pBind", "pMotion", "pMotionName", "pMotionAppear", "pMotionDisabled", "pMotionOptions"], [3, "itemClick", "menuFocus", "menuBlur", "menuKeydown", "itemMouseEnter", "root", "visible", "items", "itemTemplate", "menuId", "tabindex", "ariaLabel", "ariaLabelledBy", "baseZIndex", "autoZIndex", "autoDisplay", "popup", "focusedItemId", "activeItemPath", "pt", "unstyled", "motionOptions"]],
    template: function TieredMenu_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275conditionalCreate(0, TieredMenu_Conditional_0_Template, 4, 27, "div", 2);
      }
      if (rf & 2) {
        \u0275\u0275conditional(ctx.render() || !ctx.popup ? 0 : -1);
      }
    },
    dependencies: [CommonModule, NgStyle, TieredMenuSub, RouterModule, TooltipModule, Bind, SharedModule, BindModule, MotionModule, MotionDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TieredMenu, [{
    type: Component,
    args: [{
      selector: "p-tieredMenu, p-tieredmenu, p-tiered-menu",
      standalone: true,
      imports: [CommonModule, TieredMenuSub, RouterModule, TooltipModule, SharedModule, BindModule, MotionModule],
      template: `
        @if (render() || !popup) {
            <div
                #container
                [id]="id"
                [class]="cn(cx('root'), styleClass)"
                [ngStyle]="style"
                [pBind]="ptm('root')"
                (click)="onOverlayClick($event)"
                [pMotion]="visible || !popup"
                [pMotionName]="'p-anchored-overlay'"
                [pMotionAppear]="true"
                [pMotionDisabled]="!popup"
                [pMotionOptions]="computedMotionOptions()"
                (pMotionOnBeforeEnter)="onOverlayBeforeEnter($event)"
                (pMotionOnAfterEnter)="onOverlayAfterEnter()"
                (pMotionOnAfterLeave)="onOverlayAfterLeave()"
            >
                <p-tieredMenuSub
                    #rootmenu
                    [root]="true"
                    [visible]="true"
                    [items]="processedItems"
                    [itemTemplate]="itemTemplate || _itemTemplate"
                    [menuId]="id"
                    [tabindex]="!disabled ? tabindex : -1"
                    [ariaLabel]="ariaLabel"
                    [ariaLabelledBy]="ariaLabelledBy"
                    [baseZIndex]="baseZIndex"
                    [autoZIndex]="autoZIndex"
                    [autoDisplay]="autoDisplay"
                    [popup]="popup"
                    [focusedItemId]="focused ? focusedItemId : undefined"
                    [activeItemPath]="activeItemPath()"
                    (itemClick)="onItemClick($event)"
                    (menuFocus)="onMenuFocus($event)"
                    (menuBlur)="onMenuBlur($event)"
                    (menuKeydown)="onKeyDown($event)"
                    (itemMouseEnter)="onItemMouseEnter($event)"
                    [pt]="pt()"
                    [unstyled]="unstyled()"
                    [motionOptions]="computedMotionOptions()"
                ></p-tieredMenuSub>
            </div>
        }
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [TieredMenuStyle, {
        provide: TIEREDMENU_INSTANCE,
        useExisting: TieredMenu
      }, {
        provide: PARENT_INSTANCE,
        useExisting: TieredMenu
      }],
      hostDirectives: [Bind]
    }]
  }], () => [{
    type: OverlayService
  }], {
    model: [{
      type: Input
    }],
    popup: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    style: [{
      type: Input
    }],
    styleClass: [{
      type: Input
    }],
    breakpoint: [{
      type: Input
    }],
    autoZIndex: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    baseZIndex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    autoDisplay: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    showTransitionOptions: [{
      type: Input
    }],
    hideTransitionOptions: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    tabindex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    appendTo: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "appendTo",
        required: false
      }]
    }],
    motionOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "motionOptions",
        required: false
      }]
    }],
    onShow: [{
      type: Output
    }],
    onHide: [{
      type: Output
    }],
    rootmenu: [{
      type: ViewChild,
      args: ["rootmenu"]
    }],
    containerViewChild: [{
      type: ViewChild,
      args: ["container"]
    }],
    submenuIconTemplate: [{
      type: ContentChild,
      args: ["submenuicon", {
        descendants: false
      }]
    }],
    itemTemplate: [{
      type: ContentChild,
      args: ["item", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }]
  });
})();
var TieredMenuModule = class _TieredMenuModule {
  static \u0275fac = function TieredMenuModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TieredMenuModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _TieredMenuModule,
    imports: [TieredMenu, SharedModule],
    exports: [TieredMenu, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [TieredMenu, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TieredMenuModule, [{
    type: NgModule,
    args: [{
      imports: [TieredMenu, SharedModule],
      exports: [TieredMenu, SharedModule]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/splitbutton/index.mjs
var style19 = "\n    .p-splitbutton {\n        display: inline-flex;\n        position: relative;\n        border-radius: dt('splitbutton.border.radius');\n    }\n\n    .p-splitbutton-button.p-button {\n        border-start-end-radius: 0;\n        border-end-end-radius: 0;\n        border-inline-end: 0 none;\n    }\n\n    .p-splitbutton-button.p-button:focus-visible,\n    .p-splitbutton-dropdown.p-button:focus-visible {\n        z-index: 1;\n    }\n\n    .p-splitbutton-button.p-button:not(:disabled):hover,\n    .p-splitbutton-button.p-button:not(:disabled):active {\n        border-inline-end: 0 none;\n    }\n\n    .p-splitbutton-dropdown.p-button {\n        border-start-start-radius: 0;\n        border-end-start-radius: 0;\n    }\n\n    .p-splitbutton .p-menu {\n        min-width: 100%;\n    }\n\n    .p-splitbutton-fluid {\n        display: flex;\n    }\n\n    .p-splitbutton-rounded .p-splitbutton-dropdown.p-button {\n        border-start-end-radius: dt('splitbutton.rounded.border.radius');\n        border-end-end-radius: dt('splitbutton.rounded.border.radius');\n    }\n\n    .p-splitbutton-rounded .p-splitbutton-button.p-button {\n        border-start-start-radius: dt('splitbutton.rounded.border.radius');\n        border-end-start-radius: dt('splitbutton.rounded.border.radius');\n    }\n\n    .p-splitbutton-raised {\n        box-shadow: dt('splitbutton.raised.shadow');\n    }\n";

// node_modules/primeng/fesm2022/primeng-splitbutton.mjs
var _c025 = ["content"];
var _c121 = ["dropdownicon"];
var _c217 = ["defaultbtn"];
var _c313 = ["menu"];
function SplitButton_ng_container_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function SplitButton_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275elementStart(1, "button", 8);
    \u0275\u0275listener("click", function SplitButton_ng_container_0_Template_button_click_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDefaultButtonClick($event));
    });
    \u0275\u0275template(2, SplitButton_ng_container_0_ng_container_2_Template, 1, 0, "ng-container", 9);
    \u0275\u0275elementEnd();
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r2.cx("pcButton"));
    \u0275\u0275property("severity", ctx_r2.severity)("text", ctx_r2.text)("outlined", ctx_r2.outlined)("size", ctx_r2.size)("icon", ctx_r2.icon)("iconPos", ctx_r2.iconPos)("disabled", ctx_r2.disabled)("pAutoFocus", ctx_r2.autofocus)("pTooltip", ctx_r2.tooltip)("pTooltipUnstyled", ctx_r2.unstyled())("tooltipOptions", ctx_r2.tooltipOptions)("pt", ctx_r2.ptm("pcButton"))("unstyled", ctx_r2.unstyled());
    \u0275\u0275attribute("tabindex", ctx_r2.tabindex)("aria-label", (ctx_r2.buttonProps == null ? null : ctx_r2.buttonProps["ariaLabel"]) || ctx_r2.label);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.contentTemplate || ctx_r2._contentTemplate);
  }
}
function SplitButton_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 10, 2);
    \u0275\u0275listener("click", function SplitButton_ng_template_1_Template_button_click_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDefaultButtonClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r2.cx("pcButton"));
    \u0275\u0275property("severity", ctx_r2.severity)("text", ctx_r2.text)("outlined", ctx_r2.outlined)("size", ctx_r2.size)("icon", ctx_r2.icon)("iconPos", ctx_r2.iconPos)("label", ctx_r2.label)("disabled", ctx_r2.buttonDisabled)("pAutoFocus", ctx_r2.autofocus)("pTooltip", ctx_r2.tooltip)("pTooltipUnstyled", ctx_r2.unstyled())("tooltipOptions", ctx_r2.tooltipOptions)("pt", ctx_r2.ptm("pcButton"))("unstyled", ctx_r2.unstyled());
    \u0275\u0275attribute("tabindex", ctx_r2.tabindex)("aria-label", ctx_r2.buttonProps == null ? null : ctx_r2.buttonProps["ariaLabel"]);
  }
}
function SplitButton_span_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span");
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(ctx_r2.dropdownIcon);
  }
}
function SplitButton_ng_container_5__svg_svg_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "svg", 12);
  }
}
function SplitButton_ng_container_5_2_ng_template_0_Template(rf, ctx) {
}
function SplitButton_ng_container_5_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SplitButton_ng_container_5_2_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function SplitButton_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0);
    \u0275\u0275template(1, SplitButton_ng_container_5__svg_svg_1_Template, 1, 0, "svg", 11)(2, SplitButton_ng_container_5_2_Template, 1, 0, null, 9);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngIf", !ctx_r2.dropdownIconTemplate && !ctx_r2._dropdownIconTemplate);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r2.dropdownIconTemplate || ctx_r2._dropdownIconTemplate);
  }
}
var classes14 = {
  root: ({
    instance
  }) => ["p-splitbutton p-component", {
    "p-splitbutton-raised": instance.raised,
    "p-splitbutton-rounded": instance.rounded,
    "p-splitbutton-outlined": instance.outlined,
    "p-splitbutton-text": instance.text,
    [`p-splitbutton-${instance.size === "small" ? "sm" : "lg"}`]: instance.size
  }],
  pcButton: "p-splitbutton-button",
  pcDropdown: "p-splitbutton-dropdown p-button-icon-only"
};
var SplitButtonStyle = class _SplitButtonStyle extends BaseStyle {
  name = "splitbutton";
  style = style19;
  classes = classes14;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275SplitButtonStyle_BaseFactory;
    return function SplitButtonStyle_Factory(__ngFactoryType__) {
      return (\u0275SplitButtonStyle_BaseFactory || (\u0275SplitButtonStyle_BaseFactory = \u0275\u0275getInheritedFactory(_SplitButtonStyle)))(__ngFactoryType__ || _SplitButtonStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _SplitButtonStyle,
    factory: _SplitButtonStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitButtonStyle, [{
    type: Injectable
  }], null, null);
})();
var SplitButtonClasses;
(function(SplitButtonClasses2) {
  SplitButtonClasses2["root"] = "p-splitbutton";
  SplitButtonClasses2["pcButton"] = "p-splitbutton-button";
  SplitButtonClasses2["pcDropdown"] = "p-splitbutton-dropdown";
})(SplitButtonClasses || (SplitButtonClasses = {}));
var SPLITBUTTON_INSTANCE = new InjectionToken("SPLITBUTTON_INSTANCE");
var SplitButton = class _SplitButton extends BaseComponent {
  $pcSplitButton = inject(SPLITBUTTON_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * MenuModel instance to define the overlay items.
   * @group Props
   */
  model;
  /**
   * Defines the style of the button.
   * @group Props
   */
  severity;
  /**
   * Add a shadow to indicate elevation.
   * @group Props
   */
  raised = false;
  /**
   * Add a circular border radius to the button.
   * @group Props
   */
  rounded = false;
  /**
   * Add a textual class to the button without a background initially.
   * @group Props
   */
  text = false;
  /**
   * Add a border class without a background initially.
   * @group Props
   */
  outlined = false;
  /**
   * Defines the size of the button.
   * @group Props
   */
  size = null;
  /**
   * Add a plain textual class to the button without a background initially.
   * @group Props
   */
  plain = false;
  /**
   * Name of the icon.
   * @group Props
   */
  icon;
  /**
   * Position of the icon.
   * @group Props
   */
  iconPos = "left";
  /**
   * Text of the button.
   * @group Props
   */
  label;
  /**
   * Tooltip for the main button.
   * @group Props
   */
  tooltip;
  /**
   * Tooltip options for the main button.
   * @group Props
   */
  tooltipOptions;
  /**
   * Class of the element.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Inline style of the overlay menu.
   * @group Props
   */
  menuStyle;
  /**
   * Style class of the overlay menu.
   * @group Props
   */
  menuStyleClass;
  /**
   * Name of the dropdown icon.
   * @group Props
   */
  dropdownIcon;
  /**
   * Target element to attach the overlay, valid values are "body" or a local ng-template variable of another element (note: use binding with brackets for template variables, e.g. [appendTo]="mydiv" for a div element having #mydiv as variable name).
   * @defaultValue 'body'
   * @group Props
   */
  appendTo = input("body", ...ngDevMode ? [{
    debugName: "appendTo"
  }] : []);
  /**
   * Indicates the direction of the element.
   * @group Props
   */
  dir;
  /**
   * Defines a string that labels the expand button for accessibility.
   * @group Props
   */
  expandAriaLabel;
  /**
   * Transition options of the show animation.
   * @group Props
   * @deprecated since v21.0.0. Use `motionOptions` instead.
   */
  showTransitionOptions = ".12s cubic-bezier(0, 0, 0.2, 1)";
  /**
   * Transition options of the hide animation.
   * @group Props
   * @deprecated since v21.0.0. Use `motionOptions` instead.
   */
  hideTransitionOptions = ".1s linear";
  /**
   * The motion options.
   * @group Props
   */
  motionOptions = input(void 0, ...ngDevMode ? [{
    debugName: "motionOptions"
  }] : []);
  computedMotionOptions = computed(() => {
    return __spreadValues(__spreadValues({}, this.ptm("motion")), this.motionOptions());
  }, ...ngDevMode ? [{
    debugName: "computedMotionOptions"
  }] : []);
  /**
   * Button Props
   */
  buttonProps;
  /**
   * Menu Button Props
   */
  menuButtonProps;
  /**
   * When present, it specifies that the component should automatically get focus on load.
   * @group Props
   */
  autofocus;
  /**
   * When present, it specifies that the element should be disabled.
   * @group Props
   */
  set disabled(v2) {
    this._disabled = v2 ?? false;
    this.buttonDisabled = v2 ?? false;
    this.menuButtonDisabled = v2 ?? false;
  }
  get disabled() {
    return this._disabled;
  }
  /**
   * Index of the element in tabbing order.
   * @group Props
   */
  tabindex;
  /**
   * When present, it specifies that the menu button element should be disabled.
   * @group Props
   */
  menuButtonDisabled = false;
  /**
   * When present, it specifies that the button element should be disabled.
   * @group Props
   */
  buttonDisabled = false;
  /**
   * Callback to invoke when default command button is clicked.
   * @param {MouseEvent} event - Mouse event.
   * @group Emits
   */
  onClick = new EventEmitter();
  /**
   * Callback to invoke when overlay menu is hidden.
   * @group Emits
   */
  onMenuHide = new EventEmitter();
  /**
   * Callback to invoke when overlay menu is shown.
   * @group Emits
   */
  onMenuShow = new EventEmitter();
  /**
   * Callback to invoke when dropdown button is clicked.
   * @param {MouseEvent} event - Mouse event.
   * @group Emits
   */
  onDropdownClick = new EventEmitter();
  buttonViewChild;
  menu;
  /**
   * Custom content template.
   * @group Templates
   */
  contentTemplate;
  /**
   * Custom dropdown icon template.
   * @group Templates
   **/
  dropdownIconTemplate;
  templates;
  ariaId;
  isExpanded = signal(false, ...ngDevMode ? [{
    debugName: "isExpanded"
  }] : []);
  _disabled;
  _componentStyle = inject(SplitButtonStyle);
  _contentTemplate;
  _dropdownIconTemplate;
  $appendTo = computed(() => this.appendTo() || this.config.overlayAppendTo(), ...ngDevMode ? [{
    debugName: "$appendTo"
  }] : []);
  onInit() {
    this.ariaId = s2("pn_id_");
  }
  onAfterContentInit() {
    this.templates?.forEach((item) => {
      switch (item.getType()) {
        case "content":
          this._contentTemplate = item.template;
          break;
        case "dropdownicon":
          this._dropdownIconTemplate = item.template;
          break;
        default:
          this._contentTemplate = item.template;
          break;
      }
    });
  }
  onDefaultButtonClick(event) {
    this.onClick?.emit(event);
    this.menu?.hide();
  }
  onDropdownButtonClick(event) {
    this.onDropdownClick.emit(event);
    this.menu?.toggle({
      currentTarget: this.el?.nativeElement,
      relativeAlign: this.$appendTo() == "self"
    });
  }
  onDropdownButtonKeydown(event) {
    if (event.code === "ArrowDown" || event.code === "ArrowUp") {
      this.onDropdownButtonClick();
      event.preventDefault();
    }
  }
  onHide() {
    this.isExpanded.set(false);
    this.onMenuHide.emit();
  }
  onShow() {
    this.isExpanded.set(true);
    this.onMenuShow.emit();
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275SplitButton_BaseFactory;
    return function SplitButton_Factory(__ngFactoryType__) {
      return (\u0275SplitButton_BaseFactory || (\u0275SplitButton_BaseFactory = \u0275\u0275getInheritedFactory(_SplitButton)))(__ngFactoryType__ || _SplitButton);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _SplitButton,
    selectors: [["p-splitbutton"], ["p-splitButton"], ["p-split-button"]],
    contentQueries: function SplitButton_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c025, 4);
        \u0275\u0275contentQuery(dirIndex, _c121, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.contentTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.dropdownIconTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function SplitButton_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c217, 5);
        \u0275\u0275viewQuery(_c313, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.buttonViewChild = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.menu = _t.first);
      }
    },
    hostVars: 3,
    hostBindings: function SplitButton_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("data-p-severity", ctx.severity);
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      model: "model",
      severity: "severity",
      raised: [2, "raised", "raised", booleanAttribute],
      rounded: [2, "rounded", "rounded", booleanAttribute],
      text: [2, "text", "text", booleanAttribute],
      outlined: [2, "outlined", "outlined", booleanAttribute],
      size: "size",
      plain: [2, "plain", "plain", booleanAttribute],
      icon: "icon",
      iconPos: "iconPos",
      label: "label",
      tooltip: "tooltip",
      tooltipOptions: "tooltipOptions",
      styleClass: "styleClass",
      menuStyle: "menuStyle",
      menuStyleClass: "menuStyleClass",
      dropdownIcon: "dropdownIcon",
      appendTo: [1, "appendTo"],
      dir: "dir",
      expandAriaLabel: "expandAriaLabel",
      showTransitionOptions: "showTransitionOptions",
      hideTransitionOptions: "hideTransitionOptions",
      motionOptions: [1, "motionOptions"],
      buttonProps: "buttonProps",
      menuButtonProps: "menuButtonProps",
      autofocus: [2, "autofocus", "autofocus", booleanAttribute],
      disabled: [2, "disabled", "disabled", booleanAttribute],
      tabindex: [2, "tabindex", "tabindex", numberAttribute],
      menuButtonDisabled: [2, "menuButtonDisabled", "menuButtonDisabled", booleanAttribute],
      buttonDisabled: [2, "buttonDisabled", "buttonDisabled", booleanAttribute]
    },
    outputs: {
      onClick: "onClick",
      onMenuHide: "onMenuHide",
      onMenuShow: "onMenuShow",
      onDropdownClick: "onDropdownClick"
    },
    features: [\u0275\u0275ProvidersFeature([SplitButtonStyle, {
      provide: SPLITBUTTON_INSTANCE,
      useExisting: _SplitButton
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _SplitButton
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 8,
    vars: 27,
    consts: [["defaultButton", ""], ["menu", ""], ["defaultbtn", ""], [4, "ngIf", "ngIfElse"], ["type", "button", "pButton", "", "pRipple", "", 3, "click", "keydown", "size", "severity", "text", "outlined", "disabled", "pt", "unstyled"], [3, "class", 4, "ngIf"], [4, "ngIf"], [3, "onHide", "onShow", "id", "popup", "model", "styleClass", "appendTo", "motionOptions", "pt", "unstyled"], ["type", "button", "pButton", "", "pRipple", "", 3, "click", "severity", "text", "outlined", "size", "icon", "iconPos", "disabled", "pAutoFocus", "pTooltip", "pTooltipUnstyled", "tooltipOptions", "pt", "unstyled"], [4, "ngTemplateOutlet"], ["type", "button", "pButton", "", "pRipple", "", 3, "click", "severity", "text", "outlined", "size", "icon", "iconPos", "label", "disabled", "pAutoFocus", "pTooltip", "pTooltipUnstyled", "tooltipOptions", "pt", "unstyled"], ["data-p-icon", "chevron-down", 4, "ngIf"], ["data-p-icon", "chevron-down"]],
    template: function SplitButton_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275template(0, SplitButton_ng_container_0_Template, 3, 18, "ng-container", 3)(1, SplitButton_ng_template_1_Template, 2, 18, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementStart(3, "button", 4);
        \u0275\u0275listener("click", function SplitButton_Template_button_click_3_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDropdownButtonClick($event));
        })("keydown", function SplitButton_Template_button_keydown_3_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDropdownButtonKeydown($event));
        });
        \u0275\u0275template(4, SplitButton_span_4_Template, 1, 2, "span", 5)(5, SplitButton_ng_container_5_Template, 3, 2, "ng-container", 6);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(6, "p-tieredmenu", 7, 1);
        \u0275\u0275listener("onHide", function SplitButton_Template_p_tieredmenu_onHide_6_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onHide());
        })("onShow", function SplitButton_Template_p_tieredmenu_onShow_6_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onShow());
        });
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        const defaultButton_r5 = \u0275\u0275reference(2);
        \u0275\u0275property("ngIf", ctx.contentTemplate || ctx._contentTemplate)("ngIfElse", defaultButton_r5);
        \u0275\u0275advance(3);
        \u0275\u0275classMap(ctx.cx("pcDropdown"));
        \u0275\u0275property("size", ctx.size)("severity", ctx.severity)("text", ctx.text)("outlined", ctx.outlined)("disabled", ctx.menuButtonDisabled)("pt", ctx.ptm("pcDropdown"))("unstyled", ctx.unstyled());
        \u0275\u0275attribute("aria-label", (ctx.menuButtonProps == null ? null : ctx.menuButtonProps["ariaLabel"]) || ctx.expandAriaLabel)("aria-haspopup", (ctx.menuButtonProps == null ? null : ctx.menuButtonProps["ariaHasPopup"]) || true)("aria-expanded", (ctx.menuButtonProps == null ? null : ctx.menuButtonProps["ariaExpanded"]) || ctx.isExpanded())("aria-controls", (ctx.menuButtonProps == null ? null : ctx.menuButtonProps["ariaControls"]) || ctx.ariaId);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", ctx.dropdownIcon);
        \u0275\u0275advance();
        \u0275\u0275property("ngIf", !ctx.dropdownIcon);
        \u0275\u0275advance();
        \u0275\u0275styleMap(ctx.menuStyle);
        \u0275\u0275property("id", ctx.ariaId)("popup", true)("model", ctx.model)("styleClass", ctx.menuStyleClass)("appendTo", ctx.$appendTo())("motionOptions", ctx.computedMotionOptions())("pt", ctx.ptm("pcMenu"))("unstyled", ctx.unstyled());
      }
    },
    dependencies: [CommonModule, NgIf, NgTemplateOutlet, ButtonDirective, TieredMenu, AutoFocus, ChevronDownIcon, Ripple, TooltipModule, Tooltip, SharedModule],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitButton, [{
    type: Component,
    args: [{
      selector: "p-splitbutton, p-splitButton, p-split-button",
      standalone: true,
      imports: [CommonModule, ButtonDirective, TieredMenu, AutoFocus, ChevronDownIcon, Ripple, TooltipModule, SharedModule],
      template: `
        <ng-container *ngIf="contentTemplate || _contentTemplate; else defaultButton">
            <button
                [class]="cx('pcButton')"
                type="button"
                pButton
                pRipple
                [severity]="severity"
                [text]="text"
                [outlined]="outlined"
                [size]="size"
                [icon]="icon"
                [iconPos]="iconPos"
                (click)="onDefaultButtonClick($event)"
                [disabled]="disabled"
                [attr.tabindex]="tabindex"
                [attr.aria-label]="buttonProps?.['ariaLabel'] || label"
                [pAutoFocus]="autofocus"
                [pTooltip]="tooltip"
                [pTooltipUnstyled]="unstyled()"
                [tooltipOptions]="tooltipOptions"
                [pt]="ptm('pcButton')"
                [unstyled]="unstyled()"
            >
                <ng-container *ngTemplateOutlet="contentTemplate || _contentTemplate"></ng-container>
            </button>
        </ng-container>
        <ng-template #defaultButton>
            <button
                #defaultbtn
                [class]="cx('pcButton')"
                type="button"
                pButton
                pRipple
                [severity]="severity"
                [text]="text"
                [outlined]="outlined"
                [size]="size"
                [icon]="icon"
                [iconPos]="iconPos"
                [label]="label"
                (click)="onDefaultButtonClick($event)"
                [disabled]="buttonDisabled"
                [attr.tabindex]="tabindex"
                [attr.aria-label]="buttonProps?.['ariaLabel']"
                [pAutoFocus]="autofocus"
                [pTooltip]="tooltip"
                [pTooltipUnstyled]="unstyled()"
                [tooltipOptions]="tooltipOptions"
                [pt]="ptm('pcButton')"
                [unstyled]="unstyled()"
            ></button>
        </ng-template>
        <button
            type="button"
            pButton
            pRipple
            [size]="size"
            [severity]="severity"
            [text]="text"
            [outlined]="outlined"
            [class]="cx('pcDropdown')"
            (click)="onDropdownButtonClick($event)"
            (keydown)="onDropdownButtonKeydown($event)"
            [disabled]="menuButtonDisabled"
            [attr.aria-label]="menuButtonProps?.['ariaLabel'] || expandAriaLabel"
            [attr.aria-haspopup]="menuButtonProps?.['ariaHasPopup'] || true"
            [attr.aria-expanded]="menuButtonProps?.['ariaExpanded'] || isExpanded()"
            [attr.aria-controls]="menuButtonProps?.['ariaControls'] || ariaId"
            [pt]="ptm('pcDropdown')"
            [unstyled]="unstyled()"
        >
            <span *ngIf="dropdownIcon" [class]="dropdownIcon"></span>
            <ng-container *ngIf="!dropdownIcon">
                <svg data-p-icon="chevron-down" *ngIf="!dropdownIconTemplate && !_dropdownIconTemplate" />
                <ng-template *ngTemplateOutlet="dropdownIconTemplate || _dropdownIconTemplate"></ng-template>
            </ng-container>
        </button>
        <p-tieredmenu
            [id]="ariaId"
            #menu
            [popup]="true"
            [model]="model"
            [style]="menuStyle"
            [styleClass]="menuStyleClass"
            [appendTo]="$appendTo()"
            [motionOptions]="computedMotionOptions()"
            (onHide)="onHide()"
            (onShow)="onShow()"
            [pt]="ptm('pcMenu')"
            [unstyled]="unstyled()"
        ></p-tieredmenu>
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [SplitButtonStyle, {
        provide: SPLITBUTTON_INSTANCE,
        useExisting: SplitButton
      }, {
        provide: PARENT_INSTANCE,
        useExisting: SplitButton
      }],
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cn(cx('root'), styleClass)",
        "[attr.data-p-severity]": "severity"
      },
      hostDirectives: [Bind]
    }]
  }], null, {
    model: [{
      type: Input
    }],
    severity: [{
      type: Input
    }],
    raised: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    rounded: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    text: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    outlined: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    size: [{
      type: Input
    }],
    plain: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    icon: [{
      type: Input
    }],
    iconPos: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    tooltip: [{
      type: Input
    }],
    tooltipOptions: [{
      type: Input
    }],
    styleClass: [{
      type: Input
    }],
    menuStyle: [{
      type: Input
    }],
    menuStyleClass: [{
      type: Input
    }],
    dropdownIcon: [{
      type: Input
    }],
    appendTo: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "appendTo",
        required: false
      }]
    }],
    dir: [{
      type: Input
    }],
    expandAriaLabel: [{
      type: Input
    }],
    showTransitionOptions: [{
      type: Input
    }],
    hideTransitionOptions: [{
      type: Input
    }],
    motionOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "motionOptions",
        required: false
      }]
    }],
    buttonProps: [{
      type: Input
    }],
    menuButtonProps: [{
      type: Input
    }],
    autofocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    tabindex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    menuButtonDisabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    buttonDisabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    onClick: [{
      type: Output
    }],
    onMenuHide: [{
      type: Output
    }],
    onMenuShow: [{
      type: Output
    }],
    onDropdownClick: [{
      type: Output
    }],
    buttonViewChild: [{
      type: ViewChild,
      args: ["defaultbtn"]
    }],
    menu: [{
      type: ViewChild,
      args: ["menu"]
    }],
    contentTemplate: [{
      type: ContentChild,
      args: ["content", {
        descendants: false
      }]
    }],
    dropdownIconTemplate: [{
      type: ContentChild,
      args: ["dropdownicon", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }]
  });
})();
var SplitButtonModule = class _SplitButtonModule {
  static \u0275fac = function SplitButtonModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SplitButtonModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _SplitButtonModule,
    imports: [SplitButton, SharedModule],
    exports: [SplitButton, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [SplitButton, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SplitButtonModule, [{
    type: NgModule,
    args: [{
      imports: [SplitButton, SharedModule],
      exports: [SplitButton, SharedModule]
    }]
  }], null, null);
})();

// node_modules/@primeuix/styles/dist/toggleswitch/index.mjs
var style20 = "\n    .p-toggleswitch {\n        display: inline-block;\n        width: dt('toggleswitch.width');\n        height: dt('toggleswitch.height');\n    }\n\n    .p-toggleswitch-input {\n        cursor: pointer;\n        appearance: none;\n        position: absolute;\n        top: 0;\n        inset-inline-start: 0;\n        width: 100%;\n        height: 100%;\n        padding: 0;\n        margin: 0;\n        opacity: 0;\n        z-index: 1;\n        outline: 0 none;\n        border-radius: dt('toggleswitch.border.radius');\n    }\n\n    .p-toggleswitch-slider {\n        cursor: pointer;\n        width: 100%;\n        height: 100%;\n        border-width: dt('toggleswitch.border.width');\n        border-style: solid;\n        border-color: dt('toggleswitch.border.color');\n        background: dt('toggleswitch.background');\n        transition:\n            background dt('toggleswitch.transition.duration'),\n            color dt('toggleswitch.transition.duration'),\n            border-color dt('toggleswitch.transition.duration'),\n            outline-color dt('toggleswitch.transition.duration'),\n            box-shadow dt('toggleswitch.transition.duration');\n        border-radius: dt('toggleswitch.border.radius');\n        outline-color: transparent;\n        box-shadow: dt('toggleswitch.shadow');\n    }\n\n    .p-toggleswitch-handle {\n        position: absolute;\n        top: 50%;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        background: dt('toggleswitch.handle.background');\n        color: dt('toggleswitch.handle.color');\n        width: dt('toggleswitch.handle.size');\n        height: dt('toggleswitch.handle.size');\n        inset-inline-start: dt('toggleswitch.gap');\n        margin-block-start: calc(-1 * calc(dt('toggleswitch.handle.size') / 2));\n        border-radius: dt('toggleswitch.handle.border.radius');\n        transition:\n            background dt('toggleswitch.transition.duration'),\n            color dt('toggleswitch.transition.duration'),\n            inset-inline-start dt('toggleswitch.slide.duration'),\n            box-shadow dt('toggleswitch.slide.duration');\n    }\n\n    .p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-slider {\n        background: dt('toggleswitch.checked.background');\n        border-color: dt('toggleswitch.checked.border.color');\n    }\n\n    .p-toggleswitch.p-toggleswitch-checked .p-toggleswitch-handle {\n        background: dt('toggleswitch.handle.checked.background');\n        color: dt('toggleswitch.handle.checked.color');\n        inset-inline-start: calc(dt('toggleswitch.width') - calc(dt('toggleswitch.handle.size') + dt('toggleswitch.gap')));\n    }\n\n    .p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-slider {\n        background: dt('toggleswitch.hover.background');\n        border-color: dt('toggleswitch.hover.border.color');\n    }\n\n    .p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover) .p-toggleswitch-handle {\n        background: dt('toggleswitch.handle.hover.background');\n        color: dt('toggleswitch.handle.hover.color');\n    }\n\n    .p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-slider {\n        background: dt('toggleswitch.checked.hover.background');\n        border-color: dt('toggleswitch.checked.hover.border.color');\n    }\n\n    .p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:hover).p-toggleswitch-checked .p-toggleswitch-handle {\n        background: dt('toggleswitch.handle.checked.hover.background');\n        color: dt('toggleswitch.handle.checked.hover.color');\n    }\n\n    .p-toggleswitch:not(.p-disabled):has(.p-toggleswitch-input:focus-visible) .p-toggleswitch-slider {\n        box-shadow: dt('toggleswitch.focus.ring.shadow');\n        outline: dt('toggleswitch.focus.ring.width') dt('toggleswitch.focus.ring.style') dt('toggleswitch.focus.ring.color');\n        outline-offset: dt('toggleswitch.focus.ring.offset');\n    }\n\n    .p-toggleswitch.p-invalid > .p-toggleswitch-slider {\n        border-color: dt('toggleswitch.invalid.border.color');\n    }\n\n    .p-toggleswitch.p-disabled {\n        opacity: 1;\n    }\n\n    .p-toggleswitch.p-disabled .p-toggleswitch-slider {\n        background: dt('toggleswitch.disabled.background');\n    }\n\n    .p-toggleswitch.p-disabled .p-toggleswitch-handle {\n        background: dt('toggleswitch.handle.disabled.background');\n    }\n";

// node_modules/primeng/fesm2022/primeng-toggleswitch.mjs
var _c026 = ["handle"];
var _c126 = ["input"];
var _c218 = (a0) => ({
  checked: a0
});
function ToggleSwitch_Conditional_4_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function ToggleSwitch_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ToggleSwitch_Conditional_4_ng_container_0_Template, 1, 0, "ng-container", 3);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.handleTemplate || ctx_r1._handleTemplate)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c218, ctx_r1.checked()));
  }
}
var style21 = (
  /*css*/
  `
    ${style20}

    p-toggleswitch.ng-invalid.ng-dirty > .p-toggleswitch-slider {
        border-color: dt('toggleswitch.invalid.border.color');
    }
`
);
var inlineStyles5 = {
  root: {
    position: "relative"
  }
};
var classes15 = {
  root: ({
    instance
  }) => ["p-toggleswitch p-component", {
    "p-toggleswitch p-component": true,
    "p-toggleswitch-checked": instance.checked(),
    "p-disabled": instance.$disabled(),
    "p-invalid": instance.invalid()
  }],
  input: "p-toggleswitch-input",
  slider: "p-toggleswitch-slider",
  handle: "p-toggleswitch-handle"
};
var ToggleSwitchStyle = class _ToggleSwitchStyle extends BaseStyle {
  name = "toggleswitch";
  style = style21;
  classes = classes15;
  inlineStyles = inlineStyles5;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275ToggleSwitchStyle_BaseFactory;
    return function ToggleSwitchStyle_Factory(__ngFactoryType__) {
      return (\u0275ToggleSwitchStyle_BaseFactory || (\u0275ToggleSwitchStyle_BaseFactory = \u0275\u0275getInheritedFactory(_ToggleSwitchStyle)))(__ngFactoryType__ || _ToggleSwitchStyle);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ToggleSwitchStyle,
    factory: _ToggleSwitchStyle.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggleSwitchStyle, [{
    type: Injectable
  }], null, null);
})();
var ToggleSwitchClasses;
(function(ToggleSwitchClasses2) {
  ToggleSwitchClasses2["root"] = "p-toggleswitch";
  ToggleSwitchClasses2["input"] = "p-toggleswitch-input";
  ToggleSwitchClasses2["slider"] = "p-toggleswitch-slider";
})(ToggleSwitchClasses || (ToggleSwitchClasses = {}));
var TOGGLESWITCH_INSTANCE = new InjectionToken("TOGGLESWITCH_INSTANCE");
var TOGGLESWITCH_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => ToggleSwitch),
  multi: true
};
var ToggleSwitch = class _ToggleSwitch extends BaseEditableHolder {
  $pcToggleSwitch = inject(TOGGLESWITCH_INSTANCE, {
    optional: true,
    skipSelf: true
  }) ?? void 0;
  bindDirectiveInstance = inject(Bind, {
    self: true
  });
  onAfterViewChecked() {
    this.bindDirectiveInstance.setAttrs(this.ptms(["host", "root"]));
  }
  /**
   * Style class of the component.
   * @deprecated since v20.0.0, use `class` instead.
   * @group Props
   */
  styleClass;
  /**
   * Index of the element in tabbing order.
   * @group Props
   */
  tabindex;
  /**
   * Identifier of the input element.
   * @group Props
   */
  inputId;
  /**
   * When present, it specifies that the component cannot be edited.
   * @group Props
   */
  readonly;
  /**
   * Value in checked state.
   * @group Props
   */
  trueValue = true;
  /**
   * Value in unchecked state.
   * @group Props
   */
  falseValue = false;
  /**
   * Used to define a string that autocomplete attribute the current element.
   * @group Props
   */
  ariaLabel;
  /**
   * Specifies the size of the component.
   * @defaultValue undefined
   * @group Props
   */
  size = input(...ngDevMode ? [void 0, {
    debugName: "size"
  }] : []);
  /**
   * Establishes relationships between the component and label(s) where its value should be one or more element IDs.
   * @group Props
   */
  ariaLabelledBy;
  /**
   * When present, it specifies that the component should automatically get focus on load.
   * @group Props
   */
  autofocus;
  /**
   * Callback to invoke when the on value change.
   * @param {ToggleSwitchChangeEvent} event - Custom change event.
   * @group Emits
   */
  onChange = new EventEmitter();
  input;
  /**
   * Custom handle template.
   * @param {ToggleSwitchHandleTemplateContext} context - handle context.
   * @see {@link ToggleSwitchHandleTemplateContext}
   * @group Templates
   */
  handleTemplate;
  _handleTemplate;
  focused = false;
  _componentStyle = inject(ToggleSwitchStyle);
  templates;
  onHostClick(event) {
    this.onClick(event);
  }
  onAfterContentInit() {
    this.templates.forEach((item) => {
      switch (item.getType()) {
        case "handle":
          this._handleTemplate = item.template;
          break;
        default:
          this._handleTemplate = item.template;
          break;
      }
    });
  }
  onClick(event) {
    if (!this.$disabled() && !this.readonly) {
      this.writeModelValue(this.checked() ? this.falseValue : this.trueValue);
      this.onModelChange(this.modelValue());
      this.onChange.emit({
        originalEvent: event,
        checked: this.modelValue()
      });
      this.input.nativeElement.focus();
    }
  }
  onFocus() {
    this.focused = true;
  }
  onBlur() {
    this.focused = false;
    this.onModelTouched();
  }
  checked() {
    return this.modelValue() === this.trueValue;
  }
  /**
   * @override
   *
   * @see {@link BaseEditableHolder.writeControlValue}
   * Writes the value to the control.
   */
  writeControlValue(value, setModelValue) {
    setModelValue(value);
    this.cd.markForCheck();
  }
  get dataP() {
    return this.cn({
      checked: this.checked(),
      disabled: this.$disabled(),
      invalid: this.invalid()
    });
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275ToggleSwitch_BaseFactory;
    return function ToggleSwitch_Factory(__ngFactoryType__) {
      return (\u0275ToggleSwitch_BaseFactory || (\u0275ToggleSwitch_BaseFactory = \u0275\u0275getInheritedFactory(_ToggleSwitch)))(__ngFactoryType__ || _ToggleSwitch);
    };
  })();
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _ToggleSwitch,
    selectors: [["p-toggleswitch"], ["p-toggleSwitch"], ["p-toggle-switch"]],
    contentQueries: function ToggleSwitch_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, _c026, 4);
        \u0275\u0275contentQuery(dirIndex, PrimeTemplate, 4);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.handleTemplate = _t.first);
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.templates = _t);
      }
    },
    viewQuery: function ToggleSwitch_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c126, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.input = _t.first);
      }
    },
    hostVars: 7,
    hostBindings: function ToggleSwitch_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("click", function ToggleSwitch_click_HostBindingHandler($event) {
          return ctx.onHostClick($event);
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("data-p-checked", ctx.checked())("data-p-disabled", ctx.$disabled())("data-p", ctx.dataP);
        \u0275\u0275styleMap(ctx.sx("root"));
        \u0275\u0275classMap(ctx.cn(ctx.cx("root"), ctx.styleClass));
      }
    },
    inputs: {
      styleClass: "styleClass",
      tabindex: [2, "tabindex", "tabindex", numberAttribute],
      inputId: "inputId",
      readonly: [2, "readonly", "readonly", booleanAttribute],
      trueValue: "trueValue",
      falseValue: "falseValue",
      ariaLabel: "ariaLabel",
      size: [1, "size"],
      ariaLabelledBy: "ariaLabelledBy",
      autofocus: [2, "autofocus", "autofocus", booleanAttribute]
    },
    outputs: {
      onChange: "onChange"
    },
    features: [\u0275\u0275ProvidersFeature([TOGGLESWITCH_VALUE_ACCESSOR, ToggleSwitchStyle, {
      provide: TOGGLESWITCH_INSTANCE,
      useExisting: _ToggleSwitch
    }, {
      provide: PARENT_INSTANCE,
      useExisting: _ToggleSwitch
    }]), \u0275\u0275HostDirectivesFeature([Bind]), \u0275\u0275InheritDefinitionFeature],
    decls: 5,
    vars: 22,
    consts: [["input", ""], ["type", "checkbox", "role", "switch", 3, "focus", "blur", "checked", "pAutoFocus", "pBind"], [3, "pBind"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function ToggleSwitch_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "input", 1, 0);
        \u0275\u0275listener("focus", function ToggleSwitch_Template_input_focus_0_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onFocus());
        })("blur", function ToggleSwitch_Template_input_blur_0_listener() {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onBlur());
        });
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(2, "div", 2)(3, "div", 2);
        \u0275\u0275conditionalCreate(4, ToggleSwitch_Conditional_4_Template, 1, 4, "ng-container");
        \u0275\u0275elementEnd()();
      }
      if (rf & 2) {
        \u0275\u0275classMap(ctx.cx("input"));
        \u0275\u0275property("checked", ctx.checked())("pAutoFocus", ctx.autofocus)("pBind", ctx.ptm("input"));
        \u0275\u0275attribute("id", ctx.inputId)("required", ctx.required() ? "" : void 0)("disabled", ctx.$disabled() ? "" : void 0)("aria-checked", ctx.checked())("aria-labelledby", ctx.ariaLabelledBy)("aria-label", ctx.ariaLabel)("name", ctx.name())("tabindex", ctx.tabindex);
        \u0275\u0275advance(2);
        \u0275\u0275classMap(ctx.cx("slider"));
        \u0275\u0275property("pBind", ctx.ptm("slider"));
        \u0275\u0275attribute("data-p", ctx.dataP);
        \u0275\u0275advance();
        \u0275\u0275classMap(ctx.cx("handle"));
        \u0275\u0275property("pBind", ctx.ptm("handle"));
        \u0275\u0275attribute("data-p", ctx.dataP);
        \u0275\u0275advance();
        \u0275\u0275conditional(ctx.handleTemplate || ctx._handleTemplate ? 4 : -1);
      }
    },
    dependencies: [CommonModule, NgTemplateOutlet, AutoFocus, SharedModule, BindModule, Bind],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggleSwitch, [{
    type: Component,
    args: [{
      selector: "p-toggleswitch, p-toggleSwitch, p-toggle-switch",
      standalone: true,
      imports: [CommonModule, AutoFocus, SharedModule, BindModule],
      template: `
        <input
            #input
            [attr.id]="inputId"
            type="checkbox"
            role="switch"
            [class]="cx('input')"
            [checked]="checked()"
            [attr.required]="required() ? '' : undefined"
            [attr.disabled]="$disabled() ? '' : undefined"
            [attr.aria-checked]="checked()"
            [attr.aria-labelledby]="ariaLabelledBy"
            [attr.aria-label]="ariaLabel"
            [attr.name]="name()"
            [attr.tabindex]="tabindex"
            (focus)="onFocus()"
            (blur)="onBlur()"
            [pAutoFocus]="autofocus"
            [pBind]="ptm('input')"
        />
        <div [class]="cx('slider')" [pBind]="ptm('slider')" [attr.data-p]="dataP">
            <div [class]="cx('handle')" [pBind]="ptm('handle')" [attr.data-p]="dataP">
                @if (handleTemplate || _handleTemplate) {
                    <ng-container *ngTemplateOutlet="handleTemplate || _handleTemplate; context: { checked: checked() }" />
                }
            </div>
        </div>
    `,
      providers: [TOGGLESWITCH_VALUE_ACCESSOR, ToggleSwitchStyle, {
        provide: TOGGLESWITCH_INSTANCE,
        useExisting: ToggleSwitch
      }, {
        provide: PARENT_INSTANCE,
        useExisting: ToggleSwitch
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cn(cx('root'), styleClass)",
        "[style]": "sx('root')",
        "[attr.data-p-checked]": "checked()",
        "[attr.data-p-disabled]": "$disabled()",
        "[attr.data-p]": "dataP"
      },
      hostDirectives: [Bind]
    }]
  }], null, {
    styleClass: [{
      type: Input
    }],
    tabindex: [{
      type: Input,
      args: [{
        transform: numberAttribute
      }]
    }],
    inputId: [{
      type: Input
    }],
    readonly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    trueValue: [{
      type: Input
    }],
    falseValue: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    size: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "size",
        required: false
      }]
    }],
    ariaLabelledBy: [{
      type: Input
    }],
    autofocus: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    onChange: [{
      type: Output
    }],
    input: [{
      type: ViewChild,
      args: ["input"]
    }],
    handleTemplate: [{
      type: ContentChild,
      args: ["handle", {
        descendants: false
      }]
    }],
    templates: [{
      type: ContentChildren,
      args: [PrimeTemplate]
    }],
    onHostClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ToggleSwitchModule = class _ToggleSwitchModule {
  static \u0275fac = function ToggleSwitchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ToggleSwitchModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ToggleSwitchModule,
    imports: [ToggleSwitch, SharedModule],
    exports: [ToggleSwitch, SharedModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [ToggleSwitch, SharedModule, SharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ToggleSwitchModule, [{
    type: NgModule,
    args: [{
      imports: [ToggleSwitch, SharedModule],
      exports: [ToggleSwitch, SharedModule]
    }]
  }], null, null);
})();

// src/app/shared/components/forms/dynamic-field/dynamic-field.component.ts
var _c027 = (a0, a1) => ["p-field", a0, a1];
var _c127 = (a0, a1) => ["form-label", a0, "flex-shrink-0", "flex gap-1", a1];
var _c219 = (a0) => ({ "--swatch-color": a0 });
var _c314 = (a0) => [a0, "h-[320px]"];
var _c49 = (a0, a1) => ({ $implicit: a0, field: a1 });
var _c59 = () => [];
var _c68 = (a0) => ({ $implicit: a0 });
var _forTrack05 = ($index, $item) => $item.id;
function DynamicFieldComponent_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 5);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_2_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", (tmp_2_0 = ctx_r0.field().props) == null ? null : tmp_2_0.suffix, " ");
  }
}
function DynamicFieldComponent_Conditional_0_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 6);
    \u0275\u0275text(1, " *");
    \u0275\u0275elementEnd();
  }
}
function DynamicFieldComponent_Conditional_0_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 7);
  }
  if (rf & 2) {
    let tmp_2_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("pTooltip", (tmp_2_0 = ctx_r0.field().props) == null ? null : tmp_2_0["tooltip"])("escape", false);
  }
}
function DynamicFieldComponent_Conditional_0_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275element(1, "p-progress-spinner", 39);
    \u0275\u0275elementEnd();
  }
}
function DynamicFieldComponent_Conditional_0_Case_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "input", 40);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("placeholder", ctx_r0.field().placeholder || "")("readonly", ctx_r0.field().readonly);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-inputnumber", 41);
  }
  if (rf & 2) {
    let tmp_5_0;
    let tmp_6_0;
    let tmp_7_0;
    let tmp_8_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("showButtons", (tmp_5_0 = ctx_r0.field().props) == null ? null : tmp_5_0.showButtons)("minFractionDigits", ((tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.minFractionDigits) ?? 0)("maxFractionDigits", ((tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0.maxFractionDigits) ?? 20)("step", ((tmp_8_0 = ctx_r0.field().props) == null ? null : tmp_8_0.step) ?? 1);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-select", 42);
    \u0275\u0275listener("onChange", function DynamicFieldComponent_Conditional_0_Case_12_Template_p_select_onChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onDropdownChange($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_7_0;
    let tmp_9_0;
    let tmp_10_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("options", ctx_r0.field().options)("placeholder", ctx_r0.field().placeholder || "")("showClear", (tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0.showClear)("filter", true)("filterBy", ((tmp_9_0 = ctx_r0.field().props) == null ? null : tmp_9_0.filterBy) ?? "label")("appendTo", ((tmp_10_0 = ctx_r0.field().props) == null ? null : tmp_10_0.appendTo) ?? "body");
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-multiSelect", 43);
  }
  if (rf & 2) {
    let tmp_7_0;
    let tmp_8_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("options", ctx_r0.field().options)("placeholder", ctx_r0.field().placeholder || "")("filter", (tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0.filter)("appendTo", (tmp_8_0 = ctx_r0.field().props) == null ? null : tmp_8_0.appendTo);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-datepicker", 14);
  }
  if (rf & 2) {
    let tmp_4_0;
    let tmp_5_0;
    let tmp_6_0;
    let tmp_8_0;
    let tmp_9_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.getDateControl())("dateFormat", (tmp_4_0 = ctx_r0.field().props) == null ? null : tmp_4_0.dateFormat)("showTime", ((tmp_5_0 = ctx_r0.field().props) == null ? null : tmp_5_0.showTime) || false)("showSeconds", (tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.showSeconds)("showIcon", true)("timeOnly", (tmp_8_0 = ctx_r0.field().props) == null ? null : tmp_8_0.timeOnly)("appendTo", (tmp_9_0 = ctx_r0.field().props) == null ? null : tmp_9_0.appendTo)("styleClass", ctx_r0.fieldClasses());
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-checkbox", 15);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("ngClass", ctx_r0.field().inputStyleClass);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_16_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-radioButton", 44);
    \u0275\u0275elementStart(1, "label", 45);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const option_r3 = ctx.$implicit;
    const $index_r4 = ctx.$index;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275property("id", ctx_r0.fieldKey() + $index_r4)("formControl", ctx_r0.control())("value", option_r3.value)("ngClass", ctx_r0.field().inputStyleClass);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
    \u0275\u0275advance();
    \u0275\u0275property("for", ctx_r0.fieldKey());
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(option_r3.label);
  }
}
function DynamicFieldComponent_Conditional_0_Case_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, DynamicFieldComponent_Conditional_0_Case_16_For_1_Template, 3, 9, null, null, \u0275\u0275componentInstance().trackByOption, true);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275repeater(ctx_r0.field().options);
  }
}
function DynamicFieldComponent_Conditional_0_Case_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "textarea", 46);
  }
  if (rf & 2) {
    let tmp_5_0;
    let tmp_6_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("rows", ((tmp_5_0 = ctx_r0.field().props) == null ? null : tmp_5_0["rows"]) || 3)("autoResize", (tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.autoResize)("placeholder", ctx_r0.field().placeholder || "")("readOnly", ctx_r0.field().readonly);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-slider", 47);
  }
  if (rf & 2) {
    let tmp_5_0;
    let tmp_6_0;
    let tmp_7_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("min", ((tmp_5_0 = ctx_r0.field().props) == null ? null : tmp_5_0.min) || 0)("max", ((tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.max) || 100)("step", ((tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0.step) || 1);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-togglebutton", 18);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("onLabel", ctx_r0.getToggleButtonLabel(true))("offLabel", ctx_r0.getToggleButtonLabel(false))("ngClass", ctx_r0.field().inputStyleClass);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_20_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 55);
    \u0275\u0275element(1, "div", 56);
    \u0275\u0275elementStart(2, "div");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const option_r7 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(2, _c219, option_r7.value));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(option_r7.label);
  }
}
function DynamicFieldComponent_Conditional_0_Case_20_ng_template_9_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 55);
    \u0275\u0275element(1, "div", 56);
    \u0275\u0275elementStart(2, "div");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const selectedOption_r8 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(2, _c219, selectedOption_r8.value));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(selectedOption_r8.label);
  }
}
function DynamicFieldComponent_Conditional_0_Case_20_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DynamicFieldComponent_Conditional_0_Case_20_ng_template_9_Conditional_0_Template, 4, 4, "div", 55);
  }
  if (rf & 2) {
    const selectedOption_r8 = ctx.$implicit;
    \u0275\u0275conditional(selectedOption_r8 ? 0 : -1);
  }
}
function DynamicFieldComponent_Conditional_0_Case_20_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 19)(1, "div", 48);
    \u0275\u0275listener("click", function DynamicFieldComponent_Conditional_0_Case_20_Template_div_click_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const op_r6 = \u0275\u0275reference(3);
      return \u0275\u0275resetView(op_r6.toggle($event));
    })("keydown.enter", function DynamicFieldComponent_Conditional_0_Case_20_Template_div_keydown_enter_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const op_r6 = \u0275\u0275reference(3);
      return \u0275\u0275resetView(op_r6.toggle($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "p-popover", null, 0)(4, "div", 49)(5, "p-colorpicker", 50);
    \u0275\u0275listener("onChange", function DynamicFieldComponent_Conditional_0_Case_20_Template_p_colorpicker_onChange_5_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onColorPickerChange($event, ctx_r0.control()));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "input", 51);
    \u0275\u0275listener("ngModelChange", function DynamicFieldComponent_Conditional_0_Case_20_Template_input_ngModelChange_6_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onManualColorInputChange($event));
    });
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(7, "p-select", 52);
    \u0275\u0275twoWayListener("ngModelChange", function DynamicFieldComponent_Conditional_0_Case_20_Template_p_select_ngModelChange_7_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r0.selectedColor, $event) || (ctx_r0.selectedColor = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("onChange", function DynamicFieldComponent_Conditional_0_Case_20_Template_p_select_onChange_7_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onColorSelect($event.value));
    });
    \u0275\u0275template(8, DynamicFieldComponent_Conditional_0_Case_20_ng_template_8_Template, 4, 4, "ng-template", 53)(9, DynamicFieldComponent_Conditional_0_Case_20_ng_template_9_Template, 1, 1, "ng-template", 54);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_7_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction1(13, _c219, ctx_r0.control().value || "#ffffff"));
    \u0275\u0275attribute("aria-label", "Open color picker for " + ctx_r0.fieldLabel());
    \u0275\u0275advance(4);
    \u0275\u0275property("formControl", ctx_r0.control())("inline", true)("format", ((tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0["format"]) || "hex");
    \u0275\u0275advance();
    \u0275\u0275property("id", ctx_r0.fieldKey() + "-manual")("ngModel", ctx_r0.manualColorInput());
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel() + " manual value");
    \u0275\u0275advance();
    \u0275\u0275property("id", ctx_r0.fieldKey() + "-dropdown")("options", ctx_r0.colorOptions());
    \u0275\u0275twoWayProperty("ngModel", ctx_r0.selectedColor);
    \u0275\u0275property("styleClass", "flex-grow min-w-0");
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel() + " predefined colors");
  }
}
function DynamicFieldComponent_Conditional_0_Case_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-knob", 20);
  }
  if (rf & 2) {
    let tmp_4_0;
    let tmp_5_0;
    let tmp_6_0;
    let tmp_7_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("min", ((tmp_4_0 = ctx_r0.field().props) == null ? null : tmp_4_0.min) || 0)("max", ((tmp_5_0 = ctx_r0.field().props) == null ? null : tmp_5_0.max) || 100)("step", ((tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.step) || 1)("size", ((tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0["size"]) || 100)("ngClass", ctx_r0.field().inputStyleClass);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-editor", 57);
  }
  if (rf & 2) {
    let tmp_5_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(\u0275\u0275pureFunction1(8, _c314, ctx_r0.fieldClasses()));
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("modules", (tmp_5_0 = ctx_r0.field().props) == null ? null : tmp_5_0.modules);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_23_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-fileUpload", 58);
    \u0275\u0275listener("onSelect", function DynamicFieldComponent_Conditional_0_Case_23_Template_p_fileUpload_onSelect_0_listener($event) {
      \u0275\u0275restoreView(_r9);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onFileSelect($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_4_0;
    let tmp_5_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("maxFileSize", (tmp_4_0 = ctx_r0.field().props) == null ? null : tmp_4_0.maxFileSize)("accept", (tmp_5_0 = ctx_r0.field().props) == null ? null : tmp_5_0.accept);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_24_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-password", 59);
  }
  if (rf & 2) {
    let tmp_5_0;
    let tmp_6_0;
    let tmp_7_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("feedback", (tmp_5_0 = ctx_r0.field().props) == null ? null : tmp_5_0.feedback)("toggleMask", (tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.toggleMask)("autocomplete", ((tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0["autocomplete"]) || "password");
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-inputMask", 60);
  }
  if (rf & 2) {
    let tmp_5_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("mask", (tmp_5_0 = ctx_r0.field().props) == null ? null : tmp_5_0.mask);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_26_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-rating", 61);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("stars", 5);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_27_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 26);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.customTemplate() ?? null)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c49, ctx_r0.control(), ctx_r0.field()));
  }
}
function DynamicFieldComponent_Conditional_0_Case_28_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 63);
    \u0275\u0275pipe(1, "highlight");
  }
  if (rf & 2) {
    const option_r11 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275property("innerHTML", \u0275\u0275pipeBind2(1, 1, ctx_r0.getAutocompleteDisplayText(option_r11), ctx_r0.autocompleteSearchQuery()), \u0275\u0275sanitizeHtml);
  }
}
function DynamicFieldComponent_Conditional_0_Case_28_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 27)(1, "p-autocomplete", 62, 1);
    \u0275\u0275listener("completeMethod", function DynamicFieldComponent_Conditional_0_Case_28_Template_p_autocomplete_completeMethod_1_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.handleAutocompleteSearch($event.query));
    })("onSelect", function DynamicFieldComponent_Conditional_0_Case_28_Template_p_autocomplete_onSelect_1_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onAutocompleteChange($event));
    })("onChange", function DynamicFieldComponent_Conditional_0_Case_28_Template_p_autocomplete_onChange_1_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onAutocompleteValueChange());
    })("onUnselect", function DynamicFieldComponent_Conditional_0_Case_28_Template_p_autocomplete_onUnselect_1_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onAutocompleteValueChange());
    })("onInput", function DynamicFieldComponent_Conditional_0_Case_28_Template_p_autocomplete_onInput_1_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onAutocompleteValueChange());
    })("onKeyUp", function DynamicFieldComponent_Conditional_0_Case_28_Template_p_autocomplete_onKeyUp_1_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onAutocompleteValueChange());
    })("onBlur", function DynamicFieldComponent_Conditional_0_Case_28_Template_p_autocomplete_onBlur_1_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.onAutocompleteBlur($event));
    });
    \u0275\u0275template(3, DynamicFieldComponent_Conditional_0_Case_28_ng_template_3_Template, 2, 4, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_8_0;
    let tmp_9_0;
    let tmp_11_0;
    let tmp_13_0;
    let tmp_14_0;
    let tmp_15_0;
    let tmp_16_0;
    let tmp_17_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("suggestions", ctx_r0.getSuggestions())("forceSelection", (tmp_8_0 = ctx_r0.field().props) == null ? null : tmp_8_0.forceSelection)("optionLabel", (tmp_9_0 = ctx_r0.field().props) == null ? null : tmp_9_0.field)("placeholder", ctx_r0.field().placeholder || "")("completeOnFocus", (tmp_11_0 = ctx_r0.field().props) == null ? null : tmp_11_0.completeOnFocus)("readonly", ctx_r0.field().readonly ?? false)("typeahead", (tmp_13_0 = ctx_r0.field().props) == null ? null : tmp_13_0.typeahead)("multiple", (tmp_14_0 = ctx_r0.field().props) == null ? null : tmp_14_0.multiple)("delay", ((tmp_15_0 = ctx_r0.field().props) == null ? null : tmp_15_0.delay) || 300)("emptyMessage", ctx_r0.isAutocompleteLoading() ? "Loading..." : ((tmp_16_0 = ctx_r0.field().props) == null ? null : tmp_16_0.emptyMessage) || "No results found")("dropdown", (tmp_17_0 = ctx_r0.field().props) == null ? null : tmp_17_0.dropdown)("appendTo", ctx_r0.fieldProps().appendTo || "body");
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_29_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-listbox", 64);
  }
  if (rf & 2) {
    let tmp_6_0;
    let tmp_7_0;
    let tmp_8_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("options", ctx_r0.field().options ?? \u0275\u0275pureFunction0(11, _c59))("checkmark", (tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.checkmark)("checkbox", (tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0.checkbox)("multiple", (tmp_8_0 = ctx_r0.field().props) == null ? null : tmp_8_0.multiple);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_30_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-treeselect", 29);
  }
  if (rf & 2) {
    let tmp_7_0;
    let tmp_8_0;
    let tmp_9_0;
    let tmp_10_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("options", ctx_r0.field().treeNodeOptions ?? \u0275\u0275pureFunction0(12, _c59))("placeholder", ctx_r0.field().placeholder || "")("containerStyleClass", ctx_r0.fieldClasses())("appendTo", ((tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0.appendTo) ?? "body")("selectionMode", ((tmp_8_0 = ctx_r0.field().props) == null ? null : tmp_8_0.selectionMode) ?? "single")("showClear", (tmp_9_0 = ctx_r0.field().props) == null ? null : tmp_9_0.showClear)("filter", (tmp_10_0 = ctx_r0.field().props) == null ? null : tmp_10_0.filter);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 26);
  }
  if (rf & 2) {
    const item_r12 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.listItemTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c68, item_r12.original));
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 76);
  }
  if (rf & 2) {
    const item_r12 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275classMap(\u0275\u0275interpolate1("pi pi-", item_r12.icon, " mt-2 mr-2 !text-2xl"));
    \u0275\u0275property("ngStyle", item_r12.iconStyle);
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 74);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r12 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r12.title);
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 69);
    \u0275\u0275conditionalCreate(1, DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_2_Conditional_1_Template, 1, 4, "i", 73);
    \u0275\u0275elementStart(2, "div", 36);
    \u0275\u0275conditionalCreate(3, DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_2_Conditional_3_Template, 2, 1, "span", 74);
    \u0275\u0275elementStart(4, "span", 75);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const item_r12 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275conditional(item_r12.icon ? 1 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(item_r12.title ? 3 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r12.display);
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 77);
    \u0275\u0275listener("click", function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_4_Template_span_click_0_listener() {
      \u0275\u0275restoreView(_r13);
      const ctx_r13 = \u0275\u0275nextContext();
      const item_r12 = ctx_r13.$implicit;
      const \u0275$index_140_r15 = ctx_r13.$index;
      const ctx_r0 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r0.triggerEditItem(item_r12, \u0275$index_140_r15));
    })("keydown.enter", function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_4_Template_span_keydown_enter_0_listener() {
      \u0275\u0275restoreView(_r13);
      const ctx_r13 = \u0275\u0275nextContext();
      const item_r12 = ctx_r13.$implicit;
      const \u0275$index_140_r15 = ctx_r13.$index;
      const ctx_r0 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r0.triggerEditItem(item_r12, \u0275$index_140_r15));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const \u0275$index_140_r15 = \u0275\u0275nextContext().$index;
    \u0275\u0275attribute("aria-label", "Edit item " + (\u0275$index_140_r15 + 1));
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 78);
    \u0275\u0275listener("click", function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_5_Template_span_click_0_listener() {
      \u0275\u0275restoreView(_r16);
      const \u0275$index_140_r15 = \u0275\u0275nextContext().$index;
      const ctx_r0 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r0.triggerDeleteItem(\u0275$index_140_r15));
    })("keydown.enter", function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_5_Template_span_keydown_enter_0_listener() {
      \u0275\u0275restoreView(_r16);
      const \u0275$index_140_r15 = \u0275\u0275nextContext().$index;
      const ctx_r0 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r0.triggerDeleteItem(\u0275$index_140_r15));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const \u0275$index_140_r15 = \u0275\u0275nextContext().$index;
    \u0275\u0275attribute("aria-label", "Delete item " + (\u0275$index_140_r15 + 1));
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 68);
    \u0275\u0275conditionalCreate(1, DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_1_Template, 1, 4, "ng-container", 26)(2, DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_2_Template, 6, 3, "span", 69);
    \u0275\u0275elementStart(3, "div", 70);
    \u0275\u0275conditionalCreate(4, DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_4_Template, 1, 1, "span", 71);
    \u0275\u0275conditionalCreate(5, DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Conditional_5_Template, 1, 1, "span", 72);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_15_0;
    let tmp_16_0;
    const ctx_r0 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.listItemTemplate() ? 1 : 2);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(((tmp_15_0 = ctx_r0.modalConfig()) == null ? null : tmp_15_0.showEditButton) ?? false ? 4 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(((tmp_16_0 = ctx_r0.modalConfig()) == null ? null : tmp_16_0.showDeleteButton) ?? true ? 5 : -1);
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 65);
    \u0275\u0275repeaterCreate(1, DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_For_2_Template, 6, 3, "div", 68, _forTrack05);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r0.listItems());
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 66);
    \u0275\u0275text(1, "No items added.");
    \u0275\u0275elementEnd();
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-button", 79);
    \u0275\u0275listener("onClick", function DynamicFieldComponent_Conditional_0_Case_31_Conditional_3_Template_p_button_onClick_0_listener() {
      \u0275\u0275restoreView(_r17);
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.triggerAddItem());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275property("label", ctx_r0.getAddButtonLabel());
  }
}
function DynamicFieldComponent_Conditional_0_Case_31_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 30);
    \u0275\u0275conditionalCreate(1, DynamicFieldComponent_Conditional_0_Case_31_Conditional_1_Template, 3, 0, "div", 65)(2, DynamicFieldComponent_Conditional_0_Case_31_Conditional_2_Template, 2, 0, "div", 66);
    \u0275\u0275conditionalCreate(3, DynamicFieldComponent_Conditional_0_Case_31_Conditional_3_Template, 1, 1, "p-button", 67);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_3_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.listItems().length > 0 ? 1 : 2);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(((tmp_3_0 = ctx_r0.modalConfig()) == null ? null : tmp_3_0.showAddButton) ?? true ? 3 : -1);
  }
}
function DynamicFieldComponent_Conditional_0_Case_32_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-event-filter-field", 80);
  }
  if (rf & 2) {
    let tmp_6_0;
    let tmp_7_0;
    let tmp_8_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("ngClass", ctx_r0.field().inputStyleClass)("groupTypes", ((tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.groupTypes) ?? \u0275\u0275pureFunction0(11, _c59))("filterService", ((tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0.filterService) ?? ctx_r0.filterService)("requireActorBeforeAction", ((tmp_8_0 = ctx_r0.field().props) == null ? null : tmp_8_0.requireActorBeforeAction) ?? true);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_33_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-asset-filter-field", 81);
  }
  if (rf & 2) {
    let tmp_6_0;
    let tmp_7_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("ngClass", ctx_r0.field().inputStyleClass)("allowedAssetTypes", ((tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.allowedAssetTypes) ?? \u0275\u0275pureFunction0(11, _c59))("ownerId", ((tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0.ownerId) ?? "")("readonly", ctx_r0.field().readonly ?? false);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_34_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-zone-filter-field", 82);
  }
  if (rf & 2) {
    let tmp_6_0;
    let tmp_7_0;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("ngClass", ctx_r0.field().inputStyleClass)("ownerId", ((tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0["ownerId"]) ?? "")("multi", ((tmp_7_0 = ctx_r0.field().props) == null ? null : tmp_7_0["multi"]) !== false)("readonly", ctx_r0.field().readonly ?? false)("placeholder", ctx_r0.field().placeholder ?? "Enter zone name...");
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 26);
  }
  if (rf & 2) {
    const item_r19 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext(4);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.listItemTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c68, item_r19.original));
  }
}
function DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i");
  }
  if (rf & 2) {
    const item_r19 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275classMap(\u0275\u0275interpolate1("pi pi-", item_r19.icon, " mt-2 mr-2 !text-xl"));
  }
}
function DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Conditional_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 74);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r19 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r19.title);
  }
}
function DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 69);
    \u0275\u0275conditionalCreate(1, DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Conditional_2_Conditional_1_Template, 1, 3, "i", 86);
    \u0275\u0275elementStart(2, "div", 36);
    \u0275\u0275conditionalCreate(3, DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Conditional_2_Conditional_3_Template, 2, 1, "span", 74);
    \u0275\u0275elementStart(4, "span", 75);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const item_r19 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275conditional(item_r19.icon ? 1 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(item_r19.title ? 3 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(item_r19.display);
  }
}
function DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 68);
    \u0275\u0275conditionalCreate(1, DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Conditional_1_Template, 1, 4, "ng-container", 26)(2, DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Conditional_2_Template, 6, 3, "span", 69);
    \u0275\u0275elementStart(3, "div", 85)(4, "span", 78);
    \u0275\u0275listener("click", function DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Template_span_click_4_listener() {
      const \u0275$index_191_r20 = \u0275\u0275restoreView(_r18).$index;
      const ctx_r0 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r0.handleSplitButtonListItemDelete(\u0275$index_191_r20));
    })("keydown.enter", function DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Template_span_keydown_enter_4_listener() {
      const \u0275$index_191_r20 = \u0275\u0275restoreView(_r18).$index;
      const ctx_r0 = \u0275\u0275nextContext(4);
      return \u0275\u0275resetView(ctx_r0.handleSplitButtonListItemDelete(\u0275$index_191_r20));
    });
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const \u0275$index_191_r20 = ctx.$index;
    const ctx_r0 = \u0275\u0275nextContext(4);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.listItemTemplate() ? 1 : 2);
    \u0275\u0275advance(3);
    \u0275\u0275attribute("aria-label", "Delete item " + (\u0275$index_191_r20 + 1));
  }
}
function DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 65);
    \u0275\u0275repeaterCreate(1, DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_For_2_Template, 5, 2, "div", 68, _forTrack05);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r0.listItems());
  }
}
function DynamicFieldComponent_Conditional_0_Case_35_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 83);
    \u0275\u0275text(1, "No items added.");
    \u0275\u0275elementEnd();
  }
}
function DynamicFieldComponent_Conditional_0_Case_35_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 30);
    \u0275\u0275conditionalCreate(1, DynamicFieldComponent_Conditional_0_Case_35_Conditional_1_Template, 3, 0, "div", 65)(2, DynamicFieldComponent_Conditional_0_Case_35_Conditional_2_Template, 2, 0, "div", 83);
    \u0275\u0275element(3, "p-splitbutton", 84);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.listItems().length > 0 ? 1 : 2);
    \u0275\u0275advance(2);
    \u0275\u0275property("label", ctx_r0.getAddButtonLabel())("model", ctx_r0.splitButtonTreeModel);
  }
}
function DynamicFieldComponent_Conditional_0_Case_36_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "app-icon-selector", 87);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control());
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Case_37_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "p-toggleswitch", 15);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(ctx_r0.fieldClasses());
    \u0275\u0275property("id", ctx_r0.fieldKey())("formControl", ctx_r0.control())("ngClass", ctx_r0.field().inputStyleClass);
    \u0275\u0275attribute("aria-label", ctx_r0.fieldLabel())("aria-invalid", ctx_r0.showError())("aria-describedby", ctx_r0.fieldKey() + "-error");
  }
}
function DynamicFieldComponent_Conditional_0_Conditional_39_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "small", 37);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.errorMessage());
  }
}
function DynamicFieldComponent_Conditional_0_Conditional_40_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "small", 38);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.field().hint);
  }
}
function DynamicFieldComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3)(1, "label", 4)(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(4, DynamicFieldComponent_Conditional_0_Conditional_4_Template, 2, 1, "span", 5);
    \u0275\u0275conditionalCreate(5, DynamicFieldComponent_Conditional_0_Conditional_5_Template, 2, 0, "span", 6);
    \u0275\u0275conditionalCreate(6, DynamicFieldComponent_Conditional_0_Conditional_6_Template, 1, 2, "i", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(7, DynamicFieldComponent_Conditional_0_Conditional_7_Template, 2, 0, "div", 8);
    \u0275\u0275elementStart(8, "div", 9)(9, "div");
    \u0275\u0275conditionalCreate(10, DynamicFieldComponent_Conditional_0_Case_10_Template, 1, 9, "input", 10)(11, DynamicFieldComponent_Conditional_0_Case_11_Template, 1, 11, "p-inputnumber", 11)(12, DynamicFieldComponent_Conditional_0_Case_12_Template, 1, 13, "p-select", 12)(13, DynamicFieldComponent_Conditional_0_Case_13_Template, 1, 11, "p-multiSelect", 13)(14, DynamicFieldComponent_Conditional_0_Case_14_Template, 1, 12, "p-datepicker", 14)(15, DynamicFieldComponent_Conditional_0_Case_15_Template, 1, 6, "p-checkbox", 15)(16, DynamicFieldComponent_Conditional_0_Case_16_Template, 2, 0)(17, DynamicFieldComponent_Conditional_0_Case_17_Template, 1, 11, "textarea", 16)(18, DynamicFieldComponent_Conditional_0_Case_18_Template, 1, 10, "p-slider", 17)(19, DynamicFieldComponent_Conditional_0_Case_19_Template, 1, 8, "p-togglebutton", 18)(20, DynamicFieldComponent_Conditional_0_Case_20_Template, 10, 15, "div", 19)(21, DynamicFieldComponent_Conditional_0_Case_21_Template, 1, 10, "p-knob", 20)(22, DynamicFieldComponent_Conditional_0_Case_22_Template, 1, 10, "p-editor", 21)(23, DynamicFieldComponent_Conditional_0_Case_23_Template, 1, 8, "p-fileUpload", 22)(24, DynamicFieldComponent_Conditional_0_Case_24_Template, 1, 10, "p-password", 23)(25, DynamicFieldComponent_Conditional_0_Case_25_Template, 1, 8, "p-inputMask", 24)(26, DynamicFieldComponent_Conditional_0_Case_26_Template, 1, 8, "p-rating", 25)(27, DynamicFieldComponent_Conditional_0_Case_27_Template, 1, 5, "ng-container", 26)(28, DynamicFieldComponent_Conditional_0_Case_28_Template, 5, 19, "div", 27)(29, DynamicFieldComponent_Conditional_0_Case_29_Template, 1, 12, "p-listbox", 28)(30, DynamicFieldComponent_Conditional_0_Case_30_Template, 1, 13, "p-treeselect", 29)(31, DynamicFieldComponent_Conditional_0_Case_31_Template, 4, 2, "div", 30)(32, DynamicFieldComponent_Conditional_0_Case_32_Template, 1, 12, "app-event-filter-field", 31)(33, DynamicFieldComponent_Conditional_0_Case_33_Template, 1, 12, "app-asset-filter-field", 32)(34, DynamicFieldComponent_Conditional_0_Case_34_Template, 1, 12, "app-zone-filter-field", 33)(35, DynamicFieldComponent_Conditional_0_Case_35_Template, 4, 3, "div", 30)(36, DynamicFieldComponent_Conditional_0_Case_36_Template, 1, 7, "app-icon-selector", 34)(37, DynamicFieldComponent_Conditional_0_Case_37_Template, 1, 8, "p-toggleswitch", 35);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(38, "div", 36);
    \u0275\u0275conditionalCreate(39, DynamicFieldComponent_Conditional_0_Conditional_39_Template, 2, 1, "small", 37);
    \u0275\u0275conditionalCreate(40, DynamicFieldComponent_Conditional_0_Conditional_40_Template, 2, 1, "small", 38);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    let tmp_6_0;
    let tmp_8_0;
    let tmp_11_0;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(15, _c027, ctx_r0.field().styleClass ?? "p-2", ctx_r0.field().layout === "horizontal" ? "flex align-items-center gap-2" : ""));
    \u0275\u0275advance();
    \u0275\u0275classProp("p-error", ctx_r0.showError());
    \u0275\u0275property("for", ctx_r0.fieldKey())("ngClass", \u0275\u0275pureFunction2(18, _c127, ctx_r0.labelWidth() ? "w-" + ctx_r0.labelWidth() : "", ctx_r0.field().type === "modalList" ? "items-start" : "items-center"));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.fieldLabel());
    \u0275\u0275advance();
    \u0275\u0275conditional(((tmp_6_0 = ctx_r0.field().props) == null ? null : tmp_6_0.suffix) ? 4 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.field().required ? 5 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(((tmp_8_0 = ctx_r0.field().props) == null ? null : tmp_8_0["tooltip"]) ? 6 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.field().loading ? 7 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275classProp("flex-grow-1", ctx_r0.isHorizontal());
    \u0275\u0275advance();
    \u0275\u0275conditional((tmp_11_0 = ctx_r0.field().type) === "text" ? 10 : tmp_11_0 === "number" ? 11 : tmp_11_0 === "dropdown" ? 12 : tmp_11_0 === "multiselect" ? 13 : tmp_11_0 === "date" ? 14 : tmp_11_0 === "checkbox" ? 15 : tmp_11_0 === "radio" ? 16 : tmp_11_0 === "textarea" ? 17 : tmp_11_0 === "slider" ? 18 : tmp_11_0 === "toggleButton" ? 19 : tmp_11_0 === "colorPicker" ? 20 : tmp_11_0 === "knob" ? 21 : tmp_11_0 === "editor" ? 22 : tmp_11_0 === "file" ? 23 : tmp_11_0 === "password" ? 24 : tmp_11_0 === "mask" ? 25 : tmp_11_0 === "rating" ? 26 : tmp_11_0 === "custom" ? 27 : tmp_11_0 === "autocomplete" ? 28 : tmp_11_0 === "listbox" ? 29 : tmp_11_0 === "treeselect" ? 30 : tmp_11_0 === "modalList" ? 31 : tmp_11_0 === "eventFilter" ? 32 : tmp_11_0 === "assetFilter" ? 33 : tmp_11_0 === "zoneFilter" ? 34 : tmp_11_0 === "treeSplitButtonList" ? 35 : tmp_11_0 === "icon-selector" ? 36 : tmp_11_0 === "toggle-switch" ? 37 : -1);
    \u0275\u0275advance(29);
    \u0275\u0275conditional(ctx_r0.showError() ? 39 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.field().hint ? 40 : -1);
  }
}
var DynamicFieldComponent = class _DynamicFieldComponent {
  destroyRef = inject(DestroyRef);
  field = input.required(...ngDevMode ? [{ debugName: "field" }] : []);
  control = input.required(...ngDevMode ? [{ debugName: "control" }] : []);
  customTemplate = input(...ngDevMode ? [void 0, { debugName: "customTemplate" }] : []);
  fieldChange = output();
  // --- Outputs for list actions ---
  addItem = output();
  editItem = output();
  deleteItem = output();
  formState = signal({ invalid: false, dirty: false, touched: false }, ...ngDevMode ? [{ debugName: "formState" }] : []);
  fieldKey = computed(() => this.field().key, ...ngDevMode ? [{ debugName: "fieldKey" }] : []);
  fieldLabel = computed(() => this.field().label, ...ngDevMode ? [{ debugName: "fieldLabel" }] : []);
  fieldType = computed(() => this.field().type, ...ngDevMode ? [{ debugName: "fieldType" }] : []);
  fieldLayout = computed(() => this.field().layout, ...ngDevMode ? [{ debugName: "fieldLayout" }] : []);
  fieldProps = computed(() => {
    const props = this.field().props;
    return isObject(props) ? props : {};
  }, ...ngDevMode ? [{ debugName: "fieldProps" }] : []);
  treeNodeOptions = computed(() => this.field().treeNodeOptions, ...ngDevMode ? [{ debugName: "treeNodeOptions" }] : []);
  fieldOptions = computed(() => {
    const options = this.field().options;
    return Array.isArray(options) ? options : [];
  }, ...ngDevMode ? [{ debugName: "fieldOptions" }] : []);
  isHorizontal = computed(() => this.fieldLayout() === "horizontal", ...ngDevMode ? [{ debugName: "isHorizontal" }] : []);
  labelWidth = computed(() => {
    const field = this.field();
    return this.isHorizontal() && isDefined(field.labelWidth) && isString(field.labelWidth) ? field.labelWidth : "200px";
  }, ...ngDevMode ? [{ debugName: "labelWidth" }] : []);
  showError = computed(() => {
    const state = this.formState();
    return state.invalid && (state.dirty || state.touched);
  }, ...ngDevMode ? [{ debugName: "showError" }] : []);
  errorMessage = computed(() => {
    const validations = this.field().validations;
    const errors = this.control().errors;
    if (!isObject(errors))
      return "";
    if (!Array.isArray(validations)) {
      if (isDefined(errors["invalidTimeFormat"]))
        return "Invalid time format (HH:mm required)";
      return "Invalid value";
    }
    const errorRule = validations.find((v2) => isDefined(v2) && isString(v2.name) && hasProperty(errors, v2.name));
    if (isDefined(errorRule) && isString(errorRule.message)) {
      return errorRule.message;
    }
    if (isDefined(errors["invalidTimeFormat"]))
      return "Invalid time format (HH:mm required)";
    return "Invalid value";
  }, ...ngDevMode ? [{ debugName: "errorMessage" }] : []);
  // Helper method to evaluate loading state (supports both boolean and function)
  isFieldLoading = computed(() => this.resolveLoadingState(this.field().loading), ...ngDevMode ? [{ debugName: "isFieldLoading" }] : []);
  // Helper method to evaluate autocomplete-specific loading state
  isAutocompleteLoading = computed(() => this.resolveLoadingState(this.field().autocompleteLoading), ...ngDevMode ? [{ debugName: "isAutocompleteLoading" }] : []);
  resolveLoadingState(loading) {
    return typeof loading === "function" ? loading() : loading === true;
  }
  fieldClasses = computed(() => {
    const field = this.field();
    const baseClass = isString(field.inputStyleClass) ? field.inputStyleClass : "w-full";
    const isInvalid = this.showError();
    const isDisabled = isDefined(field) && (hasProperty(field, "disabled") && field.disabled === true || this.isFieldLoading() || hasProperty(field, "readonly") && field.readonly === true);
    const classes16 = [];
    classes16.push(baseClass);
    if (isInvalid)
      classes16.push("ng-invalid", "ng-dirty");
    if (isDisabled)
      classes16.push("p-disabled");
    return classes16.filter(isDefined).join(" ").trim();
  }, ...ngDevMode ? [{ debugName: "fieldClasses" }] : []);
  listItems = signal([], ...ngDevMode ? [{ debugName: "listItems" }] : []);
  autocompleteSearchQuery = signal("", ...ngDevMode ? [{ debugName: "autocompleteSearchQuery" }] : []);
  modalConfig = computed(() => this.field().props?.modalConfig, ...ngDevMode ? [{ debugName: "modalConfig" }] : []);
  listItemTemplate = computed(() => this.field().props?.listItemTemplate, ...ngDevMode ? [{ debugName: "listItemTemplate" }] : []);
  splitButtonTreeModel = [];
  // Signals for color picker enhancement
  defaultColorOptions = [
    { label: "Black", value: "#000000" },
    { label: "White", value: "#ffffff" },
    { label: "Red", value: "#ff0000" },
    { label: "Green", value: "#00ff00" },
    { label: "Blue", value: "#0000ff" }
  ];
  colorOptions = signal([], ...ngDevMode ? [{ debugName: "colorOptions" }] : []);
  selectedColor = signal(null, ...ngDevMode ? [{ debugName: "selectedColor" }] : []);
  manualColorInput = signal("", ...ngDevMode ? [{ debugName: "manualColorInput" }] : []);
  filterService = inject(EventFilterService);
  // Internal FormControl for date picker to handle Date objects
  internalDateControl = signal(null, ...ngDevMode ? [{ debugName: "internalDateControl" }] : []);
  activeDateControl = computed(() => {
    const isTimeOnly = this.field().props?.timeOnly ?? false;
    return isTimeOnly ? this.internalDateControl() : this.control();
  }, ...ngDevMode ? [{ debugName: "activeDateControl" }] : []);
  isUpdatingDateControl = false;
  // Prevent circular updates
  _lastControlRef = null;
  constructor() {
    effect((onCleanup) => {
      const control = this.control();
      if (isDefined(control)) {
        this.formState.set({
          invalid: control.invalid,
          dirty: control.dirty,
          touched: control.touched
        });
        const statusSub = control.statusChanges.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {
          this.formState.set({
            invalid: control.invalid,
            dirty: control.dirty,
            touched: control.touched
          });
        });
        const valueSub = control.valueChanges.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((value) => {
          this.formState.set({
            invalid: control.invalid,
            dirty: control.dirty,
            touched: control.touched
          });
          const fieldType = this.fieldType();
          const currentField = this.field();
          if (currentField.events?.onChange) {
            const hasExplicitHandler = fieldType === "dropdown" || fieldType === "autocomplete";
            if (!hasExplicitHandler) {
              currentField.events.onChange(value);
            }
          }
          if (fieldType === "modalList" || fieldType === "treeSplitButtonList") {
            const controlValue = this.control().value;
            const formatter = fieldType === "modalList" ? this.modalConfig()?.listItemFormatter : this.fieldProps().listItemFormatter;
            const items = isArray(controlValue) ? controlValue : [];
            if (isFunction(formatter)) {
              this.listItems.set(items.map((item, index) => __spreadProps(__spreadValues({}, formatter(item)), {
                original: item,
                id: `${this.fieldKey()}-${index}`
              })));
            } else if (fieldType === "modalList") {
              this.listItems.set(items.map((item, index) => ({
                id: `${this.fieldKey()}-${index}`,
                display: isObject(item) ? JSON.stringify(item) : String(item),
                original: item
              })));
            }
          } else if (this.listItems().length > 0) {
            this.listItems.set([]);
          }
          if (fieldType === "colorPicker") {
            const colorVal = this.control().value;
            this.updateColorStateAndOptions(colorVal);
            if (isDefined(colorVal) && this.manualColorInput() !== colorVal) {
              this.manualColorInput.set(colorVal);
            }
          }
        });
        onCleanup(() => {
          statusSub.unsubscribe();
          valueSub.unsubscribe();
        });
      }
    });
    effect(() => {
      if (this.fieldType() === "modalList") {
        const controlValue = this.control().value;
        const formatter = this.modalConfig()?.listItemFormatter;
        const items = isArray(controlValue) ? controlValue : [];
        if (isFunction(formatter)) {
          this.listItems.set(items.map((item, index) => __spreadProps(__spreadValues({}, formatter(item)), {
            original: item,
            // Keep original item data
            id: `${this.fieldKey()}-${index}`
            // Generate unique ID for trackBy
          })));
        } else {
          this.listItems.set(items.map((item, index) => ({
            id: `${this.fieldKey()}-${index}`,
            display: isObject(item) ? JSON.stringify(item) : String(item),
            original: item
          })));
        }
      } else if (this.fieldType() === "treeSplitButtonList") {
        const controlValue = this.control().value;
        const formatter = this.fieldProps().listItemFormatter;
        const items = isArray(controlValue) ? controlValue : [];
        if (isFunction(formatter)) {
          this.listItems.set(items.map((item, index) => __spreadProps(__spreadValues({}, formatter(item)), {
            original: item,
            // Keep original item data
            id: `${this.fieldKey()}-${index}`
            // Generate unique ID for trackBy
          })));
        }
      } else if (this.listItems().length > 0) {
        this.listItems.set([]);
      }
    });
    effect(() => {
      const type = this.fieldType();
      const treeNodes = this.treeNodeOptions() ?? [];
      if (type === "treeSplitButtonList") {
        this.splitButtonTreeModel = this.buildSplitButtonTreeModel(treeNodes);
      } else {
        this.splitButtonTreeModel = [];
      }
    });
    effect(() => {
      const control = this.control();
      const type = this.fieldType();
      if (type === "colorPicker") {
        const controlValue = control.value;
        if (!isEmpty(controlValue) && this.selectedColor() !== controlValue) {
          this.selectedColor.set(controlValue);
          this.manualColorInput.set(String(controlValue));
          const currentOpts = this.colorOptions();
          if (currentOpts.length > 0) {
            const exists = currentOpts.some((opt) => opt.value === controlValue);
            if (!exists) {
              this.colorOptions.update((options) => [
                ...options,
                { label: controlValue, value: controlValue }
              ]);
            }
          }
        } else if (controlValue === null && this.selectedColor() !== null) {
          this.selectedColor.set(null);
        }
      }
    });
    this.setupDateSyncEffect();
  }
  ngOnInit() {
    if (this.field().type === "colorPicker") {
      const propsColorOptions = this.field().props?.colorOptions;
      if (Array.isArray(propsColorOptions) && propsColorOptions.length > 0) {
        this.colorOptions.set([...propsColorOptions]);
      } else {
        this.colorOptions.set([...this.defaultColorOptions]);
      }
      const initialColor = this.control().value;
      if (isDefined(initialColor)) {
        this.manualColorInput.set(initialColor);
      }
      this.updateColorStateAndOptions(initialColor);
    }
  }
  setupDateSyncEffect() {
    let internalSub = null;
    let controlSub = null;
    effect((onCleanup) => {
      const field = this.field();
      const control = this.control();
      if (field.type === "date" && (field.props?.timeOnly ?? false)) {
        let internal = untracked(() => this.internalDateControl());
        if (!internal) {
          internal = new FormControl(null);
          this.internalDateControl.set(internal);
        }
        if (internalSub)
          internalSub.unsubscribe();
        if (controlSub)
          controlSub.unsubscribe();
        if (untracked(() => this._lastControlRef) !== control) {
          this._lastControlRef = control;
          const val = control.value;
          if (typeof val === "string" && /^\d{2}:\d{2}$/.test(val)) {
            const [h, m2] = val.split(":").map(Number);
            const d = /* @__PURE__ */ new Date();
            d.setHours(h, m2, 0, 0);
            internal.setValue(d, { emitEvent: false });
          }
        }
        internalSub = internal.valueChanges.subscribe((dateValue) => {
          if (this.isUpdatingDateControl)
            return;
          this.isUpdatingDateControl = true;
          try {
            if (dateValue instanceof Date) {
              const hours = dateValue.getHours().toString().padStart(2, "0");
              const minutes = dateValue.getMinutes().toString().padStart(2, "0");
              const timeString = `${hours}:${minutes}`;
              if (control.value !== timeString) {
                control.setValue(timeString);
                control.markAsDirty();
                control.markAsTouched();
                this.fieldChange.emit({ field, value: timeString });
              }
            } else if (control.value !== null) {
              control.setValue(null);
              control.markAsDirty();
            }
          } finally {
            this.isUpdatingDateControl = false;
          }
        });
        controlSub = control.valueChanges.subscribe((stringValue) => {
          if (this.isUpdatingDateControl)
            return;
          this.isUpdatingDateControl = true;
          try {
            if (typeof stringValue === "string" && stringValue.trim() !== "") {
              const timePattern = /^\d{2}:\d{2}$/;
              if (timePattern.test(stringValue)) {
                const [h, m2] = stringValue.split(":").map(Number);
                if (control.hasError("invalidTimeFormat")) {
                  const errors = __spreadValues({}, control.errors);
                  delete errors["invalidTimeFormat"];
                  control.setErrors(Object.keys(errors).length ? errors : null);
                }
                const current = internal?.value;
                if (current?.getHours() !== h || current.getMinutes() !== m2) {
                  const date = /* @__PURE__ */ new Date();
                  date.setHours(h, m2, 0, 0);
                  internal?.setValue(date, { emitEvent: false });
                }
              } else {
                control.setErrors(__spreadProps(__spreadValues({}, control.errors), {
                  invalidTimeFormat: true
                }));
              }
            } else if (stringValue === null && internal?.value !== null) {
              internal?.setValue(null, { emitEvent: false });
            }
          } finally {
            this.isUpdatingDateControl = false;
          }
        });
        onCleanup(() => {
          if (internalSub)
            internalSub.unsubscribe();
          if (controlSub)
            controlSub.unsubscribe();
        });
      } else {
        if (untracked(() => this.internalDateControl())) {
          this.internalDateControl.set(null);
          this._lastControlRef = null;
        }
      }
    });
  }
  buildSplitButtonTreeModel(treeNodes) {
    const buildMenuItemsWithCommands = (nodes) => nodes.map((node) => {
      const menuItem = {
        label: node.label,
        icon: node.icon,
        data: node.data ?? node
      };
      if (Array.isArray(node.children) && node.children.length > 0) {
        menuItem.items = buildMenuItemsWithCommands(node.children);
      } else if (node.selectable !== false) {
        menuItem.command = () => this.handleSplitButtonTreeItemSelect(node);
      }
      return menuItem;
    });
    return buildMenuItemsWithCommands(treeNodes);
  }
  trackByOption(_index, option) {
    if (isSelectOption(option) && (isString(option.value) || isNumber(option.value))) {
      return option.value;
    }
    return String(option);
  }
  onFileSelect(event) {
    if (isDefined(event) && isObject(event) && hasProperty(event, "files") && Array.isArray(event["files"]) && event["files"].length > 0) {
      this.control().setValue(event["files"][0]);
    }
  }
  getToggleButtonLabel(value) {
    const onLabelValue = isDefined(this.field().props?.["onLabel"]) ? String(this.field().props?.["onLabel"]) : "Yes";
    const offLabelValue = isDefined(this.field().props?.["offLabel"]) ? String(this.field().props?.["offLabel"]) : "No";
    return typeof value === "boolean" && value ? onLabelValue : offLabelValue;
  }
  onDropdownChange(event) {
    this.fieldChange.emit({ field: this.field(), value: event.value });
    const onChangeHandler = this.field().events?.onChange;
    if (isFunction(onChangeHandler)) {
      onChangeHandler(event.value);
    }
  }
  triggerAddItem() {
    if (this.fieldType() === "modalList") {
      this.addItem.emit({ field: this.field() });
    }
  }
  triggerEditItem(item, index) {
    if (this.fieldType() === "modalList") {
      this.editItem.emit({ field: this.field(), item: item.original, index });
    }
  }
  triggerDeleteItem(index) {
    if (this.fieldType() === "modalList") {
      this.deleteItem.emit({ field: this.field(), index });
    }
  }
  handleSplitButtonTreeItemSelect(selectedNode) {
    const fieldConfig = this.field();
    const control = this.control();
    let newItem;
    const transformer = fieldConfig.props?.transformTreeNodeToItem;
    if (isFunction(transformer)) {
      newItem = transformer(selectedNode);
    } else {
      newItem = selectedNode.data ?? selectedNode;
    }
    const currentItems = Array.isArray(control.value) ? [...control.value] : [];
    currentItems.push(newItem);
    control.setValue(currentItems);
    control.markAsDirty();
    control.updateValueAndValidity();
  }
  handleSplitButtonListItemDelete(index) {
    const control = this.control();
    const currentItems = Array.isArray(control.value) ? [...control.value] : [];
    currentItems.splice(index, 1);
    control.setValue(currentItems);
    control.markAsDirty();
    control.updateValueAndValidity();
  }
  // Helper for template
  getAddButtonLabel() {
    const fieldType = this.fieldType();
    const props = this.field().props;
    if (fieldType === "modalList") {
      return this.modalConfig()?.addButtonLabel ?? "Add Item";
    }
    if (fieldType === "treeSplitButtonList") {
      return props?.addButtonLabel ?? "Add from Tree";
    }
    return "Add Item";
  }
  handleAutocompleteSearch(query) {
    this.autocompleteSearchQuery.set(query);
    const onSearch = this.field().events?.onSearch;
    if (isFunction(onSearch)) {
      onSearch(query);
    }
  }
  /**
   * Handle changes to the autocomplete selection.
   * If the selected value is an object, it stringifies it before passing to onChange handler.
   * This ensures that complex objects can be handled properly by the parent form.
   * @param event The selection change event from the autocomplete component.
   * @returns void
   */
  onAutocompleteChange(event) {
    const onChange = this.field().events?.onChange;
    if (isFunction(onChange)) {
      const value = event.value;
      if (value !== null && typeof value === "object") {
        onChange(JSON.stringify(value));
      } else if (typeof value === "string" || typeof value === "number") {
        onChange(String(value));
      } else {
        onChange("");
      }
    }
  }
  onAutocompleteValueChange() {
    const control = this.control();
    if (!control.dirty) {
      control.markAsDirty();
    }
  }
  onAutocompleteBlur(event) {
    const target = event.target;
    const pendingValue = target?.value?.trim();
    const isMultiple = this.field().props?.multiple === true;
    if (pendingValue && isMultiple) {
      const control = this.control();
      const currentValue = Array.isArray(control.value) ? control.value : [];
      if (!currentValue.includes(pendingValue)) {
        control.setValue([...currentValue, pendingValue]);
        control.markAsDirty();
      }
      target.value = "";
    }
  }
  updateColorStateAndOptions(colorValue) {
    this.selectedColor.set(colorValue);
    if (typeof colorValue === "string" && !isEmpty(colorValue)) {
      const currentOpts = this.colorOptions();
      if (currentOpts.length > 0 || this.field().type === "colorPicker") {
        const exists = currentOpts.some((opt) => opt.value === colorValue);
        if (!exists) {
          this.colorOptions.update((options) => [
            ...options,
            { label: colorValue, value: colorValue }
            // Use colorValue as label for simplicity
          ]);
        }
      }
    }
  }
  onColorSelect(colorValue) {
    this.control().setValue(colorValue);
  }
  onColorPickerChange(event, control) {
    const newColor = String(event.value);
    if (isDefined(control)) {
      control.setValue(newColor);
      this.manualColorInput.set(newColor);
    }
  }
  onManualColorInputChange(value) {
    this.manualColorInput.set(value);
    const control = this.control();
    if (!isDefined(control) || !value)
      return;
    const isValidHex = (value.length === 7 || value.length === 4) && value.startsWith("#");
    const isValidRgb = value.startsWith("rgb");
    if (isValidHex || isValidRgb) {
      control.setValue(value);
    }
  }
  getDateControl() {
    return this.activeDateControl() ?? this.control();
  }
  getSuggestions() {
    const suggestions = this.field().props?.suggestions;
    if (isFunction(suggestions)) {
      return suggestions();
    }
    return suggestions ?? [];
  }
  getAutocompleteDisplayText(option) {
    if (isNullOrUndefined(option))
      return "";
    const field = this.field();
    const optionLabel = field.props?.field;
    if (isDefined(optionLabel)) {
      const value = option[optionLabel];
      return String(value ?? "");
    }
    return String(option);
  }
  static \u0275fac = function DynamicFieldComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DynamicFieldComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _DynamicFieldComponent, selectors: [["app-dynamic-field"]], inputs: { field: [1, "field"], control: [1, "control"], customTemplate: [1, "customTemplate"] }, outputs: { fieldChange: "fieldChange", addItem: "addItem", editItem: "editItem", deleteItem: "deleteItem" }, decls: 1, vars: 1, consts: [["op", ""], ["autocompleteRef", ""], ["item", ""], [3, "ngClass"], [3, "for", "ngClass"], [1, "pl-1.5", "text-sm", "opacity-60"], [1, "p-error"], ["tooltipPosition", "top", 1, "pi", "pi-question-circle", "text-xs", "opacity-60", "cursor-help", 3, "pTooltip", "escape"], [1, "p-field-loading"], [1, "flex", "flex-col", "w-full"], ["pInputText", "", 3, "id", "formControl", "placeholder", "readonly", "class"], [3, "id", "formControl", "showButtons", "minFractionDigits", "maxFractionDigits", "step", "class"], [3, "id", "formControl", "options", "placeholder", "showClear", "filter", "filterBy", "class", "appendTo"], [3, "id", "formControl", "options", "placeholder", "filter", "class", "appendTo"], [3, "id", "formControl", "dateFormat", "showTime", "showSeconds", "showIcon", "timeOnly", "appendTo", "styleClass"], [3, "id", "formControl", "ngClass"], ["pTextarea", "", 3, "id", "formControl", "rows", "autoResize", "placeholder", "class", "readOnly"], [3, "id", "formControl", "min", "max", "step", "class"], [3, "id", "formControl", "onLabel", "offLabel", "ngClass"], [1, "flex", "flex-row", "gap-2", "items-center", "w-full"], [3, "id", "formControl", "min", "max", "step", "size", "ngClass"], [3, "id", "formControl", "modules", "class"], ["mode", "basic", "chooseLabel", "Choose", 3, "id", "maxFileSize", "accept", "class"], ["inputStyleClass", "w-full", "styleClass", "w-full", 3, "id", "formControl", "feedback", "toggleMask", "class", "autocomplete"], [3, "id", "formControl", "mask", "class"], [3, "id", "formControl", "stars", "class"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "relative"], [3, "id", "formControl", "options", "checkmark", "checkbox", "multiple", "class"], ["filterMode", "strict", 3, "id", "formControl", "options", "placeholder", "containerStyleClass", "appendTo", "selectionMode", "showClear", "filter"], [1, "dynamic-field-list-container"], [3, "id", "formControl", "class", "ngClass", "groupTypes", "filterService", "requireActorBeforeAction"], [3, "id", "formControl", "class", "ngClass", "allowedAssetTypes", "ownerId", "readonly"], [3, "id", "formControl", "class", "ngClass", "ownerId", "multi", "readonly", "placeholder"], [3, "id", "formControl", "class"], [3, "id", "formControl", "class", "ngClass"], [1, "flex", "flex-col"], ["aria-live", "polite", 1, "p-error"], [1, "p-hint", "form-text", "muted", "text-xs", "mt-1"], ["strokeWidth", "2", "ariaLabel", "loading", 1, "w-[20px]", "h-[20px]"], ["pInputText", "", 3, "id", "formControl", "placeholder", "readonly"], [3, "id", "formControl", "showButtons", "minFractionDigits", "maxFractionDigits", "step"], [3, "onChange", "id", "formControl", "options", "placeholder", "showClear", "filter", "filterBy", "appendTo"], [3, "id", "formControl", "options", "placeholder", "filter", "appendTo"], [3, "id", "formControl", "value", "ngClass"], [1, "ml-2", 3, "for"], ["pTextarea", "", 3, "id", "formControl", "rows", "autoResize", "placeholder", "readOnly"], [3, "id", "formControl", "min", "max", "step"], [1, "w-6", "h-6", "rounded", "border", "cursor-pointer", "flex-shrink-0", "dynamic-color-swatch", 3, "click", "keydown.enter", "ngStyle"], [1, "flex", "flex-col", "gap-3", "p-2"], [3, "onChange", "formControl", "inline", "format"], ["pInputText", "", "placeholder", "Hex or RGB", 1, "w-full", "text-sm", 3, "ngModelChange", "id", "ngModel"], ["placeholder", "Select a color or pick one", "appendTo", "body", 3, "ngModelChange", "onChange", "id", "options", "ngModel", "styleClass"], ["pTemplate", "item"], ["pTemplate", "selectedItem"], [1, "flex", "gap-2", "items-center"], [1, "w-4", "h-4", "border", "dynamic-color-swatch", 3, "ngStyle"], [3, "id", "formControl", "modules"], ["mode", "basic", "chooseLabel", "Choose", 3, "onSelect", "id", "maxFileSize", "accept"], ["inputStyleClass", "w-full", "styleClass", "w-full", 3, "id", "formControl", "feedback", "toggleMask", "autocomplete"], [3, "id", "formControl", "mask"], [3, "id", "formControl", "stars"], ["inputStyleClass", "w-full", 3, "completeMethod", "onSelect", "onChange", "onUnselect", "onInput", "onKeyUp", "onBlur", "id", "formControl", "suggestions", "forceSelection", "optionLabel", "placeholder", "completeOnFocus", "readonly", "typeahead", "multiple", "delay", "emptyMessage", "dropdown", "appendTo"], [1, "autocomplete-item", 3, "innerHTML"], [3, "id", "formControl", "options", "checkmark", "checkbox", "multiple"], [1, "list-items-display", "border", "p-2", "mb-2", "rounded", "min-h-[50px]"], [1, "mb-2", "italic", "text-gray-500"], ["type", "button", "icon", "pi pi-plus", "severity", "secondary", 3, "label"], [1, "flex", "flex-row", "justify-between", "items-center", "p-2", "my-4", "border-b", "last:border-b-0"], [1, "flex", "flex-row", "gap-4", "items-center"], [1, "flex", "gap-2", "ml-4", "list-item-actions"], [1, "pi", "pi-pen-to-square", "action", "hover", "!text-xl"], [1, "pi", "pi-trash", "action", "hover", "!text-xl"], [3, "class", "ngStyle"], [1, "font-medium"], [1, "text-sm", "whitespace-pre-line", "muted"], [3, "ngStyle"], [1, "pi", "pi-pen-to-square", "action", "hover", "!text-xl", 3, "click", "keydown.enter"], [1, "pi", "pi-trash", "action", "hover", "!text-xl", 3, "click", "keydown.enter"], ["type", "button", "icon", "pi pi-plus", "severity", "secondary", 3, "onClick", "label"], [3, "id", "formControl", "ngClass", "groupTypes", "filterService", "requireActorBeforeAction"], [3, "id", "formControl", "ngClass", "allowedAssetTypes", "ownerId", "readonly"], [3, "id", "formControl", "ngClass", "ownerId", "multi", "readonly", "placeholder"], [1, "mb-2", "italic"], ["severity", "secondary", "appendTo", "body", 3, "label", "model"], [1, "list-item-actions"], [3, "class"], [3, "id", "formControl"]], template: function DynamicFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275conditionalCreate(0, DynamicFieldComponent_Conditional_0_Template, 41, 21, "div", 3);
    }
    if (rf & 2) {
      \u0275\u0275conditional(!ctx.field().hidden ? 0 : -1);
    }
  }, dependencies: [
    CommonModule,
    NgClass,
    NgTemplateOutlet,
    NgStyle,
    ReactiveFormsModule,
    DefaultValueAccessor,
    NgControlStatus,
    FormControlDirective,
    InputTextModule,
    InputText,
    InputNumberModule,
    InputNumber,
    PrimeTemplate,
    MultiSelectModule,
    MultiSelect,
    CheckboxModule,
    Checkbox,
    RadioButtonModule,
    RadioButton,
    TextareaModule,
    Textarea,
    DatePickerModule,
    DatePicker,
    FileUploadModule,
    FileUpload,
    PasswordModule,
    Password,
    InputMaskModule,
    InputMask,
    ColorPickerModule,
    ColorPicker,
    SliderModule,
    Slider,
    RatingModule,
    Rating,
    ChipModule,
    EditorModule,
    Editor,
    KeyFilterModule,
    MessageModule,
    ToggleButtonModule,
    ToggleButton,
    KnobModule,
    Knob,
    SelectModule,
    Select,
    ProgressSpinnerModule,
    ProgressSpinner,
    AutoCompleteModule,
    AutoComplete,
    ListboxModule,
    Listbox,
    TreeSelectModule,
    TreeSelect,
    TooltipModule,
    Tooltip,
    ButtonModule,
    Button,
    EventFilterFieldComponent,
    AssetFilterFieldComponent,
    ZoneFilterFieldComponent,
    SplitButtonModule,
    SplitButton,
    FormsModule,
    NgModel,
    ToggleSwitchModule,
    ToggleSwitch,
    IconSelectorComponent,
    PopoverModule,
    Popover,
    HighlightPipe
  ], styles: ["\n\n.p-error[_ngcontent-%COMP%] {\n  color: var(--p-inputtext-invalid-border-color);\n}\n.autocomplete-item[_ngcontent-%COMP%] {\n  padding: 0.5rem;\n  cursor: pointer;\n}\n.dynamic-color-swatch[_ngcontent-%COMP%] {\n  background-color: var(--swatch-color, #ffffff);\n}\n/*# sourceMappingURL=dynamic-field.component.css.map */"] });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamicFieldComponent, [{
    type: Component,
    args: [{ selector: "app-dynamic-field", imports: [
      CommonModule,
      ReactiveFormsModule,
      InputTextModule,
      InputNumberModule,
      MultiSelectModule,
      CheckboxModule,
      RadioButtonModule,
      TextareaModule,
      DatePickerModule,
      FileUploadModule,
      PasswordModule,
      InputMaskModule,
      ColorPickerModule,
      SliderModule,
      RatingModule,
      ChipModule,
      EditorModule,
      KeyFilterModule,
      MessageModule,
      ToggleButtonModule,
      KnobModule,
      SelectModule,
      ProgressSpinnerModule,
      AutoCompleteModule,
      ListboxModule,
      TreeSelectModule,
      TooltipModule,
      ButtonModule,
      EventFilterFieldComponent,
      AssetFilterFieldComponent,
      ZoneFilterFieldComponent,
      SplitButtonModule,
      FormsModule,
      ToggleSwitchModule,
      IconSelectorComponent,
      HighlightPipe,
      PopoverModule
    ], template: `@if (!field().hidden) {
  <div
    [ngClass]="[
      'p-field',
      field().styleClass ?? 'p-2',
      field().layout === 'horizontal' ? 'flex align-items-center gap-2' : '',
    ]"
  >
    <label
      [for]="fieldKey()"
      [class.p-error]="showError()"
      [ngClass]="[
        'form-label',
        labelWidth() ? 'w-' + labelWidth() : '',
        'flex-shrink-0',
        'flex gap-1',
        field().type === 'modalList' ? 'items-start' : 'items-center',
      ]"
    >
      <span>{{ fieldLabel() }}</span>
      @if (field().props?.suffix) {
        <span class="pl-1.5 text-sm opacity-60">
          {{ field().props?.suffix }}
        </span>
      }
      @if (field().required) {
        <span class="p-error"> *</span>
      }
      @if (field().props?.['tooltip']) {
        <i
          class="pi pi-question-circle text-xs opacity-60 cursor-help"
          [pTooltip]="$any(field().props?.['tooltip'])"
          tooltipPosition="top"
          [escape]="false"
        ></i>
      }
    </label>

    @if (field().loading) {
      <div class="p-field-loading">
        <p-progress-spinner
          strokeWidth="2"
          class="w-[20px] h-[20px]"
          ariaLabel="loading"
        />
      </div>
    }

    <div class="flex flex-col w-full">
      <div [class.flex-grow-1]="isHorizontal()">
        @switch (field().type) {
          @case ('text') {
            <input
              pInputText
              [id]="fieldKey()"
              [formControl]="control()"
              [placeholder]="field().placeholder || ''"
              [readonly]="field().readonly"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('number') {
            <p-inputnumber
              [id]="fieldKey()"
              [formControl]="control()"
              [showButtons]="field().props?.showButtons"
              [minFractionDigits]="field().props?.minFractionDigits ?? 0"
              [maxFractionDigits]="field().props?.maxFractionDigits ?? 20"
              [step]="field().props?.step ?? 1"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('dropdown') {
            <p-select
              [id]="fieldKey()"
              [formControl]="control()"
              [options]="field().options"
              [placeholder]="field().placeholder || ''"
              [showClear]="field().props?.showClear"
              [filter]="true"
              [filterBy]="field().props?.filterBy ?? 'label'"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
              [appendTo]="field().props?.appendTo ?? 'body'"
              (onChange)="onDropdownChange($event)"
            />
          }
          @case ('multiselect') {
            <p-multiSelect
              [id]="fieldKey()"
              [formControl]="control()"
              [options]="field().options"
              [placeholder]="field().placeholder || ''"
              [filter]="field().props?.filter"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
              [appendTo]="field().props?.appendTo"
            />
          }
          @case ('date') {
            <p-datepicker
              [id]="fieldKey()"
              [formControl]="getDateControl()"
              [dateFormat]="field().props?.dateFormat"
              [showTime]="field().props?.showTime || false"
              [showSeconds]="field().props?.showSeconds"
              [showIcon]="true"
              [timeOnly]="field().props?.timeOnly"
              [appendTo]="field().props?.appendTo"
              [styleClass]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('checkbox') {
            <p-checkbox
              [id]="fieldKey()"
              [formControl]="control()"
              [ngClass]="field().inputStyleClass"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('radio') {
            @for (
              option of field().options;
              track trackByOption($index, option)
            ) {
              <p-radioButton
                [id]="fieldKey() + $index"
                [formControl]="control()"
                [value]="option.value"
                [ngClass]="field().inputStyleClass"
                [attr.aria-label]="fieldLabel()"
                [attr.aria-invalid]="showError()"
                [attr.aria-describedby]="fieldKey() + '-error'"
              />
              <label [for]="fieldKey()" class="ml-2">{{ option.label }}</label>
            }
          }
          @case ('textarea') {
            <textarea
              pTextarea
              [id]="fieldKey()"
              [formControl]="control()"
              [rows]="field().props?.['rows'] || 3"
              [autoResize]="field().props?.autoResize"
              [placeholder]="field().placeholder || ''"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
              [readOnly]="field().readonly"
            ></textarea>
          }
          @case ('slider') {
            <p-slider
              [id]="fieldKey()"
              [formControl]="control()"
              [min]="field().props?.min || 0"
              [max]="field().props?.max || 100"
              [step]="field().props?.step || 1"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('toggleButton') {
            <p-togglebutton
              [id]="fieldKey()"
              [formControl]="control()"
              [onLabel]="getToggleButtonLabel(true)"
              [offLabel]="getToggleButtonLabel(false)"
              [ngClass]="field().inputStyleClass"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('colorPicker') {
            <div class="flex flex-row gap-2 items-center w-full">
              <!-- Trigger Swatch for Popover -->
              <!--  eslint-disable-next-line @angular-eslint/template/no-inline-styles -->
              <div
                class="w-6 h-6 rounded border cursor-pointer flex-shrink-0 dynamic-color-swatch"
                [ngStyle]="{ '--swatch-color': control().value || '#ffffff' }"
                (click)="op.toggle($event)"
                (keydown.enter)="op.toggle($event)"
                [attr.aria-label]="'Open color picker for ' + fieldLabel()"
              ></div>

              <p-popover #op>
                <div class="flex flex-col gap-3 p-2">
                  <p-colorpicker
                    [formControl]="control()"
                    [inline]="true"
                    [format]="field().props?.['format'] || 'hex'"
                    (onChange)="onColorPickerChange($event, control())"
                  />
                  <input
                    pInputText
                    [id]="fieldKey() + '-manual'"
                    [ngModel]="manualColorInput()"
                    (ngModelChange)="onManualColorInputChange($event)"
                    placeholder="Hex or RGB"
                    class="w-full text-sm"
                    [attr.aria-label]="fieldLabel() + ' manual value'"
                  />
                </div>
              </p-popover>

              <p-select
                [id]="fieldKey() + '-dropdown'"
                [options]="colorOptions()"
                [(ngModel)]="selectedColor"
                (onChange)="onColorSelect($event.value)"
                placeholder="Select a color or pick one"
                [styleClass]="'flex-grow min-w-0'"
                [attr.aria-label]="fieldLabel() + ' predefined colors'"
                appendTo="body"
              >
                <ng-template pTemplate="item" let-option>
                  <div class="flex gap-2 items-center">
                    <!--  eslint-disable-next-line @angular-eslint/template/no-inline-styles -->
                    <div
                      class="w-4 h-4 border dynamic-color-swatch"
                      [ngStyle]="{ '--swatch-color': option.value }"
                    ></div>
                    <div>{{ option.label }}</div>
                  </div>
                </ng-template>
                <ng-template pTemplate="selectedItem" let-selectedOption>
                  @if (selectedOption) {
                    <div class="flex gap-2 items-center">
                      <!--  eslint-disable-next-line @angular-eslint/template/no-inline-styles -->
                      <div
                        class="w-4 h-4 border dynamic-color-swatch"
                        [ngStyle]="{ '--swatch-color': selectedOption.value }"
                      ></div>
                      <div>{{ selectedOption.label }}</div>
                    </div>
                  }
                </ng-template>
              </p-select>
            </div>
          }
          @case ('knob') {
            <p-knob
              [id]="fieldKey()"
              [formControl]="control()"
              [min]="field().props?.min || 0"
              [max]="field().props?.max || 100"
              [step]="field().props?.step || 1"
              [size]="field().props?.['size'] || 100"
              [ngClass]="field().inputStyleClass"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('editor') {
            <p-editor
              [id]="fieldKey()"
              [formControl]="control()"
              [modules]="field().props?.modules"
              [class]="[fieldClasses(), 'h-[320px]']"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('file') {
            <p-fileUpload
              [id]="fieldKey()"
              mode="basic"
              [maxFileSize]="field().props?.maxFileSize"
              [accept]="field().props?.accept"
              chooseLabel="Choose"
              (onSelect)="onFileSelect($event)"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('password') {
            <p-password
              [id]="fieldKey()"
              [formControl]="control()"
              [feedback]="field().props?.feedback"
              [toggleMask]="field().props?.toggleMask"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
              [autocomplete]="field().props?.['autocomplete'] || 'password'"
              inputStyleClass="w-full"
              styleClass="w-full"
            />
          }
          @case ('mask') {
            <p-inputMask
              [id]="fieldKey()"
              [formControl]="control()"
              [mask]="field().props?.mask"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('rating') {
            <p-rating
              [id]="fieldKey()"
              [formControl]="control()"
              [stars]="5"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('custom') {
            <ng-container
              [ngTemplateOutlet]="customTemplate() ?? null"
              [ngTemplateOutletContext]="{
                $implicit: control(),
                field: field(),
              }"
            />
          }
          @case ('autocomplete') {
            <div class="relative">
              <p-autocomplete
                #autocompleteRef
                [id]="fieldKey()"
                [formControl]="control()"
                [suggestions]="getSuggestions()"
                [forceSelection]="field().props?.forceSelection"
                [optionLabel]="field().props?.field"
                [placeholder]="field().placeholder || ''"
                [completeOnFocus]="field().props?.completeOnFocus"
                [readonly]="field().readonly ?? false"
                (completeMethod)="handleAutocompleteSearch($event.query)"
                (onSelect)="onAutocompleteChange($event)"
                (onChange)="onAutocompleteValueChange()"
                (onUnselect)="onAutocompleteValueChange()"
                (onInput)="onAutocompleteValueChange()"
                (onKeyUp)="onAutocompleteValueChange()"
                (onBlur)="onAutocompleteBlur($event)"
                [class]="fieldClasses()"
                [attr.aria-label]="fieldLabel()"
                [attr.aria-invalid]="showError()"
                [attr.aria-describedby]="fieldKey() + '-error'"
                [typeahead]="field().props?.typeahead"
                [multiple]="field().props?.multiple"
                [delay]="field().props?.delay || 300"
                [emptyMessage]="
                  isAutocompleteLoading()
                    ? 'Loading...'
                    : field().props?.emptyMessage || 'No results found'
                "
                [dropdown]="field().props?.dropdown"
                [appendTo]="fieldProps().appendTo || 'body'"
                inputStyleClass="w-full"
              >
                <ng-template let-option #item>
                  <div
                    class="autocomplete-item"
                    [innerHTML]="
                      getAutocompleteDisplayText(option)
                        | highlight: autocompleteSearchQuery()
                    "
                  ></div>
                </ng-template>
              </p-autocomplete>
            </div>
          }
          @case ('listbox') {
            <p-listbox
              [id]="fieldKey()"
              [formControl]="control()"
              [options]="field().options ?? []"
              [checkmark]="field().props?.checkmark"
              [checkbox]="field().props?.checkbox"
              [multiple]="field().props?.multiple"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('treeselect') {
            <p-treeselect
              [id]="fieldKey()"
              [formControl]="control()"
              [options]="field().treeNodeOptions ?? []"
              [placeholder]="field().placeholder || ''"
              [containerStyleClass]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
              [appendTo]="field().props?.appendTo ?? 'body'"
              [selectionMode]="field().props?.selectionMode ?? 'single'"
              [showClear]="field().props?.showClear"
              [filter]="field().props?.filter"
              filterMode="strict"
            />
          }
          @case ('modalList') {
            <div class="dynamic-field-list-container">
              <!-- Display Area for List Items -->
              @if (listItems().length > 0) {
                <div
                  class="list-items-display border p-2 mb-2 rounded min-h-[50px]"
                >
                  @for (item of listItems(); track item.id; let i = $index) {
                    <div
                      class="flex flex-row justify-between items-center p-2 my-4 border-b last:border-b-0"
                    >
                      <!-- Use custom template if provided, otherwise default display -->
                      @if (listItemTemplate()) {
                        <ng-container
                          [ngTemplateOutlet]="listItemTemplate()!"
                          [ngTemplateOutletContext]="{
                            $implicit: item.original,
                          }"
                        ></ng-container>
                      } @else {
                        <span class="flex flex-row gap-4 items-center">
                          @if (item.icon) {
                            <!--  eslint-disable-next-line @angular-eslint/template/no-inline-styles -->
                            <i
                              class="pi pi-{{ item.icon }} mt-2 mr-2 !text-2xl"
                              [ngStyle]="item.iconStyle"
                            ></i>
                          }
                          <div class="flex flex-col">
                            @if (item.title) {
                              <span class="font-medium">{{ item.title }}</span>
                            }
                            <span class="text-sm whitespace-pre-line muted">{{
                              item.display
                            }}</span>
                          </div>
                        </span>
                      }
                      <div class="flex gap-2 ml-4 list-item-actions">
                        @if (modalConfig()?.showEditButton ?? false) {
                          <span
                            class="pi pi-pen-to-square action hover !text-xl"
                            (click)="triggerEditItem(item, i)"
                            (keydown.enter)="triggerEditItem(item, i)"
                            [attr.aria-label]="'Edit item ' + (i + 1)"
                          ></span>
                        }
                        @if (modalConfig()?.showDeleteButton ?? true) {
                          <span
                            class="pi pi-trash action hover !text-xl"
                            (click)="triggerDeleteItem(i)"
                            (keydown.enter)="triggerDeleteItem(i)"
                            [attr.aria-label]="'Delete item ' + (i + 1)"
                          ></span>
                        }
                      </div>
                    </div>
                  }
                </div>
              } @else {
                <div class="mb-2 italic text-gray-500">No items added.</div>
              }

              @if (modalConfig()?.showAddButton ?? true) {
                <!-- Add Button -->
                <p-button
                  type="button"
                  [label]="getAddButtonLabel()"
                  icon="pi pi-plus"
                  severity="secondary"
                  (onClick)="triggerAddItem()"
                />
              }
            </div>
          }
          @case ('eventFilter') {
            <app-event-filter-field
              [id]="fieldKey()"
              [formControl]="control()"
              [class]="fieldClasses()"
              [ngClass]="field().inputStyleClass"
              [groupTypes]="field().props?.groupTypes ?? []"
              [filterService]="field().props?.filterService ?? filterService"
              [requireActorBeforeAction]="
                field().props?.requireActorBeforeAction ?? true
              "
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('assetFilter') {
            <app-asset-filter-field
              [id]="fieldKey()"
              [formControl]="control()"
              [class]="fieldClasses()"
              [ngClass]="field().inputStyleClass"
              [allowedAssetTypes]="field().props?.allowedAssetTypes ?? []"
              [ownerId]="field().props?.ownerId ?? ''"
              [readonly]="field().readonly ?? false"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('zoneFilter') {
            <app-zone-filter-field
              [id]="fieldKey()"
              [formControl]="control()"
              [class]="fieldClasses()"
              [ngClass]="field().inputStyleClass"
              [ownerId]="field().props?.['ownerId'] ?? ''"
              [multi]="field().props?.['multi'] !== false"
              [readonly]="field().readonly ?? false"
              [placeholder]="field().placeholder ?? 'Enter zone name...'"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('treeSplitButtonList') {
            <div class="dynamic-field-list-container">
              @if (listItems().length > 0) {
                <div
                  class="list-items-display border p-2 mb-2 rounded min-h-[50px]"
                >
                  @for (item of listItems(); track item.id; let i = $index) {
                    <div
                      class="flex flex-row justify-between items-center p-2 my-4 border-b last:border-b-0"
                    >
                      <!-- Use custom template if provided, otherwise default display -->
                      @if (listItemTemplate()) {
                        <ng-container
                          [ngTemplateOutlet]="listItemTemplate()!"
                          [ngTemplateOutletContext]="{
                            $implicit: item.original,
                          }"
                        ></ng-container>
                      } @else {
                        <span class="flex flex-row gap-4 items-center">
                          @if (item.icon) {
                            <i
                              class="pi pi-{{ item.icon }} mt-2 mr-2 !text-xl"
                            ></i>
                          }
                          <div class="flex flex-col">
                            @if (item.title) {
                              <span class="font-medium">{{ item.title }}</span>
                            }
                            <span class="text-sm whitespace-pre-line muted">{{
                              item.display
                            }}</span>
                          </div>
                        </span>
                      }
                      <div class="list-item-actions">
                        <span
                          class="pi pi-trash action hover !text-xl"
                          (click)="handleSplitButtonListItemDelete(i)"
                          (keydown.enter)="handleSplitButtonListItemDelete(i)"
                          [attr.aria-label]="'Delete item ' + (i + 1)"
                        ></span>
                      </div>
                    </div>
                  }
                </div>
              } @else {
                <div class="mb-2 italic">No items added.</div>
              }

              <p-splitbutton
                [label]="getAddButtonLabel()"
                [model]="splitButtonTreeModel"
                severity="secondary"
                appendTo="body"
              />
            </div>
          }
          @case ('icon-selector') {
            <app-icon-selector
              [id]="fieldKey()"
              [formControl]="control()"
              [class]="fieldClasses()"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
          @case ('toggle-switch') {
            <p-toggleswitch
              [id]="fieldKey()"
              [formControl]="control()"
              [class]="fieldClasses()"
              [ngClass]="field().inputStyleClass"
              [attr.aria-label]="fieldLabel()"
              [attr.aria-invalid]="showError()"
              [attr.aria-describedby]="fieldKey() + '-error'"
            />
          }
        }
      </div>

      <div class="flex flex-col">
        @if (showError()) {
          <small class="p-error" aria-live="polite">{{ errorMessage() }}</small>
        }
        @if (field().hint) {
          <small class="p-hint form-text muted text-xs mt-1">{{
            field().hint
          }}</small>
        }
      </div>
    </div>
  </div>
}
`, styles: ["/* src/app/shared/components/forms/dynamic-field/dynamic-field.component.scss */\n.p-error {\n  color: var(--p-inputtext-invalid-border-color);\n}\n.autocomplete-item {\n  padding: 0.5rem;\n  cursor: pointer;\n}\n.dynamic-color-swatch {\n  background-color: var(--swatch-color, #ffffff);\n}\n/*# sourceMappingURL=dynamic-field.component.css.map */\n"] }]
  }], () => [], { field: [{ type: Input, args: [{ isSignal: true, alias: "field", required: true }] }], control: [{ type: Input, args: [{ isSignal: true, alias: "control", required: true }] }], customTemplate: [{ type: Input, args: [{ isSignal: true, alias: "customTemplate", required: false }] }], fieldChange: [{ type: Output, args: ["fieldChange"] }], addItem: [{ type: Output, args: ["addItem"] }], editItem: [{ type: Output, args: ["editItem"] }], deleteItem: [{ type: Output, args: ["deleteItem"] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(DynamicFieldComponent, { className: "DynamicFieldComponent", filePath: "src/app/shared/components/forms/dynamic-field/dynamic-field.component.ts", lineNumber: 129 });
})();

// src/app/shared/services/forms/form-comparison.service.ts
var import_isEqualWith = __toESM(require_isEqualWith());
var FormComparisonService = class _FormComparisonService {
  /**
   * Compares two field arrays for deep equality
   */
  areFieldsEqual(prevFields, currentFields) {
    if (!prevFields || prevFields.length !== currentFields.length) {
      return false;
    }
    for (let i = 0; i < currentFields.length; i++) {
      if (!this.areFieldConfigsEqual(prevFields[i], currentFields[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Deep comparison of two FormFieldConfig objects, ignoring functions
   */
  areFieldConfigsEqual(fieldA, fieldB) {
    const keysA = Object.keys(fieldA).filter((k3) => typeof fieldA[k3] !== "function");
    const keysB = Object.keys(fieldB).filter((k3) => typeof fieldB[k3] !== "function");
    if (keysA.length !== keysB.length) {
      return false;
    }
    for (const key of keysA) {
      const valA = fieldA[key];
      const valB = fieldB[key];
      if (!this.areValuesEqual(key, valA, valB)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Compare two values for a given key
   */
  areValuesEqual(key, valA, valB) {
    if (typeof valA === "function" || typeof valB === "function") {
      return true;
    }
    if (isArray(valA) && isArray(valB)) {
      return this.areArrayValuesEqual(key, valA, valB);
    }
    if (key === "conditions" && isObject(valA) && isObject(valB)) {
      return this.areConditionsEqual(valA, valB);
    }
    if (isObject(valA) && isObject(valB)) {
      return (0, import_isEqualWith.default)(valA, valB, this.customEqualityComparator);
    }
    return valA === valB;
  }
  /**
   * Compare two array values for a given key
   */
  areArrayValuesEqual(key, arrA, arrB) {
    if (arrA.length !== arrB.length) {
      return false;
    }
    if (key === "fields" || key === "options" || key === "treeNodeOptions") {
      return this.areArraysEqual(arrA, arrB);
    }
    return (0, import_isEqualWith.default)(arrA, arrB, this.customEqualityComparator);
  }
  /**
   * Compare two conditions objects
   */
  areConditionsEqual(condA, condB) {
    const condKeysA = Object.keys(condA);
    const condKeysB = Object.keys(condB);
    if (condKeysA.length !== condKeysB.length) {
      return false;
    }
    for (const condKey of condKeysA) {
      if (!this.isConditionKeyEqual(condKey, condA, condB, condKeysB)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Check if a specific condition key is equal between two objects
   */
  isConditionKeyEqual(condKey, condA, condB, condKeysB) {
    if (!condKeysB.includes(condKey)) {
      return false;
    }
    const condFieldsA = condA[condKey];
    const condFieldsB = condB[condKey];
    if (!isArray(condFieldsA) || !isArray(condFieldsB)) {
      return false;
    }
    return this.areFieldsEqual(condFieldsA, condFieldsB);
  }
  /**
   * Custom equality comparator for lodash isEqualWith
   */
  customEqualityComparator(valA, valB) {
    if (isFunction(valA) || isFunction(valB)) {
      return true;
    }
    return void 0;
  }
  /**
   * Compare two arrays for equality
   */
  areArraysEqual(arrA, arrB) {
    if (arrA.length !== arrB.length) {
      return false;
    }
    for (let i = 0; i < arrA.length; i++) {
      const itemA = arrA[i];
      const itemB = arrB[i];
      if (isObject(itemA) && isObject(itemB)) {
        if (!(0, import_isEqualWith.default)(itemA, itemB, this.customEqualityComparator)) {
          return false;
        }
      } else if (itemA !== itemB) {
        return false;
      }
    }
    return true;
  }
  /**
   * Determines if field update should be skipped based on comparison
   */
  shouldSkipFieldUpdate(previousFields, currentFields, updateInProgress, formExists) {
    if (updateInProgress || !formExists) {
      return true;
    }
    if (previousFields === currentFields) {
      return true;
    }
    if (this.areFieldsEqual(previousFields, currentFields)) {
      return true;
    }
    return false;
  }
  static \u0275fac = function FormComparisonService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormComparisonService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _FormComparisonService, factory: _FormComparisonService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormComparisonService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/services/forms/form-path.service.ts
var FormPathService = class _FormPathService {
  /**
   * Constructs a full path by combining parent path and key
   */
  getFullPath(key, parentPath) {
    return parentPath ? `${parentPath}.${key}` : key;
  }
  /**
   * Returns a field with its full path set
   */
  getFieldWithPath(field, parentPath) {
    return __spreadProps(__spreadValues({}, field), {
      key: this.getFullPath(field.key, parentPath)
    });
  }
  /**
   * Extracts parent path from a full path
   * e.g., "parent.child.field" -> "parent.child"
   */
  getParentPath(fullPath) {
    const parts = fullPath.split(".");
    parts.pop();
    return parts.join(".");
  }
  /**
   * Extracts field name from full path
   * e.g., "parent.child.field" -> "field"
   */
  getFieldName(fullPath) {
    const parts = fullPath.split(".");
    return parts.at(-1);
  }
  /**
   * Checks if a path is a child of another path
   */
  isChildPath(childPath, parentPath) {
    if (!parentPath)
      return true;
    return childPath.startsWith(`${parentPath}.`);
  }
  /**
   * Gets the depth of a path (number of dots + 1)
   */
  getPathDepth(path) {
    return path ? path.split(".").length : 0;
  }
  static \u0275fac = function FormPathService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormPathService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _FormPathService, factory: _FormPathService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormPathService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/services/forms/form-structure.service.ts
var FormStructureService = class _FormStructureService {
  /**
   * Helper method to safely check if a control is a FormGroup
   */
  isFormGroup(control) {
    return control instanceof FormGroup;
  }
  /**
   * Create an appropriate form control/group for a field
   */
  createControl(field) {
    if (field.type === "group") {
      const group = new FormGroup({});
      for (const childField of field.fields ?? []) {
        group.addControl(childField.name, this.createControl(childField));
      }
      return group;
    } else {
      const validators = field.validations?.map((v2) => v2.validator) ?? [];
      return new FormControl(field.value, validators);
    }
  }
  /**
   * Ensure a form group exists at the specified path, creating it if needed
   */
  ensureGroupExists(form, path, parentPath) {
    const existingGroup = form.get(path);
    if (existingGroup instanceof FormGroup) {
      return existingGroup;
    }
    const pathParts = path.split(".");
    const groupName = pathParts.at(-1);
    if (isNullOrUndefined(parentPath)) {
      const group = new FormGroup({});
      form.addControl(groupName, group);
      return group;
    } else {
      const parentGroup = this.ensureGroupExists(form, parentPath);
      const group = new FormGroup({});
      parentGroup.addControl(groupName, group);
      return group;
    }
  }
  /**
   * Clear all controls from a form group but preserve the group itself
   */
  clearFormGroup(form, groupPath) {
    this.ensureGroupExists(form, groupPath);
    const group = form.get(groupPath);
    if (group instanceof FormGroup) {
      for (const key of Object.keys(group.controls)) {
        group.removeControl(key);
      }
    }
  }
  /**
   * Collect all groups and their paths recursively
   */
  collectGroupsAndPaths(fields, parentPath, groupMap) {
    for (const field of fields) {
      if (field.type === "group") {
        const path = parentPath ? `${parentPath}.${field.name}` : field.name;
        groupMap.set(path, { path, parentPath, field });
        if (field.fields) {
          this.collectGroupsAndPaths(field.fields, path, groupMap);
        }
      }
    }
  }
  /**
   * Build the entire form group hierarchy for conditional fields
   * This method creates all necessary form groups before populating them with fields
   */
  buildConditionalFormGroupHierarchy(form, fields, parentPath = "") {
    const groupsToCreate = /* @__PURE__ */ new Map();
    this.collectGroupsAndPaths(fields, parentPath, groupsToCreate);
    this.createGroupsInOrder(form, groupsToCreate);
    this.processNestedConditionalFields(form, groupsToCreate);
  }
  /**
   * Create groups in hierarchical order (parents first)
   */
  createGroupsInOrder(form, groupsToCreate) {
    const paths = Array.from(groupsToCreate.keys()).sort((a, b2) => a.split(".").length - b2.split(".").length);
    for (const path of paths) {
      const groupInfo = groupsToCreate.get(path);
      if (groupInfo) {
        const { parentPath } = groupInfo;
        this.ensureGroupExists(form, path, parentPath);
      }
    }
  }
  /**
   * Process nested conditional fields inside groups
   */
  processNestedConditionalFields(form, groupsToCreate) {
    for (const { path, field } of groupsToCreate.values()) {
      if (field.fields) {
        this.processChildConditionalFields(form, field.fields, path);
      }
    }
  }
  /**
   * Process conditional fields for child fields
   */
  processChildConditionalFields(form, childFields, path) {
    for (const childField of childFields) {
      if ((childField.conditional ?? false) && childField.conditions) {
        this.handleChildConditionalField(form, childField, path);
      }
    }
  }
  /**
   * Handle a single conditional field
   */
  handleChildConditionalField(form, childField, path) {
    const defaultValue = childField.value;
    if (isDefined(defaultValue) && isDefined(childField.conditions?.[defaultValue])) {
      const conditionalFields = childField.conditions[defaultValue] ?? [];
      this.buildConditionalFormGroupHierarchy(form, conditionalFields, path);
    }
  }
  /**
   * Populate a form group with fields recursively
   */
  populateFormGroup(form, fields, groupPath) {
    const group = this.ensureGroupExists(form, groupPath);
    try {
      for (const field of fields) {
        if (field.type === "group") {
          const childGroupPath = `${groupPath}.${field.name}`;
          this.ensureGroupExists(form, childGroupPath, groupPath);
        }
      }
      for (const field of fields) {
        if (field.type === "group" && field.fields) {
          this.populateFormGroup(form, field.fields, `${groupPath}.${field.name}`);
        } else if (isNullOrUndefined(group.get(field.name))) {
          group.addControl(field.name, this.createControl(field));
        }
      }
    } catch (error) {
      console.error(`Error populating group ${groupPath}:`, error);
    }
  }
  /**
   * Create form groups for all group-type fields (including nested groups)
   */
  createGroupsFromFields(form, fields) {
    for (const field of fields) {
      if (field.type !== "group") {
        continue;
      }
      if (form.get(field.name)) {
        continue;
      }
      const control = this.createControl(field);
      form.addControl(field.name, control);
      if (field.fields) {
        this.createGroupsFromFields(form, field.fields);
      }
    }
  }
  /**
   * Create form groups from conditional fields with default values
   */
  createConditionalGroups(form, fields, parentPath = "") {
    for (const field of fields) {
      if (isNullOrUndefined(field.conditional) || isNullOrUndefined(field.conditions) || isNullOrUndefined(field.value)) {
        continue;
      }
      const value = field.value;
      if (isNullOrUndefined(field.conditions[value])) {
        continue;
      }
      const conditionalFields = field.conditions[value] ?? [];
      for (const condField of conditionalFields) {
        if (condField.type === "group") {
          this.buildFormGroupHierarchy(form, [condField], parentPath);
        }
      }
    }
  }
  /**
   * Build the entire form group hierarchy first before populating fields
   */
  buildFormGroupHierarchy(form, fields, parentPath = "") {
    this.createGroupsFromFields(form, fields);
    this.createConditionalGroups(form, fields, parentPath);
  }
  /**
   * Restore form values from a saved state
   */
  restoreFormValues(form, values) {
    if (isNullOrUndefined(values) || isNullOrUndefined(form))
      return;
    for (const key of Object.keys(form.controls)) {
      const control = form.get(key);
      if (control && isDefined(values[key])) {
        if (typeof values[key] === "object" && control instanceof FormGroup) {
          this.restoreNestedValues(control, values[key]);
        } else {
          control.setValue(values[key], { emitEvent: false });
        }
      }
    }
    form.updateValueAndValidity();
  }
  /**
   * Restore nested form values recursively
   */
  restoreNestedValues(group, values) {
    if (isNullOrUndefined(values))
      return;
    for (const key of Object.keys(values)) {
      const control = group.get(key);
      if (control) {
        if (typeof values[key] === "object" && control instanceof FormGroup) {
          this.restoreNestedValues(control, values[key]);
        } else {
          control.setValue(values[key], { emitEvent: false });
        }
      }
    }
  }
  /**
   * Rebuild a form with new field definitions
   */
  rebuildForm(form, newFields, createFormGroupFn, callbacks) {
    const currentValues = isDefined(callbacks?.preserveValues) && isDefined(form) ? structuredClone(form.value) : void 0;
    if (isDefined(form)) {
      for (const key of Object.keys(form.controls)) {
        form.removeControl(key);
      }
    }
    const formControls = createFormGroupFn(newFields);
    for (const key of Object.keys(formControls.controls)) {
      form.addControl(key, formControls.get(key));
    }
    callbacks?.onFieldsProcessed?.(form, newFields);
    if (isDefined(currentValues) && (callbacks?.preserveValues ?? false)) {
      this.restoreFormValues(form, currentValues);
      callbacks?.onValuesRestored?.();
    }
    return form;
  }
  /**
   * Recursively remove a field and all its nested fields from the form
   */
  removeFieldFromForm(form, field, parentPath = "") {
    const fullPath = parentPath ? `${parentPath}.${field.name}` : field.name;
    this.removeConditionalFields(form, field, fullPath);
    this.removeGroupFields(form, field, fullPath);
    this.removeControl(form, field, parentPath, fullPath);
  }
  /**
   * Remove all conditional fields for a given field
   */
  removeConditionalFields(form, field, fullPath) {
    if ((field.conditional ?? false) && field.conditions) {
      const allConditionalFields = Object.values(field.conditions).flat();
      for (const condField of allConditionalFields) {
        this.removeFieldFromForm(form, condField, fullPath);
      }
    }
  }
  /**
   * Remove all child fields from a group field
   */
  removeGroupFields(form, field, fullPath) {
    if (field.type === "group" && field.fields) {
      for (const childField of [...field.fields].reverse()) {
        this.removeFieldFromForm(form, childField, fullPath);
      }
    }
  }
  /**
   * Remove a single control from the form
   */
  removeControl(form, field, parentPath, fullPath) {
    try {
      if (isNullOrUndefined(parentPath)) {
        this.removeTopLevelControl(form, field);
      } else {
        this.removeNestedControl(form, field, parentPath);
      }
    } catch (error) {
      console.error(`Error removing field ${fullPath}:`, error);
    }
  }
  /**
   * Remove a top-level control
   */
  removeTopLevelControl(form, field) {
    if (form.get(field.name)) {
      form.removeControl(field.name);
    }
  }
  /**
   * Remove a nested control
   */
  removeNestedControl(form, field, parentPath) {
    const parent = form.get(parentPath);
    if (parent instanceof FormGroup && parent.get(field.name)) {
      parent.removeControl(field.name);
    }
  }
  /**
   * Add a single field to the form with proper hierarchy
   */
  addFieldToForm(form, field, parentPath = "") {
    const fullPath = parentPath ? `${parentPath}.${field.name}` : field.name;
    if (form.get(fullPath)) {
      return;
    }
    const control = this.createControl(field);
    const parent = parentPath?.trim() ? form.get(parentPath) : null;
    if (parent instanceof FormGroup) {
      parent.addControl(field.name, control);
    } else {
      form.addControl(field.name, control);
    }
  }
  /**
   * Add fields to form structure
   */
  addFieldsToForm(form, fields, parentPath) {
    for (const field of fields) {
      if (field.type === "group" && field.fields) {
        const fullPath = parentPath ? `${parentPath}.${field.name}` : field.name;
        this.populateFormGroup(form, field.fields, fullPath);
      } else if (isNullOrUndefined(form.get(field.name))) {
        this.addFieldToForm(form, field, parentPath);
      }
    }
  }
  static \u0275fac = function FormStructureService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormStructureService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _FormStructureService, factory: _FormStructureService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormStructureService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/services/forms/conditional-field.service.ts
var ConditionalFieldService = class _ConditionalFieldService {
  formStructureService = inject(FormStructureService);
  /**
   * Main entry point for handling field value changes that trigger conditional fields
   */
  handleFieldChange(field, value, parentPath, context, onFieldChange) {
    if (field.conditional !== true || !isDefined(field.conditions) || !isDefined(field.conditions[value])) {
      return;
    }
    try {
      const { conditionalFields, previousFields } = this.prepareFieldMaps(field, value);
      const { fieldsToRemove, groupsToPreserve } = this.handleFieldPreservation(conditionalFields, previousFields);
      this.processFormStructureChanges(conditionalFields, previousFields, fieldsToRemove, groupsToPreserve, parentPath, context.form);
      this.updateDynamicFieldsWithConditionals(conditionalFields, fieldsToRemove, groupsToPreserve, parentPath, context);
      this.processNestedConditionalTriggers(conditionalFields, parentPath, onFieldChange);
    } catch (error) {
      console.error("Error in handleFieldChange:", error);
    }
  }
  /**
   * Prepare maps of conditional and previous fields
   */
  prepareFieldMaps(field, value) {
    const conditionalFields = field.conditions?.[value] ?? [];
    const previousFields = Object.entries(field.conditions ?? {}).filter(([k3]) => k3 !== String(value)).flatMap(([_, fields]) => fields);
    return { conditionalFields, previousFields };
  }
  /**
   * Handle group preservation and collect fields to remove
   */
  handleFieldPreservation(conditionalFields, previousFields) {
    const fieldsToRemove = /* @__PURE__ */ new Set();
    const groupsToPreserve = /* @__PURE__ */ new Set();
    const newFieldsMap = /* @__PURE__ */ new Map();
    for (const f of conditionalFields) {
      newFieldsMap.set(f.name, f);
    }
    for (const oldField of previousFields) {
      if (oldField.type === "group" && newFieldsMap.has(oldField.name)) {
        groupsToPreserve.add(oldField.name);
      }
      this.collectFieldsToRemove(oldField, fieldsToRemove);
    }
    return { fieldsToRemove, groupsToPreserve };
  }
  /**
   * Process form structure changes
   */
  processFormStructureChanges(conditionalFields, previousFields, fieldsToRemove, groupsToPreserve, parentPath, form) {
    for (const fieldToRemove of previousFields) {
      if (!(fieldToRemove.type === "group" && groupsToPreserve.has(fieldToRemove.name))) {
        this.formStructureService.removeFieldFromForm(form, fieldToRemove, parentPath);
      }
    }
    this.formStructureService.buildConditionalFormGroupHierarchy(form, conditionalFields, parentPath);
    for (const groupName of groupsToPreserve) {
      const groupPath = parentPath ? `${parentPath}.${groupName}` : groupName;
      this.formStructureService.clearFormGroup(form, groupPath);
    }
  }
  /**
   * Update dynamic fields with conditional fields
   */
  updateDynamicFieldsWithConditionals(conditionalFields, fieldsToRemove, groupsToPreserve, parentPath, context) {
    const currentFields = context.dynamicFields();
    const updatedFields = currentFields.filter((f) => !fieldsToRemove.has(f.name) || groupsToPreserve.has(f.name));
    const finalFields = [];
    for (const field of updatedFields) {
      if (groupsToPreserve.has(field.name) && field.type === "group") {
        this.updateGroupField(field, conditionalFields, finalFields);
      } else {
        finalFields.push(field);
      }
    }
    this.addNewFields(conditionalFields, updatedFields, finalFields);
    context.updateDynamicFields(() => finalFields);
    this.formStructureService.addFieldsToForm(context.form, conditionalFields, parentPath);
  }
  /**
   * Update a group field with new content
   */
  updateGroupField(groupField, conditionalFields, finalFields) {
    const newVersion = conditionalFields.find((f) => f.name === groupField.name);
    if (newVersion) {
      finalFields.push(__spreadProps(__spreadValues({}, groupField), {
        fields: [...newVersion.fields ?? []]
      }));
    } else {
      finalFields.push(__spreadProps(__spreadValues({}, groupField), { fields: [] }));
    }
  }
  /**
   * Add new fields not already present
   */
  addNewFields(newFields, existingFields, finalFields) {
    for (const newField of newFields) {
      if (!existingFields.some((f) => f.name === newField.name)) {
        finalFields.push(newField);
      }
    }
  }
  /**
   * Process nested conditional triggers
   */
  processNestedConditionalTriggers(fields, parentPath, onFieldChange) {
    for (const field of fields) {
      if (field.conditional === true && field.conditions) {
        const defaultValue = field.value;
        if (isDefined(defaultValue) && isDefined(field.conditions[defaultValue])) {
          const childPath = parentPath ? `${parentPath}.${field.name}` : field.name;
          setTimeout(() => {
            onFieldChange(field, defaultValue, childPath);
          }, 0);
        }
      }
    }
  }
  /**
   * Recursively collect a field and all its descendants' names
   */
  collectFieldsToRemove(field, fieldNames) {
    fieldNames.add(field.name);
    if ((field.conditional ?? false) && field.conditions) {
      for (const condField of Object.values(field.conditions).flat()) {
        this.collectFieldsToRemove(condField, fieldNames);
      }
    }
    if (field.type === "group" && field.fields) {
      for (const childField of field.fields) {
        this.collectFieldsToRemove(childField, fieldNames);
      }
    }
  }
  /**
   * Process initial conditional fields based on default values
   */
  processInitialConditionalFields(fields, form, callbacks) {
    this.formStructureService.buildFormGroupHierarchy(form, fields);
    callbacks.processConditionalFieldsAtLevel(fields);
  }
  /**
   * Process conditional fields at a given level of the form structure
   */
  processConditionalFieldsAtLevel(fields, parentPath, form, callbacks) {
    const conditionalFields = fields.filter((field) => field.conditional === true && isDefined(field.conditions));
    for (const field of conditionalFields) {
      const fullPath = parentPath ? `${parentPath}.${field.name}` : field.name;
      const control = form.get(fullPath);
      if (!control) {
        return;
      }
      const initialValue = control.value;
      if (isDefined(initialValue) && field.conditions?.[initialValue]) {
        const conditionalFieldsToAdd = field.conditions[initialValue] ?? [];
        callbacks.addConditionalFields(conditionalFieldsToAdd, parentPath);
        callbacks.processNestedConditionalFields(conditionalFieldsToAdd, parentPath);
      }
    }
    for (const field of fields) {
      if (field.type === "group" && field.fields) {
        const groupPath = parentPath ? `${parentPath}.${field.name}` : field.name;
        this.processConditionalFieldsAtLevel(field.fields, groupPath, form, callbacks);
      }
    }
  }
  /**
   * Add conditional fields to both the form model and dynamic fields
   */
  addConditionalFields(fields, parentPath, context, processNestedConditionalFields) {
    for (const field of fields) {
      this.formStructureService.addFieldToForm(context.form, field, parentPath);
    }
    context.updateDynamicFields((currentFields) => {
      const fieldMap = new Map(currentFields.map((f) => [f.name, f]));
      const newFields = [...currentFields];
      for (const field of fields) {
        if (!fieldMap.has(field.name)) {
          newFields.push(field);
        }
      }
      return newFields;
    });
    setTimeout(() => {
      processNestedConditionalFields(fields, parentPath);
    }, 0);
  }
  /**
   * Process nested conditional fields recursively
   */
  processNestedConditionalFields(fields, parentPath, form, callbacks) {
    setTimeout(() => {
      this.processNestedFields(fields, parentPath, form, callbacks);
    }, 0);
  }
  /**
   * Helper method to process nested fields
   */
  processNestedFields(fields, parentPath, form, callbacks) {
    for (const field of fields) {
      const fieldPath = parentPath ? `${parentPath}.${field.name}` : field.name;
      this.processGroupField(field, fieldPath, callbacks);
      this.processConditionalField(field, fieldPath, form, callbacks);
    }
  }
  /**
   * Process a group field
   */
  processGroupField(field, fieldPath, callbacks) {
    if (field.type === "group" && field.fields) {
      callbacks.processConditionalFieldsAtLevel(field.fields, fieldPath);
    }
  }
  /**
   * Process a conditional field
   */
  processConditionalField(field, fieldPath, form, callbacks) {
    if (field.conditional !== true || !field.conditions) {
      return;
    }
    const control = form.get(fieldPath);
    if (!control) {
      return;
    }
    const value = control.value;
    if (!isDefined(value) || !isDefined(field.conditions[value])) {
      return;
    }
    callbacks.addConditionalFields(field.conditions[value], fieldPath);
    this.processNestedConditionalFields(field.conditions[value], fieldPath, form, callbacks);
  }
  static \u0275fac = function ConditionalFieldService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ConditionalFieldService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _ConditionalFieldService, factory: _ConditionalFieldService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConditionalFieldService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/services/forms/form-dependency.service.ts
var FormDependencyService = class _FormDependencyService {
  /**
   * Set up all dependencies for fields in the given sections
   */
  handleDependencies(sections, form, destroyRef) {
    for (const section of sections) {
      for (const field of section.fields) {
        if (field.dependencies) {
          this.setupFieldDependencies(field, form, destroyRef);
        }
      }
    }
  }
  /**
   * Set up dependencies for a single field
   */
  setupFieldDependencies(field, form, destroyRef) {
    for (const dep of field.dependencies ?? []) {
      form.get(dep.field)?.valueChanges.pipe(takeUntilDestroyed(destroyRef)).subscribe((value) => this.handleDependencyAction(field, dep, value, form));
    }
  }
  /**
   * Handle the action triggered by a dependency value change
   */
  handleDependencyAction(field, dep, value, form) {
    const matches = dep.invertMatch ?? false ? value !== dep.value : value === dep.value;
    if (matches) {
      switch (dep.action) {
        case "show":
          field.visible = true;
          break;
        case "hide":
          field.visible = false;
          break;
        case "enable":
          form.get(field.key)?.enable();
          break;
        case "disable":
          form.get(field.key)?.disable();
          break;
      }
    } else {
      switch (dep.action) {
        case "show":
          field.visible = false;
          break;
        case "hide":
          field.visible = true;
          break;
        case "enable":
          form.get(field.key)?.disable();
          break;
        case "disable":
          form.get(field.key)?.enable();
          break;
      }
    }
  }
  static \u0275fac = function FormDependencyService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormDependencyService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _FormDependencyService, factory: _FormDependencyService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormDependencyService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/services/forms/form-persistence.service.ts
var FormPersistenceService = class _FormPersistenceService {
  localStorage = inject(LocalStorageService);
  /**
   * Sets up automatic form persistence with debounced saves
   * @param form The form to persist
   * @param sections Form sections containing persistKey configurations
   * @param destroyRef Component destroy reference for cleanup
   * @param debounceMs Debounce time in milliseconds (default: 500)
   */
  setupFormPersistence(form, sections, destroyRef, debounceMs = 500) {
    form.valueChanges.pipe(debounceTime(debounceMs), distinctUntilChanged(), takeUntilDestroyed(destroyRef)).subscribe(() => {
      this.saveState(form, sections);
    });
  }
  /**
   * Saves form state to localStorage for fields with persistKey
   * @param form The form to save
   * @param sections Form sections containing persistKey configurations
   */
  saveState(form, sections) {
    for (const section of sections) {
      for (const field of section.fields) {
        if (isDefined(field.persistKey)) {
          const value = form.get(field.key)?.value;
          if (value !== void 0) {
            this.localStorage.setItem(field.persistKey, value);
          }
        }
      }
    }
  }
  /**
   * Loads persisted form state from localStorage
   * @param form The form to restore values into
   * @param sections Form sections containing persistKey configurations
   */
  loadPersistedState(form, sections) {
    for (const section of sections) {
      for (const field of section.fields) {
        if (isDefined(field.persistKey)) {
          const savedValue = this.localStorage.getItem(field.persistKey);
          if (savedValue !== null) {
            form.get(field.key)?.setValue(savedValue);
          }
        }
      }
    }
  }
  static \u0275fac = function FormPersistenceService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormPersistenceService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _FormPersistenceService, factory: _FormPersistenceService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormPersistenceService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/services/forms/form-validation.service.ts
var FormValidationService = class _FormValidationService {
  /**
   * Validates field names recursively to ensure proper form structure
   * @param fields The fields to validate
   */
  validateFieldNames(fields) {
    for (const field of fields) {
      if (field.type === "group" && field.fields) {
        this.validateFieldNames(field.fields);
      }
      if (isDefined(field.conditional) && field.conditions) {
        for (const conditionalFields of Object.values(field.conditions)) {
          this.validateFieldNames(conditionalFields);
        }
      }
    }
  }
  /**
   * Checks if a field has validation errors
   * @param fieldName The name of the field to check
   * @param group The form group containing the field
   * @returns True if the field has errors and has been touched/dirtied
   */
  hasError(fieldName, group) {
    const control = group.get(fieldName);
    return control ? control.invalid && (control.dirty || control.touched) : false;
  }
  /**
   * Retrieves the first error message for a field
   * @param fieldName The name of the field
   * @param group The form group containing the field
   * @returns The error message string, or empty string if no errors
   */
  getErrorMessage(fieldName, group) {
    const control = group.get(fieldName);
    if (!isDefined(control) || !isDefined(control.errors))
      return "";
    const errorKeys = Object.keys(control.errors);
    if (!isArray(errorKeys) || errorKeys.length === 0)
      return "";
    const firstError = errorKeys[0];
    if (!hasProperty(control.errors, firstError))
      return "";
    const errorValue = control.errors[firstError];
    return isString(errorValue) ? errorValue : "";
  }
  static \u0275fac = function FormValidationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormValidationService)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _FormValidationService, factory: _FormValidationService.\u0275fac, providedIn: "root" });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormValidationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// src/app/shared/services/forms/list-field-modal-config.builder.ts
var ListFieldModalConfigBuilder = class {
  config = {};
  /**
   * Set the modal component to render
   */
  withModalComponent(component) {
    this.config.modalComponent = component;
    return this;
  }
  /**
   * Set the modal title (can be static string or function)
   */
  withTitle(title) {
    this.config.modalTitle = title;
    return this;
  }
  /**
   * Set the form fields displayed in the modal (can be array or function)
   */
  withFields(fields) {
    this.config.modalFields = fields;
    return this;
  }
  /**
   * Set the formatter for displaying list items
   */
  withFormatter(formatter) {
    this.config.listItemFormatter = formatter;
    return this;
  }
  /**
   * Set the default item provider for new items
   */
  withDefaultProvider(provider) {
    this.config.defaultItemProvider = provider;
    return this;
  }
  /**
   * Set the subheader text displayed in the modal
   */
  withSubHeader(text) {
    this.config.subHeader = text;
    return this;
  }
  /**
   * Set the label for the add button
   */
  withAddButtonLabel(label) {
    this.config.addButtonLabel = label;
    return this;
  }
  /**
   * Set whether to show the save notification after submission
   */
  withHideSaveNotification(hide) {
    this.config.hideSaveNotification = hide;
    return this;
  }
  /**
   * Set whether to show the edit button
   */
  withShowEditButton(show) {
    this.config.showEditButton = show;
    return this;
  }
  /**
   * Set whether to show the add button
   */
  withShowAddButton(show) {
    this.config.showAddButton = show;
    return this;
  }
  /**
   * Set whether to show the delete button
   */
  withShowDeleteButton(show) {
    this.config.showDeleteButton = show;
    return this;
  }
  /**
   * Set custom onSubmit handler
   */
  withOnSubmit(handler) {
    this.config.onSubmit = handler;
    return this;
  }
  /**
   * Set custom onDeleteItem handler
   */
  withOnDeleteItem(handler) {
    this.config.onDeleteItem = handler;
    return this;
  }
  /**
   * Build the final configuration object
   */
  build() {
    if (typeof this.config.modalComponent !== "function") {
      throw new TypeError("Modal component is required");
    }
    if (this.config.modalTitle === void 0) {
      throw new TypeError("Modal title is required");
    }
    if (this.config.modalFields === void 0) {
      throw new TypeError("Modal fields are required");
    }
    return {
      modalComponent: this.config.modalComponent,
      modalTitle: this.config.modalTitle,
      modalFields: this.config.modalFields,
      listItemFormatter: this.config.listItemFormatter,
      defaultItemProvider: this.config.defaultItemProvider,
      addButtonLabel: this.config.addButtonLabel,
      subHeader: this.config.subHeader,
      hideSaveNotification: this.config.hideSaveNotification,
      showEditButton: this.config.showEditButton,
      showAddButton: this.config.showAddButton,
      showDeleteButton: this.config.showDeleteButton,
      onSubmit: this.config.onSubmit,
      onDeleteItem: this.config.onDeleteItem
    };
  }
};

// src/app/shared/services/forms/list-modal-result.handler.ts
var ListModalResultHandler = class {
  /**
   * Handles a modal submission result and updates the target form control
   * Automatically determines whether to add (push) or update (splice) based on result.isEdit
   *
   * @param result The modal submission result
   * @param control The form control containing the list
   * @returns true if operation was successful, false otherwise
   */
  static handleResult(result, control) {
    const currentValue = control.value;
    const updatedValue = isArray(currentValue) ? [...currentValue] : [];
    try {
      if (result.isEdit && isDefined(result.index)) {
        if (result.index < 0 || result.index >= updatedValue.length) {
          console.warn(`Edit index ${result.index} out of bounds for array of length ${updatedValue.length}`);
          return false;
        }
        updatedValue[result.index] = result.data;
      } else {
        updatedValue.push(result.data);
      }
      control.setValue(updatedValue);
      control.markAsDirty();
      control.updateValueAndValidity();
      return true;
    } catch (error) {
      console.error("Error handling modal result:", error);
      return false;
    }
  }
  /**
   * Deep clones an item to prevent reference sharing during edits
   * Useful when editing nested objects to ensure immutability
   *
   * @param item The item to clone
   * @returns A deep clone of the item
   */
  static deepCloneItem(item) {
    if (typeof structuredClone === "function") {
      return structuredClone(item);
    }
    try {
      if (Array.isArray(item)) {
        return [...item];
      }
      return __spreadValues({}, item);
    } catch (error) {
      console.warn("Failed to shallow clone item, returning original:", error);
      return item;
    }
  }
  /**
   * Validates that an edit index is within bounds of the array
   */
  static isEditIndexValid(index, arrayLength) {
    return isDefined(index) && index >= 0 && index < arrayLength;
  }
};

// src/app/shared/components/forms/dynamic-form/dynamic-form.component.ts
var _c028 = (a0, a1) => ({ fields: a0, group: a1, parentPath: "" });
var _c128 = (a0, a1, a2) => ({ fields: a0, group: a1, parentPath: a2 });
var _forTrack06 = ($index, $item) => $item.key;
var _forTrack12 = ($index, $item) => $item.label;
function DynamicFormComponent_Conditional_0_Conditional_1_For_1_Conditional_5_For_2_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-dynamic-field", 9);
    \u0275\u0275listener("fieldChange", function DynamicFormComponent_Conditional_0_Conditional_1_For_1_Conditional_5_For_2_Conditional_0_Conditional_0_Template_app_dynamic_field_fieldChange_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(7);
      return \u0275\u0275resetView(ctx_r1.onFieldChange($event.field, $event.value));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275controlCreate();
  }
  if (rf & 2) {
    const field_r6 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275control(field_r6);
    \u0275\u0275property("control", ctx)("customTemplate", ctx_r1.templates()[field_r6.key]);
  }
}
function DynamicFormComponent_Conditional_0_Conditional_1_For_1_Conditional_5_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DynamicFormComponent_Conditional_0_Conditional_1_For_1_Conditional_5_For_2_Conditional_0_Conditional_0_Template, 1, 4, "app-dynamic-field", 8);
  }
  if (rf & 2) {
    let tmp_25_0;
    const field_r6 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275conditional((tmp_25_0 = ctx_r1.getFieldControl(field_r6.key)) ? 0 : -1, tmp_25_0);
  }
}
function DynamicFormComponent_Conditional_0_Conditional_1_For_1_Conditional_5_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DynamicFormComponent_Conditional_0_Conditional_1_For_1_Conditional_5_For_2_Conditional_0_Template, 1, 1);
  }
  if (rf & 2) {
    const field_r6 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275conditional(ctx_r1.isFieldVisible(field_r6) ? 0 : -1);
  }
}
function DynamicFormComponent_Conditional_0_Conditional_1_For_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275repeaterCreate(1, DynamicFormComponent_Conditional_0_Conditional_1_For_1_Conditional_5_For_2_Template, 1, 1, null, null, _forTrack06);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const section_r4 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275repeater(section_r4.fields);
  }
}
function DynamicFormComponent_Conditional_0_Conditional_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 5);
    \u0275\u0275listener("click", function DynamicFormComponent_Conditional_0_Conditional_1_For_1_Template_div_click_1_listener() {
      const section_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.toggleSection(section_r4.key));
    })("keydown.enter", function DynamicFormComponent_Conditional_0_Conditional_1_For_1_Template_div_keydown_enter_1_listener() {
      const section_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.toggleSection(section_r4.key));
    });
    \u0275\u0275elementStart(2, "h3", 6);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275element(4, "i");
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(5, DynamicFormComponent_Conditional_0_Conditional_1_For_1_Conditional_5_Template, 3, 0, "div", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const section_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(section_r4.title);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.isSectionCollapsed(section_r4.key) ? "pi pi-chevron-down" : "pi pi-chevron-up");
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r1.isSectionCollapsed(section_r4.key) ? 5 : -1);
  }
}
function DynamicFormComponent_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, DynamicFormComponent_Conditional_0_Conditional_1_For_1_Template, 6, 4, "div", 4, _forTrack06);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275repeater(ctx_r1.sections());
  }
}
function DynamicFormComponent_Conditional_0_Conditional_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DynamicFormComponent_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DynamicFormComponent_Conditional_0_Conditional_2_ng_container_0_Template, 1, 0, "ng-container", 10);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    const formTemplate_r7 = \u0275\u0275reference(2);
    \u0275\u0275property("ngTemplateOutlet", formTemplate_r7)("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c028, ctx_r1.dynamicFields(), ctx_r1.form));
  }
}
function DynamicFormComponent_Conditional_0_Conditional_3_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "p-button", 12);
    \u0275\u0275listener("onClick", function DynamicFormComponent_Conditional_0_Conditional_3_For_2_Conditional_0_Template_p_button_onClick_0_listener() {
      \u0275\u0275restoreView(_r8);
      const action_r9 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.handleAction(action_r9));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const action_r9 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("type", action_r9.type || "button")("label", action_r9.label)("severity", action_r9.severity)("outlined", action_r9.outlined)("disabled", ctx_r1.isDisabled(action_r9))("icon", action_r9.icon)("styleClass", action_r9.styleClass)("loading", (action_r9 == null ? null : action_r9.loading == null ? null : action_r9.loading()) ?? false);
  }
}
function DynamicFormComponent_Conditional_0_Conditional_3_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DynamicFormComponent_Conditional_0_Conditional_3_For_2_Conditional_0_Template, 1, 8, "p-button", 11);
  }
  if (rf & 2) {
    const action_r9 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275conditional(ctx_r1.isVisible(action_r9) ? 0 : -1);
  }
}
function DynamicFormComponent_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275repeaterCreate(1, DynamicFormComponent_Conditional_0_Conditional_3_For_2_Template, 1, 1, null, null, _forTrack12);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.actions());
  }
}
function DynamicFormComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "form", 2);
    \u0275\u0275listener("ngSubmit", function DynamicFormComponent_Conditional_0_Template_form_ngSubmit_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onSubmit());
    });
    \u0275\u0275conditionalCreate(1, DynamicFormComponent_Conditional_0_Conditional_1_Template, 2, 0)(2, DynamicFormComponent_Conditional_0_Conditional_2_Template, 1, 5, "ng-container");
    \u0275\u0275conditionalCreate(3, DynamicFormComponent_Conditional_0_Conditional_3_Template, 3, 0, "div", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("formGroup", ctx_r1.form);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.sections().length ? 1 : 2);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!ctx_r1.hideActions() ? 3 : -1);
  }
}
function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_1_Conditional_0_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13)(1, "h4", 14);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275template(3, DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_1_Conditional_0_ng_container_3_Template, 1, 0, "ng-container", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r10 = \u0275\u0275nextContext(3).$implicit;
    const ctx_r10 = \u0275\u0275nextContext();
    const group_r12 = ctx_r10.group;
    const parentPath_r13 = ctx_r10.parentPath;
    \u0275\u0275nextContext();
    const formTemplate_r7 = \u0275\u0275reference(2);
    \u0275\u0275property("formGroupName", field_r10.key);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(field_r10.label);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", formTemplate_r7)("ngTemplateOutletContext", \u0275\u0275pureFunction3(4, _c128, field_r10.fields, group_r12.get(field_r10.key), parentPath_r13 ? parentPath_r13 + "." + field_r10.key : field_r10.key));
  }
}
function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const field_r10 = \u0275\u0275nextContext(3).$implicit;
    const parentPath_r13 = \u0275\u0275nextContext().parentPath;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate1(" ", ctx_r1.warn("FormGroup not found for key:", field_r10.key, "in parent path:", parentPath_r13), " ");
  }
}
function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_1_Conditional_0_Template, 4, 8, "div", 13)(1, DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_1_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    let tmp_17_0;
    const field_r10 = \u0275\u0275nextContext(2).$implicit;
    const group_r12 = \u0275\u0275nextContext().group;
    \u0275\u0275conditional((tmp_17_0 = group_r12.get(field_r10.key)) ? 0 : 1, tmp_17_0);
  }
}
function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "app-dynamic-field", 15);
    \u0275\u0275listener("fieldChange", function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Conditional_0_Template_app_dynamic_field_fieldChange_0_listener($event) {
      \u0275\u0275restoreView(_r14);
      const ctx_r1 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r1.onFieldChange($event.field, $event.value));
    })("addItem", function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Conditional_0_Template_app_dynamic_field_addItem_0_listener($event) {
      \u0275\u0275restoreView(_r14);
      const ctx_r1 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r1.handleAddItem($event));
    })("editItem", function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Conditional_0_Template_app_dynamic_field_editItem_0_listener($event) {
      \u0275\u0275restoreView(_r14);
      const ctx_r1 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r1.handleEditItem($event));
    })("deleteItem", function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Conditional_0_Template_app_dynamic_field_deleteItem_0_listener($event) {
      \u0275\u0275restoreView(_r14);
      const ctx_r1 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r1.handleDeleteItem($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275controlCreate();
  }
  if (rf & 2) {
    const field_r10 = \u0275\u0275nextContext(3).$implicit;
    const parentPath_r13 = \u0275\u0275nextContext().parentPath;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275control(ctx_r1.getFieldWithPath(field_r10, parentPath_r13));
    \u0275\u0275property("control", ctx)("customTemplate", ctx_r1.templates()[field_r10.key]);
  }
}
function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const field_r10 = \u0275\u0275nextContext(3).$implicit;
    const ctx_r10 = \u0275\u0275nextContext();
    const group_r12 = ctx_r10.group;
    const parentPath_r13 = ctx_r10.parentPath;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate1(" ", ctx_r1.warn("FormControl not found for key:", field_r10.key, "in parent path:", parentPath_r13, group_r12.value), " ");
  }
}
function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Conditional_0_Template, 1, 4, "app-dynamic-field", 8)(1, DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    let tmp_17_0;
    const field_r10 = \u0275\u0275nextContext(2).$implicit;
    const group_r12 = \u0275\u0275nextContext().group;
    \u0275\u0275conditional((tmp_17_0 = group_r12.get(field_r10.key)) ? 0 : 1, tmp_17_0);
  }
}
function DynamicFormComponent_ng_template_1_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275conditionalCreate(1, DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_1_Template, 2, 1)(2, DynamicFormComponent_ng_template_1_For_1_Conditional_0_Conditional_2_Template, 2, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const field_r10 = \u0275\u0275nextContext().$implicit;
    const group_r12 = \u0275\u0275nextContext().group;
    \u0275\u0275property("formGroup", group_r12);
    \u0275\u0275advance();
    \u0275\u0275conditional(field_r10.type === "group" ? 1 : 2);
  }
}
function DynamicFormComponent_ng_template_1_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DynamicFormComponent_ng_template_1_For_1_Conditional_0_Template, 3, 2, "div", 1);
  }
  if (rf & 2) {
    const field_r10 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(ctx_r1.isFieldVisible(field_r10) ? 0 : -1);
  }
}
function DynamicFormComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, DynamicFormComponent_ng_template_1_For_1_Template, 1, 1, null, null, _forTrack06);
  }
  if (rf & 2) {
    const fields_r15 = ctx.fields;
    \u0275\u0275repeater(fields_r15);
  }
}
var DynamicFormComponent = class _DynamicFormComponent {
  fields = input.required(...ngDevMode ? [{ debugName: "fields" }] : []);
  templates = input({}, ...ngDevMode ? [{ debugName: "templates" }] : []);
  sections = input([], ...ngDevMode ? [{ debugName: "sections" }] : []);
  actions = input([], ...ngDevMode ? [{ debugName: "actions" }] : []);
  hideActions = input(false, ...ngDevMode ? [{ debugName: "hideActions" }] : []);
  formReady = output();
  formSubmit = output();
  formValidityChange = output();
  formValueChange = output();
  fieldValueChange = output();
  formService = inject(DynamicFormService);
  cdr = inject(ChangeDetectorRef);
  messageService = inject(MessageService);
  modalFormService = inject(ModalFormService);
  _previousFields;
  ngZone = inject(NgZone);
  destroyRef = inject(DestroyRef);
  formPathService = inject(FormPathService);
  formComparisonService = inject(FormComparisonService);
  formStructureService = inject(FormStructureService);
  conditionalFieldService = inject(ConditionalFieldService);
  formDependencyService = inject(FormDependencyService);
  formPersistenceService = inject(FormPersistenceService);
  formValidationService = inject(FormValidationService);
  fieldUpdateInProgress = false;
  rebuildTimeoutId = null;
  isDestroyed = false;
  form;
  collapsedSections = signal(/* @__PURE__ */ new Set(), ...ngDevMode ? [{ debugName: "collapsedSections" }] : []);
  dynamicFields = signal([], ...ngDevMode ? [{ debugName: "dynamicFields" }] : []);
  constructor() {
    this.setupFieldChangeEffect();
  }
  /**
   * Sets up the effect to handle field definition changes
   */
  setupFieldChangeEffect() {
    this.ngZone.runOutsideAngular(() => {
      effect(() => {
        const currentFields = this.fields();
        if (this.shouldSkipFieldUpdate(currentFields)) {
          return;
        }
        this.fieldUpdateInProgress = true;
        this._previousFields = currentFields;
        this.scheduleFormRebuild();
      });
    });
  }
  /**
   * Determines if field update should be skipped
   */
  shouldSkipFieldUpdate(currentFields) {
    const shouldSkip = this.formComparisonService.shouldSkipFieldUpdate(this._previousFields, currentFields, this.fieldUpdateInProgress, isDefined(this.form));
    if (shouldSkip && this._previousFields !== currentFields) {
      this._previousFields = currentFields;
    }
    return shouldSkip;
  }
  /**
   * Schedules form rebuild on next tick
   */
  scheduleFormRebuild() {
    if (isNullOrUndefined(this.form))
      return;
    if (this.rebuildTimeoutId) {
      clearTimeout(this.rebuildTimeoutId);
    }
    this.rebuildTimeoutId = setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.ngZone.run(() => {
        try {
          this.formStructureService.rebuildForm(this.form, this.fields(), this.formService.createFormGroup.bind(this.formService), {
            preserveValues: true,
            onFieldsProcessed: (form, fields) => {
              this.validateFieldNames(fields);
              this.dynamicFields.set([...fields]);
              this.processInitialConditionalFields();
              this.handleDependencies();
            },
            onValuesRestored: () => {
              this.formReady.emit(this.form);
            }
          });
        } finally {
          this.fieldUpdateInProgress = false;
        }
      });
    });
  }
  ngOnInit() {
    this.validateFieldNames(this.fields());
    this.form = this.formService.createFormGroup(this.fields());
    this.dynamicFields.set([...this.fields()]);
    this.processInitialConditionalFields();
    this.loadPersistedState();
    this.handleDependencies();
    this.setupFormPersistence();
    this.formReady.emit(this.form);
    this.form.statusChanges.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((status) => {
      this.formValidityChange.emit(status === "VALID");
    });
    this.form.valueChanges.pipe(distinctUntilChanged(), debounceTime(50), takeUntilDestroyed(this.destroyRef)).subscribe({
      next: (value) => {
        if (!isEmpty(value)) {
          this.formValueChange.emit(value);
        }
      },
      error: (err) => {
        console.error("Error in form value changes:", err);
      }
    });
  }
  ngOnDestroy() {
    this.isDestroyed = true;
    if (this.rebuildTimeoutId) {
      clearTimeout(this.rebuildTimeoutId);
    }
    this.modalFormService.closeActiveDialog();
  }
  validateFieldNames(fields) {
    this.formValidationService.validateFieldNames(fields);
  }
  setupFormPersistence() {
    this.formPersistenceService.setupFormPersistence(this.form, this.sections(), this.destroyRef);
  }
  handleDependencies() {
    this.formDependencyService.handleDependencies(this.sections(), this.form, this.destroyRef);
  }
  loadPersistedState() {
    this.formPersistenceService.loadPersistedState(this.form, this.sections());
  }
  handleAction(action) {
    if (action.action) {
      action.action(this.form);
    }
  }
  isDisabled(action) {
    if (isDefined(action.disabled)) {
      return isFunction(action.disabled) ? action.disabled(this.form) : !!action.disabled;
    }
    return false;
  }
  isVisible(action) {
    if (isDefined(action.visible)) {
      return isFunction(action.visible) ? action.visible(this.form) : !!action.visible;
    }
    return true;
  }
  toggleSection(sectionId) {
    const current = this.collapsedSections();
    if (current.has(sectionId)) {
      current.delete(sectionId);
    } else {
      current.add(sectionId);
    }
    this.collapsedSections.set(new Set(current));
  }
  isSectionCollapsed(sectionId) {
    return this.collapsedSections().has(sectionId);
  }
  isFieldVisible(field) {
    return field.visible !== false;
  }
  getFieldControl(key) {
    return this.form.get(key);
  }
  hasError(fieldName, group) {
    return this.formValidationService.hasError(fieldName, group);
  }
  getErrorMessage(fieldName, group) {
    return this.formValidationService.getErrorMessage(fieldName, group);
  }
  onSubmit() {
    if (this.form.valid) {
      this.formSubmit.emit(this.form.value);
    }
  }
  getFieldWithPath(field, parentPath) {
    return this.formPathService.getFieldWithPath(field, parentPath);
  }
  getFullPath(key, parentPath) {
    return this.formPathService.getFullPath(key, parentPath);
  }
  /**
   * Handles field changes that might trigger conditional fields
   * Uses the ConditionalFieldService for processing
   * @param field The field that changed
   * @param value The new value of the field
   * @param parentPath The parent path for nested fields
   */
  onFieldChange(field, value, parentPath = "") {
    this.conditionalFieldService.handleFieldChange(field, value, parentPath, {
      form: this.form,
      dynamicFields: this.dynamicFields,
      updateDynamicFields: (updater) => this.dynamicFields.set(updater(this.dynamicFields()))
    }, (f, v2, p2) => this.onFieldChange(f, v2, p2));
  }
  /**
   * Process initial conditional fields based on default values
   */
  processInitialConditionalFields() {
    this.conditionalFieldService.processInitialConditionalFields(this.fields(), this.form, {
      processConditionalFieldsAtLevel: (fields, parentPath = "") => this.processConditionalFieldsAtLevel(fields, parentPath)
    });
  }
  /**
   * Process conditional fields at a given level of the form structure
   * @param fields The fields to process at this level
   * @param parentPath Optional parent path for nested fields
   */
  processConditionalFieldsAtLevel(fields, parentPath = "") {
    this.conditionalFieldService.processConditionalFieldsAtLevel(fields, parentPath, this.form, {
      addConditionalFields: (fields2, parentPath2) => this.addConditionalFields(fields2, parentPath2),
      processNestedConditionalFields: (fields2, parentPath2) => this.processNestedConditionalFields(fields2, parentPath2)
    });
  }
  /**
   * Add conditional fields to both the form model and dynamic fields
   */
  addConditionalFields(fields, parentPath = "") {
    this.conditionalFieldService.addConditionalFields(fields, parentPath, {
      form: this.form,
      dynamicFields: this.dynamicFields,
      updateDynamicFields: (updater) => this.dynamicFields.set(updater(this.dynamicFields()))
    }, (fields2, parentPath2) => this.processNestedConditionalFields(fields2, parentPath2));
  }
  /**
   * Process nested conditional fields recursively
   */
  processNestedConditionalFields(fields, parentPath = "") {
    this.conditionalFieldService.processNestedConditionalFields(fields, parentPath, this.form, {
      processConditionalFieldsAtLevel: (fields2, parentPath2) => this.processConditionalFieldsAtLevel(fields2, parentPath2),
      addConditionalFields: (fields2, parentPath2) => this.addConditionalFields(fields2, parentPath2)
    });
  }
  handleAddItem(event) {
    const { field } = event;
    const modalConfig = field.props?.modalConfig;
    if (!modalConfig) {
      console.error(`Modal config missing for list field: ${field.key}`);
      return;
    }
    const initialData = modalConfig.defaultItemProvider ? modalConfig.defaultItemProvider() : {};
    this.openListItemModal(field, modalConfig, initialData);
  }
  handleEditItem(event) {
    const { field, item, index } = event;
    const modalConfig = field.props?.modalConfig;
    if (!modalConfig) {
      console.error(`Modal config missing for list field: ${field.key}`);
      return;
    }
    const itemDataForModal = ListModalResultHandler.deepCloneItem(item);
    this.openListItemModal(field, modalConfig, itemDataForModal, index);
  }
  async handleDeleteItem(event) {
    const { field, index } = event;
    const control = this.form.get(field.key);
    if (!control)
      return;
    const currentValue = control.value;
    if (!isArray(currentValue))
      return;
    if (!ListModalResultHandler.isEditIndexValid(index, currentValue.length)) {
      console.warn(`Delete index ${index} out of bounds for array of length ${currentValue.length}`);
      return;
    }
    const itemToDelete = currentValue[index];
    const modalConfig = field.props?.modalConfig;
    let proceedWithDefaultDeletion = true;
    if (modalConfig && isFunction(modalConfig.onDeleteItem)) {
      try {
        const result = await modalConfig.onDeleteItem(itemToDelete, index, field);
        if (result === false) {
          proceedWithDefaultDeletion = false;
        }
      } catch (error) {
        console.error(`Error in custom onDeleteItem for field ${field.key}:`, error);
      }
    }
    if (proceedWithDefaultDeletion) {
      const updatedValue = [...currentValue];
      updatedValue.splice(index, 1);
      control.setValue(updatedValue);
      control.markAsDirty();
      control.updateValueAndValidity();
      this.cdr.markForCheck();
    }
    this.modalFormService.showDeletionNotification();
  }
  /**
   * Opens a modal for adding or editing a list item
   *
   * @param field - The field configuration for the list
   * @param modalConfig - The modal configuration for the list
   * @param itemData - The data for the list item
   * @param editIndex - The index of the list item to edit
   * @returns void
   */
  openListItemModal(field, modalConfig, itemData, editIndex) {
    const control = this.form.get(field.key);
    if (isNullOrUndefined(control))
      return;
    this.modalFormService.openListItemModal({
      field,
      modalConfig,
      itemData,
      editIndex,
      destroyRef: this.destroyRef
    }).pipe(takeUntilDestroyed(this.destroyRef)).subscribe((result) => {
      const success = ListModalResultHandler.handleResult(result, control);
      if (success) {
        this.modalFormService.showSubmissionNotification(result.isEdit, modalConfig.hideSaveNotification);
        this.cdr.markForCheck();
      }
    });
  }
  warn = console.warn;
  static \u0275fac = function DynamicFormComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DynamicFormComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _DynamicFormComponent, selectors: [["app-dynamic-form"]], inputs: { fields: [1, "fields"], templates: [1, "templates"], sections: [1, "sections"], actions: [1, "actions"], hideActions: [1, "hideActions"] }, outputs: { formReady: "formReady", formSubmit: "formSubmit", formValidityChange: "formValidityChange", formValueChange: "formValueChange", fieldValueChange: "fieldValueChange" }, decls: 3, vars: 1, consts: [["formTemplate", ""], [3, "formGroup"], [3, "ngSubmit", "formGroup"], [1, "flex", "justify-end", "gap-2", "mt-4"], [1, "mb-4"], [1, "flex", "justify-between", "items-center", "p-3", "bg-gray-50", "cursor-pointer", "hover:bg-gray-100", 3, "click", "keydown.enter"], [1, "text-lg", "font-medium"], [1, "p-4"], [3, "field", "control", "customTemplate"], [3, "fieldChange", "field", "control", "customTemplate"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "type", "label", "severity", "outlined", "disabled", "icon", "styleClass", "loading"], [3, "onClick", "type", "label", "severity", "outlined", "disabled", "icon", "styleClass", "loading"], [3, "formGroupName"], [1, "mb-3"], [3, "fieldChange", "addItem", "editItem", "deleteItem", "field", "control", "customTemplate"]], template: function DynamicFormComponent_Template(rf, ctx) {
    if (rf & 1) {
      \u0275\u0275conditionalCreate(0, DynamicFormComponent_Conditional_0_Template, 4, 3, "form", 1);
      \u0275\u0275template(1, DynamicFormComponent_ng_template_1_Template, 2, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    }
    if (rf & 2) {
      \u0275\u0275conditional(ctx.form ? 0 : -1);
    }
  }, dependencies: [
    ReactiveFormsModule,
    \u0275NgNoValidate,
    NgControlStatusGroup,
    FormGroupDirective,
    FormGroupName,
    InputTextModule,
    InputNumberModule,
    TextareaModule,
    DatePickerModule,
    CheckboxModule,
    RadioButtonModule,
    MultiSelectModule,
    RatingModule,
    SliderModule,
    ChipModule,
    ColorPickerModule,
    PasswordModule,
    KnobModule,
    EditorModule,
    ButtonModule,
    Button,
    TooltipModule,
    DynamicFieldComponent,
    CommonModule,
    NgTemplateOutlet
  ], encapsulation: 2 });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamicFormComponent, [{
    type: Component,
    args: [{ selector: "app-dynamic-form", imports: [
      ReactiveFormsModule,
      InputTextModule,
      InputNumberModule,
      TextareaModule,
      DatePickerModule,
      CheckboxModule,
      RadioButtonModule,
      MultiSelectModule,
      RatingModule,
      SliderModule,
      ChipModule,
      ColorPickerModule,
      PasswordModule,
      KnobModule,
      EditorModule,
      ButtonModule,
      TooltipModule,
      DynamicFieldComponent,
      CommonModule
    ], template: `@if (form) {
  <form [formGroup]="form" (ngSubmit)="onSubmit()">
    @if (sections().length) {
      @for (section of sections(); track section.key) {
        <div class="mb-4">
          <div
            class="flex justify-between items-center p-3 bg-gray-50 cursor-pointer hover:bg-gray-100"
            (click)="toggleSection(section.key)"
            (keydown.enter)="toggleSection(section.key)"
          >
            <h3 class="text-lg font-medium">{{ section.title }}</h3>
            <i
              [class]="
                isSectionCollapsed(section.key)
                  ? 'pi pi-chevron-down'
                  : 'pi pi-chevron-up'
              "
            ></i>
          </div>

          @if (!isSectionCollapsed(section.key)) {
            <div class="p-4">
              @for (field of section.fields; track field.key) {
                @if (isFieldVisible(field)) {
                  @if (getFieldControl(field.key); as control) {
                    <app-dynamic-field
                      [field]="field"
                      [control]="control"
                      [customTemplate]="templates()[field.key]"
                      (fieldChange)="onFieldChange($event.field, $event.value)"
                    >
                    </app-dynamic-field>
                  }
                }
              }
            </div>
          }
        </div>
      }
    } @else {
      <ng-container
        *ngTemplateOutlet="
          formTemplate;
          context: { fields: dynamicFields(), group: form, parentPath: '' }
        "
      >
      </ng-container>
    }

    <!-- Form Actions -->
    @if (!hideActions()) {
      <div class="flex justify-end gap-2 mt-4">
        @for (action of actions(); track action.label) {
          @if (isVisible(action)) {
            <p-button
              [type]="action.type || 'button'"
              [label]="action.label"
              [severity]="action.severity"
              [outlined]="action.outlined"
              [disabled]="isDisabled(action)"
              [icon]="action.icon"
              [styleClass]="action.styleClass"
              [loading]="action?.loading?.() ?? false"
              (onClick)="handleAction(action)"
            >
            </p-button>
          }
        }
      </div>
    }
  </form>
}

<ng-template
  #formTemplate
  let-fields="fields"
  let-group="group"
  let-parentPath="parentPath"
>
  @for (field of fields; track field.key) {
    @if (isFieldVisible(field)) {
      <div [formGroup]="group">
        @if (field.type === 'group') {
          @if (group.get(field.key); as nestedGroup) {
            <div [formGroupName]="field.key">
              <h4 class="mb-3">{{ field.label }}</h4>
              <ng-container
                *ngTemplateOutlet="
                  formTemplate;
                  context: {
                    fields: field.fields,
                    group: group.get(field.key),
                    parentPath: parentPath
                      ? parentPath + '.' + field.key
                      : field.key,
                  }
                "
              >
              </ng-container>
            </div>
          } @else {
            {{
              warn(
                'FormGroup not found for key:',
                field.key,
                'in parent path:',
                parentPath
              )
            }}
          }
        } @else {
          @if (group.get(field.key); as control) {
            <app-dynamic-field
              [field]="getFieldWithPath(field, parentPath)"
              [control]="control"
              [customTemplate]="templates()[field.key]"
              (fieldChange)="onFieldChange($event.field, $event.value)"
              (addItem)="handleAddItem($event)"
              (editItem)="handleEditItem($event)"
              (deleteItem)="handleDeleteItem($event)"
            ></app-dynamic-field>
          } @else {
            {{
              warn(
                'FormControl not found for key:',
                field.key,
                'in parent path:',
                parentPath,
                group.value
              )
            }}
          }
        }
      </div>
    }
  }
</ng-template>
` }]
  }], () => [], { fields: [{ type: Input, args: [{ isSignal: true, alias: "fields", required: true }] }], templates: [{ type: Input, args: [{ isSignal: true, alias: "templates", required: false }] }], sections: [{ type: Input, args: [{ isSignal: true, alias: "sections", required: false }] }], actions: [{ type: Input, args: [{ isSignal: true, alias: "actions", required: false }] }], hideActions: [{ type: Input, args: [{ isSignal: true, alias: "hideActions", required: false }] }], formReady: [{ type: Output, args: ["formReady"] }], formSubmit: [{ type: Output, args: ["formSubmit"] }], formValidityChange: [{ type: Output, args: ["formValidityChange"] }], formValueChange: [{ type: Output, args: ["formValueChange"] }], fieldValueChange: [{ type: Output, args: ["fieldValueChange"] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(DynamicFormComponent, { className: "DynamicFormComponent", filePath: "src/app/shared/components/forms/dynamic-form/dynamic-form.component.ts", lineNumber: 91 });
})();

export {
  ApiSchemaService,
  ScrollPanel,
  ScrollPanelModule,
  EyeIcon,
  DynamicDialogConfig,
  DynamicDialogRef,
  DialogService,
  Password,
  PasswordModule,
  Rating,
  RatingModule,
  SliderModule,
  FileUpload,
  FileUploadModule,
  Platform,
  coerceArray,
  Tree,
  TreeModule,
  AssetGroupingService,
  EventFilterService,
  SplitButton,
  SplitButtonModule,
  ToggleSwitchModule,
  ModalFormService,
  ListFieldModalConfigBuilder,
  DynamicFormComponent
};
//# sourceMappingURL=chunk-JHNPE5AD.js.map

{
  "version": 3,
  "sources": ["src/app/shared/components/grid/grid-config-factory.ts", "src/app/shared/components/tree-table/tree-table-config-factory.ts"],
  "sourcesContent": ["/* eslint-disable @angular-eslint/prefer-inject */\nimport { Inject, Injectable, Injector, Optional, Type } from '@angular/core';\nimport { GridConfiguration, GridConfigurationEntry } from '../../models';\nimport { GRID_CONFIGS } from '../../../core/models';\nimport { GridConfigRegistryService } from '../../services/grid-config-registry.service';\n\n/**\n * Factory for creating grid configurations\n * @class GridConfigurationFactory\n */\n@Injectable()\nexport class GridConfigurationFactory {\n  private readonly configs = new Map<\n    string,\n    Type<GridConfiguration<unknown>>\n  >();\n  private readonly instanceCache = new Map<\n    string,\n    GridConfiguration<unknown>\n  >();\n\n  /**\n   * Creates an instance of GridConfigurationFactory\n   * @param {Injector} injector - Angular injector for dependency injection\n   * @param {GridConfigurationEntry[][]} configurations - Array of grid configuration entries\n   */\n  constructor(\n    private readonly injector: Injector,\n    @Optional() private readonly registry: GridConfigRegistryService | null,\n    @Optional()\n    @Inject(GRID_CONFIGS)\n    configurations: GridConfigurationEntry[][] = [],\n  ) {\n    const flatConfigs = configurations.flat();\n    for (const { entityType, config } of flatConfigs) {\n      this.configs.set(entityType, config);\n    }\n  }\n\n  /**\n   * Creates a grid configuration instance.\n   * Uses singleton pattern - returns cached instance if available, re-initializing with new params.\n   * @template T Type of data managed by the grid\n   * @param {ValidGridTypes} entityType - Type of grid configuration to create\n   * @param {Record<string, string | number>} params - Configuration parameters\n   * @returns {GridConfiguration<T>} The created grid configuration\n   * @throws {InvalidGridTypeError} If the grid type is not valid\n   * @throws {GridConfigurationError} If configuration creation fails\n   */\n  create<T>(\n    entityType: string,\n    params: Record<string, string | number>,\n  ): GridConfiguration<T> {\n    // Check cache first for singleton behavior\n    const cached = this.instanceCache.get(entityType);\n    if (cached !== undefined) {\n      cached.initialize(params); // Re-initialize with new params\n      return cached as GridConfiguration<T>;\n    }\n\n    const ConfigClass = this.configs.get(entityType);\n    if (!ConfigClass) {\n      throw new Error(`No grid configuration found for type: ${entityType}`);\n    }\n    const config = this.injector.get(ConfigClass) as GridConfiguration<T>;\n    // Initialize BEFORE registering to ensure config is fully initialized\n    config.initialize(params);\n    // Register with the registry if available (optional for better testability)\n    this.registry?.register(config);\n    // Cache the instance to prevent duplicates\n    // Type assertion is safe here because we control the cache and always return the correct type\n    this.instanceCache.set(entityType, config as GridConfiguration<unknown>);\n    return config;\n  }\n}\n", "/* eslint-disable @angular-eslint/prefer-inject */\nimport { Inject, Injectable, Injector, Optional, Type } from '@angular/core';\nimport {\n  TreeTableConfiguration,\n  TreeTableConfigurationEntry,\n} from '../../models';\nimport { TREE_TABLE_CONFIGS } from '../../../core/models';\nimport { GridConfigRegistryService } from '../../services/grid-config-registry.service';\n\n/**\n * Factory service for creating TreeTable configurations dynamically\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class TreeTableConfigurationFactory {\n  private readonly configRegistry = new Map<\n    string,\n    Type<TreeTableConfiguration>\n  >();\n  private readonly instanceCache = new Map<\n    string,\n    TreeTableConfiguration<unknown>\n  >();\n\n  constructor(\n    private readonly injector: Injector,\n    @Optional() private readonly registry: GridConfigRegistryService | null,\n    @Optional()\n    @Inject(TREE_TABLE_CONFIGS)\n    configurations: TreeTableConfigurationEntry[][] = [],\n  ) {\n    const flatConfigs = configurations.flat();\n    for (const { entityType, config } of flatConfigs) {\n      this.configRegistry.set(entityType, config);\n    }\n  }\n\n  /**\n   * Creates a TreeTable configuration for the specified entityType with the given parameters.\n   * Uses singleton pattern - returns cached instance if available, re-initializing with new params.\n   * @param entityType The type of TreeTable to create configuration for\n   * @param params Optional parameters to pass to the configuration factory\n   * @returns A TreeTable configuration object\n   */\n  create<T>(\n    entityType: string,\n    params: Record<string, string | number> = {},\n  ): TreeTableConfiguration<T> {\n    // Check cache first for singleton behavior\n    const cached = this.instanceCache.get(entityType);\n    if (cached !== undefined) {\n      cached.initialize(params); // Re-initialize with new params\n      return cached as TreeTableConfiguration<T>;\n    }\n\n    const factory = this.configRegistry.get(entityType);\n\n    if (!factory) {\n      throw new Error(\n        `No tree table configuration registered for type '${entityType}'`,\n      );\n    }\n\n    const config = this.injector.get<TreeTableConfiguration<T>>(factory);\n    // Initialize BEFORE registering to ensure config is fully initialized\n    config.initialize(params);\n    // Register with the registry if available (optional for better testability)\n    this.registry?.register(config);\n    // Cache the instance to prevent duplicates\n    // Type assertion is safe here because we control the cache and always return the correct type\n    this.instanceCache.set(\n      entityType,\n      config as TreeTableConfiguration<unknown>,\n    );\n    return config;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAWM,IAAO,2BAAP,MAAO,0BAAwB;EAgBhB;EACY;EAhBd,UAAU,oBAAI,IAAG;EAIjB,gBAAgB,oBAAI,IAAG;;;;;;EAUxC,YACmB,UACY,UAG7B,iBAA6C,CAAA,GAAE;AAJ9B,SAAA,WAAA;AACY,SAAA,WAAA;AAK7B,UAAM,cAAc,eAAe,KAAI;AACvC,eAAW,EAAE,YAAY,OAAM,KAAM,aAAa;AAChD,WAAK,QAAQ,IAAI,YAAY,MAAM;IACrC;EACF;;;;;;;;;;;EAYA,OACE,YACA,QAAuC;AAGvC,UAAM,SAAS,KAAK,cAAc,IAAI,UAAU;AAChD,QAAI,WAAW,QAAW;AACxB,aAAO,WAAW,MAAM;AACxB,aAAO;IACT;AAEA,UAAM,cAAc,KAAK,QAAQ,IAAI,UAAU;AAC/C,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI,MAAM,yCAAyC,UAAU,EAAE;IACvE;AACA,UAAM,SAAS,KAAK,SAAS,IAAI,WAAW;AAE5C,WAAO,WAAW,MAAM;AAExB,SAAK,UAAU,SAAS,MAAM;AAG9B,SAAK,cAAc,IAAI,YAAY,MAAoC;AACvE,WAAO;EACT;;qCA9DW,2BAAwB,mBAAA,QAAA,GAAA,mBAAA,2BAAA,CAAA,GAAA,mBAmBzB,cAAY,CAAA,CAAA;EAAA;4EAnBX,2BAAwB,SAAxB,0BAAwB,UAAA,CAAA;;;sEAAxB,0BAAwB,CAAA;UADpC;;UAkBI;;UACA;;UACA;WAAO,YAAY;;;;;ACflB,IAAO,gCAAP,MAAO,+BAA6B;EAWrB;EACY;EAXd,iBAAiB,oBAAI,IAAG;EAIxB,gBAAgB,oBAAI,IAAG;EAKxC,YACmB,UACY,UAG7B,iBAAkD,CAAA,GAAE;AAJnC,SAAA,WAAA;AACY,SAAA,WAAA;AAK7B,UAAM,cAAc,eAAe,KAAI;AACvC,eAAW,EAAE,YAAY,OAAM,KAAM,aAAa;AAChD,WAAK,eAAe,IAAI,YAAY,MAAM;IAC5C;EACF;;;;;;;;EASA,OACE,YACA,SAA0C,CAAA,GAAE;AAG5C,UAAM,SAAS,KAAK,cAAc,IAAI,UAAU;AAChD,QAAI,WAAW,QAAW;AACxB,aAAO,WAAW,MAAM;AACxB,aAAO;IACT;AAEA,UAAM,UAAU,KAAK,eAAe,IAAI,UAAU;AAElD,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MACR,oDAAoD,UAAU,GAAG;IAErE;AAEA,UAAM,SAAS,KAAK,SAAS,IAA+B,OAAO;AAEnE,WAAO,WAAW,MAAM;AAExB,SAAK,UAAU,SAAS,MAAM;AAG9B,SAAK,cAAc,IACjB,YACA,MAAyC;AAE3C,WAAO;EACT;;qCA7DW,gCAA6B,mBAAA,QAAA,GAAA,mBAAA,2BAAA,CAAA,GAAA,mBAc9B,oBAAkB,CAAA,CAAA;EAAA;4EAdjB,gCAA6B,SAA7B,+BAA6B,WAAA,YAF5B,OAAM,CAAA;;;sEAEP,+BAA6B,CAAA;UAHzC;WAAW;MACV,YAAY;KACb;;UAaI;;UACA;;UACA;WAAO,kBAAkB;;;",
  "names": []
}

{
  "version": 3,
  "sources": ["src/app/core/models/message.model.ts", "src/app/core/services/message.service.ts"],
  "sourcesContent": ["//broadcast-message.model.ts\nexport interface Message<T extends ActionType> {\n  id: string;\n  timestamp: number;\n  sender: 'angular' | 'flutter';\n  type: 'message' | 'action';\n  content?: string;\n  action?: T;\n  payload?: ActionPayload<T> | object;\n}\n\nexport interface ConnectionStatus {\n  isConnected: boolean;\n  lastError?: string;\n}\n\nexport enum ActionType {\n  navigate = 'navigate', //requesting navigation to route\n  get_auth_tokens = 'get_auth_tokens', //flutter requesting auth tokens from angular\n  update_auth_tokens = 'update_auth_tokens', //updating auth tokens in flutter with angular received auth tokens\n  logout = 'logout', //logout\n  profile_changed = 'profile_changed', //profile (client) changed event\n  update_hash = 'update_hash',\n  ready = 'ready',\n  r2_token_generated = 'r2_token_generated',\n  r2_token_failed = 'r2_token_failed',\n  entity_updated = 'entity_updated',\n}\n\nexport enum NavigationPaths {\n  positions = 'positions',\n  login = 'login',\n  test = 'test',\n  auth = 'auth',\n}\n\n/**\n * Payload for navigation actions\n */\nexport interface NavigatePayload {\n  route: string;\n  params?: Record<string, string>;\n  queryParams?: Record<string, string>;\n  timestamp?: number;\n  updateUrlOnly?: boolean; // Add this field\n}\n\n/**\n * Payload for auth token update actions\n */\nexport interface AuthTokensPayload {\n  accessToken: string;\n  refreshToken: string;\n  tokenExpiry: string;\n  userSession: string;\n}\n\n/**\n * Payload for profile changed actions\n */\nexport interface ProfileChangedPayload {\n  clientId?: string;\n  id?: string;\n}\n\n/**\n * Union type of all possible action payloads\n */\nexport type ActionPayload<T extends ActionType> = T extends ActionType.navigate\n  ? NavigatePayload\n  : T extends ActionType.update_auth_tokens\n    ? AuthTokensPayload\n    : T extends ActionType.profile_changed\n      ? ProfileChangedPayload\n      : undefined;\n", "// message.service.ts\nimport { Injectable, inject } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport {\n  Message,\n  ConnectionStatus,\n  ActionType,\n  ActionPayload,\n  AuthTokensPayload,\n  NavigatePayload,\n  ProfileChangedPayload,\n} from './../models/message.model';\nimport { AuthDataService } from './auth-data.service';\nimport {\n  LOCAL_STORAGE_KEY_ACCESS_TOKEN,\n  LOCAL_STORAGE_KEY_REFRESH_TOKEN,\n  LOCAL_STORAGE_KEY_TOKEN_EXPIRY,\n  LOCAL_STORAGE_KEY_USER_SESSION,\n} from '../models';\nimport { Router } from '@angular/router';\nimport {\n  hasProperty,\n  isDefined,\n  isNullOrUndefined,\n  isObject,\n  isString,\n} from '../../shared/utils';\nimport { ApiUrlService } from './api-url.service';\nimport { BroadcastEventMessageService } from '../../features/administration/services/broadcast-event-messages.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class BroadcastMessageService {\n  private readonly authDataService = inject(AuthDataService);\n  private readonly router = inject(Router);\n  private readonly apiUrlService = inject(ApiUrlService);\n  private readonly broadcastEventMessageService = inject(\n    BroadcastEventMessageService,\n  );\n\n  private channel!: BroadcastChannel;\n  private readonly messageSubject = new BehaviorSubject<Message<ActionType>[]>(\n    [],\n  );\n  private readonly connectionStatusSubject =\n    new BehaviorSubject<ConnectionStatus>({\n      isConnected: false,\n    });\n  private isUpdatingHash = false;\n  private hasSentInitialRoute = false;\n  private readonly MAX_INITIAL_ROUTE_RETRIES = 3;\n  private initialRouteRetryCount = 0;\n\n  readonly messages$ = this.messageSubject.asObservable();\n  readonly connectionStatus$ = this.connectionStatusSubject.asObservable();\n\n  constructor() {\n    this.initializeChannel();\n    this.subscribeToBroadcastEvents();\n  }\n\n  private subscribeToBroadcastEvents(): void {\n    this.broadcastEventMessageService\n      .on('entity-updated')\n      .subscribe((payload) => {\n        this.sendAction(\n          ActionType.entity_updated,\n          payload,\n          'Entity updated event',\n        );\n      });\n  }\n\n  private sendInitialRoute(): void {\n    try {\n      const currentPath = window.location.hash.substring(1); // Remove the # character\n      if (currentPath !== '') {\n        const [path, queryString] = currentPath.split('?');\n        const cleanPath = path.replace(/^\\/+|\\/+$/g, '');\n\n        // Use route mapping to get the Flutter route\n        const flutterRoute = this.getFlutterRoute(cleanPath);\n\n        // Skip sending route for auth/login\n        if (flutterRoute === '/auth/login') {\n          return;\n        }\n\n        const queryParams =\n          queryString !== undefined && queryString !== ''\n            ? Object.fromEntries(new URLSearchParams(queryString))\n            : undefined;\n\n        this.sendAction(\n          ActionType.navigate,\n          {\n            route: flutterRoute || '/position', // Fallback to position if path is empty\n            queryParams,\n          },\n          'Sending initial route to Flutter',\n        );\n      } else {\n        this.sendAction(\n          ActionType.navigate,\n          {\n            route: '/position',\n            queryParams: undefined,\n          },\n          'Sending default route to Flutter',\n        );\n      }\n    } catch (error) {\n      this.handleError('Failed to send initial route', error);\n    }\n  }\n\n  private initializeChannel(): void {\n    try {\n      this.channel = new BroadcastChannel('flutter-angular-channel');\n      this.connectionStatusSubject.next({ isConnected: true });\n\n      this.channel.onmessage = async (event) => {\n        const message: Message<ActionType> =\n          typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n\n        // Handle the received message based on its type\n        await this.handleReceivedMessage(message);\n      };\n\n      this.channel.onmessageerror = (error) => {\n        this.handleError('Message error occurred', error);\n      };\n\n      window.addEventListener('unload', () => {\n        this.channel.close();\n      });\n    } catch (error) {\n      this.handleError('Failed to initialize channel', error);\n    }\n  }\n\n  private async handleReceivedMessage(\n    message: Message<ActionType>,\n  ): Promise<void> {\n    switch (message.type) {\n      case 'message': {\n        const currentMessages = this.messageSubject.value;\n        this.messageSubject.next([...currentMessages, message]);\n        break;\n      }\n      case 'action':\n        if (isDefined(message.action)) {\n          await this.performAction(message.action, message.payload);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  private async performAction<T extends ActionType>(\n    action: T,\n    payload?: ActionPayload<T>,\n  ): Promise<void> {\n    switch (action) {\n      case ActionType.ready: {\n        if (!this.hasSentInitialRoute) {\n          try {\n            this.sendInitialRoute();\n            this.hasSentInitialRoute = true;\n            this.initialRouteRetryCount = 0;\n          } catch (error) {\n            this.handleError('Failed to send initial route', error);\n            // Retry sending initial route if we haven't exceeded max retries\n            if (this.initialRouteRetryCount < this.MAX_INITIAL_ROUTE_RETRIES) {\n              this.initialRouteRetryCount++;\n              void new Promise<void>((resolve) => {\n                setTimeout(() => {\n                  this.hasSentInitialRoute = false;\n                  resolve();\n                }, 1000 * this.initialRouteRetryCount); // Exponential backoff\n              }).then(() => this.performAction(ActionType.ready, undefined));\n            }\n          }\n        }\n        break;\n      }\n      case ActionType.update_hash: {\n        if (this.isUpdatingHash) {\n          return;\n        }\n        const hashPayload = payload as {\n          path: string;\n          queryParams?: Record<string, string>;\n        };\n        if (\n          (hashPayload?.path !== undefined && hashPayload.path !== '') ||\n          (hashPayload?.queryParams !== undefined &&\n            Object.keys(hashPayload.queryParams).length > 0)\n        ) {\n          this.isUpdatingHash = true;\n          try {\n            const baseUrl = window.location.href.split('#')[0];\n            const currentPath = window.location.hash.substring(1) || '';\n\n            // Get the path without query parameters\n            const pathWithoutQuery = currentPath.split('?')[0];\n            let newHash =\n              hashPayload.path !== undefined && hashPayload.path !== ''\n                ? `#/${hashPayload.path}`\n                : `#${pathWithoutQuery}`;\n\n            if (\n              hashPayload.queryParams !== undefined &&\n              Object.keys(hashPayload.queryParams).length > 0\n            ) {\n              // Get current query params\n              const currentQueryString = currentPath.split('?')[1] || '';\n              const params = new URLSearchParams(currentQueryString);\n\n              // Update with new params\n              Object.entries(hashPayload.queryParams).forEach(\n                ([key, value]) => {\n                  params.set(key, value);\n                },\n              );\n\n              newHash += `?${params.toString()}`;\n            }\n\n            window.history.replaceState(null, '', baseUrl + newHash);\n          } catch (error) {\n            this.handleError('Failed to update hash', error);\n          } finally {\n            this.isUpdatingHash = false;\n          }\n        }\n        break;\n      }\n      case ActionType.navigate: {\n        const navPayload = payload as NavigatePayload;\n        if (navPayload?.route !== undefined && navPayload.route !== '') {\n          // Remove leading slash if present\n          const route = navPayload.route.startsWith('/')\n            ? navPayload.route.substring(1)\n            : navPayload.route;\n\n          if (navPayload.updateUrlOnly === true) {\n            await this.router.navigate([route], {\n              queryParams: navPayload.queryParams,\n              replaceUrl: true,\n              skipLocationChange: false,\n            });\n          } else {\n            // Regular navigation\n            if (navPayload?.queryParams !== undefined) {\n              await this.router.navigate([route], {\n                queryParams: navPayload.queryParams,\n              });\n            } else {\n              await this.router.navigate([route]);\n            }\n          }\n        }\n        break;\n      }\n      case ActionType.get_auth_tokens:\n        this.sendAuthTokensToFlutter();\n        break;\n      case ActionType.update_auth_tokens: {\n        // Handle token updates from Flutter\n        const tokenPayload = payload as AuthTokensPayload;\n        if (\n          tokenPayload?.accessToken !== undefined &&\n          tokenPayload.accessToken !== ''\n        ) {\n          localStorage.setItem(\n            LOCAL_STORAGE_KEY_ACCESS_TOKEN,\n            tokenPayload.accessToken,\n          );\n          localStorage.setItem(\n            LOCAL_STORAGE_KEY_REFRESH_TOKEN,\n            tokenPayload.refreshToken,\n          );\n          localStorage.setItem(\n            LOCAL_STORAGE_KEY_TOKEN_EXPIRY,\n            tokenPayload.tokenExpiry,\n          );\n          localStorage.setItem(\n            LOCAL_STORAGE_KEY_USER_SESSION,\n            tokenPayload.userSession,\n          );\n        }\n        break;\n      }\n      case ActionType.logout:\n        this.authDataService.logout();\n        break;\n      case ActionType.profile_changed: {\n        const profilePayload = payload as ProfileChangedPayload;\n        if (isDefined(profilePayload?.clientId)) {\n          this.sendProfileChangedEventToFlutter(profilePayload.clientId);\n        }\n        break;\n      }\n      // Handle R2 token generation success\n      case ActionType.r2_token_generated: {\n        const tokenPayload = payload as {\n          r2Token: string;\n          success: boolean;\n          timestamp: string;\n        };\n        if (\n          tokenPayload?.r2Token !== undefined &&\n          tokenPayload.r2Token !== ''\n        ) {\n          // No specific action needed for now, but we can store/use the token if needed in future\n        }\n        break;\n      }\n      // Handle R2 token generation failure\n      case ActionType.r2_token_failed: {\n        const errorPayload = payload as {\n          success: boolean;\n          error?: string;\n          timestamp: string;\n        };\n        console.error(\n          'R2 token generation failed:',\n          errorPayload.error !== undefined && errorPayload.error !== ''\n            ? errorPayload.error\n            : 'unknown error',\n        );\n        // Attempt to retry token generation after a delay\n        setTimeout(() => {\n          this.sendAuthTokensToFlutter();\n        }, 5000); // Wait 5 seconds before trying again\n        break;\n      }\n      default:\n        console.warn('Unknown action:', action);\n        break;\n    }\n  }\n\n  sendAuthTokensToFlutter(): void {\n    //send tokens to flutter\n    const accessToken =\n      localStorage.getItem(LOCAL_STORAGE_KEY_ACCESS_TOKEN) ?? '';\n    const refreshToken =\n      localStorage.getItem(LOCAL_STORAGE_KEY_REFRESH_TOKEN) ?? '';\n    const tokenExpiry =\n      localStorage.getItem(LOCAL_STORAGE_KEY_TOKEN_EXPIRY) ?? '';\n    const userSession =\n      localStorage.getItem(LOCAL_STORAGE_KEY_USER_SESSION) ?? '';\n    const currentApiUrl = this.apiUrlService.getCurrentApiUrl();\n\n    // Only send tokens if we have valid authentication\n    if (accessToken && refreshToken && userSession) {\n      try {\n        // Add a flag to indicate this is a forced refresh to regenerate R2 token\n        this.sendAction(\n          ActionType.update_auth_tokens,\n          {\n            accessToken,\n            refreshToken,\n            tokenExpiry,\n            userSession,\n            forceRegenerateR2Token: true,\n            timestamp: Date.now(), // Add timestamp to ensure message is treated as unique\n            apiUrl: currentApiUrl,\n          },\n          'Sending auth tokens to flutter with R2 token regeneration flag',\n        );\n      } catch (error) {\n        console.error('Error sending auth tokens to Flutter:', error);\n      }\n    } else {\n      console.warn(\n        'Cannot send auth tokens to Flutter - missing required tokens',\n      );\n    }\n  }\n\n  sendProfileChangedEventToFlutter(id: string): void {\n    //send profile (client) changed event to flutter\n    this.sendAction(\n      ActionType.profile_changed,\n      {\n        id: id,\n      },\n      'Profile changed event',\n    );\n  }\n\n  sendMessage(content: string): void {\n    if (isNullOrUndefined(this.channel)) {\n      this.handleError('Channel not initialized', null);\n      return;\n    }\n    try {\n      const message: Message<ActionType> = {\n        id: crypto.randomUUID(),\n        content,\n        timestamp: Date.now(),\n        sender: 'angular',\n        type: 'message',\n      };\n      this.channel.postMessage(JSON.stringify(message));\n      const currentMessages = this.messageSubject.value;\n      this.messageSubject.next([...currentMessages, message]);\n    } catch (error) {\n      this.handleError('Failed to send message', error);\n    }\n  }\n\n  sendAction<T extends ActionType>(\n    action: T,\n    payload?: ActionPayload<T> | object,\n    content?: string,\n  ): void {\n    if (isNullOrUndefined(this.channel)) {\n      this.handleError('Channel not initialized', null);\n      return;\n    }\n\n    try {\n      const message: Message<T> = {\n        id: crypto.randomUUID(),\n        timestamp: Date.now(),\n        sender: 'angular',\n        type: 'action',\n        content: isString(content) ? content : '',\n        action,\n        payload,\n      };\n\n      this.channel.postMessage(JSON.stringify(message));\n    } catch (error) {\n      this.handleError('Failed to send action', error);\n    }\n  }\n\n  private handleError(message: string, error: unknown): void {\n    console.error(message, error);\n\n    const errorMessage =\n      isObject(error) && hasProperty(error, 'message')\n        ? error['message']\n        : 'Unknown error';\n\n    this.connectionStatusSubject.next({\n      isConnected: false,\n      lastError: `${message}: ${errorMessage}`,\n    });\n  }\n\n  // Add route mapping based on your existing routes\n  private readonly routeMapping: Record<string, string> = {\n    position: '/position',\n    alerts: '/alerts',\n    media: '/media',\n    history: '/history',\n    user: '/user',\n    admin: '/admin',\n  };\n\n  // Add method to convert Angular routes to Flutter routes\n  getFlutterRoute(angularRoute: string): string {\n    // Remove leading slash and hash if present\n    const normalizedRoute = angularRoute.replace(/^[/#]+/, '');\n\n    // Check direct mapping\n    for (const [key, value] of Object.entries(this.routeMapping)) {\n      if (normalizedRoute.startsWith(key)) {\n        return value;\n      }\n    }\n\n    // Return original route if no mapping found\n    return '/' + normalizedRoute;\n  }\n}\n"],
  "mappings": "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",
  "names": ["ActionType", "NavigationPaths"]
}

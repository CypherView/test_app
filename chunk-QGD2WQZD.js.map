{
  "version": 3,
  "sources": ["src/app/features/administration/services/admin-state.service.ts", "src/app/core/services/session-cleanup.service.ts", "src/app/core/services/auth-data.service.ts"],
  "sourcesContent": ["import { computed, Injectable, signal } from '@angular/core';\nimport {\n  ClientListItem,\n  CompanyGroupResponse,\n  ClientResponse,\n  VendorResponse,\n  VendorListItem,\n  DistributorResponse,\n  DistributorListItem,\n} from '../../../api';\nimport {\n  AdminTreeState,\n  ClientPaginationState,\n} from '../models/admin-tree-state.interface';\nimport { TreeNode } from 'primeng/api';\nimport { isDefined, isNullOrUndefined } from '../../../shared/utils';\n\n// Type alias for vendor union type\ntype VendorItem = VendorListItem | VendorResponse;\n\n/**\n * Service responsible for managing the state of the administration tree.\n * Handles loading states, vendor data, client relationships, and UI state.\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class AdminStateService {\n  // Private signals for state\n  private readonly state = signal<AdminTreeState>({\n    // New distributor-scoped data\n    distributorVendors: {},\n    vendorClients: {},\n    vendorGroups: {},\n    groupClients: {},\n    loadedVendors: {},\n    loadingVendors: {},\n    failedVendors: {},\n    expandedNodes: {},\n    expandedGroups: {},\n    clientPagination: {},\n\n    // Global state\n    selectedClient: null,\n    clientVendor: null,\n    vendorDistributor: null,\n    distributors: [],\n    initialLoading: false,\n    expandedDistributors: new Set<string>(),\n  });\n\n  // Public computed values\n  readonly distributorVendors = computed(() => this.state().distributorVendors);\n  readonly vendorClients = computed(() => this.state().vendorClients);\n  readonly vendorGroups = computed(() => this.state().vendorGroups);\n  readonly groupClients = computed(() => this.state().groupClients);\n  readonly loadedVendors = computed(() => this.state().loadedVendors);\n  readonly loadingVendors = computed(() => this.state().loadingVendors);\n  readonly failedVendors = computed(() => this.state().failedVendors);\n  readonly expandedNodes = computed(() => this.state().expandedNodes);\n  readonly expandedGroups = computed(() => this.state().expandedGroups);\n  readonly clientPagination = computed(() => this.state().clientPagination);\n  readonly selectedClient = computed(() => this.state().selectedClient);\n  readonly clientVendor = computed(() => this.state().clientVendor);\n  readonly vendorDistributor = computed(() => this.state().vendorDistributor);\n  readonly distributors = computed(() => this.state().distributors);\n  readonly initialLoading = computed(() => this.state().initialLoading);\n  readonly expandedDistributors = computed(\n    () => this.state().expandedDistributors,\n  );\n\n  // Computed values that depend on multiple state properties\n  readonly isLoading = computed(() => {\n    const state = this.state();\n\n    // Early return for initial loading\n    if (state.initialLoading) {\n      return true;\n    }\n\n    // Get current distributor context once\n    const currentDistributorId = this.getCurrentDistributorId();\n\n    // If no distributor context, no vendor loading can occur\n    if (isNullOrUndefined(currentDistributorId)) {\n      return false;\n    }\n\n    // Check for loading vendors in current distributor - simplified lookup\n    const distributorLoadingVendors =\n      state.loadingVendors[currentDistributorId];\n    return isDefined(distributorLoadingVendors)\n      ? distributorLoadingVendors.size > 0\n      : false;\n  });\n\n  readonly hasClientData = computed(() => !!this.state().selectedClient);\n  readonly hasVendorData = computed(() => !!this.state().clientVendor);\n  readonly hasDistributorData = computed(\n    () => !!this.state().vendorDistributor,\n  );\n\n  // Helper to generate pagination key\n  private getPaginationKey(vendorId: string, groupId?: string): string {\n    return isDefined(groupId) ? `${vendorId}_${groupId}` : vendorId;\n  }\n\n  /**\n   * Validates vendor ID and throws if invalid\n   * @param vendorId - The vendor ID to validate\n   * @throws Error if vendor ID is invalid\n   */\n  private validateVendorId(vendorId: string): void {\n    if (!vendorId?.trim()) {\n      throw new Error('Invalid vendor ID');\n    }\n  }\n\n  /**\n   * Gets the current distributor context ID from the vendor distributor\n   * @returns The current distributor ID or null if not available\n   */\n  getCurrentDistributorId(): string | null {\n    return this.vendorDistributor()?.id ?? null;\n  }\n\n  /**\n   * Helper method to get distributor-scoped pagination key\n   * @param distributorId - The distributor ID\n   * @param vendorId - The vendor ID\n   * @param groupId - Optional group ID\n   * @returns Combined pagination key\n   */\n  getDistributorPaginationKey(\n    distributorId: string,\n    vendorId: string,\n    groupId?: string,\n  ): string {\n    const baseKey = isDefined(groupId) ? `${vendorId}_${groupId}` : vendorId;\n    return `${distributorId}_${baseKey}`;\n  }\n\n  // State update methods\n  /**\n   * Sets the initial loading state of the administration tree\n   * @param loading - Boolean indicating if initial data is being loaded\n   */\n  setInitialLoading(loading: boolean): void {\n    this.state.update((state) => ({\n      ...state,\n      initialLoading: loading,\n    }));\n  }\n\n  /**\n   * @deprecated Use addDistributorLoadingVendor instead\n   * Adds a vendor to the loading state (legacy method for backward compatibility)\n   * @param vendorId - The ID of the vendor to mark as loading\n   */\n  addLoadingVendor(vendorId: string): void {\n    const distributorId = this.getCurrentDistributorId();\n    if (isDefined(distributorId)) {\n      this.addDistributorLoadingVendor(distributorId, vendorId);\n    }\n  }\n\n  /**\n   * @deprecated Use removeDistributorLoadingVendor instead\n   * Removes a vendor from the loading state (legacy method for backward compatibility)\n   * @param vendorId - The ID of the vendor to remove from loading state\n   */\n  removeLoadingVendor(vendorId: string): void {\n    const distributorId = this.getCurrentDistributorId();\n    if (isDefined(distributorId)) {\n      this.removeDistributorLoadingVendor(distributorId, vendorId);\n    }\n  }\n\n  /**\n   * @deprecated Use addDistributorVendorClients instead\n   * Adds vendor clients (legacy method for backward compatibility)\n   * @param vendorId - The ID of the vendor\n   * @param clients - Array of client items\n   * @param pagination - Pagination info from the API call\n   * @param append - Whether to append or replace clients\n   */\n  addVendorClients(\n    vendorId: string,\n    clients: ClientListItem[],\n    pagination: Omit<ClientPaginationState, 'loadingMore'>,\n    append = false,\n  ): void {\n    const distributorId = this.getCurrentDistributorId();\n    if (isDefined(distributorId)) {\n      this.addDistributorVendorClients(\n        distributorId,\n        vendorId,\n        clients,\n        pagination,\n        append,\n      );\n    }\n  }\n\n  /**\n   * @deprecated Use markDistributorVendorAsLoaded instead\n   * Marks a vendor as loaded (legacy method for backward compatibility)\n   * @param vendorId - The ID of the vendor to mark as loaded\n   */\n  markVendorAsLoaded(vendorId: string): void {\n    const distributorId = this.getCurrentDistributorId();\n    if (isDefined(distributorId)) {\n      this.markDistributorVendorAsLoaded(distributorId, vendorId);\n    }\n  }\n\n  /**\n   * Marks a vendor as failed to load for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor to mark as failed\n   */\n  markDistributorVendorAsFailedToLoad(\n    distributorId: string,\n    vendorId: string,\n  ): void {\n    this.state.update((state) => {\n      const distributorFailedVendors =\n        state.failedVendors[distributorId] ?? new Set();\n      return {\n        ...state,\n        failedVendors: {\n          ...state.failedVendors,\n          [distributorId]: new Set(distributorFailedVendors).add(vendorId),\n        },\n      };\n    });\n  }\n\n  /**\n   * @deprecated Use markDistributorVendorAsFailedToLoad instead\n   * Marks a vendor as failed to load (legacy method for backward compatibility)\n   * @param vendorId - The ID of the vendor to mark as failed\n   */\n  markVendorAsFailedToLoad(vendorId: string): void {\n    const distributorId = this.getCurrentDistributorId();\n    if (isDefined(distributorId)) {\n      this.markDistributorVendorAsFailedToLoad(distributorId, vendorId);\n    }\n  }\n\n  /**\n   * @deprecated Use setDistributorNodeExpanded instead\n   * Toggles the expansion state of a node (legacy method for backward compatibility)\n   * @param nodeId - The ID of the node to toggle\n   * @param expanded - Optional explicit expanded state, if not provided will toggle current state\n   */\n  toggleNodeExpansion(nodeId: string, expanded?: boolean): void {\n    const distributorId = this.getCurrentDistributorId();\n    if (isDefined(distributorId)) {\n      const currentlyExpanded = this.isDistributorNodeExpanded(\n        distributorId,\n        nodeId,\n      );\n      const newExpanded = expanded ?? !currentlyExpanded;\n      this.setDistributorNodeExpanded(distributorId, nodeId, newExpanded);\n    }\n  }\n\n  /**\n   * Sets vendor groups for a vendor (legacy method for backward compatibility)\n   * @deprecated Use setDistributorVendorGroups instead\n   * @param vendorId - The ID of the vendor\n   * @param groups - Array of company group responses\n   */\n  setVendorGroups(vendorId: string, groups: CompanyGroupResponse[]): void {\n    const distributorId = this.getCurrentDistributorId();\n    if (isDefined(distributorId)) {\n      this.setDistributorVendorGroups(distributorId, vendorId, groups);\n    }\n  }\n\n  /**\n   * Checks if a vendor is currently loading within a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @returns Whether the vendor is loading\n   */\n  isDistributorVendorLoading(distributorId: string, vendorId: string): boolean {\n    return this.state().loadingVendors[distributorId]?.has(vendorId) ?? false;\n  }\n\n  /**\n   * Checks if a vendor has been loaded within a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @returns Whether the vendor has been loaded\n   */\n  isDistributorVendorLoaded(distributorId: string, vendorId: string): boolean {\n    return this.state().loadedVendors[distributorId]?.has(vendorId) ?? false;\n  }\n\n  /**\n   * Checks if a vendor failed to load within a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @returns Whether the vendor failed to load\n   */\n  isDistributorVendorFailedToLoad(\n    distributorId: string,\n    vendorId: string,\n  ): boolean {\n    return this.state().failedVendors[distributorId]?.has(vendorId) ?? false;\n  }\n\n  /**\n   * @deprecated Use isDistributorVendorLoading instead\n   * Checks if a vendor is currently loading (legacy method)\n   * @param vendorId - The ID of the vendor\n   * @returns Whether the vendor is loading in current distributor context\n   */\n  isVendorLoading(vendorId: string): boolean {\n    const distributorId = this.getCurrentDistributorId();\n    return isDefined(distributorId)\n      ? this.isDistributorVendorLoading(distributorId, vendorId)\n      : false;\n  }\n\n  /**\n   * @deprecated Use isDistributorVendorLoaded instead\n   * Checks if a vendor has been loaded (legacy method)\n   * @param vendorId - The ID of the vendor\n   * @returns Whether the vendor has been loaded in current distributor context\n   */\n  isVendorLoaded(vendorId: string): boolean {\n    const distributorId = this.getCurrentDistributorId();\n    return isDefined(distributorId)\n      ? this.isDistributorVendorLoaded(distributorId, vendorId)\n      : false;\n  }\n\n  /**\n   * @deprecated Use isDistributorVendorFailedToLoad instead\n   * Checks if a vendor failed to load (legacy method)\n   * @param vendorId - The ID of the vendor\n   * @returns Whether the vendor failed to load in current distributor context\n   */\n  isVendorFailedToLoad(vendorId: string): boolean {\n    const distributorId = this.getCurrentDistributorId();\n    return isDefined(distributorId)\n      ? this.isDistributorVendorFailedToLoad(distributorId, vendorId)\n      : false;\n  }\n\n  /**\n   * Clears failed vendor state for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor to clear from failed state\n   */\n  clearDistributorVendorFailedState(\n    distributorId: string,\n    vendorId: string,\n  ): void {\n    this.state.update((state) => {\n      const distributorFailedVendors =\n        state.failedVendors[distributorId] ?? new Set();\n      const newFailedVendors = new Set(distributorFailedVendors);\n      newFailedVendors.delete(vendorId);\n\n      return {\n        ...state,\n        failedVendors: {\n          ...state.failedVendors,\n          [distributorId]: newFailedVendors,\n        },\n      };\n    });\n  }\n\n  /**\n   * Gets all vendor IDs that are currently loading for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @returns Set of vendor IDs that are loading\n   */\n  getDistributorLoadingVendorIds(distributorId: string): Set<string> {\n    return this.state().loadingVendors[distributorId] ?? new Set();\n  }\n\n  /**\n   * Gets all vendor IDs that have been loaded for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @returns Set of vendor IDs that have been loaded\n   */\n  getDistributorLoadedVendorIds(distributorId: string): Set<string> {\n    return this.state().loadedVendors[distributorId] ?? new Set();\n  }\n\n  /**\n   * Gets all vendor IDs that failed to load for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @returns Set of vendor IDs that failed to load\n   */\n  getDistributorFailedVendorIds(distributorId: string): Set<string> {\n    return this.state().failedVendors[distributorId] ?? new Set();\n  }\n\n  /**\n   * Set the loading state for a specific vendor in a distributor\n   */\n  setVendorLoadingForDistributor(\n    distributorId: string,\n    vendorId: string,\n  ): void {\n    this.state.update((state) => {\n      const distributorLoading =\n        state.loadingVendors[distributorId] ?? new Set();\n      return {\n        ...state,\n        loadingVendors: {\n          ...state.loadingVendors,\n          [distributorId]: new Set(distributorLoading).add(vendorId),\n        },\n      };\n    });\n  }\n\n  /**\n   * Clear the loading state for a specific vendor in a distributor\n   */\n  clearVendorLoadingForDistributor(\n    distributorId: string,\n    vendorId: string,\n  ): void {\n    this.state.update((state) => {\n      const distributorLoading = state.loadingVendors[distributorId];\n      if (isNullOrUndefined(distributorLoading)) return state;\n\n      const newLoadingVendors = new Set(distributorLoading);\n      newLoadingVendors.delete(vendorId);\n\n      return {\n        ...state,\n        loadingVendors: {\n          ...state.loadingVendors,\n          [distributorId]: newLoadingVendors,\n        },\n      };\n    });\n  }\n\n  /**\n   * Sets the currently selected client\n   * @param client - The client response object or null to clear selection\n   */\n  setSelectedClient(client: ClientResponse | null): void {\n    this.state.update((state) => ({\n      ...state,\n      selectedClient: client,\n    }));\n  }\n\n  /**\n   * Sets the vendor associated with the selected client\n   * @param vendor - The vendor response object or null to clear\n   */\n  setClientVendor(vendor: VendorResponse | null): void {\n    this.state.update((state) => ({\n      ...state,\n      clientVendor: vendor,\n    }));\n  }\n\n  /**\n   * Sets the distributor associated with the current vendor\n   * @param vendor - The vendor response object or null to clear\n   */\n  setVendorDistributor(vendor: DistributorResponse | null): void {\n    this.state.update((state) => ({\n      ...state,\n      vendorDistributor: vendor,\n    }));\n  }\n\n  /**\n   * Updates the list of vendors in the state\n   * @param vendors - Array of vendor list items\n   */\n  setVendors(vendors: VendorListItem[]): void {\n    this.state.update((state) => ({\n      ...state,\n      vendors,\n    }));\n  }\n\n  /**\n   * Updates the list of distributors in the state\n   * @param distributors - Array of distributor list items\n   */\n  setDistributors(distributors: DistributorListItem[]): void {\n    this.state.update((state) => ({\n      ...state,\n      distributors,\n    }));\n  }\n\n  /**\n   * Adds or appends group clients and updates pagination state.\n   * @param distributorId - The ID of the distributor.\n   * @param vendorId - The ID of the vendor.\n   * @param groupId - The ID of the group.\n   * @param clients - Array of client items.\n   * @param pagination - Pagination info from the API call.\n   * @param append - Whether to append or replace clients.\n   */\n  addGroupClients(\n    distributorId: string,\n    vendorId: string,\n    groupId: string,\n    clients: ClientListItem[],\n    pagination: Omit<ClientPaginationState, 'loadingMore'>,\n    append = false,\n  ): void {\n    this.validateVendorId(vendorId);\n    if (!groupId) return;\n\n    const paginationKey = this.getDistributorPaginationKey(\n      distributorId,\n      vendorId,\n      groupId,\n    );\n\n    this.state.update((state) => {\n      // Ensure distributor exists in groupClients\n      const distributorGroupClients = state.groupClients[distributorId] ?? {};\n      const vendorGroups = distributorGroupClients[vendorId] ?? {};\n      const existingClients = append ? (vendorGroups[groupId] ?? []) : [];\n\n      const newGroupClients = {\n        ...state.groupClients,\n        [distributorId]: {\n          ...distributorGroupClients,\n          [vendorId]: {\n            ...vendorGroups,\n            [groupId]: [...existingClients, ...clients],\n          },\n        },\n      };\n\n      // Ensure distributor exists in clientPagination\n      const distributorPagination = state.clientPagination[distributorId] ?? {};\n      const newPagination = {\n        ...state.clientPagination,\n        [distributorId]: {\n          ...distributorPagination,\n          [paginationKey]: { ...pagination, loadingMore: false },\n        },\n      };\n\n      return {\n        ...state,\n        groupClients: newGroupClients,\n        clientPagination: newPagination,\n      };\n    });\n  }\n\n  /**\n   * Gets clients for a specific group\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @param groupId - The ID of the group\n   * @returns Array of client items associated with the group\n   */\n  getGroupClients(\n    distributorId: string,\n    vendorId: string,\n    groupId: string,\n  ): ClientListItem[] {\n    return (\n      this.state().groupClients[distributorId]?.[vendorId]?.[groupId] ?? []\n    );\n  }\n\n  /**\n   * Checks if a group has any clients loaded\n   * @param vendorId - The ID of the vendor\n   * @param groupId - The ID of the group\n   * @returns boolean indicating if group has clients\n   */\n  hasGroupClients(\n    distributorId: string,\n    vendorId: string,\n    groupId: string,\n  ): boolean {\n    return this.getGroupClients(distributorId, vendorId, groupId).length > 0;\n  }\n\n  /**\n   * Updates the children of a specific group node within a distributor context\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @param groupId - The ID of the group\n   * @param children - Array of tree nodes representing the children\n   */\n  updateGroupChildren(\n    distributorId: string,\n    vendorId: string,\n    groupId: string,\n    children: TreeNode[],\n  ): void {\n    this.state.update((state) => {\n      // Ensure distributor exists in groupClients\n      const distributorGroupClients = state.groupClients[distributorId] ?? {};\n      const vendorGroups = distributorGroupClients[vendorId] ?? {};\n\n      return {\n        ...state,\n        groupClients: {\n          ...state.groupClients,\n          [distributorId]: {\n            ...distributorGroupClients,\n            [vendorId]: {\n              ...vendorGroups,\n              [groupId]: children.map((node) => node.data),\n            },\n          },\n        },\n      };\n    });\n  }\n\n  /**\n   * Resets all state to initial values\n   * Use this when navigating away or cleaning up\n   */\n  clearAllState(): void {\n    this.state.set({\n      loadedVendors: {},\n      loadingVendors: {},\n      failedVendors: {},\n      expandedNodes: {},\n      vendorClients: {},\n      vendorGroups: {},\n      groupClients: {},\n      selectedClient: null,\n      clientVendor: null,\n      vendorDistributor: null,\n      distributors: [],\n      initialLoading: false,\n      expandedGroups: {},\n      expandedDistributors: new Set<string>(),\n      clientPagination: {},\n      distributorVendors: {},\n    });\n  }\n\n  /**\n   * Fallback handler when only client data is available\n   * Clears all vendor-related data and sets the client\n   * @param client - The client response object to fall back to\n   */\n  setFallbackToClient(client: ClientResponse): void {\n    this.state.update((state) => ({\n      ...state,\n      selectedClient: client,\n      clientVendor: null,\n      vendorDistributor: null,\n      vendors: [],\n      // Clear other vendor-related data\n      vendorClients: {},\n      vendorGroups: {},\n      loadedVendors: {},\n      loadingVendors: {},\n      failedVendors: {},\n    }));\n  }\n\n  setFallbackToVendor(vendor: VendorResponse | VendorListItem): void {\n    this.state.update((state) => ({\n      ...state,\n      clientVendor: vendor,\n      vendorDistributor: null,\n      // Clear distributor-scoped data since we're falling back to vendor level\n      distributorVendors: {},\n      vendorClients: {},\n      vendorGroups: {},\n      groupClients: {},\n      loadedVendors: {},\n      loadingVendors: {},\n      failedVendors: {},\n      expandedNodes: {},\n      expandedGroups: {},\n      clientPagination: {},\n      // Reset distributor expansion state\n      expandedDistributors: new Set<string>(),\n      // Clear distributors list since we don't have distributor context\n      distributors: [],\n    }));\n  }\n\n  /**\n   * Checks if a vendor has any associated clients in a specific distributor context\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor to check\n   * @returns boolean indicating if vendor has clients\n   * @throws Error if vendor ID is invalid\n   */\n  hasDistributorVendorClients(\n    distributorId: string,\n    vendorId: string,\n  ): boolean {\n    this.validateVendorId(vendorId);\n    const clients = this.state().vendorClients[distributorId]?.[vendorId];\n    return Array.isArray(clients) && clients.length > 0;\n  }\n\n  /**\n   * Sets expanded state for a group within a specific distributor context\n   * @param distributorId - The ID of the distributor\n   * @param groupId - The ID of the group\n   * @param expanded - Whether the group is expanded\n   */\n  setDistributorExpandedGroup(\n    distributorId: string,\n    groupId: string,\n    expanded: boolean,\n  ): void {\n    this.state.update((state) => {\n      const distributorExpandedGroups =\n        state.expandedGroups[distributorId] ?? new Set();\n      const newExpandedGroups = new Set(distributorExpandedGroups);\n\n      if (expanded) {\n        newExpandedGroups.add(groupId);\n      } else {\n        newExpandedGroups.delete(groupId);\n      }\n\n      return {\n        ...state,\n        expandedGroups: {\n          ...state.expandedGroups,\n          [distributorId]: newExpandedGroups,\n        },\n      };\n    });\n  }\n\n  /**\n   * @deprecated Use setDistributorExpandedGroup instead\n   * Sets expanded state for a group (legacy method for backward compatibility)\n   * @param groupId - The ID of the group\n   * @param expanded - Whether the group is expanded\n   */\n  setExpandedGroup(groupId: string, expanded: boolean): void {\n    const distributorId = this.getCurrentDistributorId();\n    if (isDefined(distributorId)) {\n      this.setDistributorExpandedGroup(distributorId, groupId, expanded);\n    }\n  }\n\n  /**\n   * Checks if a group is expanded within a specific distributor context\n   * @param distributorId - The ID of the distributor\n   * @param groupId - The ID of the group\n   * @returns Whether the group is expanded\n   */\n  isDistributorGroupExpanded(distributorId: string, groupId: string): boolean {\n    return this.state().expandedGroups[distributorId]?.has(groupId) ?? false;\n  }\n\n  /**\n   * Sets initial expansion state for a group within a distributor context\n   * @param distributorId - The ID of the distributor\n   * @param groupId - The ID of the group\n   */\n  setDistributorInitialGroupExpansion(\n    distributorId: string,\n    groupId: string,\n  ): void {\n    this.state.update((state) => {\n      const distributorExpandedGroups =\n        state.expandedGroups[distributorId] ?? new Set();\n      return {\n        ...state,\n        expandedGroups: {\n          ...state.expandedGroups,\n          [distributorId]: new Set(distributorExpandedGroups).add(groupId),\n        },\n      };\n    });\n  }\n\n  setExpandedDistributor(distributorId: string, expanded: boolean): void {\n    this.state.update((state) => ({\n      ...state,\n      expandedDistributors: expanded\n        ? new Set(state.expandedDistributors).add(distributorId)\n        : new Set(\n            [...state.expandedDistributors].filter(\n              (id) => id !== distributorId,\n            ),\n          ),\n    }));\n  }\n\n  /**\n   * Gets a specific client by ID from any loaded clients within distributor contexts\n   * @param clientId - The ID of the client to find\n   * @param distributorId - Optional distributor ID to scope the search\n   * @returns The client object if found, null otherwise\n   */\n  getClientById(\n    clientId: string,\n    distributorId?: string,\n  ): ClientListItem | ClientResponse | null {\n    if (!clientId) {\n      return null;\n    }\n\n    // Check if this is the currently selected client\n    if (this.state().selectedClient?.id === clientId) {\n      return this.state().selectedClient;\n    }\n\n    // If distributor is specified, search within that distributor's data\n    if (isDefined(distributorId)) {\n      return this.getClientByIdInDistributor(clientId, distributorId);\n    }\n\n    // Otherwise, search across all distributors\n    const distributorVendorClients = this.state().vendorClients;\n    for (const [distId] of Object.entries(distributorVendorClients)) {\n      const client = this.getClientByIdInDistributor(clientId, distId);\n      if (client) return client;\n    }\n\n    return null;\n  }\n\n  /**\n   * Helper method to find a client within a specific distributor's data\n   * @param clientId - The ID of the client to find\n   * @param distributorId - The ID of the distributor to search within\n   * @returns The client object if found, null otherwise\n   */\n  private getClientByIdInDistributor(\n    clientId: string,\n    distributorId: string,\n  ): ClientListItem | null {\n    // Check in vendor clients for this distributor\n    const vendorClients = this.state().vendorClients[distributorId] ?? {};\n    for (const clients of Object.values(vendorClients)) {\n      const client = clients.find((c) => c.id === clientId);\n      if (client) return client;\n    }\n\n    // Check in group clients for this distributor\n    const groupClients = this.state().groupClients[distributorId] ?? {};\n    for (const vendorGroups of Object.values(groupClients)) {\n      for (const clients of Object.values(vendorGroups)) {\n        const client = clients.find((c) => c.id === clientId);\n        if (client) return client;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets a specific vendor by ID within distributor contexts\n   * @param vendorId - The ID of the vendor to find\n   * @param distributorId - Optional distributor ID to scope the search\n   * @returns The vendor object if found, null otherwise\n   */\n  getVendorById(vendorId: string, distributorId?: string): VendorItem | null {\n    if (!vendorId) {\n      return null;\n    }\n\n    // Check if this is the vendor of the currently selected client\n    if (this.state().clientVendor?.id === vendorId) {\n      return this.state().clientVendor;\n    }\n\n    // If distributor is specified, search within that distributor's vendors\n    if (isDefined(distributorId)) {\n      const distributorVendors =\n        this.state().distributorVendors[distributorId] ?? [];\n      const vendor = distributorVendors.find((v) => v.id === vendorId);\n      if (vendor) return vendor;\n    } else {\n      // Search across all distributors\n      const distributorVendors = this.state().distributorVendors;\n      for (const vendors of Object.values(distributorVendors)) {\n        const vendor = vendors.find((v) => v.id === vendorId);\n        if (vendor) return vendor;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets the parent vendor for a specific client within distributor contexts\n   * @param clientId - The ID of the client\n   * @param distributorId - Optional distributor ID to scope the search\n   * @returns The parent vendor if found, null otherwise\n   */\n  getVendorForClient(\n    clientId: string,\n    distributorId?: string,\n  ): VendorItem | null {\n    if (!clientId) {\n      return null;\n    }\n\n    // If this is the currently selected client, return its vendor\n    if (this.state().selectedClient?.id === clientId) {\n      return this.state().clientVendor;\n    }\n\n    // If distributor is specified, search within that distributor's data\n    if (isDefined(distributorId)) {\n      return this.getVendorForClientInDistributor(clientId, distributorId);\n    }\n\n    // Otherwise, search across all distributors\n    const distributorVendorClients = this.state().vendorClients;\n    for (const [distId] of Object.entries(distributorVendorClients)) {\n      const vendor = this.getVendorForClientInDistributor(clientId, distId);\n      if (vendor) return vendor;\n    }\n\n    return null;\n  }\n\n  /**\n   * Helper method to find the vendor for a client within a specific distributor\n   * @param clientId - The ID of the client\n   * @param distributorId - The ID of the distributor to search within\n   * @returns The parent vendor if found, null otherwise\n   */\n  private getVendorForClientInDistributor(\n    clientId: string,\n    distributorId: string,\n  ): VendorItem | null {\n    // Search through vendor clients\n    const vendorClients = this.state().vendorClients[distributorId] ?? {};\n    for (const [vendorId, clients] of Object.entries(vendorClients)) {\n      const foundClient = clients.find((c) => c.id === clientId);\n      if (foundClient) {\n        return this.getVendorById(vendorId, distributorId);\n      }\n    }\n\n    // Search through group clients\n    const groupClients = this.state().groupClients[distributorId] ?? {};\n    for (const [vendorId, vendorGroups] of Object.entries(groupClients)) {\n      for (const clients of Object.values(vendorGroups)) {\n        const foundClient = clients.find((c) => c.id === clientId);\n        if (foundClient) {\n          return this.getVendorById(vendorId, distributorId);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets all clients for a specific vendor within a distributor context\n   * @param vendorId - The ID of the vendor\n   * @param distributorId - The ID of the distributor\n   * @returns Array of all clients associated with the vendor within the distributor\n   */\n  getAllClientsForVendorInDistributor(\n    vendorId: string,\n    distributorId: string,\n  ): ClientListItem[] {\n    if (!vendorId || !distributorId) {\n      return [];\n    }\n\n    const allClients: ClientListItem[] = [];\n\n    // Add direct vendor clients\n    const directClients =\n      this.state().vendorClients[distributorId]?.[vendorId] ?? [];\n    allClients.push(...directClients);\n\n    // Add group clients\n    const vendorGroups =\n      this.state().groupClients[distributorId]?.[vendorId] ?? {};\n    for (const clients of Object.values(vendorGroups)) {\n      allClients.push(...clients);\n    }\n\n    return allClients;\n  }\n\n  /**\n   * Gets all clients for a specific vendor (legacy method for backward compatibility)\n   * @param vendorId - The ID of the vendor\n   * @returns Array of all clients associated with the vendor across all distributors\n   * @deprecated Use getAllClientsForVendorInDistributor instead\n   */\n  getAllClientsForVendor(vendorId: string): ClientListItem[] {\n    if (!vendorId) {\n      return [];\n    }\n\n    const allClients: ClientListItem[] = [];\n\n    // Search across all distributors\n    const distributorVendorClients = this.state().vendorClients;\n    for (const [distributorId] of Object.entries(distributorVendorClients)) {\n      const distributorClients = this.getAllClientsForVendorInDistributor(\n        vendorId,\n        distributorId,\n      );\n      allClients.push(...distributorClients);\n    }\n\n    // Fallback to legacy structure (for backward compatibility)\n    const legacyDirectClients = this.state().vendorClients[vendorId] ?? [];\n    if (Array.isArray(legacyDirectClients)) {\n      allClients.push(...legacyDirectClients);\n    }\n\n    return allClients;\n  }\n\n  /**\n   * Sets the loading state for loading more clients within a distributor context\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @param groupId - Optional group ID\n   * @param loading - Whether more clients are being loaded\n   */\n  setLoadingMoreClients(\n    distributorId: string,\n    vendorId: string,\n    groupId: string | undefined,\n    loading: boolean,\n  ): void {\n    const paginationKey = this.getDistributorPaginationKey(\n      distributorId,\n      vendorId,\n      groupId,\n    );\n\n    this.state.update((state) => {\n      const distributorPagination = state.clientPagination[distributorId] ?? {};\n      const currentPagination = distributorPagination[paginationKey];\n\n      if (isNullOrUndefined(currentPagination)) {\n        return state; // Should not happen if called correctly\n      }\n\n      return {\n        ...state,\n        clientPagination: {\n          ...state.clientPagination,\n          [distributorId]: {\n            ...distributorPagination,\n            [paginationKey]: { ...currentPagination, loadingMore: loading },\n          },\n        },\n      };\n    });\n  }\n\n  /**\n   * @deprecated Use clearDistributorGroupPagination instead\n   * Clears pagination state for a specific group (legacy method for backward compatibility)\n   * @param vendorId - The ID of the vendor\n   * @param groupId - The ID of the group\n   */\n  clearGroupPagination(vendorId: string, groupId: string): void {\n    const distributorId = this.getCurrentDistributorId();\n    if (isDefined(distributorId)) {\n      this.clearDistributorGroupPagination(distributorId, vendorId, groupId);\n    } else {\n      // Fallback to legacy behavior\n      const key = this.getPaginationKey(vendorId, groupId);\n      this.state.update((state) => {\n        const newPagination = { ...state.clientPagination };\n        delete newPagination[key];\n        return { ...state, clientPagination: newPagination };\n      });\n    }\n  }\n\n  /**\n   * Clears pagination state for a vendor's direct clients\n   * @param vendorId - ID of the vendor\n   */\n  clearVendorPagination(vendorId: string): void {\n    this.state.update((state) => {\n      const paginationKey = vendorId;\n      const newPagination = { ...state.clientPagination };\n      delete newPagination[paginationKey];\n      return {\n        ...state,\n        clientPagination: newPagination,\n      };\n    });\n  }\n\n  /**\n   * Clears all client data for a specific vendor\n   * @param vendorId - ID of the vendor\n   */\n  clearVendorClients(vendorId: string): void {\n    this.state.update((state) => {\n      const newVendorClients = { ...state.vendorClients };\n      delete newVendorClients[vendorId];\n      return {\n        ...state,\n        vendorClients: newVendorClients,\n      };\n    });\n  }\n\n  /**\n   * Clears all group data for a specific vendor\n   * @param vendorId - ID of the vendor\n   */\n  clearVendorGroups(vendorId: string): void {\n    this.state.update((state) => {\n      const newVendorGroups = { ...state.vendorGroups };\n      delete newVendorGroups[vendorId];\n\n      // Also clear group clients for this vendor\n      const newGroupClients = { ...state.groupClients };\n      for (const key of Object.keys(newGroupClients)) {\n        if (key.startsWith(`${vendorId}_`)) {\n          delete newGroupClients[key];\n        }\n      }\n\n      // Clear group pagination for this vendor\n      const newPagination = { ...state.clientPagination };\n      for (const key of Object.keys(newPagination)) {\n        if (key.startsWith(`${vendorId}_`)) {\n          delete newPagination[key];\n        }\n      }\n\n      return {\n        ...state,\n        vendorGroups: newVendorGroups,\n        groupClients: newGroupClients,\n        clientPagination: newPagination,\n      };\n    });\n  }\n\n  // ========================================\n  // NEW DISTRIBUTOR-SCOPED METHODS\n  // ========================================\n\n  /**\n   * Sets vendors for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendors - Array of vendor items\n   */\n  setDistributorVendors(\n    distributorId: string,\n    vendors: VendorListItem[],\n  ): void {\n    this.state.update((state) => ({\n      ...state,\n      distributorVendors: {\n        ...state.distributorVendors,\n        [distributorId]: vendors,\n      },\n    }));\n  }\n\n  /**\n   * Gets vendors for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @returns Array of vendors for the distributor\n   */\n  getDistributorVendors(distributorId: string): VendorListItem[] {\n    return this.state().distributorVendors[distributorId] ?? [];\n  }\n\n  /**\n   * Gets vendors for the current distributor context\n   * @returns Array of vendors for the current distributor\n   */\n  getVendorsForCurrentDistributor(): VendorListItem[] {\n    const distributorId = this.getCurrentDistributorId();\n    if (isNullOrUndefined(distributorId)) {\n      return [];\n    }\n    return this.getDistributorVendors(distributorId);\n  }\n\n  /**\n   * Adds or appends vendor clients for a specific distributor and vendor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @param clients - Array of client items\n   * @param pagination - Pagination info from the API call\n   * @param append - Whether to append or replace clients\n   */\n  addDistributorVendorClients(\n    distributorId: string,\n    vendorId: string,\n    clients: ClientListItem[],\n    pagination: Omit<ClientPaginationState, 'loadingMore'>,\n    append = false,\n  ): void {\n    this.validateVendorId(vendorId);\n    const paginationKey = this.getDistributorPaginationKey(\n      distributorId,\n      vendorId,\n    );\n\n    this.state.update((state) => {\n      // Ensure distributor exists in vendorClients\n      const distributorClients = state.vendorClients[distributorId] ?? {};\n      const existingClients = append\n        ? (distributorClients[vendorId] ?? [])\n        : [];\n\n      const newVendorClients = {\n        ...state.vendorClients,\n        [distributorId]: {\n          ...distributorClients,\n          [vendorId]: [...existingClients, ...clients],\n        },\n      };\n\n      // Ensure distributor exists in clientPagination\n      const distributorPagination = state.clientPagination[distributorId] ?? {};\n      const newPagination = {\n        ...state.clientPagination,\n        [distributorId]: {\n          ...distributorPagination,\n          [paginationKey]: { ...pagination, loadingMore: false },\n        },\n      };\n\n      return {\n        ...state,\n        vendorClients: newVendorClients,\n        clientPagination: newPagination,\n      };\n    });\n  }\n\n  /**\n   * Sets vendor groups for a specific distributor and vendor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @param groups - Array of company group responses\n   */\n  setDistributorVendorGroups(\n    distributorId: string,\n    vendorId: string,\n    groups: CompanyGroupResponse[],\n  ): void {\n    this.state.update((state) => ({\n      ...state,\n      vendorGroups: {\n        ...state.vendorGroups,\n        [distributorId]: {\n          ...state.vendorGroups[distributorId],\n          [vendorId]: groups,\n        },\n      },\n    }));\n  }\n\n  /**\n   * Gets vendor clients for a specific distributor and vendor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @returns Array of clients for the vendor within the distributor\n   */\n  getDistributorVendorClients(\n    distributorId: string,\n    vendorId: string,\n  ): ClientListItem[] {\n    return this.state().vendorClients[distributorId]?.[vendorId] ?? [];\n  }\n\n  /**\n   * Gets vendor groups for a specific distributor and vendor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @returns Array of groups for the vendor within the distributor\n   */\n  getDistributorVendorGroups(\n    distributorId: string,\n    vendorId: string,\n  ): CompanyGroupResponse[] {\n    return this.state().vendorGroups[distributorId]?.[vendorId] ?? [];\n  }\n\n  /**\n   * Adds loading vendor for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor to mark as loading\n   */\n  addDistributorLoadingVendor(distributorId: string, vendorId: string): void {\n    this.validateVendorId(vendorId);\n    this.state.update((state) => {\n      const distributorLoadingVendors =\n        state.loadingVendors[distributorId] ?? new Set();\n      return {\n        ...state,\n        loadingVendors: {\n          ...state.loadingVendors,\n          [distributorId]: new Set(distributorLoadingVendors).add(vendorId),\n        },\n      };\n    });\n  }\n\n  /**\n   * Removes loading vendor for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor to remove from loading state\n   */\n  removeDistributorLoadingVendor(\n    distributorId: string,\n    vendorId: string,\n  ): void {\n    this.state.update((state) => {\n      const distributorLoadingVendors =\n        state.loadingVendors[distributorId] ?? new Set();\n      const newLoadingVendors = new Set(distributorLoadingVendors);\n      newLoadingVendors.delete(vendorId);\n\n      return {\n        ...state,\n        loadingVendors: {\n          ...state.loadingVendors,\n          [distributorId]: newLoadingVendors,\n        },\n      };\n    });\n  }\n\n  /**\n   * Removes a vendor from the loaded vendors set for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor to remove from loaded state\n   */\n  removeDistributorLoadedVendor(distributorId: string, vendorId: string): void {\n    this.state.update((state) => {\n      const distributorLoadedVendors =\n        state.loadedVendors[distributorId] ?? new Set();\n      const newLoadedVendors = new Set(distributorLoadedVendors);\n      newLoadedVendors.delete(vendorId);\n\n      return {\n        ...state,\n        loadedVendors: {\n          ...state.loadedVendors,\n          [distributorId]: newLoadedVendors,\n        },\n      };\n    });\n  }\n\n  /**\n   * Marks a vendor as loaded for a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor to mark as loaded\n   */\n  markDistributorVendorAsLoaded(distributorId: string, vendorId: string): void {\n    this.state.update((state) => {\n      const distributorLoadedVendors =\n        state.loadedVendors[distributorId] ?? new Set();\n      return {\n        ...state,\n        loadedVendors: {\n          ...state.loadedVendors,\n          [distributorId]: new Set(distributorLoadedVendors).add(vendorId),\n        },\n      };\n    });\n  }\n\n  /**\n   * Sets expanded state for a node within a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param nodeId - The ID of the node\n   * @param expanded - Whether the node is expanded\n   */\n  setDistributorNodeExpanded(\n    distributorId: string,\n    nodeId: string,\n    expanded: boolean,\n  ): void {\n    this.state.update((state) => {\n      const distributorExpandedNodes =\n        state.expandedNodes[distributorId] ?? new Set();\n      const newExpandedNodes = new Set(distributorExpandedNodes);\n\n      if (expanded) {\n        newExpandedNodes.add(nodeId);\n      } else {\n        newExpandedNodes.delete(nodeId);\n      }\n\n      return {\n        ...state,\n        expandedNodes: {\n          ...state.expandedNodes,\n          [distributorId]: newExpandedNodes,\n        },\n      };\n    });\n  }\n\n  /**\n   * Checks if a node is expanded within a specific distributor\n   * @param distributorId - The ID of the distributor\n   * @param nodeId - The ID of the node\n   * @returns Whether the node is expanded\n   */\n  isDistributorNodeExpanded(distributorId: string, nodeId: string): boolean {\n    return this.state().expandedNodes[distributorId]?.has(nodeId) ?? false;\n  }\n\n  /**\n   * Gets pagination state for a specific distributor, vendor, and optional group\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @param groupId - Optional group ID\n   * @returns Pagination state or undefined if not found\n   */\n  getDistributorPaginationState(\n    distributorId: string,\n    vendorId: string,\n    groupId?: string,\n  ): ClientPaginationState | undefined {\n    const paginationKey = this.getDistributorPaginationKey(\n      distributorId,\n      vendorId,\n      groupId,\n    );\n    return this.state().clientPagination[distributorId]?.[paginationKey];\n  }\n\n  /**\n   * Updates loading more state for a specific distributor pagination\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @param groupId - Optional group ID\n   * @param loadingMore - Whether more data is being loaded\n   */\n  setDistributorLoadingMore(\n    distributorId: string,\n    vendorId: string,\n    groupId: string | undefined,\n    loadingMore: boolean,\n  ): void {\n    const paginationKey = this.getDistributorPaginationKey(\n      distributorId,\n      vendorId,\n      groupId,\n    );\n\n    this.state.update((state) => {\n      const distributorPagination = state.clientPagination[distributorId] ?? {};\n      const currentPagination = distributorPagination[paginationKey];\n\n      if (isNullOrUndefined(currentPagination)) {\n        return state;\n      }\n\n      return {\n        ...state,\n        clientPagination: {\n          ...state.clientPagination,\n          [distributorId]: {\n            ...distributorPagination,\n            [paginationKey]: {\n              ...currentPagination,\n              loadingMore,\n            },\n          },\n        },\n      };\n    });\n  }\n\n  /**\n   * Clears pagination state for a specific group within a distributor context\n   * @param distributorId - The ID of the distributor\n   * @param vendorId - The ID of the vendor\n   * @param groupId - The ID of the group\n   */\n  clearDistributorGroupPagination(\n    distributorId: string,\n    vendorId: string,\n    groupId: string,\n  ): void {\n    const paginationKey = this.getDistributorPaginationKey(\n      distributorId,\n      vendorId,\n      groupId,\n    );\n\n    this.state.update((state) => {\n      const distributorPagination = state.clientPagination[distributorId] ?? {};\n      const newDistributorPagination = { ...distributorPagination };\n      delete newDistributorPagination[paginationKey];\n\n      return {\n        ...state,\n        clientPagination: {\n          ...state.clientPagination,\n          [distributorId]: newDistributorPagination,\n        },\n      };\n    });\n  }\n\n  /**\n   * Checks if a distributor is expanded\n   * @param distributorId - The ID of the distributor\n   * @returns Whether the distributor is expanded\n   */\n  isDistributorExpanded(distributorId: string): boolean {\n    return this.state().expandedDistributors.has(distributorId);\n  }\n}\n", "import { inject, Injectable } from '@angular/core';\nimport { LocalStorageService } from '../../shared/services/local-storage.service';\nimport { UserSessionService } from './user-session.service';\nimport { AuthTokenManagerService } from './auth-token-manager.service';\nimport { AdminStateService } from '../../features/administration/services/admin-state.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class SessionCleanupService {\n  private readonly localStorage = inject(LocalStorageService);\n  private readonly authTokenManager = inject(AuthTokenManagerService);\n  private readonly adminState = inject(AdminStateService);\n  private readonly userSessionService = inject(UserSessionService);\n\n  /**\n   * Clears all authentication and user data.\n   * Use this for logout operations.\n   */\n  clearAllAuthData(): void {\n    // Clear tokens\n    this.authTokenManager.clearTokens();\n\n    // Clear sessions\n    this.userSessionService.clearAllSessions();\n\n    // Clear admin state\n    this.adminState.clearAllState();\n  }\n\n  /**\n   * Detects and handles user mismatch scenarios.\n   * Returns true if mismatch was detected and cleaned up.\n   */\n  detectAndHandleUserMismatch(newUserId: string): boolean {\n    const hasMismatch = this.localStorage.detectUserMismatch(newUserId);\n\n    if (hasMismatch) {\n      console.warn('User mismatch detected, clearing previous user data');\n\n      // Clear only user-scoped data (keep API tokens)\n      this.localStorage.clearUserScopedData();\n      this.userSessionService.clearAllSessions();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Records the last authenticated user.\n   */\n  setLastAuthenticatedUser(userId: string): void {\n    this.localStorage.setLastAuthenticatedUserId(userId);\n  }\n}\n", "import {\n  computed,\n  inject,\n  Injectable,\n  signal,\n  WritableSignal,\n} from '@angular/core';\nimport {\n  AccountsService,\n  AuthService,\n  UserProfileResponse,\n  UserRoleResponse,\n} from '../../api';\nimport { Router } from '@angular/router';\nimport { firstValueFrom } from 'rxjs';\nimport { isEmpty, isNullOrUndefined } from '../../shared/utils';\nimport { DEFAULT_SYSTEM_ID, SUPER_ADMIN_ROLE_ID } from '../models';\nimport { SessionCleanupService } from './session-cleanup.service';\nimport { LocalStorageService } from '../../shared/services/local-storage.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthDataService {\n  private readonly userProfileSignal = signal<UserProfileResponse | null>(null);\n  private readonly userPermissionsSignal = signal<string[]>([]);\n  private readonly router = inject(Router);\n  private readonly authService = inject(AuthService);\n  private readonly accountsService = inject(AccountsService);\n  private readonly sessionCleanup = inject(SessionCleanupService);\n  private readonly localStorage = inject(LocalStorageService);\n\n  flags = {\n    otpTestingEnabled: () =>\n      this.getUserProfile()?.owner.type === 'system' ||\n      this.getUserProfile()?.emailAddress?.endsWith('keytelematics.com'),\n    labelsEnabled: () => true,\n    tripLimitsEnabled: () => true,\n    assetPerformanceEnabled: () =>\n      this.getUserProfile()?.owner?.type === 'system' ||\n      this.getUserProfile()?.emailAddress?.endsWith('keytelematics.com'),\n    deviceHealthEnabled: () =>\n      this.getUserProfile()?.owner?.type === 'system' ||\n      this.getUserProfile()?.emailAddress?.endsWith('keytelematics.com'),\n  };\n\n  /**\n   * Computed signal for accessing the user profile\n   */\n  readonly profile = computed(() => this.userProfileSignal());\n\n  /**\n   * Returns the writable signal for the user profile\n   */\n  getUserProfileSignal(): WritableSignal<UserProfileResponse | null> {\n    return this.userProfileSignal;\n  }\n\n  /**\n   * Returns the current user profile value\n   */\n  getUserProfile(): UserProfileResponse | null {\n    return this.userProfileSignal();\n  }\n\n  /**\n   * Updates the user profile, merging with existing data if present\n   * Also extracts and sets user permissions.\n   * @param userProfile - Partial user profile data to update\n   */\n  async setUserProfile(\n    userProfile: Partial<UserProfileResponse>,\n  ): Promise<void> {\n    const currentProfile = this.userProfileSignal();\n    let updatedProfile: UserProfileResponse;\n\n    if (isNullOrUndefined(currentProfile)) {\n      updatedProfile = userProfile as UserProfileResponse;\n    } else {\n      updatedProfile = { ...currentProfile, ...userProfile };\n    }\n    this.userProfileSignal.set(updatedProfile);\n    // Update LocalStorageService with current user ID\n    if (updatedProfile.id) {\n      this.localStorage.setCurrentUserId(updatedProfile.id);\n    }\n\n    // Extract permissions from all roles\n    await this.extractAndSetAllPermissions(updatedProfile.roles || []);\n  }\n\n  /**\n   * Extracts permissions from all user roles and updates the permissions signal.\n   * @param roles - Array of user roles\n   */\n  private async extractAndSetAllPermissions(\n    roles: UserProfileResponse['roles'],\n  ): Promise<void> {\n    if (!roles || roles.length === 0) {\n      this.userPermissionsSignal.set([]);\n      return;\n    }\n\n    const allPermissions: string[] = [];\n\n    for (const role of roles) {\n      const permissions = await this.extractPermissionsFromRole(role.id);\n      allPermissions.push(...permissions);\n    }\n\n    // Remove duplicates and set all permissions\n    this.userPermissionsSignal.set([...new Set(allPermissions)]);\n  }\n\n  /**\n   * Extracts permissions from a single role\n   * @param roleId - The role ID\n   * @returns Promise<string[]> - Array of permissions for this role\n   */\n  private async extractPermissionsFromRole(roleId: string): Promise<string[]> {\n    if (isNullOrUndefined(roleId)) {\n      console.warn('Cannot extract permissions: Role ID is missing.');\n      return [];\n    }\n\n    if (roleId === DEFAULT_SYSTEM_ID) {\n      return ['system:all'];\n    }\n\n    try {\n      const userRole: UserRoleResponse = await firstValueFrom(\n        this.accountsService.getUserRole(roleId),\n      );\n\n      if (isNullOrUndefined(userRole) || !userRole.legacyRights) {\n        if (isNullOrUndefined(userRole)) {\n          console.warn('UserRoleResponse is null or undefined.');\n        } else {\n          console.warn('legacyRights are missing in UserRoleResponse.');\n        }\n        return [];\n      }\n\n      const permissions: string[] = [];\n      const legacyRights = userRole.legacyRights;\n\n      for (const feature in legacyRights) {\n        if (Object.hasOwn(legacyRights, feature)) {\n          const actions = legacyRights[feature as keyof typeof legacyRights];\n          if (Array.isArray(actions)) {\n            for (const action of actions) {\n              permissions.push(`${feature}:${action}`);\n            }\n          }\n        }\n      }\n\n      return permissions;\n    } catch (error) {\n      console.error(\n        'Error fetching or processing user role for permissions:',\n        error,\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Checks if the current user has a specific permission.\n   * @param permission - The permission string to check for.\n   */\n  hasPermission(permission: string): boolean {\n    return (\n      this.userPermissionsSignal().includes(permission) ||\n      this.userPermissionsSignal().includes('system:all')\n    );\n  }\n\n  /**\n   * Checks if the current user has ALL of the specified permissions.\n   * @param permissions - An array of permission strings to check for.\n   */\n  hasAllPermissions(permissions: string[]): boolean {\n    if (isEmpty(permissions) || permissions.length === 0) {\n      return true;\n    }\n    const userPerms = this.userPermissionsSignal();\n    return (\n      permissions.every((p) => userPerms.includes(p)) ||\n      userPerms.includes('system:all')\n    );\n  }\n\n  /**\n   * Checks if the current user has ANY of the specified permissions.\n   * @param permissions - An array of permission strings to check for.\n   */\n  hasAnyPermission(permissions: string[]): boolean {\n    if (isEmpty(permissions) || permissions.length === 0) {\n      return true;\n    }\n    const userPerms = this.userPermissionsSignal();\n    return (\n      permissions.some((p) => userPerms.includes(p)) ||\n      userPerms.includes('system:all')\n    );\n  }\n\n  /**\n   * Clears the user profile data and permissions (for account switching)\n   * Preserves currentUserId to maintain namespace\n   */\n  clearUserProfile(): void {\n    this.userProfileSignal.set(null);\n    this.userPermissionsSignal.set([]);\n  }\n\n  /**\n   * Clears the user profile data and permissions\n   */\n  clearAllUserData(): void {\n    this.clearUserProfile();\n    this.localStorage.setCurrentUserId(null);\n  }\n\n  logout() {\n    this.authService.signOut({}).subscribe({\n      next: () => {\n        this.clearAllUserData();\n        this.sessionCleanup.clearAllAuthData();\n        this.router.navigate(['/auth/login']).catch(() => {});\n      },\n      error: () => {\n        this.forceLogout();\n      },\n    });\n  }\n\n  forceLogout() {\n    this.clearAllUserData();\n    this.sessionCleanup.clearAllAuthData();\n    this.router.navigate(['/auth/login']).catch(() => {});\n  }\n\n  /**\n   * Checks if the current user is a Super Admin.\n   */\n  isSuperAdmin(): boolean {\n    const userProfile = this.userProfileSignal();\n    if (!userProfile?.roles) return false;\n\n    return userProfile.roles.some(\n      (role) =>\n        role.id === DEFAULT_SYSTEM_ID ||\n        role.id === SUPER_ADMIN_ROLE_ID ||\n        (role.name?.toLowerCase().includes('super admin') ?? false),\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
